begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library,    version 0.12.    (Implements POSIX draft P1003.2/D11.2, except for some of the    internationalization features.)     Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.     the C library, however.  The master source lives in /gd/gnu/lib.  NOTE: The canonical source of this file is maintained with the GNU C Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REGEX_MALLOC
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|_GNU_SOURCE
end_undef

begin_define
DECL|macro|_GNU_SOURCE
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|emacs
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We need this for `regex.h', and perhaps for the Emacs include files.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For platform which support the ISO C amendement 1 functionality we    support user defined character classes.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
operator|(
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|)
end_if

begin_comment
comment|/* Solaris 2.5 has a bug:<wchar.h> must be included before<wctype.h>.  */
end_comment

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The `emacs' switch turns on certain matching commands    that make sense only in Emacs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* If we are not linking with Emacs proper,    we can't use the relocating allocator    even if config.h says that we can.  */
end_comment

begin_undef
undef|#
directive|undef
name|REL_ALLOC
end_undef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|_LIBC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.    If nothing else has been done, use the method below.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INHIBIT_STRING_HEADER
end_ifdef

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_BZERO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_BCOPY
argument_list|)
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|bzero
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bcopy
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|INHIBIT_STRING_HEADER
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the normal way of making sure we have a bcopy and a bzero.    This is used in most programs--a few other programs avoid this    by defining INHIBIT_STRING_HEADER.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INHIBIT_STRING_HEADER
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|_LIBC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bcmp
end_ifndef

begin_define
DECL|macro|bcmp (s1,s2,n)
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|memcmp ((s1), (s2), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bcopy
end_ifndef

begin_define
DECL|macro|bcopy (s,d,n)
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy ((d), (s), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bzero
end_ifndef

begin_define
DECL|macro|bzero (s,n)
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset ((s), 0, (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the syntax stuff for \<, \>, etc.  */
end_comment

begin_comment
comment|/* This must be nonzero for the wordchar and notwordchar pattern    commands in re_match_2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sword
end_ifndef

begin_define
DECL|macro|Sword
define|#
directive|define
name|Sword
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
end_ifdef

begin_define
DECL|macro|SWITCH_ENUM_CAST (x)
define|#
directive|define
name|SWITCH_ENUM_CAST
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|SWITCH_ENUM_CAST (x)
define|#
directive|define
name|SWITCH_ENUM_CAST
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTAX_TABLE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|re_syntax_table
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_comment
comment|/* How many characters in the character set.  */
end_comment

begin_define
DECL|macro|CHAR_SET_SIZE
define|#
directive|define
name|CHAR_SET_SIZE
value|256
end_define

begin_decl_stmt
DECL|variable|re_syntax_table
specifier|static
name|char
name|re_syntax_table
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|init_syntax_once ()
name|init_syntax_once
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|bzero
argument_list|(
name|re_syntax_table
argument_list|,
sizeof|sizeof
name|re_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'A'
init|;
name|c
operator|<=
literal|'Z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
name|re_syntax_table
index|[
literal|'_'
index|]
operator|=
name|Sword
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_define
DECL|macro|SYNTAX (c)
define|#
directive|define
name|SYNTAX
parameter_list|(
name|c
parameter_list|)
value|re_syntax_table[c]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get the interface, including the syntax bits.  */
end_comment

begin_include
include|#
directive|include
file|"regexrepl/regex.h"
end_include

begin_comment
comment|/* isalpha etc. are used for the character classes.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Jim Meyering writes:     "... Some ctype macros are valid only for character codes that    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when    using /bin/cc or gcc but without giving an ansi option).  So, all    ctype uses should be through macros like ISPRINT...  If    STDC_HEADERS is defined, then autoconf has verified that the ctype    macros don't need to be guarded with references to isascii. ...    Defining isascii to 1 should let any compiler worth its salt    eliminate the&& through constant folding."  */
end_comment

begin_undef
undef|#
directive|undef
name|ISASCII
end_undef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|isascii
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ISASCII
argument_list|)
operator|)
end_if

begin_define
DECL|macro|ISASCII (c)
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|ISASCII (c)
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|isblank
end_ifdef

begin_define
DECL|macro|ISBLANK (c)
define|#
directive|define
name|ISBLANK
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isblank (c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|ISBLANK (c)
define|#
directive|define
name|ISBLANK
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|isgraph
end_ifdef

begin_define
DECL|macro|ISGRAPH (c)
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isgraph (c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|ISGRAPH (c)
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isprint (c)&& !isspace (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|ISPRINT
end_undef

begin_define
DECL|macro|ISPRINT (c)
define|#
directive|define
name|ISPRINT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isprint (c))
end_define

begin_define
DECL|macro|ISDIGIT (c)
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isdigit (c))
end_define

begin_define
DECL|macro|ISALNUM (c)
define|#
directive|define
name|ISALNUM
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isalnum (c))
end_define

begin_define
DECL|macro|ISALPHA (c)
define|#
directive|define
name|ISALPHA
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isalpha (c))
end_define

begin_define
DECL|macro|ISCNTRL (c)
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& iscntrl (c))
end_define

begin_define
DECL|macro|ISLOWER (c)
define|#
directive|define
name|ISLOWER
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& islower (c))
end_define

begin_define
DECL|macro|ISPUNCT (c)
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& ispunct (c))
end_define

begin_define
DECL|macro|ISSPACE (c)
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isspace (c))
end_define

begin_define
DECL|macro|ISUPPER (c)
define|#
directive|define
name|ISUPPER
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isupper (c))
end_define

begin_define
DECL|macro|ISXDIGIT (c)
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isxdigit (c))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
DECL|macro|NULL
define|#
directive|define
name|NULL
value|(void *)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We remove any previous definition of `SIGN_EXTEND_CHAR',    since ours (we hope) works properly with all combinations of    machines, compilers, `char' and `unsigned char' argument types.    (Per Bothner suggested the basic approach.)  */
end_comment

begin_undef
undef|#
directive|undef
name|SIGN_EXTEND_CHAR
end_undef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
DECL|macro|SIGN_EXTEND_CHAR (c)
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|c
parameter_list|)
value|((signed char) (c))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/* As in Harbison and Steele.  */
end_comment

begin_define
DECL|macro|SIGN_EXTEND_CHAR (c)
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|c
parameter_list|)
value|((((unsigned char) (c)) ^ 128) - 128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we    use `alloca' instead of `malloc'.  This is because using malloc in    re_search* or re_match* could cause memory leaks when C-g is used in    Emacs; also, malloc is slower and causes storage fragmentation.  On    the other hand, malloc is more portable, and easier to debug.     Because we sometimes use alloca, some routines have to be macros,    not functions -- `alloca'-allocated space disappears at the end of the    function it is called in.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX_MALLOC
end_ifdef

begin_define
DECL|macro|REGEX_ALLOCATE
define|#
directive|define
name|REGEX_ALLOCATE
value|malloc
end_define

begin_define
DECL|macro|REGEX_REALLOCATE (source,osize,nsize)
define|#
directive|define
name|REGEX_REALLOCATE
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
value|realloc (source, nsize)
end_define

begin_define
DECL|macro|REGEX_FREE
define|#
directive|define
name|REGEX_FREE
value|free
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not REGEX_MALLOC  */
end_comment

begin_comment
comment|/* Emacs already defines alloca, sometimes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_comment
comment|/* Make alloca work the best possible way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
DECL|macro|alloca
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_if
if|#
directive|if
name|HAVE_ALLOCA_H
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ or HAVE_ALLOCA_H */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* It is a bad idea to declare alloca.  We always cast the result.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_AIX
end_ifndef

begin_comment
comment|/* Already did AIX, up at the top.  */
end_comment

begin_endif
unit|char *alloca ();
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not alloca */
end_comment

begin_define
DECL|macro|REGEX_ALLOCATE
define|#
directive|define
name|REGEX_ALLOCATE
value|alloca
end_define

begin_comment
comment|/* Assumes a `char *destination' variable.  */
end_comment

begin_define
DECL|macro|REGEX_REALLOCATE (source,osize,nsize)
define|#
directive|define
name|REGEX_REALLOCATE
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|(destination = (char *) alloca (nsize),				\    bcopy (source, destination, osize),					\    destination)
end_define

begin_comment
comment|/* No need to do anything to free, after alloca.  */
end_comment

begin_define
DECL|macro|REGEX_FREE (arg)
define|#
directive|define
name|REGEX_FREE
parameter_list|(
name|arg
parameter_list|)
value|((void)0)
end_define

begin_comment
DECL|macro|REGEX_FREE (arg)
comment|/* Do nothing!  But inhibit gcc warning.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_comment
comment|/* Define how to allocate the failure stack.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REL_ALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|REGEX_MALLOC
argument_list|)
end_if

begin_define
DECL|macro|REGEX_ALLOCATE_STACK (size)
define|#
directive|define
name|REGEX_ALLOCATE_STACK
parameter_list|(
name|size
parameter_list|)
define|\
value|r_alloc (&failure_stack_ptr, (size))
end_define

begin_define
DECL|macro|REGEX_REALLOCATE_STACK (source,osize,nsize)
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|r_re_alloc (&failure_stack_ptr, (nsize))
end_define

begin_define
DECL|macro|REGEX_FREE_STACK (ptr)
define|#
directive|define
name|REGEX_FREE_STACK
parameter_list|(
name|ptr
parameter_list|)
define|\
value|r_alloc_free (&failure_stack_ptr)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not using relocating allocator */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX_MALLOC
end_ifdef

begin_define
DECL|macro|REGEX_ALLOCATE_STACK
define|#
directive|define
name|REGEX_ALLOCATE_STACK
value|malloc
end_define

begin_define
DECL|macro|REGEX_REALLOCATE_STACK (source,osize,nsize)
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
value|realloc (source, nsize)
end_define

begin_define
DECL|macro|REGEX_FREE_STACK
define|#
directive|define
name|REGEX_FREE_STACK
value|free
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_define
DECL|macro|REGEX_ALLOCATE_STACK
define|#
directive|define
name|REGEX_ALLOCATE_STACK
value|alloca
end_define

begin_define
DECL|macro|REGEX_REALLOCATE_STACK (source,osize,nsize)
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|REGEX_REALLOCATE (source, osize, nsize)
end_define

begin_comment
comment|/* No need to explicitly free anything.  */
end_comment

begin_define
DECL|macro|REGEX_FREE_STACK (arg)
define|#
directive|define
name|REGEX_FREE_STACK
parameter_list|(
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not using relocating allocator */
end_comment

begin_comment
comment|/* True if `size1' is non-NULL and PTR is pointing anywhere inside    `string1' or just past its end.  This works if PTR is NULL, which is    a good thing.  */
end_comment

begin_define
DECL|macro|FIRST_STRING_P (ptr)
define|#
directive|define
name|FIRST_STRING_P
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(size1&& string1<= (ptr)&& (ptr)<= string1 + size1)
end_define

begin_comment
comment|/* (Re)Allocate N items of type T using malloc, or fail.  */
end_comment

begin_define
DECL|macro|TALLOC (n,t)
define|#
directive|define
name|TALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|((t *) malloc ((n) * sizeof (t)))
end_define

begin_define
DECL|macro|RETALLOC (addr,n,t)
define|#
directive|define
name|RETALLOC
parameter_list|(
name|addr
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|((addr) = (t *) realloc (addr, (n) * sizeof (t)))
end_define

begin_define
DECL|macro|RETALLOC_IF (addr,n,t)
define|#
directive|define
name|RETALLOC_IF
parameter_list|(
name|addr
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
end_define

begin_define
DECL|macro|REGEX_TALLOC (n,t)
define|#
directive|define
name|REGEX_TALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
end_define

begin_define
DECL|macro|BYTEWIDTH
define|#
directive|define
name|BYTEWIDTH
value|8
end_define

begin_comment
DECL|macro|BYTEWIDTH
comment|/* In bits.  */
end_comment

begin_define
DECL|macro|STREQ (s1,s2)
define|#
directive|define
name|STREQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|((strcmp (s1, s2) == 0))
end_define

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
DECL|macro|MAX (a,b)
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
DECL|macro|MIN (a,b)
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_typedef
DECL|typedef|boolean
typedef|typedef
name|char
name|boolean
typedef|;
end_typedef

begin_define
DECL|macro|false
define|#
directive|define
name|false
value|0
end_define

begin_define
DECL|macro|true
define|#
directive|define
name|true
value|1
end_define

begin_function_decl
specifier|static
name|int
name|re_match_2_internal
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* These are the command codes that appear in compiled regular    expressions.  Some opcodes are followed by argument bytes.  A    command code can specify any interpretation whatsoever for its    arguments.  Zero bytes may appear in the compiled regular expression.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon277f6f6a0103
block|{
DECL|enumerator|no_op
name|no_op
init|=
literal|0
block|,
comment|/* Succeed right away--no more backtracking.  */
DECL|enumerator|succeed
name|succeed
block|,
comment|/* Followed by one byte giving n, then by n literal bytes.  */
DECL|enumerator|exactn
name|exactn
block|,
comment|/* Matches any (more or less) character.  */
DECL|enumerator|anychar
name|anychar
block|,
comment|/* Matches any one char belonging to specified set.  First            following byte is number of bitmap bytes.  Then come bytes            for a bitmap saying which chars are in.  Bits in each byte            are ordered low-bit-first.  A character is in the set if its            bit is 1.  A character too large to have a bit in the map is            automatically not in the set.  */
DECL|enumerator|charset
name|charset
block|,
comment|/* Same parameters as charset, but match any character that is            not one of those specified.  */
DECL|enumerator|charset_not
name|charset_not
block|,
comment|/* Start remembering the text that is matched, for storing in a            register.  Followed by one byte with the register number, in            the range 0 to one less than the pattern buffer's re_nsub            field.  Then followed by one byte with the number of groups            inner to this one.  (This last has to be part of the            start_memory only because we need it in the on_failure_jump            of re_match_2.)  */
DECL|enumerator|start_memory
name|start_memory
block|,
comment|/* Stop remembering the text that is matched and store it in a            memory register.  Followed by one byte with the register            number, in the range 0 to one less than `re_nsub' in the            pattern buffer, and one byte with the number of inner groups,            just like `start_memory'.  (We need the number of inner            groups here because we don't have any easy way of finding the            corresponding start_memory when we're at a stop_memory.)  */
DECL|enumerator|stop_memory
name|stop_memory
block|,
comment|/* Match a duplicate of something remembered. Followed by one            byte containing the register number.  */
DECL|enumerator|duplicate
name|duplicate
block|,
comment|/* Fail unless at beginning of line.  */
DECL|enumerator|begline
name|begline
block|,
comment|/* Fail unless at end of line.  */
DECL|enumerator|endline
name|endline
block|,
comment|/* Succeeds if at beginning of buffer (if emacs) or at beginning            of string to be matched (if not).  */
DECL|enumerator|begbuf
name|begbuf
block|,
comment|/* Analogously, for end of buffer/string.  */
DECL|enumerator|endbuf
name|endbuf
block|,
comment|/* Followed by two byte relative address to which to jump.  */
DECL|enumerator|jump
name|jump
block|,
comment|/* Same as jump, but marks the end of an alternative.  */
DECL|enumerator|jump_past_alt
name|jump_past_alt
block|,
comment|/* Followed by two-byte relative address of place to resume at            in case of failure.  */
DECL|enumerator|on_failure_jump
name|on_failure_jump
block|,
comment|/* Like on_failure_jump, but pushes a placeholder instead of the            current string position when executed.  */
DECL|enumerator|on_failure_keep_string_jump
name|on_failure_keep_string_jump
block|,
comment|/* Throw away latest failure point and then jump to following            two-byte relative address.  */
DECL|enumerator|pop_failure_jump
name|pop_failure_jump
block|,
comment|/* Change to pop_failure_jump if know won't have to backtrack to            match; otherwise change to jump.  This is used to jump            back to the beginning of a repeat.  If what follows this jump            clearly won't match what the repeat does, such that we can be            sure that there is no use backtracking out of repetitions            already matched, then we change it to a pop_failure_jump.            Followed by two-byte address.  */
DECL|enumerator|maybe_pop_jump
name|maybe_pop_jump
block|,
comment|/* Jump to following two-byte address, and push a dummy failure            point. This failure point will be thrown away if an attempt            is made to use it for a failure.  A `+' construct makes this            before the first repeat.  Also used as an intermediary kind            of jump when compiling an alternative.  */
DECL|enumerator|dummy_failure_jump
name|dummy_failure_jump
block|,
comment|/* Push a dummy failure point and continue.  Used at the end of 	   alternatives.  */
DECL|enumerator|push_dummy_failure
name|push_dummy_failure
block|,
comment|/* Followed by two-byte relative address and two-byte number n.            After matching N times, jump to the address upon failure.  */
DECL|enumerator|succeed_n
name|succeed_n
block|,
comment|/* Followed by two-byte relative address, and two-byte number n.            Jump to the address N times, then fail.  */
DECL|enumerator|jump_n
name|jump_n
block|,
comment|/* Set the following two-byte relative address to the            subsequent two-byte number.  The address *includes* the two            bytes of number.  */
DECL|enumerator|set_number_at
name|set_number_at
block|,
DECL|enumerator|wordchar
name|wordchar
block|,
comment|/* Matches any word-constituent character.  */
DECL|enumerator|notwordchar
name|notwordchar
block|,
comment|/* Matches any char that is not a word-constituent.  */
DECL|enumerator|wordbeg
name|wordbeg
block|,
comment|/* Succeeds if at word beginning.  */
DECL|enumerator|wordend
name|wordend
block|,
comment|/* Succeeds if at word end.  */
DECL|enumerator|wordbound
name|wordbound
block|,
comment|/* Succeeds if at a word boundary.  */
DECL|enumerator|notwordbound
name|notwordbound
comment|/* Succeeds if not at a word boundary.  */
ifdef|#
directive|ifdef
name|emacs
DECL|enumerator|before_dot
block|,
name|before_dot
block|,
comment|/* Succeeds if before point.  */
DECL|enumerator|at_dot
name|at_dot
block|,
comment|/* Succeeds if at point.  */
DECL|enumerator|after_dot
name|after_dot
block|,
comment|/* Succeeds if after point.  */
comment|/* Matches any character whose syntax is specified.  Followed by            a byte which contains a syntax code, e.g., Sword.  */
DECL|enumerator|syntaxspec
name|syntaxspec
block|,
comment|/* Matches any character whose syntax is not that specified.  */
DECL|enumerator|notsyntaxspec
name|notsyntaxspec
endif|#
directive|endif
comment|/* emacs */
DECL|typedef|re_opcode_t
block|}
name|re_opcode_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Common operations on the compiled pattern.  */
end_comment

begin_comment
comment|/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
end_comment

begin_define
DECL|macro|STORE_NUMBER (destination,number)
define|#
directive|define
name|STORE_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|do {									\     (destination)[0] = (number)& 0377;					\     (destination)[1] = (number)>> 8;					\   } while (0)
end_define

begin_comment
comment|/* Same as STORE_NUMBER, except increment DESTINATION to    the byte after where the number is stored.  Therefore, DESTINATION    must be an lvalue.  */
end_comment

begin_define
DECL|macro|STORE_NUMBER_AND_INCR (destination,number)
define|#
directive|define
name|STORE_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|do {									\     STORE_NUMBER (destination, number);					\     (destination) += 2;							\   } while (0)
end_define

begin_comment
comment|/* Put into DESTINATION a number stored in two contiguous bytes starting    at SOURCE.  */
end_comment

begin_define
DECL|macro|EXTRACT_NUMBER (destination,source)
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|do {									\     (destination) = *(source)& 0377;					\     (destination) += SIGN_EXTEND_CHAR (*((source) + 1))<< 8;		\   } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|extract_number
name|_RE_ARGS
argument_list|(
operator|(
name|int
operator|*
name|dest
operator|,
name|unsigned
name|char
operator|*
name|source
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|extract_number (dest,source)
name|extract_number
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|int
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|char
modifier|*
name|source
decl_stmt|;
block|{
name|int
name|temp
init|=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|source
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|*
name|source
operator|&
literal|0377
expr_stmt|;
operator|*
name|dest
operator|+=
name|temp
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRACT_MACROS
end_ifndef

begin_comment
comment|/* To debug the macros.  */
end_comment

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER
end_undef

begin_define
DECL|macro|EXTRACT_NUMBER (dest,src)
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|extract_number (&dest, src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EXTRACT_MACROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.    SOURCE must be an lvalue.  */
end_comment

begin_define
DECL|macro|EXTRACT_NUMBER_AND_INCR (destination,source)
define|#
directive|define
name|EXTRACT_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|do {									\     EXTRACT_NUMBER (destination, source);				\     (source) += 2; 							\   } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|extract_number_and_incr
name|_RE_ARGS
argument_list|(
operator|(
name|int
operator|*
name|destination
operator|,
name|unsigned
name|char
operator|*
operator|*
name|source
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|extract_number_and_incr (destination,source)
name|extract_number_and_incr
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
name|int
modifier|*
name|destination
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|source
decl_stmt|;
block|{
name|extract_number
argument_list|(
name|destination
argument_list|,
operator|*
name|source
argument_list|)
expr_stmt|;
operator|*
name|source
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRACT_MACROS
end_ifndef

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER_AND_INCR
end_undef

begin_define
DECL|macro|EXTRACT_NUMBER_AND_INCR (dest,src)
define|#
directive|define
name|EXTRACT_NUMBER_AND_INCR
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|extract_number_and_incr (&dest,&src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EXTRACT_MACROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* If DEBUG is defined, Regex prints many voluminous messages about what    it is doing (if the variable `debug' is nonzero).  If linked with the    main program in `iregex.c', you can enter patterns and strings    interactively.  And if linked with the main program in `main.c' and    the other test files, you can run the already-written tests.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* We use standard I/O for debugging.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* It is useful to test things that ``must'' be true when debugging.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
DECL|variable|debug
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|DEBUG_STATEMENT (e)
define|#
directive|define
name|DEBUG_STATEMENT
parameter_list|(
name|e
parameter_list|)
value|e
end_define

begin_define
DECL|macro|DEBUG_PRINT1 (x)
define|#
directive|define
name|DEBUG_PRINT1
parameter_list|(
name|x
parameter_list|)
value|if (debug) printf (x)
end_define

begin_define
DECL|macro|DEBUG_PRINT2 (x1,x2)
define|#
directive|define
name|DEBUG_PRINT2
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|)
value|if (debug) printf (x1, x2)
end_define

begin_define
DECL|macro|DEBUG_PRINT3 (x1,x2,x3)
define|#
directive|define
name|DEBUG_PRINT3
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|)
value|if (debug) printf (x1, x2, x3)
end_define

begin_define
DECL|macro|DEBUG_PRINT4 (x1,x2,x3,x4)
define|#
directive|define
name|DEBUG_PRINT4
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|,
name|x4
parameter_list|)
value|if (debug) printf (x1, x2, x3, x4)
end_define

begin_define
DECL|macro|DEBUG_PRINT_COMPILED_PATTERN (p,s,e)
define|#
directive|define
name|DEBUG_PRINT_COMPILED_PATTERN
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
define|\
value|if (debug) print_partial_compiled_pattern (s, e)
end_define

begin_define
DECL|macro|DEBUG_PRINT_DOUBLE_STRING (w,s1,sz1,s2,sz2)
define|#
directive|define
name|DEBUG_PRINT_DOUBLE_STRING
parameter_list|(
name|w
parameter_list|,
name|s1
parameter_list|,
name|sz1
parameter_list|,
name|s2
parameter_list|,
name|sz2
parameter_list|)
define|\
value|if (debug) print_double_string (w, s1, sz1, s2, sz2)
end_define

begin_comment
comment|/* Print the fastmap in human-readable form.  */
end_comment

begin_function
name|void
DECL|function|print_fastmap (fastmap)
name|print_fastmap
parameter_list|(
name|fastmap
parameter_list|)
name|char
modifier|*
name|fastmap
decl_stmt|;
block|{
name|unsigned
name|was_a_range
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|)
block|{
if|if
condition|(
name|fastmap
index|[
name|i
operator|++
index|]
condition|)
block|{
name|was_a_range
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|&&
name|fastmap
index|[
name|i
index|]
condition|)
block|{
name|was_a_range
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|was_a_range
condition|)
block|{
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a compiled pattern string in human-readable form, starting at    the START pointer into it and ending just before the pointer END.  */
end_comment

begin_function
name|void
DECL|function|print_partial_compiled_pattern (start,end)
name|print_partial_compiled_pattern
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|int
name|mcnt
decl_stmt|,
name|mcnt2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pend
init|=
name|end
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"(null)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Loop over pattern commands.  */
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|printf
argument_list|(
literal|"%d:\t"
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
condition|)
block|{
case|case
name|no_op
case|:
name|printf
argument_list|(
literal|"/no_op"
argument_list|)
expr_stmt|;
break|break;
case|case
name|exactn
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/exactn/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
do|do
block|{
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
break|break;
case|case
name|start_memory
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/start_memory/%d/%d"
argument_list|,
name|mcnt
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|stop_memory
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/stop_memory/%d/%d"
argument_list|,
name|mcnt
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|duplicate
case|:
name|printf
argument_list|(
literal|"/duplicate/%d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|anychar
case|:
name|printf
argument_list|(
literal|"/anychar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|last
init|=
operator|-
literal|100
decl_stmt|;
specifier|register
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"/charset [%s"
argument_list|,
operator|(
name|re_opcode_t
operator|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
name|charset_not
condition|?
literal|"^"
else|:
literal|""
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|+
operator|*
name|p
operator|<
name|pend
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|c
operator|/
literal|8
operator|<
operator|*
name|p
operator|&&
operator|(
name|p
index|[
literal|1
operator|+
operator|(
name|c
operator|/
literal|8
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Are we starting a range?  */
if|if
condition|(
name|last
operator|+
literal|1
operator|==
name|c
operator|&&
operator|!
name|in_range
condition|)
block|{
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|in_range
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Have we broken a range?  */
elseif|else
if|if
condition|(
name|last
operator|+
literal|1
operator|!=
name|c
operator|&&
name|in_range
condition|)
block|{
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_range
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|in_range
condition|)
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
block|}
break|break;
case|case
name|begline
case|:
name|printf
argument_list|(
literal|"/begline"
argument_list|)
expr_stmt|;
break|break;
case|case
name|endline
case|:
name|printf
argument_list|(
literal|"/endline"
argument_list|)
expr_stmt|;
break|break;
case|case
name|on_failure_jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/on_failure_jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|on_failure_keep_string_jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/on_failure_keep_string_jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|dummy_failure_jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/dummy_failure_jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|push_dummy_failure
case|:
name|printf
argument_list|(
literal|"/push_dummy_failure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|maybe_pop_jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/maybe_pop_jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|pop_failure_jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/pop_failure_jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|jump_past_alt
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/jump_past_alt to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|jump
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/jump to %d"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|succeed_n
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/succeed_n to %d, %d times"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
break|break;
case|case
name|jump_n
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/jump_n to %d, %d times"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
break|break;
case|case
name|set_number_at
case|:
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|extract_number_and_incr
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/set_number_at location %d to %d"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
break|break;
case|case
name|wordbound
case|:
name|printf
argument_list|(
literal|"/wordbound"
argument_list|)
expr_stmt|;
break|break;
case|case
name|notwordbound
case|:
name|printf
argument_list|(
literal|"/notwordbound"
argument_list|)
expr_stmt|;
break|break;
case|case
name|wordbeg
case|:
name|printf
argument_list|(
literal|"/wordbeg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|wordend
case|:
name|printf
argument_list|(
literal|"/wordend"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
name|printf
argument_list|(
literal|"/before_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|at_dot
case|:
name|printf
argument_list|(
literal|"/at_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|after_dot
case|:
name|printf
argument_list|(
literal|"/after_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|syntaxspec
case|:
name|printf
argument_list|(
literal|"/syntaxspec"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|printf
argument_list|(
literal|"/notsyntaxspec"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
name|wordchar
case|:
name|printf
argument_list|(
literal|"/wordchar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|printf
argument_list|(
literal|"/notwordchar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|begbuf
case|:
name|printf
argument_list|(
literal|"/begbuf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|endbuf
case|:
name|printf
argument_list|(
literal|"/endbuf"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?%d"
argument_list|,
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d:\tend of pattern.\n"
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|print_compiled_pattern (bufp)
name|print_compiled_pattern
parameter_list|(
name|bufp
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
name|print_partial_compiled_pattern
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|bufp
operator|->
name|used
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld bytes used/%ld bytes allocated.\n"
argument_list|,
name|bufp
operator|->
name|used
argument_list|,
name|bufp
operator|->
name|allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|fastmap_accurate
operator|&&
name|bufp
operator|->
name|fastmap
condition|)
block|{
name|printf
argument_list|(
literal|"fastmap: "
argument_list|)
expr_stmt|;
name|print_fastmap
argument_list|(
name|bufp
operator|->
name|fastmap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"re_nsub: %d\t"
argument_list|,
name|bufp
operator|->
name|re_nsub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"regs_alloc: %d\t"
argument_list|,
name|bufp
operator|->
name|regs_allocated
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can_be_null: %d\t"
argument_list|,
name|bufp
operator|->
name|can_be_null
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"newline_anchor: %d\n"
argument_list|,
name|bufp
operator|->
name|newline_anchor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no_sub: %d\t"
argument_list|,
name|bufp
operator|->
name|no_sub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"not_bol: %d\t"
argument_list|,
name|bufp
operator|->
name|not_bol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"not_eol: %d\t"
argument_list|,
name|bufp
operator|->
name|not_eol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"syntax: %lx\n"
argument_list|,
name|bufp
operator|->
name|syntax
argument_list|)
expr_stmt|;
comment|/* Perhaps we should print the translate table?  */
block|}
end_function

begin_function
name|void
DECL|function|print_double_string (where,string1,size1,string2,size2)
name|print_double_string
parameter_list|(
name|where
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|)
specifier|const
name|char
modifier|*
name|where
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|;
specifier|const
name|char
modifier|*
name|string2
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|int
name|size2
decl_stmt|;
block|{
name|int
name|this_char
decl_stmt|;
if|if
condition|(
name|where
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"(null)"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|FIRST_STRING_P
argument_list|(
name|where
argument_list|)
condition|)
block|{
for|for
control|(
name|this_char
operator|=
name|where
operator|-
name|string1
init|;
name|this_char
operator|<
name|size1
condition|;
name|this_char
operator|++
control|)
name|putchar
argument_list|(
name|string1
index|[
name|this_char
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|string2
expr_stmt|;
block|}
for|for
control|(
name|this_char
operator|=
name|where
operator|-
name|string2
init|;
name|this_char
operator|<
name|size2
condition|;
name|this_char
operator|++
control|)
name|putchar
argument_list|(
name|string2
index|[
name|this_char
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|printchar (c)
name|printchar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not DEBUG */
end_comment

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_define
DECL|macro|assert (e)
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_STATEMENT (e)
define|#
directive|define
name|DEBUG_STATEMENT
parameter_list|(
name|e
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT1 (x)
define|#
directive|define
name|DEBUG_PRINT1
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT2 (x1,x2)
define|#
directive|define
name|DEBUG_PRINT2
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT3 (x1,x2,x3)
define|#
directive|define
name|DEBUG_PRINT3
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT4 (x1,x2,x3,x4)
define|#
directive|define
name|DEBUG_PRINT4
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|,
name|x4
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT_COMPILED_PATTERN (p,s,e)
define|#
directive|define
name|DEBUG_PRINT_COMPILED_PATTERN
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_PRINT_DOUBLE_STRING (w,s1,sz1,s2,sz2)
define|#
directive|define
name|DEBUG_PRINT_DOUBLE_STRING
parameter_list|(
name|w
parameter_list|,
name|s1
parameter_list|,
name|sz1
parameter_list|,
name|s2
parameter_list|,
name|sz2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can    also be assigned to arbitrarily: each pattern buffer stores its own    syntax, so it can be changed between regex compilations.  */
end_comment

begin_comment
comment|/* This has no initializer because initialized variables in Emacs    become read-only after dumping.  */
end_comment

begin_decl_stmt
DECL|variable|re_syntax_options
name|reg_syntax_t
name|re_syntax_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the precise syntax of regexps for compilation.  This provides    for compatibility for various utilities which historically have    different, incompatible syntaxes.     The argument SYNTAX is a bit mask comprised of the various bits    defined in regex.h.  We return the old syntax.  */
end_comment

begin_function
name|reg_syntax_t
DECL|function|re_set_syntax (syntax)
name|re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|reg_syntax_t
name|ret
init|=
name|re_syntax_options
decl_stmt|;
name|re_syntax_options
operator|=
name|syntax
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|syntax
operator|&
name|RE_DEBUG
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
condition|)
comment|/* was on but now is not */
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This table gives an error message for each of the error codes listed    in regex.h.  Obviously the order here has to be same as there.    POSIX doesn't require that we do anything for REG_NOERROR,    but why not be nice?  */
end_comment

begin_decl_stmt
DECL|variable|re_error_msgid
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|re_error_msgid
index|[]
init|=
block|{
literal|"Success"
block|,
comment|/* REG_NOERROR */
literal|"No match"
block|,
comment|/* REG_NOMATCH */
literal|"Invalid regular expression"
block|,
comment|/* REG_BADPAT */
literal|"Invalid collation character"
block|,
comment|/* REG_ECOLLATE */
literal|"Invalid character class name"
block|,
comment|/* REG_ECTYPE */
literal|"Trailing backslash"
block|,
comment|/* REG_EESCAPE */
literal|"Invalid back reference"
block|,
comment|/* REG_ESUBREG */
literal|"Unmatched [ or [^"
block|,
comment|/* REG_EBRACK */
literal|"Unmatched ( or \\("
block|,
comment|/* REG_EPAREN */
literal|"Unmatched \\{"
block|,
comment|/* REG_EBRACE */
literal|"Invalid content of \\{\\}"
block|,
comment|/* REG_BADBR */
literal|"Invalid range end"
block|,
comment|/* REG_ERANGE */
literal|"Memory exhausted"
block|,
comment|/* REG_ESPACE */
literal|"Invalid preceding regular expression"
block|,
comment|/* REG_BADRPT */
literal|"Premature end of regular expression"
block|,
comment|/* REG_EEND */
literal|"Regular expression too big"
block|,
comment|/* REG_ESIZE */
literal|"Unmatched ) or \\)"
block|,
comment|/* REG_ERPAREN */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Avoiding alloca during matching, to placate r_alloc.  */
end_comment

begin_comment
comment|/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the    searching and matching functions should not call alloca.  On some    systems, alloca is implemented in terms of malloc, and if we're    using the relocating allocator routines, then malloc could cause a    relocation, which might (if the strings being searched are in the    ralloc heap) shift the data out from underneath the regexp    routines.     Here's another reason to avoid allocation: Emacs    processes input from X in a signal handler; processing X input may    call malloc; if input arrives while a matching routine is calling    malloc, then we're scrod.  But Emacs can't just block input while    calling matching routines; then we don't notice interrupts when    they come in.  So, Emacs blocks input around all regexp calls    except the matching calls, which it leaves unprotected, in the    faith that they will not malloc.  */
end_comment

begin_comment
comment|/* Normally, this is fine.  */
end_comment

begin_define
DECL|macro|MATCH_MAY_ALLOCATE
define|#
directive|define
name|MATCH_MAY_ALLOCATE
end_define

begin_comment
comment|/* When using GNU C, we are not REALLY using the C alloca, no matter    what config.h may say.  So don't take precautions for it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_undef
undef|#
directive|undef
name|C_ALLOCA
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The match routines may not allocate if (1) they would do it with malloc    and (2) it's not safe for them to use malloc.    Note that if REL_ALLOC is defined, matching would not use malloc for the    failure stack, but we would still use it for the register vectors;    so REL_ALLOC should not affect this.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|C_ALLOCA
argument_list|)
operator|||
name|defined
argument_list|(
name|REGEX_MALLOC
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|emacs
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|MATCH_MAY_ALLOCATE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Failure stack declarations and macros; both re_compile_fastmap and    re_match_2 use a failure stack.  These have to be macros because of    REGEX_ALLOCATE_STACK.  */
end_comment

begin_comment
comment|/* Number of failure points for which to initially allocate space    when matching.  If this number is exceeded, we allocate more    space, so it is not a hard limit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INIT_FAILURE_ALLOC
end_ifndef

begin_define
DECL|macro|INIT_FAILURE_ALLOC
define|#
directive|define
name|INIT_FAILURE_ALLOC
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Roughly the maximum number of failure points on the stack.  Would be    exactly that if always used MAX_FAILURE_ITEMS items each time we failed.    This is a variable only so users of regex can assign to it; we never    change it ourselves.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INT_IS_16BIT
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MATCH_MAY_ALLOCATE
argument_list|)
end_if

begin_comment
comment|/* 4400 was enough to cause a crash on Alpha OSF/1,    whose default stack limit is 2mb.  */
end_comment

begin_decl_stmt
DECL|variable|re_max_failures
name|long
name|int
name|re_max_failures
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
DECL|variable|re_max_failures
name|long
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_union
DECL|union|fail_stack_elt
union|union
name|fail_stack_elt
block|{
DECL|member|pointer
name|unsigned
name|char
modifier|*
name|pointer
decl_stmt|;
DECL|member|integer
name|long
name|int
name|integer
decl_stmt|;
block|}
union|;
end_union

begin_typedef
DECL|typedef|fail_stack_elt_t
typedef|typedef
name|union
name|fail_stack_elt
name|fail_stack_elt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277f6f6a0208
block|{
DECL|member|stack
name|fail_stack_elt_t
modifier|*
name|stack
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|int
name|size
decl_stmt|;
DECL|member|avail
name|unsigned
name|long
name|int
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
DECL|typedef|fail_stack_type
block|}
name|fail_stack_type
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INT_IS_16BIT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MATCH_MAY_ALLOCATE
argument_list|)
end_if

begin_comment
comment|/* 4400 was enough to cause a crash on Alpha OSF/1,    whose default stack limit is 2mb.  */
end_comment

begin_decl_stmt
DECL|variable|re_max_failures
name|int
name|re_max_failures
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
DECL|variable|re_max_failures
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_union
DECL|union|fail_stack_elt
union|union
name|fail_stack_elt
block|{
DECL|member|pointer
name|unsigned
name|char
modifier|*
name|pointer
decl_stmt|;
DECL|member|integer
name|int
name|integer
decl_stmt|;
block|}
union|;
end_union

begin_typedef
DECL|typedef|fail_stack_elt_t
typedef|typedef
name|union
name|fail_stack_elt
name|fail_stack_elt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277f6f6a0308
block|{
DECL|member|stack
name|fail_stack_elt_t
modifier|*
name|stack
decl_stmt|;
DECL|member|size
name|unsigned
name|size
decl_stmt|;
DECL|member|avail
name|unsigned
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
DECL|typedef|fail_stack_type
block|}
name|fail_stack_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT_IS_16BIT */
end_comment

begin_define
DECL|macro|FAIL_STACK_EMPTY ()
define|#
directive|define
name|FAIL_STACK_EMPTY
parameter_list|()
value|(fail_stack.avail == 0)
end_define

begin_define
DECL|macro|FAIL_STACK_PTR_EMPTY ()
define|#
directive|define
name|FAIL_STACK_PTR_EMPTY
parameter_list|()
value|(fail_stack_ptr->avail == 0)
end_define

begin_define
DECL|macro|FAIL_STACK_FULL ()
define|#
directive|define
name|FAIL_STACK_FULL
parameter_list|()
value|(fail_stack.avail == fail_stack.size)
end_define

begin_comment
comment|/* Define macros to initialize and free the failure stack.    Do `return -2' if the alloc fails.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
end_ifdef

begin_define
DECL|macro|INIT_FAIL_STACK ()
define|#
directive|define
name|INIT_FAIL_STACK
parameter_list|()
define|\
value|do {									\     fail_stack.stack = (fail_stack_elt_t *)				\       REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\ 									\     if (fail_stack.stack == NULL)					\       return -2;							\ 									\     fail_stack.size = INIT_FAILURE_ALLOC;				\     fail_stack.avail = 0;						\   } while (0)
end_define

begin_define
DECL|macro|RESET_FAIL_STACK ()
define|#
directive|define
name|RESET_FAIL_STACK
parameter_list|()
value|REGEX_FREE_STACK (fail_stack.stack)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|INIT_FAIL_STACK ()
define|#
directive|define
name|INIT_FAIL_STACK
parameter_list|()
define|\
value|do {									\     fail_stack.avail = 0;						\   } while (0)
end_define

begin_define
DECL|macro|RESET_FAIL_STACK ()
define|#
directive|define
name|RESET_FAIL_STACK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.     Return 1 if succeeds, and 0 if either ran out of memory    allocating space for it or it was already too large.     REGEX_REALLOCATE_STACK requires `destination' be declared.   */
end_comment

begin_define
DECL|macro|DOUBLE_FAIL_STACK (fail_stack)
define|#
directive|define
name|DOUBLE_FAIL_STACK
parameter_list|(
name|fail_stack
parameter_list|)
define|\
value|((fail_stack).size> (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\    ? 0									\    : ((fail_stack).stack = (fail_stack_elt_t *)				\         REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\           (fail_stack).size * sizeof (fail_stack_elt_t),		\           ((fail_stack).size<< 1) * sizeof (fail_stack_elt_t)),	\ 									\       (fail_stack).stack == NULL					\       ? 0								\       : ((fail_stack).size<<= 1, 					\          1)))
end_define

begin_comment
comment|/* Push pointer POINTER on FAIL_STACK.    Return 1 if was able to do so and 0 if ran out of memory allocating    space to do so.  */
end_comment

begin_define
DECL|macro|PUSH_PATTERN_OP (POINTER,FAIL_STACK)
define|#
directive|define
name|PUSH_PATTERN_OP
parameter_list|(
name|POINTER
parameter_list|,
name|FAIL_STACK
parameter_list|)
define|\
value|((FAIL_STACK_FULL ()							\&& !DOUBLE_FAIL_STACK (FAIL_STACK))					\    ? 0									\    : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\       1))
end_define

begin_comment
comment|/* Push a pointer value onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
DECL|macro|PUSH_FAILURE_POINTER (item)
define|#
directive|define
name|PUSH_FAILURE_POINTER
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
end_define

begin_comment
comment|/* This pushes an integer-valued item onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
DECL|macro|PUSH_FAILURE_INT (item)
define|#
directive|define
name|PUSH_FAILURE_INT
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++].integer = (item)
end_define

begin_comment
comment|/* Push a fail_stack_elt_t value onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
DECL|macro|PUSH_FAILURE_ELT (item)
define|#
directive|define
name|PUSH_FAILURE_ELT
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++] =  (item)
end_define

begin_comment
comment|/* These three POP... operations complement the three PUSH... operations.    All assume that `fail_stack' is nonempty.  */
end_comment

begin_define
DECL|macro|POP_FAILURE_POINTER ()
define|#
directive|define
name|POP_FAILURE_POINTER
parameter_list|()
value|fail_stack.stack[--fail_stack.avail].pointer
end_define

begin_define
DECL|macro|POP_FAILURE_INT ()
define|#
directive|define
name|POP_FAILURE_INT
parameter_list|()
value|fail_stack.stack[--fail_stack.avail].integer
end_define

begin_define
DECL|macro|POP_FAILURE_ELT ()
define|#
directive|define
name|POP_FAILURE_ELT
parameter_list|()
value|fail_stack.stack[--fail_stack.avail]
end_define

begin_comment
comment|/* Used to omit pushing failure point id's when we're not debugging.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|DEBUG_PUSH
define|#
directive|define
name|DEBUG_PUSH
value|PUSH_FAILURE_INT
end_define

begin_define
DECL|macro|DEBUG_POP (item_addr)
define|#
directive|define
name|DEBUG_POP
parameter_list|(
name|item_addr
parameter_list|)
value|(item_addr)->integer = POP_FAILURE_INT ()
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|DEBUG_PUSH (item)
define|#
directive|define
name|DEBUG_PUSH
parameter_list|(
name|item
parameter_list|)
end_define

begin_define
DECL|macro|DEBUG_POP (item_addr)
define|#
directive|define
name|DEBUG_POP
parameter_list|(
name|item_addr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push the information about the state we will need    if we ever fail back to it.     Requires variables fail_stack, regstart, regend, reg_info, and    num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be    declared.     Does `return FAILURE_CODE' if runs out of memory.  */
end_comment

begin_define
DECL|macro|PUSH_FAILURE_POINT (pattern_place,string_place,failure_code)
define|#
directive|define
name|PUSH_FAILURE_POINT
parameter_list|(
name|pattern_place
parameter_list|,
name|string_place
parameter_list|,
name|failure_code
parameter_list|)
define|\
value|do {									\
comment|/* char *destination; */
value|\
comment|/* Must be int, so when we don't save any registers, the arithmetic	\        of 0 + -1 isn't done as unsigned.  */
value|\
comment|/* Can't be int, since there is not a shred of a guarantee that int	\        is wide enough to hold a value of something to which pointer can	\        be assigned */
value|\     s_reg_t this_reg;							\     									\     DEBUG_STATEMENT (failure_id++);					\     DEBUG_STATEMENT (nfailure_points_pushed++);				\     DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\     DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\     DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\ 									\     DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\     DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\ 									\
comment|/* Ensure we have enough space allocated for what we will push.  */
value|\     while (REMAINING_AVAIL_SLOTS< NUM_FAILURE_ITEMS)			\       {									\         if (!DOUBLE_FAIL_STACK (fail_stack))				\           return failure_code;						\ 									\         DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\ 		       (fail_stack).size);				\         DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\       }									\ 									\
comment|/* Push the info, starting with the registers.  */
value|\     DEBUG_PRINT1 ("\n");						\ 									\     if (1)								\       for (this_reg = lowest_active_reg; this_reg<= highest_active_reg; \ 	   this_reg++)							\ 	{								\ 	  DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);		\ 	  DEBUG_STATEMENT (num_regs_pushed++);				\ 									\ 	  DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);	\ 	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\ 									\ 	  DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\ 	  PUSH_FAILURE_POINTER (regend[this_reg]);			\ 									\ 	  DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\ 	  DEBUG_PRINT2 (" match_null=%d",				\ 			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" matched_something=%d",			\ 			MATCHED_SOMETHING (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" ever_matched=%d",				\ 			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\ 	  DEBUG_PRINT1 ("\n");						\ 	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\ 	}								\ 									\     DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\     PUSH_FAILURE_INT (lowest_active_reg);				\ 									\     DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\     PUSH_FAILURE_INT (highest_active_reg);				\ 									\     DEBUG_PRINT2 ("  Pushing pattern 0x%x:\n", pattern_place);		\     DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\     PUSH_FAILURE_POINTER (pattern_place);				\ 									\     DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\     DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \ 				 size2);				\     DEBUG_PRINT1 ("'\n");						\     PUSH_FAILURE_POINTER (string_place);				\ 									\     DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\     DEBUG_PUSH (failure_id);						\   } while (0)
end_define

begin_comment
comment|/* This is the number of items that are pushed and popped on the stack    for each register.  */
end_comment

begin_define
DECL|macro|NUM_REG_ITEMS
define|#
directive|define
name|NUM_REG_ITEMS
value|3
end_define

begin_comment
comment|/* Individual items aside from the registers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|NUM_NONREG_ITEMS
define|#
directive|define
name|NUM_NONREG_ITEMS
value|5
end_define

begin_comment
DECL|macro|NUM_NONREG_ITEMS
comment|/* Includes failure point id.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|NUM_NONREG_ITEMS
define|#
directive|define
name|NUM_NONREG_ITEMS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We push at most this many items on the stack.  */
end_comment

begin_comment
comment|/* We used to use (num_regs - 1), which is the number of registers    this regexp will save; but that was changed to 5    to avoid stack overflow for a regexp with lots of parens.  */
end_comment

begin_define
DECL|macro|MAX_FAILURE_ITEMS
define|#
directive|define
name|MAX_FAILURE_ITEMS
value|(5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
end_define

begin_comment
comment|/* We actually push this many items.  */
end_comment

begin_define
DECL|macro|NUM_FAILURE_ITEMS
define|#
directive|define
name|NUM_FAILURE_ITEMS
define|\
value|(((0							\      ? 0 : highest_active_reg - lowest_active_reg + 1)	\     * NUM_REG_ITEMS)					\    + NUM_NONREG_ITEMS)
end_define

begin_comment
comment|/* How many items can still be added to the stack without overflowing it.  */
end_comment

begin_define
DECL|macro|REMAINING_AVAIL_SLOTS
define|#
directive|define
name|REMAINING_AVAIL_SLOTS
value|((fail_stack).size - (fail_stack).avail)
end_define

begin_comment
comment|/* Pops what PUSH_FAIL_STACK pushes.     We restore into the parameters, all of which should be lvalues:      STR -- the saved data position.      PAT -- the saved pattern position.      LOW_REG, HIGH_REG -- the highest and lowest active registers.      REGSTART, REGEND -- arrays of string positions.      REG_INFO -- array of information about each subexpression.     Also assumes the variables `fail_stack' and (if debugging), `bufp',    `pend', `string1', `size1', `string2', and `size2'.  */
end_comment

begin_define
DECL|macro|POP_FAILURE_POINT (str,pat,low_reg,high_reg,regstart,regend,reg_info)
define|#
directive|define
name|POP_FAILURE_POINT
parameter_list|(
name|str
parameter_list|,
name|pat
parameter_list|,
name|low_reg
parameter_list|,
name|high_reg
parameter_list|,
name|regstart
parameter_list|,
name|regend
parameter_list|,
name|reg_info
parameter_list|)
define|\
value|{									\   DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\   s_reg_t this_reg;							\   const unsigned char *string_temp;					\ 									\   assert (!FAIL_STACK_EMPTY ());					\ 									\
comment|/* Remove failure points and point to how many regs pushed.  */
value|\   DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\   DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\   DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\ 									\   assert (fail_stack.avail>= NUM_NONREG_ITEMS);			\ 									\   DEBUG_POP (&failure_id);						\   DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\ 									\
comment|/* If the saved string location is NULL, it came from an		\      on_failure_keep_string_jump opcode, and we want to throw away the	\      saved NULL, thus retaining our current position in the string.  */
value|\   string_temp = POP_FAILURE_POINTER ();					\   if (string_temp != NULL)						\     str = (const char *) string_temp;					\ 									\   DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\   DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\   DEBUG_PRINT1 ("'\n");							\ 									\   pat = (unsigned char *) POP_FAILURE_POINTER ();			\   DEBUG_PRINT2 ("  Popping pattern 0x%x:\n", pat);			\   DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\ 									\
comment|/* Restore register info.  */
value|\   high_reg = (active_reg_t) POP_FAILURE_INT ();				\   DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\ 									\   low_reg = (active_reg_t) POP_FAILURE_INT ();				\   DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\ 									\   if (1)								\     for (this_reg = high_reg; this_reg>= low_reg; this_reg--)		\       {									\ 	DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);		\ 									\ 	reg_info[this_reg].word = POP_FAILURE_ELT ();			\ 	DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);	\ 									\ 	regend[this_reg] = (const char *) POP_FAILURE_POINTER ();	\ 	DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\ 									\ 	regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();	\ 	DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);	\       }									\   else									\     {									\       for (this_reg = highest_active_reg; this_reg> high_reg; this_reg--) \ 	{								\ 	  reg_info[this_reg].word.integer = 0;				\ 	  regend[this_reg] = 0;						\ 	  regstart[this_reg] = 0;					\ 	}								\       highest_active_reg = high_reg;					\     }									\ 									\   set_regs_matched_done = 0;						\   DEBUG_STATEMENT (nfailure_points_popped++);				\ }
end_define

begin_comment
comment|/* POP_FAILURE_POINT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Structure for per-register (a.k.a. per-group) information.    Other register information, such as the    starting and ending positions (which are addresses), and the list of    inner groups (which is a bits list) are maintained in separate    variables.     We are making a (strictly speaking) nonportable assumption here: that    the compiler will pack our bit fields into something that fits into    the type of `word', i.e., is something that fits into one item on the    failure stack.  */
end_comment

begin_comment
comment|/* Declarations and macros for re_match_2.  */
end_comment

begin_typedef
typedef|typedef
union|union
DECL|union|__anon277f6f6a040a
block|{
DECL|member|word
name|fail_stack_elt_t
name|word
decl_stmt|;
struct|struct
DECL|struct|__anon277f6f6a0508
block|{
comment|/* This field is one if this group can match the empty string,          zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
DECL|macro|MATCH_NULL_UNSET_VALUE
define|#
directive|define
name|MATCH_NULL_UNSET_VALUE
value|3
DECL|member|match_null_string_p
name|unsigned
name|match_null_string_p
range|:
literal|2
decl_stmt|;
DECL|member|is_active
name|unsigned
name|is_active
range|:
literal|1
decl_stmt|;
DECL|member|matched_something
name|unsigned
name|matched_something
range|:
literal|1
decl_stmt|;
DECL|member|ever_matched_something
name|unsigned
name|ever_matched_something
range|:
literal|1
decl_stmt|;
DECL|member|bits
block|}
name|bits
struct|;
DECL|typedef|register_info_type
block|}
name|register_info_type
typedef|;
end_typedef

begin_define
DECL|macro|REG_MATCH_NULL_STRING_P (R)
define|#
directive|define
name|REG_MATCH_NULL_STRING_P
parameter_list|(
name|R
parameter_list|)
value|((R).bits.match_null_string_p)
end_define

begin_define
DECL|macro|IS_ACTIVE (R)
define|#
directive|define
name|IS_ACTIVE
parameter_list|(
name|R
parameter_list|)
value|((R).bits.is_active)
end_define

begin_define
DECL|macro|MATCHED_SOMETHING (R)
define|#
directive|define
name|MATCHED_SOMETHING
parameter_list|(
name|R
parameter_list|)
value|((R).bits.matched_something)
end_define

begin_define
DECL|macro|EVER_MATCHED_SOMETHING (R)
define|#
directive|define
name|EVER_MATCHED_SOMETHING
parameter_list|(
name|R
parameter_list|)
value|((R).bits.ever_matched_something)
end_define

begin_comment
comment|/* Call this when have matched a real character; it sets `matched' flags    for the subexpressions which we are currently inside.  Also records    that those subexprs have matched.  */
end_comment

begin_define
DECL|macro|SET_REGS_MATCHED ()
define|#
directive|define
name|SET_REGS_MATCHED
parameter_list|()
define|\
value|do									\     {									\       if (!set_regs_matched_done)					\ 	{								\ 	  active_reg_t r;						\ 	  set_regs_matched_done = 1;					\ 	  for (r = lowest_active_reg; r<= highest_active_reg; r++)	\ 	    {								\ 	      MATCHED_SOMETHING (reg_info[r])				\ 		= EVER_MATCHED_SOMETHING (reg_info[r])			\ 		= 1;							\ 	    }								\ 	}								\     }									\   while (0)
end_define

begin_comment
comment|/* Registers are set to a sentinel when they haven't yet matched.  */
end_comment

begin_decl_stmt
DECL|variable|reg_unset_dummy
specifier|static
name|char
name|reg_unset_dummy
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|REG_UNSET_VALUE
define|#
directive|define
name|REG_UNSET_VALUE
value|(&reg_unset_dummy)
end_define

begin_define
DECL|macro|REG_UNSET (e)
define|#
directive|define
name|REG_UNSET
parameter_list|(
name|e
parameter_list|)
value|((e) == REG_UNSET_VALUE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Subroutine declarations and macros for regex_compile.  */
end_comment

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|regex_compile
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|pattern
operator|,
name|size_t
name|size
operator|,
name|reg_syntax_t
name|syntax
operator|,
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_op1
name|_RE_ARGS
argument_list|(
operator|(
name|re_opcode_t
name|op
operator|,
name|unsigned
name|char
operator|*
name|loc
operator|,
name|int
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_op2
name|_RE_ARGS
argument_list|(
operator|(
name|re_opcode_t
name|op
operator|,
name|unsigned
name|char
operator|*
name|loc
operator|,
name|int
name|arg1
operator|,
name|int
name|arg2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_op1
name|_RE_ARGS
argument_list|(
operator|(
name|re_opcode_t
name|op
operator|,
name|unsigned
name|char
operator|*
name|loc
operator|,
name|int
name|arg
operator|,
name|unsigned
name|char
operator|*
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_op2
name|_RE_ARGS
argument_list|(
operator|(
name|re_opcode_t
name|op
operator|,
name|unsigned
name|char
operator|*
name|loc
operator|,
name|int
name|arg1
operator|,
name|int
name|arg2
operator|,
name|unsigned
name|char
operator|*
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|at_begline_loc_p
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|pattern
operator|,
specifier|const
name|char
operator|*
name|p
operator|,
name|reg_syntax_t
name|syntax
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|at_endline_loc_p
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|p
operator|,
specifier|const
name|char
operator|*
name|pend
operator|,
name|reg_syntax_t
name|syntax
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|compile_range
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
name|p_ptr
operator|,
specifier|const
name|char
operator|*
name|pend
operator|,
name|char
operator|*
name|translate
operator|,
name|reg_syntax_t
name|syntax
operator|,
name|unsigned
name|char
operator|*
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch the next character in the uncompiled pattern---translating it    if necessary.  Also cast from a signed character in the constant    string passed to us by the user to an unsigned char that we can use    as an array index (in, e.g., `translate').  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATFETCH
end_ifndef

begin_define
DECL|macro|PATFETCH (c)
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (unsigned char) *p++;						\     if (translate) c = (unsigned char) translate[c];			\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fetch the next character in the uncompiled pattern, with no    translation.  */
end_comment

begin_define
DECL|macro|PATFETCH_RAW (c)
define|#
directive|define
name|PATFETCH_RAW
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (unsigned char) *p++; 						\   } while (0)
end_define

begin_comment
comment|/* Go backwards one character in the pattern.  */
end_comment

begin_define
DECL|macro|PATUNFETCH
define|#
directive|define
name|PATUNFETCH
value|p--
end_define

begin_comment
comment|/* If `translate' is non-null, return translate[D], else just D.  We    cast the subscript to translate because some data is declared as    `char *', to avoid warnings when a string constant is passed.  But    when we use a character as a subscript we must make it unsigned.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRANSLATE
end_ifndef

begin_define
DECL|macro|TRANSLATE (d)
define|#
directive|define
name|TRANSLATE
parameter_list|(
name|d
parameter_list|)
define|\
value|(translate ? (char) translate[(unsigned char) (d)] : (d))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for outputting the compiled pattern into `buffer'.  */
end_comment

begin_comment
comment|/* If the buffer isn't allocated when it comes in, use this.  */
end_comment

begin_define
DECL|macro|INIT_BUF_SIZE
define|#
directive|define
name|INIT_BUF_SIZE
value|32
end_define

begin_comment
comment|/* Make sure we have at least N more bytes of space in buffer.  */
end_comment

begin_define
DECL|macro|GET_BUFFER_SPACE (n)
define|#
directive|define
name|GET_BUFFER_SPACE
parameter_list|(
name|n
parameter_list|)
define|\
value|while ((unsigned long) (b - bufp->buffer + (n))> bufp->allocated)	\       EXTEND_BUFFER ()
end_define

begin_comment
comment|/* Make sure we have one more byte of buffer space and then add C to it.  */
end_comment

begin_define
DECL|macro|BUF_PUSH (c)
define|#
directive|define
name|BUF_PUSH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (1);						\     *b++ = (unsigned char) (c);						\   } while (0)
end_define

begin_comment
comment|/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
end_comment

begin_define
DECL|macro|BUF_PUSH_2 (c1,c2)
define|#
directive|define
name|BUF_PUSH_2
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (2);						\     *b++ = (unsigned char) (c1);					\     *b++ = (unsigned char) (c2);					\   } while (0)
end_define

begin_comment
comment|/* As with BUF_PUSH_2, except for three bytes.  */
end_comment

begin_define
DECL|macro|BUF_PUSH_3 (c1,c2,c3)
define|#
directive|define
name|BUF_PUSH_3
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|c3
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (3);						\     *b++ = (unsigned char) (c1);					\     *b++ = (unsigned char) (c2);					\     *b++ = (unsigned char) (c3);					\   } while (0)
end_define

begin_comment
comment|/* Store a jump with opcode OP at LOC to location TO.  We store a    relative address offset by the three bytes the jump itself occupies.  */
end_comment

begin_define
DECL|macro|STORE_JUMP (op,loc,to)
define|#
directive|define
name|STORE_JUMP
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|)
define|\
value|store_op1 (op, loc, (int) ((to) - (loc) - 3))
end_define

begin_comment
comment|/* Likewise, for a two-argument jump.  */
end_comment

begin_define
DECL|macro|STORE_JUMP2 (op,loc,to,arg)
define|#
directive|define
name|STORE_JUMP2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|,
name|arg
parameter_list|)
define|\
value|store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)
end_define

begin_comment
comment|/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
end_comment

begin_define
DECL|macro|INSERT_JUMP (op,loc,to)
define|#
directive|define
name|INSERT_JUMP
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|)
define|\
value|insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)
end_define

begin_comment
comment|/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
end_comment

begin_define
DECL|macro|INSERT_JUMP2 (op,loc,to,arg)
define|#
directive|define
name|INSERT_JUMP2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|,
name|arg
parameter_list|)
define|\
value|insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)
end_define

begin_comment
comment|/* This is not an arbitrary limit: the arguments which represent offsets    into the pattern are two bytes long.  So if 2^16 bytes turns out to    be too small, many things would have to change.  */
end_comment

begin_comment
comment|/* Any other compiler which, like MSC, has allocation limit below 2^16    bytes will have to use approach similar to what was done below for    MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up    reallocating to 0 bytes.  Such thing is not going to work too well.    You have been warned!!  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_comment
comment|/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.    The REALLOC define eliminates a flurry of conversion warnings,    but is not required. */
end_comment

begin_define
DECL|macro|MAX_BUF_SIZE
define|#
directive|define
name|MAX_BUF_SIZE
value|65500L
end_define

begin_define
DECL|macro|REALLOC (p,s)
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|realloc ((p), (size_t) (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|MAX_BUF_SIZE
define|#
directive|define
name|MAX_BUF_SIZE
value|(1L<< 16)
end_define

begin_define
DECL|macro|REALLOC (p,s)
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|realloc ((p), (s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Extend the buffer by twice its current size via realloc and    reset the pointers that pointed into the old block to point to the    correct places in the new one.  If extending the buffer results in it    being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
end_comment

begin_define
DECL|macro|EXTEND_BUFFER ()
define|#
directive|define
name|EXTEND_BUFFER
parameter_list|()
define|\
value|do { 									\     unsigned char *old_buffer = bufp->buffer;				\     if (bufp->allocated == MAX_BUF_SIZE) 				\       return REG_ESIZE;							\     bufp->allocated<<= 1;						\     if (bufp->allocated> MAX_BUF_SIZE)					\       bufp->allocated = MAX_BUF_SIZE; 					\     bufp->buffer = (unsigned char *) REALLOC (bufp->buffer, bufp->allocated);\     if (bufp->buffer == NULL)						\       return REG_ESPACE;						\
comment|/* If the buffer moved, move all the pointers into it.  */
value|\     if (old_buffer != bufp->buffer)					\       {									\         b = (b - old_buffer) + bufp->buffer;				\         begalt = (begalt - old_buffer) + bufp->buffer;			\         if (fixup_alt_jump)						\           fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\         if (laststart)							\           laststart = (laststart - old_buffer) + bufp->buffer;		\         if (pending_exact)						\           pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\       }									\   } while (0)
end_define

begin_comment
comment|/* Since we have one byte reserved for the register number argument to    {start,stop}_memory, the maximum number of groups we can report    things about is what fits in that byte.  */
end_comment

begin_define
DECL|macro|MAX_REGNUM
define|#
directive|define
name|MAX_REGNUM
value|255
end_define

begin_comment
comment|/* But patterns can have more than `MAX_REGNUM' registers.  We just    ignore the excess.  */
end_comment

begin_typedef
DECL|typedef|regnum_t
typedef|typedef
name|unsigned
name|regnum_t
typedef|;
end_typedef

begin_comment
comment|/* Macros for the compile stack.  */
end_comment

begin_comment
comment|/* Since offsets can go either forwards or backwards, this type needs to    be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
end_comment

begin_comment
comment|/* int may be not enough when sizeof(int) == 2.  */
end_comment

begin_typedef
DECL|typedef|pattern_offset_t
typedef|typedef
name|long
name|pattern_offset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277f6f6a0608
block|{
DECL|member|begalt_offset
name|pattern_offset_t
name|begalt_offset
decl_stmt|;
DECL|member|fixup_alt_jump
name|pattern_offset_t
name|fixup_alt_jump
decl_stmt|;
DECL|member|inner_group_offset
name|pattern_offset_t
name|inner_group_offset
decl_stmt|;
DECL|member|laststart_offset
name|pattern_offset_t
name|laststart_offset
decl_stmt|;
DECL|member|regnum
name|regnum_t
name|regnum
decl_stmt|;
DECL|typedef|compile_stack_elt_t
block|}
name|compile_stack_elt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277f6f6a0708
block|{
DECL|member|stack
name|compile_stack_elt_t
modifier|*
name|stack
decl_stmt|;
DECL|member|size
name|unsigned
name|size
decl_stmt|;
DECL|member|avail
name|unsigned
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
DECL|typedef|compile_stack_type
block|}
name|compile_stack_type
typedef|;
end_typedef

begin_define
DECL|macro|INIT_COMPILE_STACK_SIZE
define|#
directive|define
name|INIT_COMPILE_STACK_SIZE
value|32
end_define

begin_define
DECL|macro|COMPILE_STACK_EMPTY
define|#
directive|define
name|COMPILE_STACK_EMPTY
value|(compile_stack.avail == 0)
end_define

begin_define
DECL|macro|COMPILE_STACK_FULL
define|#
directive|define
name|COMPILE_STACK_FULL
value|(compile_stack.avail == compile_stack.size)
end_define

begin_comment
comment|/* The next available element.  */
end_comment

begin_define
DECL|macro|COMPILE_STACK_TOP
define|#
directive|define
name|COMPILE_STACK_TOP
value|(compile_stack.stack[compile_stack.avail])
end_define

begin_comment
comment|/* Set the bit for character C in a list.  */
end_comment

begin_define
DECL|macro|SET_LIST_BIT (c)
define|#
directive|define
name|SET_LIST_BIT
parameter_list|(
name|c
parameter_list|)
define|\
value|(b[((unsigned char) (c)) / BYTEWIDTH]               \    |= 1<< (((unsigned char) c) % BYTEWIDTH))
end_define

begin_comment
comment|/* Get the next unsigned number in the uncompiled pattern.  */
end_comment

begin_define
DECL|macro|GET_UNSIGNED_NUMBER (num)
define|#
directive|define
name|GET_UNSIGNED_NUMBER
parameter_list|(
name|num
parameter_list|)
define|\
value|{ if (p != pend)							\      {									\        PATFETCH (c); 							\        while (ISDIGIT (c)) 						\          { 								\            if (num< 0)							\               num = 0;							\            num = num * 10 + c - '0'; 					\            if (p == pend) 						\               break; 							\            PATFETCH (c);						\          } 								\        } 								\     }
end_define

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
operator|(
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|)
end_if

begin_comment
comment|/* The GNU C library provides support for user-defined character classes    and the functions from ISO C amendement 1.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHARCLASS_NAME_MAX
end_ifdef

begin_define
DECL|macro|CHAR_CLASS_MAX_LENGTH
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|CHARCLASS_NAME_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This shouldn't happen but some implementation might still have this    problem.  Use a reasonable default value.  */
end_comment

begin_define
DECL|macro|CHAR_CLASS_MAX_LENGTH
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|IS_CHAR_CLASS (string)
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
value|wctype (string)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|CHAR_CLASS_MAX_LENGTH
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|256
end_define

begin_comment
DECL|macro|CHAR_CLASS_MAX_LENGTH
comment|/* Namely, `xdigit'.  */
end_comment

begin_define
DECL|macro|IS_CHAR_CLASS (string)
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
define|\
value|(STREQ (string, "alpha") || STREQ (string, "upper")			\     || STREQ (string, "lower") || STREQ (string, "digit")		\     || STREQ (string, "alnum") || STREQ (string, "xdigit")		\     || STREQ (string, "space") || STREQ (string, "print")		\     || STREQ (string, "punct") || STREQ (string, "graph")		\     || STREQ (string, "cntrl") || STREQ (string, "blank"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MATCH_MAY_ALLOCATE
end_ifndef

begin_comment
comment|/* If we cannot allocate large objects within re_match_2_internal,    we make the fail stack and register vectors global.    The fail stack, we grow to the maximum size when a regexp    is compiled.    The register vectors, we adjust in size each time we    compile a regexp, according to the number of registers it needs.  */
end_comment

begin_decl_stmt
DECL|variable|fail_stack
specifier|static
name|fail_stack_type
name|fail_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size with which the following vectors are currently allocated.    That is so we can make them bigger as needed,    but never make them smaller.  */
end_comment

begin_decl_stmt
DECL|variable|regs_allocated_size
specifier|static
name|int
name|regs_allocated_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|regstart
DECL|variable|regend
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|regstart
decl_stmt|,
modifier|*
modifier|*
name|regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|old_regstart
DECL|variable|old_regend
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|old_regstart
decl_stmt|,
modifier|*
modifier|*
name|old_regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|best_regstart
DECL|variable|best_regend
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|best_regstart
decl_stmt|,
modifier|*
modifier|*
name|best_regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|reg_info
specifier|static
name|register_info_type
modifier|*
name|reg_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|reg_dummy
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|reg_dummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|reg_info_dummy
specifier|static
name|register_info_type
modifier|*
name|reg_info_dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the register vectors big enough for NUM_REGS registers,    but don't make them smaller.  */
end_comment

begin_expr_stmt
specifier|static
DECL|function|regex_grow_registers (num_regs)
name|regex_grow_registers
argument_list|(
argument|num_regs
argument_list|)
name|int
name|num_regs
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|num_regs
operator|>
name|regs_allocated_size
condition|)
block|{
name|RETALLOC_IF
argument_list|(
name|regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|old_regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|old_regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|best_regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|best_regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|reg_info
argument_list|,
name|num_regs
argument_list|,
name|register_info_type
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|reg_dummy
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|reg_info_dummy
argument_list|,
name|num_regs
argument_list|,
name|register_info_type
argument_list|)
expr_stmt|;
name|regs_allocated_size
operator|=
name|num_regs
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MATCH_MAY_ALLOCATE */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|boolean
name|group_in_compile_stack
name|_RE_ARGS
argument_list|(
operator|(
name|compile_stack_type
name|compile_stack
operator|,
name|regnum_t
name|regnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.    Returns one of error codes defined in `regex.h', or zero for success.     Assumes the `allocated' (and perhaps `buffer') and `translate'    fields are set in BUFP on entry.     If it succeeds, results are put in BUFP (if it returns an error, the    contents of BUFP are undefined):      `buffer' is the compiled pattern;      `syntax' is set to SYNTAX;      `used' is set to the length of the compiled pattern;      `fastmap_accurate' is zero;      `re_nsub' is the number of subexpressions in PATTERN;      `not_bol' and `not_eol' are zero;     The `fastmap' and `newline_anchor' fields are neither    examined nor set.  */
end_comment

begin_comment
comment|/* Return, freeing storage we allocated.  */
end_comment

begin_define
DECL|macro|FREE_STACK_RETURN (value)
define|#
directive|define
name|FREE_STACK_RETURN
parameter_list|(
name|value
parameter_list|)
define|\
value|return (free (compile_stack.stack), value)
end_define

begin_function
specifier|static
name|reg_errcode_t
DECL|function|regex_compile (pattern,size,syntax,bufp)
name|regex_compile
parameter_list|(
name|pattern
parameter_list|,
name|size
parameter_list|,
name|syntax
parameter_list|,
name|bufp
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
comment|/* We fetch characters from PATTERN here.  Even though PATTERN is      `char *' (i.e., signed), we declare these variables as unsigned, so      they can be reliably used as array indices.  */
specifier|register
name|unsigned
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|;
comment|/* A random temporary spot in PATTERN.  */
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Points to the end of the buffer, where we should append.  */
specifier|register
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
comment|/* Keeps track of unclosed groups.  */
name|compile_stack_type
name|compile_stack
decl_stmt|;
comment|/* Points to the current (ending) position in the pattern.  */
specifier|const
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
comment|/* How to translate the characters in the pattern.  */
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* Address of the count-byte of the most recently inserted `exactn'      command.  This makes it possible to tell if a new exact-match      character can be added to that command or if the character requires      a new `exactn' command.  */
name|unsigned
name|char
modifier|*
name|pending_exact
init|=
literal|0
decl_stmt|;
comment|/* Address of start of the most recently finished expression.      This tells, e.g., postfix * where to find the start of its      operand.  Reset at the beginning of groups and alternatives.  */
name|unsigned
name|char
modifier|*
name|laststart
init|=
literal|0
decl_stmt|;
comment|/* Address of beginning of regexp, or inside of last group.  */
name|unsigned
name|char
modifier|*
name|begalt
decl_stmt|;
comment|/* Place in the uncompiled pattern (i.e., the {) to      which to go back if the interval is invalid.  */
specifier|const
name|char
modifier|*
name|beg_interval
decl_stmt|;
comment|/* Address of the place where a forward jump should go to the end of      the containing expression.  Each alternative of an `or' -- except the      last -- ends with a forward jump of this sort.  */
name|unsigned
name|char
modifier|*
name|fixup_alt_jump
init|=
literal|0
decl_stmt|;
comment|/* Counts open-groups as they are encountered.  Remembered for the      matching close-group on the compile stack, so the same register      number is put in the stop_memory as the start_memory.  */
name|regnum_t
name|regnum
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|DEBUG_PRINT1
argument_list|(
literal|"\nCompiling pattern: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|unsigned
name|debug_count
decl_stmt|;
for|for
control|(
name|debug_count
operator|=
literal|0
init|;
name|debug_count
operator|<
name|size
condition|;
name|debug_count
operator|++
control|)
name|putchar
argument_list|(
name|pattern
index|[
name|debug_count
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Initialize the compile stack.  */
name|compile_stack
operator|.
name|stack
operator|=
name|TALLOC
argument_list|(
name|INIT_COMPILE_STACK_SIZE
argument_list|,
name|compile_stack_elt_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|compile_stack
operator|.
name|size
operator|=
name|INIT_COMPILE_STACK_SIZE
expr_stmt|;
name|compile_stack
operator|.
name|avail
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the pattern buffer.  */
name|bufp
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
name|bufp
operator|->
name|not_bol
operator|=
name|bufp
operator|->
name|not_eol
operator|=
literal|0
expr_stmt|;
comment|/* Set `used' to zero, so that if we return an error, the pattern      printer (for debugging) will think there's no pattern.  We reset it      at the end.  */
name|bufp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Always count groups, whether or not bufp->no_sub is set.  */
name|bufp
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|emacs
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYNTAX_TABLE
argument_list|)
comment|/* Initialize the syntax table.  */
name|init_syntax_once
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bufp
operator|->
name|allocated
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bufp
operator|->
name|buffer
condition|)
block|{
comment|/* If zero allocated, but buffer is non-null, try to realloc              enough space.  This loses if buffer's address is bogus, but              that is the user's responsibility.  */
name|RETALLOC
argument_list|(
argument|bufp->buffer
argument_list|,
argument|INIT_BUF_SIZE
argument_list|,
argument|unsigned char
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Caller did not allocate a buffer.  Do it for them.  */
name|bufp
operator|->
name|buffer
operator|=
name|TALLOC
argument_list|(
argument|INIT_BUF_SIZE
argument_list|,
argument|unsigned char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bufp
operator|->
name|buffer
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|allocated
operator|=
name|INIT_BUF_SIZE
expr_stmt|;
block|}
name|begalt
operator|=
name|b
operator|=
name|bufp
operator|->
name|buffer
expr_stmt|;
comment|/* Loop through the uncompiled pattern until we're at the end.  */
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
block|{
if|if
condition|(
comment|/* If at start of pattern, it's an operator.  */
name|p
operator|==
name|pattern
operator|+
literal|1
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's come before.  */
operator|||
name|at_begline_loc_p
argument_list|(
name|pattern
argument_list|,
name|p
argument_list|,
name|syntax
argument_list|)
condition|)
name|BUF_PUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'$'
case|:
block|{
if|if
condition|(
comment|/* If at end of pattern, it's an operator.  */
name|p
operator|==
name|pend
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's next.  */
operator|||
name|at_endline_loc_p
argument_list|(
name|p
argument_list|,
name|pend
argument_list|,
name|syntax
argument_list|)
condition|)
name|BUF_PUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|||
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|handle_plus
label|:
case|case
literal|'*'
case|:
comment|/* If there is no previous pattern... */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
block|}
block|{
comment|/* Are we optimizing this jump?  */
name|boolean
name|keep_string_p
init|=
name|false
decl_stmt|;
comment|/* 1 means zero (many) matches is allowed.  */
name|char
name|zero_times_ok
init|=
literal|0
decl_stmt|,
name|many_times_ok
init|=
literal|0
decl_stmt|;
comment|/* If there is a sequence of repetition chars, collapse it                down to just one (the right one).  We can't combine                interval operators with these because of, e.g., `a{2}*',                which should only match an even number of `a's.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|zero_times_ok
operator||=
name|c
operator|!=
literal|'+'
expr_stmt|;
name|many_times_ok
operator||=
name|c
operator|!=
literal|'?'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|||
operator|(
operator|!
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|==
literal|'+'
operator|||
name|c1
operator|==
literal|'?'
operator|)
condition|)
block|{
name|PATUNFETCH
expr_stmt|;
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
comment|/* If we get here, we found another repeat character.  */
block|}
comment|/* Star, etc. applied to an empty pattern is equivalent                to an empty pattern.  */
if|if
condition|(
operator|!
name|laststart
condition|)
break|break;
comment|/* Now we know whether or not zero matches is allowed                and also whether or not two or more matches is allowed.  */
if|if
condition|(
name|many_times_ok
condition|)
block|{
comment|/* More than one repetition is allowed, so put in at the                    end a backward relative jump from `b' to before the next                    jump we're going to put in below (which jumps from                    laststart to after this jump).                     But if we are at the `*' in the exact sequence `.*\n',                    insert an unconditional jump backwards to the .,                    instead of the beginning of the loop.  This way we only                    push a failure point once, instead of every time                    through the loop.  */
name|assert
argument_list|(
name|p
operator|-
literal|1
operator|>
name|pattern
argument_list|)
expr_stmt|;
comment|/* Allocate the space for the jump.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* We know we are not at the first character of the pattern,                    because laststart was nonzero.  And we've already                    incremented `p', by the way, to be the character after                    the `*'.  Do we have to do something analogous here                    for null bytes, because of RE_DOT_NOT_NULL?  */
if|if
condition|(
name|TRANSLATE
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
argument_list|)
operator|==
name|TRANSLATE
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|zero_times_ok
operator|&&
name|p
operator|<
name|pend
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|TRANSLATE
argument_list|(
literal|'\n'
argument_list|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
block|{
comment|/* We have .*\n.  */
name|STORE_JUMP
argument_list|(
name|jump
argument_list|,
name|b
argument_list|,
name|laststart
argument_list|)
expr_stmt|;
name|keep_string_p
operator|=
name|true
expr_stmt|;
block|}
else|else
comment|/* Anything else.  */
name|STORE_JUMP
argument_list|(
name|maybe_pop_jump
argument_list|,
name|b
argument_list|,
name|laststart
operator|-
literal|3
argument_list|)
expr_stmt|;
comment|/* We've added more stuff to the buffer.  */
name|b
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* On failure, jump from laststart to b + 3, which will be the                end of the buffer after this jump is inserted.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|keep_string_p
condition|?
name|on_failure_keep_string_jump
else|:
name|on_failure_jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|zero_times_ok
condition|)
block|{
comment|/* At least one repetition is required, so insert a                    `dummy_failure_jump' before the initial                    `on_failure_jump' instruction of the loop. This                    effects a skip over that instruction the first time                    we hit that loop.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|dummy_failure_jump
argument_list|,
name|laststart
argument_list|,
name|laststart
operator|+
literal|6
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|anychar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
block|{
name|boolean
name|had_char_class
init|=
name|false
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough space to push a charset: the                opcode, the length count, and the bitset; 34 bytes in all.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|laststart
operator|=
name|b
expr_stmt|;
comment|/* We test `*p == '^' twice, instead of using an if                statement, so we only need one BUF_PUSH.  */
name|BUF_PUSH
argument_list|(
operator|*
name|p
operator|==
literal|'^'
condition|?
name|charset_not
else|:
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Remember the first position in the bracket expression.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Push the number of bytes in the bitmap.  */
name|BUF_PUSH
argument_list|(
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Clear the whole map.  */
name|bzero
argument_list|(
name|b
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* charset_not matches newline according to a syntax bit.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|b
index|[
operator|-
literal|2
index|]
operator|==
name|charset_not
operator|&&
operator|(
name|syntax
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Read in characters and ranges, setting map bits.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* \ might escape characters inside [...] and [^...].  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
name|c1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Could be the end of the bracket expression.  If it's                    not (i.e., when the bracket expression is `[]' so                    far), the ']' character bit gets set way below.  */
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|p
operator|!=
name|p1
operator|+
literal|1
condition|)
break|break;
comment|/* Look ahead to see if it's a range when the last thing                    was a character class.  */
if|if
condition|(
name|had_char_class
operator|&&
name|c
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
comment|/* Look ahead to see if it's a range when the last thing                    was a character: if this is a hyphen not at the                    beginning or the end of a list, then it's the range                    operator.  */
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
operator|(
name|p
operator|-
literal|2
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'['
operator|)
operator|&&
operator|!
operator|(
name|p
operator|-
literal|3
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|3
index|]
operator|==
literal|'['
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'^'
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|reg_errcode_t
name|ret
init|=
name|compile_range
argument_list|(
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
comment|/* This handles ranges made up of characters only.  */
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Move past the `-'.  */
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|compile_range
argument_list|(
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* See if we're at the beginning of a possible character                    class.  */
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* Leave room for the null.  */
name|char
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[:'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
operator|||
name|c1
operator|==
name|CHAR_CLASS_MAX_LENGTH
condition|)
break|break;
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If isn't a word bracketed by `[:' and:`]':                        undo the ending character, the letters, and leave                        the leading `:' and `[' (but set bits for them).  */
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|||
operator|(
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|)
name|boolean
name|is_lower
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
decl_stmt|;
name|boolean
name|is_upper
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
decl_stmt|;
name|wctype_t
name|wt
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|wt
operator|=
name|wctype
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt
operator|==
literal|0
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|1
operator|<<
name|BYTEWIDTH
condition|;
operator|++
name|ch
control|)
block|{
if|if
condition|(
name|iswctype
argument_list|(
name|btowc
argument_list|(
name|ch
argument_list|)
argument_list|,
name|wt
argument_list|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|translate
operator|&&
operator|(
name|is_upper
operator|||
name|is_lower
operator|)
operator|&&
operator|(
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|||
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|had_char_class
operator|=
name|true
expr_stmt|;
else|#
directive|else
name|int
name|ch
decl_stmt|;
name|boolean
name|is_alnum
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"alnum"
argument_list|)
decl_stmt|;
name|boolean
name|is_alpha
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"alpha"
argument_list|)
decl_stmt|;
name|boolean
name|is_blank
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"blank"
argument_list|)
decl_stmt|;
name|boolean
name|is_cntrl
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"cntrl"
argument_list|)
decl_stmt|;
name|boolean
name|is_digit
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"digit"
argument_list|)
decl_stmt|;
name|boolean
name|is_graph
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"graph"
argument_list|)
decl_stmt|;
name|boolean
name|is_lower
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
decl_stmt|;
name|boolean
name|is_print
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"print"
argument_list|)
decl_stmt|;
name|boolean
name|is_punct
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"punct"
argument_list|)
decl_stmt|;
name|boolean
name|is_space
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"space"
argument_list|)
decl_stmt|;
name|boolean
name|is_upper
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
decl_stmt|;
name|boolean
name|is_xdigit
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"xdigit"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|1
operator|<<
name|BYTEWIDTH
condition|;
name|ch
operator|++
control|)
block|{
comment|/* This was split into 3 if's to 			       avoid an arbitrary limit in some compiler.  */
if|if
condition|(
operator|(
name|is_alnum
operator|&&
name|ISALNUM
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_alpha
operator|&&
name|ISALPHA
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_blank
operator|&&
name|ISBLANK
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_cntrl
operator|&&
name|ISCNTRL
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_digit
operator|&&
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_graph
operator|&&
name|ISGRAPH
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_lower
operator|&&
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_print
operator|&&
name|ISPRINT
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_punct
operator|&&
name|ISPUNCT
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_space
operator|&&
name|ISSPACE
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_upper
operator|&&
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_xdigit
operator|&&
name|ISXDIGIT
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|translate
operator|&&
operator|(
name|is_upper
operator|||
name|is_lower
operator|)
operator|&&
operator|(
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|||
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|had_char_class
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* libc || wctype.h */
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|had_char_class
operator|=
name|false
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Discard any (non)matching list bytes that are all 0 at the                end of the map.  Decrease the map-length byte too.  */
while|while
condition|(
operator|(
name|int
operator|)
name|b
index|[
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|b
index|[
name|b
index|[
operator|-
literal|1
index|]
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|b
operator|+=
name|b
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_open
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_close
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NEWLINE_ALT
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'{'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_INTERVALS
operator|&&
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|handle_interval
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
comment|/* Do not translate the character after the \, so that we can              distinguish, e.g., \B from \b, even if we normally would              translate, e.g., B to b.  */
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_open
label|:
name|bufp
operator|->
name|re_nsub
operator|++
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
if|if
condition|(
name|COMPILE_STACK_FULL
condition|)
block|{
name|RETALLOC
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|,
name|compile_stack
operator|.
name|size
operator|<<
literal|1
argument_list|,
name|compile_stack_elt_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|compile_stack
operator|.
name|size
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* These are the values to restore when we hit end of this                  group.  They are all relative offsets, so that if the                  whole pattern moves because of realloc, they will still                  be valid.  */
name|COMPILE_STACK_TOP
operator|.
name|begalt_offset
operator|=
name|begalt
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
operator|=
name|fixup_alt_jump
condition|?
name|fixup_alt_jump
operator|-
name|bufp
operator|->
name|buffer
operator|+
literal|1
else|:
literal|0
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|laststart_offset
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|regnum
operator|=
name|regnum
expr_stmt|;
comment|/* We will eventually replace the 0 with the number of                  groups inner to this one.  But do not push a                  start_memory for groups beyond the last one we can                  represent in the compiled pattern.  */
if|if
condition|(
name|regnum
operator|<=
name|MAX_REGNUM
condition|)
block|{
name|COMPILE_STACK_TOP
operator|.
name|inner_group_offset
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
operator|+
literal|2
expr_stmt|;
name|BUF_PUSH_3
argument_list|(
name|start_memory
argument_list|,
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|compile_stack
operator|.
name|avail
operator|++
expr_stmt|;
name|fixup_alt_jump
operator|=
literal|0
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
comment|/* If we've reached MAX_REGNUM groups, then this open 		 won't actually generate any code, so we'll have to 		 clear pending_exact explicitly.  */
name|pending_exact
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
if|if
condition|(
name|COMPILE_STACK_EMPTY
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_backslash
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERPAREN
argument_list|)
expr_stmt|;
block|}
name|handle_close
label|:
if|if
condition|(
name|fixup_alt_jump
condition|)
block|{
comment|/* Push a dummy failure point at the end of the                      alternative for a possible future                      `pop_failure_jump' to pop.  See comments at                      `push_dummy_failure' in `re_match_2'.  */
name|BUF_PUSH
argument_list|(
name|push_dummy_failure
argument_list|)
expr_stmt|;
comment|/* We allocated space for this jump when we assigned                      to `fixup_alt_jump', in the `handle_alt' case below.  */
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See similar code for backslashed left paren above.  */
if|if
condition|(
name|COMPILE_STACK_EMPTY
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_char
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERPAREN
argument_list|)
expr_stmt|;
block|}
comment|/* Since we just checked for an empty stack above, this                  ``can't happen''.  */
name|assert
argument_list|(
name|compile_stack
operator|.
name|avail
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|{
comment|/* We don't just want to restore into `regnum', because                    later groups should continue to be numbered higher,                    as in `(ab)c(de)' -- the second group is #2.  */
name|regnum_t
name|this_group_regnum
decl_stmt|;
name|compile_stack
operator|.
name|avail
operator|--
expr_stmt|;
name|begalt
operator|=
name|bufp
operator|->
name|buffer
operator|+
name|COMPILE_STACK_TOP
operator|.
name|begalt_offset
expr_stmt|;
name|fixup_alt_jump
operator|=
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
condition|?
name|bufp
operator|->
name|buffer
operator|+
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|laststart
operator|=
name|bufp
operator|->
name|buffer
operator|+
name|COMPILE_STACK_TOP
operator|.
name|laststart_offset
expr_stmt|;
name|this_group_regnum
operator|=
name|COMPILE_STACK_TOP
operator|.
name|regnum
expr_stmt|;
comment|/* If we've reached MAX_REGNUM groups, then this open 		   won't actually generate any code, so we'll have to 		   clear pending_exact explicitly.  */
name|pending_exact
operator|=
literal|0
expr_stmt|;
comment|/* We're at the end of the group, so now we know how many                    groups were inside this one.  */
if|if
condition|(
name|this_group_regnum
operator|<=
name|MAX_REGNUM
condition|)
block|{
name|unsigned
name|char
modifier|*
name|inner_group_loc
init|=
name|bufp
operator|->
name|buffer
operator|+
name|COMPILE_STACK_TOP
operator|.
name|inner_group_offset
decl_stmt|;
operator|*
name|inner_group_loc
operator|=
name|regnum
operator|-
name|this_group_regnum
expr_stmt|;
name|BUF_PUSH_3
argument_list|(
name|stop_memory
argument_list|,
name|this_group_regnum
argument_list|,
name|regnum
operator|-
name|this_group_regnum
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* `\|'.  */
if|if
condition|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|||
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_alt
label|:
if|if
condition|(
name|syntax
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Insert before the previous alternative a jump which                  jumps to this alternative if the former fails.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|on_failure_jump
argument_list|,
name|begalt
argument_list|,
name|b
operator|+
literal|6
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
comment|/* The alternative before this one has a jump after it                  which gets executed if it gets matched.  Adjust that                  jump so it will jump to this alternative's analogous                  jump (put in below, which in turn will jump to the next                  (if any) alternative's such jump, etc.).  The last such                  jump jumps to the correct final destination.  A picture:                           _____ _____                           |   | |   |                           |   v |   v                          a | b   | c                   If we are at `b', then fixup_alt_jump right now points to a                  three-byte space after `a'.  We'll put in the jump, set                  fixup_alt_jump to right after `b', and leave behind three                  bytes which we'll fill in when we get to after `c'.  */
if|if
condition|(
name|fixup_alt_jump
condition|)
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Mark and leave space for a jump after this alternative,                  to be filled in later either by next alternative or                  when know we're at the end of a series of alternatives.  */
name|fixup_alt_jump
operator|=
name|b
expr_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* If \{ is a literal.  */
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
comment|/* If we're at `\{' and it's not the open-interval                         operator.  */
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|)
operator|||
operator|(
name|p
operator|-
literal|2
operator|==
name|pattern
operator|&&
name|p
operator|==
name|pend
operator|)
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_interval
label|:
block|{
comment|/* If got here, then the syntax allows intervals.  */
comment|/* At least (most) this many matches must be made.  */
name|int
name|lower_bound
init|=
operator|-
literal|1
decl_stmt|,
name|upper_bound
init|=
operator|-
literal|1
decl_stmt|;
name|beg_interval
operator|=
name|p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACE
argument_list|)
expr_stmt|;
block|}
name|GET_UNSIGNED_NUMBER
argument_list|(
name|lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|GET_UNSIGNED_NUMBER
argument_list|(
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|<
literal|0
condition|)
name|upper_bound
operator|=
name|RE_DUP_MAX
expr_stmt|;
block|}
else|else
comment|/* Interval such as `{1}' => match exactly once. */
name|upper_bound
operator|=
name|lower_bound
expr_stmt|;
if|if
condition|(
name|lower_bound
operator|<
literal|0
operator|||
name|upper_bound
operator|>
name|RE_DUP_MAX
operator|||
name|lower_bound
operator|>
name|upper_bound
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
comment|/* We just parsed a valid interval.  */
comment|/* If it's invalid to have no preceding re.  */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
condition|)
name|laststart
operator|=
name|b
expr_stmt|;
else|else
goto|goto
name|unfetch_interval
goto|;
block|}
comment|/* If the upper bound is zero, don't want to succeed at                    all; jump from `laststart' to `b + 3', which will be                    the end of the buffer after we insert the jump.  */
if|if
condition|(
name|upper_bound
operator|==
literal|0
condition|)
block|{
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|3
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* Otherwise, we have a nontrivial interval.  When                     we're all done, the pattern will look like:                       set_number_at<jump count><upper bound>                       set_number_at<succeed_n count><lower bound>                       succeed_n<after jump addr><succeed_n count><body of loop>                       jump_n<succeed_n addr><jump count>                     (The upper bound and `jump_n' are omitted if                     `upper_bound' is 1, though.)  */
else|else
block|{
comment|/* If the upper bound is> 1, we need to insert                         more at the end of the loop.  */
name|unsigned
name|nbytes
init|=
literal|10
operator|+
operator|(
name|upper_bound
operator|>
literal|1
operator|)
operator|*
literal|10
decl_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Initialize lower bound of the `succeed_n', even                         though it will be set during matching by its                         attendant `set_number_at' (inserted next),                         because `re_compile_fastmap' needs to know.                         Jump to the `jump_n' we might insert below.  */
name|INSERT_JUMP2
argument_list|(
name|succeed_n
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|5
operator|+
operator|(
name|upper_bound
operator|>
literal|1
operator|)
operator|*
literal|5
argument_list|,
name|lower_bound
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
comment|/* Code to initialize the lower bound.  Insert                         before the `succeed_n'.  The `5' is the last two                         bytes of this `set_number_at', plus 3 bytes of                         the following `succeed_n'.  */
name|insert_op2
argument_list|(
name|set_number_at
argument_list|,
name|laststart
argument_list|,
literal|5
argument_list|,
name|lower_bound
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|>
literal|1
condition|)
block|{
comment|/* More than one repetition is allowed, so                             append a backward jump to the `succeed_n'                             that starts this interval.                              When we've reached this during matching,                             we'll have matched the interval once, so                             jump back only `upper_bound - 1' times.  */
name|STORE_JUMP2
argument_list|(
name|jump_n
argument_list|,
name|b
argument_list|,
name|laststart
operator|+
literal|5
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
comment|/* The location we want to set is the second                             parameter of the `jump_n'; that is `b-2' as                             an absolute address.  `laststart' will be                             the `set_number_at' we're about to insert;                             `laststart+3' the number to set, the source                             for the relative address.  But we are                             inserting into the middle of the pattern --                             so everything is getting moved up by 5.                             Conclusion: (b - 2) - (laststart + 3) + 5,                             i.e., b - laststart.                              We insert this at the beginning of the loop                             so that if we fail during matching, we'll                             reinitialize the bounds.  */
name|insert_op2
argument_list|(
name|set_number_at
argument_list|,
name|laststart
argument_list|,
name|b
operator|-
name|laststart
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
block|}
block|}
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|beg_interval
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
name|unfetch_interval
label|:
comment|/* If an invalid interval, match the characters as literals.  */
name|assert
argument_list|(
name|beg_interval
argument_list|)
expr_stmt|;
name|p
operator|=
name|beg_interval
expr_stmt|;
name|beg_interval
operator|=
name|NULL
expr_stmt|;
comment|/* normal_char and normal_backslash need `c'.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|pattern
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
goto|goto
name|normal_backslash
goto|;
block|}
goto|goto
name|normal_char
goto|;
ifdef|#
directive|ifdef
name|emacs
comment|/* There is no way to specify the before_dot and after_dot                operators.  rms says this is ok.  --karl  */
case|case
literal|'='
case|:
name|BUF_PUSH
argument_list|(
name|at_dot
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|syntaxspec
argument_list|,
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|notsyntaxspec
argument_list|,
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
literal|'w'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|wordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|notwordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordbeg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordend
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|notwordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|begbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|re_syntax_options
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|endbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_REFS
condition|)
goto|goto
name|normal_char
goto|;
name|c1
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c1
operator|>
name|regnum
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ESUBREG
argument_list|)
expr_stmt|;
comment|/* Can't back reference to a subexpression if inside of it.  */
if|if
condition|(
name|group_in_compile_stack
argument_list|(
name|compile_stack
argument_list|,
operator|(
name|regnum_t
operator|)
name|c1
argument_list|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|duplicate
argument_list|,
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|handle_plus
goto|;
else|else
goto|goto
name|normal_backslash
goto|;
default|default:
name|normal_backslash
label|:
comment|/* You might think it would be useful for \ to mean                  not to translate; but if we don't translate it                  it will never match anything.  */
name|c
operator|=
name|TRANSLATE
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|normal_char
goto|;
block|}
break|break;
default|default:
comment|/* Expects the character in `c'.  */
name|normal_char
label|:
comment|/* If no exactn currently being built.  */
if|if
condition|(
operator|!
name|pending_exact
comment|/* If last exactn not at current position.  */
operator|||
name|pending_exact
operator|+
operator|*
name|pending_exact
operator|+
literal|1
operator|!=
name|b
comment|/* We have only one byte following the exactn for the count.  */
operator|||
operator|*
name|pending_exact
operator|==
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|-
literal|1
comment|/* If followed by a repetition operator.  */
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'^'
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|?
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
else|:
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|?
operator|*
name|p
operator|==
literal|'{'
else|:
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'{'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Start building a new exactn.  */
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|exactn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
name|b
operator|-
literal|1
expr_stmt|;
block|}
name|BUF_PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pending_exact
operator|)
operator|++
expr_stmt|;
break|break;
block|}
comment|/* switch (c) */
block|}
comment|/* while p != pend */
comment|/* Through the pattern now.  */
if|if
condition|(
name|fixup_alt_jump
condition|)
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPILE_STACK_EMPTY
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
comment|/* If we don't want backtracking, force success      the first time we reach the end of the compiled pattern.  */
if|if
condition|(
name|syntax
operator|&
name|RE_NO_POSIX_BACKTRACKING
condition|)
name|BUF_PUSH
argument_list|(
name|succeed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|)
expr_stmt|;
comment|/* We have succeeded; set the length of the buffer.  */
name|bufp
operator|->
name|used
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|DEBUG_PRINT1
argument_list|(
literal|"\nCompiled pattern: \n"
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
ifndef|#
directive|ifndef
name|MATCH_MAY_ALLOCATE
comment|/* Initialize the failure stack to the largest possible stack.  This      isn't necessary unless we're trying to avoid calling alloca in      the search and match routines.  */
block|{
name|int
name|num_regs
init|=
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
decl_stmt|;
comment|/* Since DOUBLE_FAIL_STACK refuses to double only if the current size        is strictly greater than re_max_failures, the largest possible stack        is 2 * re_max_failures failure points.  */
if|if
condition|(
name|fail_stack
operator|.
name|size
operator|<
operator|(
literal|2
operator|*
name|re_max_failures
operator|*
name|MAX_FAILURE_ITEMS
operator|)
condition|)
block|{
name|fail_stack
operator|.
name|size
operator|=
operator|(
literal|2
operator|*
name|re_max_failures
operator|*
name|MAX_FAILURE_ITEMS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
if|if
condition|(
operator|!
name|fail_stack
operator|.
name|stack
condition|)
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|fail_stack_elt_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|fail_stack_elt_t
operator|*
operator|)
name|xrealloc
argument_list|(
name|fail_stack
operator|.
name|stack
argument_list|,
operator|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not emacs */
if|if
condition|(
operator|!
name|fail_stack
operator|.
name|stack
condition|)
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|fail_stack_elt_t
operator|*
operator|)
name|malloc
argument_list|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|fail_stack_elt_t
operator|*
operator|)
name|realloc
argument_list|(
name|fail_stack
operator|.
name|stack
argument_list|,
operator|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not emacs */
block|}
name|regex_grow_registers
argument_list|(
name|num_regs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not MATCH_MAY_ALLOCATE */
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* regex_compile */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines for `regex_compile'.  */
end_comment

begin_comment
comment|/* Store OP at LOC followed by two-byte integer parameter ARG.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|store_op1 (op,loc,arg)
name|store_op1
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg
parameter_list|)
name|re_opcode_t
name|op
decl_stmt|;
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
operator|*
name|loc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|op
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|store_op2 (op,loc,arg1,arg2)
name|store_op2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|re_opcode_t
name|op
decl_stmt|;
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
operator|*
name|loc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|op
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|3
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the bytes from LOC to END to open up three bytes of space at LOC    for OP followed by two-byte integer parameter ARG.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|insert_op1 (op,loc,arg,end)
name|insert_op1
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg
parameter_list|,
name|end
parameter_list|)
name|re_opcode_t
name|op
decl_stmt|;
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|pfrom
init|=
name|end
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pto
init|=
name|end
operator|+
literal|3
decl_stmt|;
while|while
condition|(
name|pfrom
operator|!=
name|loc
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|store_op1
argument_list|(
name|op
argument_list|,
name|loc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|insert_op2 (op,loc,arg1,arg2,end)
name|insert_op2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|end
parameter_list|)
name|re_opcode_t
name|op
decl_stmt|;
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|pfrom
init|=
name|end
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pto
init|=
name|end
operator|+
literal|5
decl_stmt|;
while|while
condition|(
name|pfrom
operator|!=
name|loc
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|store_op2
argument_list|(
name|op
argument_list|,
name|loc
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* P points to just after a ^ in PATTERN.  Return true if that ^ comes    after an alternative or a begin-subexpression.  We assume there is at    least one character before the ^.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|at_begline_loc_p (pattern,p,syntax)
name|at_begline_loc_p
parameter_list|(
name|pattern
parameter_list|,
name|p
parameter_list|,
name|syntax
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_decl_stmt
name|reg_syntax_t
name|syntax
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|prev
init|=
name|p
operator|-
literal|2
decl_stmt|;
name|boolean
name|prev_prev_backslash
init|=
name|prev
operator|>
name|pattern
operator|&&
name|prev
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
decl_stmt|;
return|return
comment|/* After a subexpression?  */
operator|(
operator|*
name|prev
operator|==
literal|'('
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|||
name|prev_prev_backslash
operator|)
operator|)
comment|/* After an alternative?  */
operator|||
operator|(
operator|*
name|prev
operator|==
literal|'|'
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|||
name|prev_prev_backslash
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The dual of at_begline_loc_p.  This one is for $.  We assume there is    at least one character after the $, i.e., `P< PEND'.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|at_endline_loc_p (p,pend,syntax)
name|at_endline_loc_p
parameter_list|(
name|p
parameter_list|,
name|pend
parameter_list|,
name|syntax
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|pend
decl_stmt|;
end_function

begin_decl_stmt
name|reg_syntax_t
name|syntax
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|p
decl_stmt|;
name|boolean
name|next_backslash
init|=
operator|*
name|next
operator|==
literal|'\\'
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_next
init|=
name|p
operator|+
literal|1
operator|<
name|pend
condition|?
name|p
operator|+
literal|1
else|:
literal|0
decl_stmt|;
return|return
comment|/* Before a subexpression?  */
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|?
operator|*
name|next
operator|==
literal|')'
else|:
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|*
name|next_next
operator|==
literal|')'
operator|)
comment|/* Before an alternative?  */
operator|||
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|?
operator|*
name|next
operator|==
literal|'|'
else|:
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|*
name|next_next
operator|==
literal|'|'
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Returns true if REGNUM is in one of COMPILE_STACK's elements and    false if it's not.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|group_in_compile_stack (compile_stack,regnum)
name|group_in_compile_stack
parameter_list|(
name|compile_stack
parameter_list|,
name|regnum
parameter_list|)
name|compile_stack_type
name|compile_stack
decl_stmt|;
name|regnum_t
name|regnum
decl_stmt|;
block|{
name|int
name|this_element
decl_stmt|;
for|for
control|(
name|this_element
operator|=
name|compile_stack
operator|.
name|avail
operator|-
literal|1
init|;
name|this_element
operator|>=
literal|0
condition|;
name|this_element
operator|--
control|)
if|if
condition|(
name|compile_stack
operator|.
name|stack
index|[
name|this_element
index|]
operator|.
name|regnum
operator|==
name|regnum
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read the ending character of a range (in a bracket expression) from the    uncompiled pattern *P_PTR (which ends at PEND).  We assume the    starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)    Then we set the translation of all bits between the starting and    ending characters (inclusive) in the compiled pattern B.     Return an error code.     We use these short variable names so we can use the same macros as    `regex_compile' itself.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
DECL|function|compile_range (p_ptr,pend,translate,syntax,b)
name|compile_range
parameter_list|(
name|p_ptr
parameter_list|,
name|pend
parameter_list|,
name|translate
parameter_list|,
name|syntax
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|p_ptr
decl_stmt|,
decl|*
name|pend
decl_stmt|;
end_function

begin_decl_stmt
name|RE_TRANSLATE_TYPE
name|translate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reg_syntax_t
name|syntax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|this_char
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|p_ptr
decl_stmt|;
name|unsigned
name|int
name|range_start
decl_stmt|,
name|range_end
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Even though the pattern is a signed `char *', we need to fetch      with unsigned char *'s; if the high bit of the pattern character      is set, the range endpoints will be negative if we fetch using a      signed char *.       We also want to fetch the endpoints without translating them; the      appropriate translation is done in the bit-setting loop below.  */
comment|/* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */
name|range_start
operator|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|)
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|range_end
operator|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|/* Have to increment the pointer into the pattern string, so the      caller isn't still at the ending character.  */
operator|(
operator|*
name|p_ptr
operator|)
operator|++
expr_stmt|;
comment|/* If the start is after the end, the range is empty.  */
if|if
condition|(
name|range_start
operator|>
name|range_end
condition|)
return|return
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
condition|?
name|REG_ERANGE
else|:
name|REG_NOERROR
return|;
comment|/* Here we see why `this_char' has to be larger than an `unsigned      char' -- the range is inclusive, so if `range_end' == 0xff      (assuming 8-bit characters), we would otherwise go into an infinite      loop, since all characters<= 0xff.  */
for|for
control|(
name|this_char
operator|=
name|range_start
init|;
name|this_char
operator|<=
name|range_end
condition|;
name|this_char
operator|++
control|)
block|{
name|SET_LIST_BIT
argument_list|(
name|TRANSLATE
argument_list|(
name|this_char
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in    BUFP.  A fastmap records which of the (1<< BYTEWIDTH) possible    characters can start a string that matches the pattern.  This fastmap    is used by re_search to skip quickly over impossible starting points.     The caller must supply the address of a (1<< BYTEWIDTH)-byte data    area as BUFP->fastmap.     We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in    the pattern buffer.     Returns 0 if we succeed, -2 if an internal error.   */
end_comment

begin_function
name|int
DECL|function|re_compile_fastmap (bufp)
name|re_compile_fastmap
parameter_list|(
name|bufp
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
name|fail_stack_type
name|fail_stack
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|REGEX_MALLOC
name|char
modifier|*
name|destination
decl_stmt|;
endif|#
directive|endif
comment|/* We don't push any register information onto the failure stack.  */
comment|/* unsigned num_regs = 0; */
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pattern
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|bufp
operator|->
name|used
decl_stmt|;
ifdef|#
directive|ifdef
name|REL_ALLOC
comment|/* This holds the pointer to the failure stack, when      it is allocated relocatably.  */
name|fail_stack_elt_t
modifier|*
name|failure_stack_ptr
decl_stmt|;
endif|#
directive|endif
comment|/* Assume that each path through the pattern can be null until      proven otherwise.  We set this false at the bottom of switch      statement, to which we get only if a particular path doesn't      match the empty string.  */
name|boolean
name|path_can_be_null
init|=
name|true
decl_stmt|;
comment|/* We aren't doing a `succeed_n' to begin with.  */
name|boolean
name|succeed_n_p
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|fastmap
operator|!=
name|NULL
operator|&&
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INIT_FAIL_STACK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|fastmap
argument_list|,
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Assume nothing's valid.  */
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
comment|/* It will be when we're done.  */
name|bufp
operator|->
name|can_be_null
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
operator|||
operator|*
name|p
operator|==
name|succeed
condition|)
block|{
comment|/* We have reached the (effective) end of pattern.  */
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
name|bufp
operator|->
name|can_be_null
operator||=
name|path_can_be_null
expr_stmt|;
comment|/* Reset for next path.  */
name|path_can_be_null
operator|=
name|true
expr_stmt|;
name|p
operator|=
name|fail_stack
operator|.
name|stack
index|[
operator|--
name|fail_stack
operator|.
name|avail
index|]
operator|.
name|pointer
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
comment|/* We should never be about to go beyond the end of the pattern.  */
name|assert
argument_list|(
name|p
operator|<
name|pend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SWITCH_ENUM_CAST
argument_list|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
comment|/* I guess the idea here is to simply not bother with a fastmap            if a backreference is used, since it's too hard to figure out            the fastmap for the corresponding group.  Setting            `can_be_null' stops `re_search_2' from using the fastmap, so            that is all we do.  */
case|case
name|duplicate
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* Following are the cases which match a character.  These end          with `break'.  */
case|case
name|exactn
case|:
name|fastmap
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|charset
case|:
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|charset_not
case|:
comment|/* Chars beyond end of map must be allowed.  */
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|*
name|BYTEWIDTH
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|wordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|anychar
case|:
block|{
name|int
name|fastmap_newline
init|=
name|fastmap
index|[
literal|'\n'
index|]
decl_stmt|;
comment|/* `.' matches anything ...  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
comment|/* ... except perhaps newline.  */
if|if
condition|(
operator|!
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|fastmap
index|[
literal|'\n'
index|]
operator|=
name|fastmap_newline
expr_stmt|;
comment|/* Return if we have already set `can_be_null'; if we have, 	       then the fastmap is irrelevant.  Something's wrong here.  */
elseif|else
if|if
condition|(
name|bufp
operator|->
name|can_be_null
condition|)
goto|goto
name|done
goto|;
comment|/* Otherwise, have to check alternative paths.  */
break|break;
block|}
ifdef|#
directive|ifdef
name|emacs
case|case
name|syntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* All cases after this match the empty string.  These end with          `continue'.  */
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
continue|continue;
endif|#
directive|endif
comment|/* emacs */
case|case
name|no_op
case|:
case|case
name|begline
case|:
case|case
name|endline
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
case|case
name|push_dummy_failure
case|:
continue|continue;
case|case
name|jump_n
case|:
case|case
name|pop_failure_jump
case|:
case|case
name|maybe_pop_jump
case|:
case|case
name|jump
case|:
case|case
name|jump_past_alt
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
continue|continue;
comment|/* Jump backward implies we just went through the body of a              loop and matched nothing.  Opcode jumped to should be              `on_failure_jump' or `succeed_n'.  Just treat it like an              ordinary jump.  For a * loop, it has pushed its failure              point already; if so, discard that as redundant.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|!=
name|on_failure_jump
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|!=
name|succeed_n
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
comment|/* If what's on the stack is where we are now, pop it.  */
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
operator|&&
name|fail_stack
operator|.
name|stack
index|[
name|fail_stack
operator|.
name|avail
operator|-
literal|1
index|]
operator|.
name|pointer
operator|==
name|p
condition|)
name|fail_stack
operator|.
name|avail
operator|--
expr_stmt|;
continue|continue;
case|case
name|on_failure_jump
case|:
case|case
name|on_failure_keep_string_jump
case|:
name|handle_on_failure_jump
label|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* For some patterns, e.g., `(a?)?', `p+j' here points to the              end of the pattern.  We don't want to push such a point,              since when we restore it above, entering the switch will              increment `p' past the end of the pattern.  We don't need              to push such a point since we obviously won't find any more              fastmap entries beyond `pend'.  Such a pattern can match              the null string, though.  */
if|if
condition|(
name|p
operator|+
name|j
operator|<
name|pend
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH_PATTERN_OP
argument_list|(
name|p
operator|+
name|j
argument_list|,
name|fail_stack
argument_list|)
condition|)
block|{
name|RESET_FAIL_STACK
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
else|else
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|succeed_n_p
condition|)
block|{
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the n.  */
name|succeed_n_p
operator|=
name|false
expr_stmt|;
block|}
continue|continue;
case|case
name|succeed_n
case|:
comment|/* Get to the number of times to succeed.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Increment p past the n for when k != 0.  */
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|p
operator|-=
literal|4
expr_stmt|;
name|succeed_n_p
operator|=
name|true
expr_stmt|;
comment|/* Spaghetti code alert.  */
goto|goto
name|handle_on_failure_jump
goto|;
block|}
continue|continue;
case|case
name|set_number_at
case|:
name|p
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
name|start_memory
case|:
case|case
name|stop_memory
case|:
name|p
operator|+=
literal|2
expr_stmt|;
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* We have listed all the cases.  */
block|}
comment|/* switch *p++ */
comment|/* Getting here means we have found the possible starting          characters for one path of the pattern -- and that the empty          string does not match.  We need not follow this path further.          Instead, look at the next alternative (remembered on the          stack), or quit if no more.  The test at the top of the loop          does these things.  */
name|path_can_be_null
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|pend
expr_stmt|;
block|}
comment|/* while p */
comment|/* Set `can_be_null' for the last path (also the first path, if the      pattern is empty).  */
name|bufp
operator|->
name|can_be_null
operator||=
name|path_can_be_null
expr_stmt|;
name|done
label|:
name|RESET_FAIL_STACK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* re_compile_fastmap */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and    ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use    this memory for recording register information.  STARTS and ENDS    must be allocated using the malloc library routine, and must each    be at least NUM_REGS * sizeof (regoff_t) bytes long.     If NUM_REGS == 0, then subsequent matches should allocate their own    register data.     Unless this function is called, the first search or match using    PATTERN_BUFFER will allocate its own register data, without    freeing the old data.  */
end_comment

begin_function
name|void
DECL|function|re_set_registers (bufp,regs,num_regs,starts,ends)
name|re_set_registers
parameter_list|(
name|bufp
parameter_list|,
name|regs
parameter_list|,
name|num_regs
parameter_list|,
name|starts
parameter_list|,
name|ends
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
name|unsigned
name|num_regs
decl_stmt|;
name|regoff_t
modifier|*
name|starts
decl_stmt|,
decl|*
name|ends
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|num_regs
condition|)
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|starts
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|ends
expr_stmt|;
block|}
else|else
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|regs
operator|->
name|end
operator|=
operator|(
name|regoff_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Searching routines.  */
end_comment

begin_comment
comment|/* Like re_search_2, below, but only one string is specified, and    doesn't let you say where to stop matching. */
end_comment

begin_function
name|int
DECL|function|re_search (bufp,string,size,startpos,range,regs)
name|re_search
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|startpos
decl_stmt|,
name|range
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_search_2
argument_list|(
name|bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Using the compiled pattern in BUFP->buffer, first tries to match the    virtual concatenation of STRING1 and STRING2, starting first at index    STARTPOS, then at STARTPOS + 1, and so on.     STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.     RANGE is how far to scan while trying to match.  RANGE = 0 means try    only at STARTPOS; in general, the last start tried is STARTPOS +    RANGE.     In REGS, return the indices of the virtual concatenation of STRING1    and STRING2 that matched the entire BUFP->buffer and its contained    subexpressions.     Do not consider matching one past the index STOP in the virtual    concatenation of STRING1 and STRING2.     We return either the position in the strings at which the match was    found, -1 if no match, or -2 if error (such as failure    stack overflow).  */
end_comment

begin_function
name|int
DECL|function|re_search_2 (bufp,string1,size1,string2,size2,startpos,range,regs,stop)
name|re_search_2
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
name|int
name|total_size
init|=
name|size1
operator|+
name|size2
decl_stmt|;
name|int
name|endpos
init|=
name|startpos
operator|+
name|range
decl_stmt|;
comment|/* Check for out-of-range STARTPOS.  */
if|if
condition|(
name|startpos
operator|<
literal|0
operator|||
name|startpos
operator|>
name|total_size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fix up RANGE if it might eventually take us outside      the virtual concatenation of STRING1 and STRING2.      Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
if|if
condition|(
name|endpos
operator|<
literal|0
condition|)
name|range
operator|=
literal|0
operator|-
name|startpos
expr_stmt|;
elseif|else
if|if
condition|(
name|endpos
operator|>
name|total_size
condition|)
name|range
operator|=
name|total_size
operator|-
name|startpos
expr_stmt|;
comment|/* If the search isn't to be a backwards one, don't waste time in a      search for a pattern that must be anchored.  */
if|if
condition|(
name|bufp
operator|->
name|used
operator|>
literal|0
operator|&&
operator|(
name|re_opcode_t
operator|)
name|bufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|begbuf
operator|&&
name|range
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|startpos
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|range
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|emacs
comment|/* In a forward search for something that starts with \=.      don't keep searching past point.  */
if|if
condition|(
name|bufp
operator|->
name|used
operator|>
literal|0
operator|&&
operator|(
name|re_opcode_t
operator|)
name|bufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|at_dot
operator|&&
name|range
operator|>
literal|0
condition|)
block|{
name|range
operator|=
name|PT
operator|-
name|startpos
expr_stmt|;
if|if
condition|(
name|range
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* emacs */
comment|/* Update the fastmap now if not correct already.  */
if|if
condition|(
name|fastmap
operator|&&
operator|!
name|bufp
operator|->
name|fastmap_accurate
condition|)
if|if
condition|(
name|re_compile_fastmap
argument_list|(
name|bufp
argument_list|)
operator|==
operator|-
literal|2
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Loop through the string, looking for a place to start matching.  */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If a fastmap is supplied, skip quickly over characters that          cannot be the start of a match.  If the pattern can match the          null string, however, we don't need to skip characters; we want          the first null string.  */
if|if
condition|(
name|fastmap
operator|&&
name|startpos
operator|<
name|total_size
operator|&&
operator|!
name|bufp
operator|->
name|can_be_null
condition|)
block|{
if|if
condition|(
name|range
operator|>
literal|0
condition|)
comment|/* Searching forwards.  */
block|{
specifier|register
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|lim
init|=
literal|0
decl_stmt|;
name|int
name|irange
init|=
name|range
decl_stmt|;
if|if
condition|(
name|startpos
operator|<
name|size1
operator|&&
name|startpos
operator|+
name|range
operator|>=
name|size1
condition|)
name|lim
operator|=
name|range
operator|-
operator|(
name|size1
operator|-
name|startpos
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|startpos
operator|>=
name|size1
condition|?
name|string2
operator|-
name|size1
else|:
name|string1
operator|)
operator|+
name|startpos
expr_stmt|;
comment|/* Written out as an if-else to avoid testing `translate'                  inside the loop.  */
if|if
condition|(
name|translate
condition|)
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
name|translate
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
index|]
condition|)
name|range
operator|--
expr_stmt|;
else|else
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
condition|)
name|range
operator|--
expr_stmt|;
name|startpos
operator|+=
name|irange
operator|-
name|range
expr_stmt|;
block|}
else|else
comment|/* Searching backwards.  */
block|{
specifier|register
name|char
name|c
init|=
operator|(
name|size1
operator|==
literal|0
operator|||
name|startpos
operator|>=
name|size1
condition|?
name|string2
index|[
name|startpos
operator|-
name|size1
index|]
else|:
name|string1
index|[
name|startpos
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
name|TRANSLATE
argument_list|(
name|c
argument_list|)
index|]
condition|)
goto|goto
name|advance
goto|;
block|}
block|}
comment|/* If can't match the null string, and that's all we have left, fail.  */
if|if
condition|(
name|range
operator|>=
literal|0
operator|&&
name|startpos
operator|==
name|total_size
operator|&&
name|fastmap
operator|&&
operator|!
name|bufp
operator|->
name|can_be_null
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
return|return
name|startpos
return|;
if|if
condition|(
name|val
operator|==
operator|-
literal|2
condition|)
return|return
operator|-
literal|2
return|;
name|advance
label|:
if|if
condition|(
operator|!
name|range
condition|)
break|break;
elseif|else
if|if
condition|(
name|range
operator|>
literal|0
condition|)
block|{
name|range
operator|--
expr_stmt|;
name|startpos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|range
operator|++
expr_stmt|;
name|startpos
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/* re_search_2 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This converts PTR, a pointer into one of the search strings `string1'    and `string2' into an offset from the beginning of that string.  */
end_comment

begin_define
DECL|macro|POINTER_TO_OFFSET (ptr)
define|#
directive|define
name|POINTER_TO_OFFSET
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(FIRST_STRING_P (ptr)				\    ? ((regoff_t) ((ptr) - string1))		\    : ((regoff_t) ((ptr) - string2 + size1)))
end_define

begin_comment
comment|/* Macros for dealing with the split strings in re_match_2.  */
end_comment

begin_define
DECL|macro|MATCHING_IN_FIRST_STRING
define|#
directive|define
name|MATCHING_IN_FIRST_STRING
value|(dend == end_match_1)
end_define

begin_comment
comment|/* Call before fetching a character with *d.  This switches over to    string2 if necessary.  */
end_comment

begin_define
DECL|macro|PREFETCH ()
define|#
directive|define
name|PREFETCH
parameter_list|()
define|\
value|while (d == dend)						    	\     {									\
comment|/* End of string2 => fail.  */
value|\       if (dend == end_match_2) 						\         goto fail;							\
comment|/* End of string1 => advance to string2.  */
value|\       d = string2;						        \       dend = end_match_2;						\     }
end_define

begin_comment
comment|/* Test if at very beginning or at very end of the virtual concatenation    of `string1' and `string2'.  If only one string, it's `string2'.  */
end_comment

begin_define
DECL|macro|AT_STRINGS_BEG (d)
define|#
directive|define
name|AT_STRINGS_BEG
parameter_list|(
name|d
parameter_list|)
value|((d) == (size1 ? string1 : string2) || !size2)
end_define

begin_define
DECL|macro|AT_STRINGS_END (d)
define|#
directive|define
name|AT_STRINGS_END
parameter_list|(
name|d
parameter_list|)
value|((d) == end2)
end_define

begin_comment
comment|/* Test if D points to a character which is word-constituent.  We have    two special cases to check for: if past the end of string1, look at    the first character in string2; and if before the beginning of    string2, look at the last character in string1.  */
end_comment

begin_define
DECL|macro|WORDCHAR_P (d)
define|#
directive|define
name|WORDCHAR_P
parameter_list|(
name|d
parameter_list|)
define|\
value|(SYNTAX ((d) == end1 ? *string2					\            : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\    == Sword)
end_define

begin_comment
comment|/* Disabled due to a compiler bug -- see comment at case wordbound */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Test if the character before D and the one at D differ with respect    to being word-constituent.  */
end_comment

begin_define
define|#
directive|define
name|AT_WORD_BOUNDARY
parameter_list|(
name|d
parameter_list|)
define|\
value|(AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free everything we malloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
end_ifdef

begin_define
DECL|macro|FREE_VAR (var)
define|#
directive|define
name|FREE_VAR
parameter_list|(
name|var
parameter_list|)
value|if (var) REGEX_FREE (var); var = NULL
end_define

begin_define
DECL|macro|FREE_VARIABLES ()
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
define|\
value|do {									\     REGEX_FREE_STACK (fail_stack.stack);				\     FREE_VAR (regstart);						\     FREE_VAR (regend);							\     FREE_VAR (old_regstart);						\     FREE_VAR (old_regend);						\     FREE_VAR (best_regstart);						\     FREE_VAR (best_regend);						\     FREE_VAR (reg_info);						\     FREE_VAR (reg_dummy);						\     FREE_VAR (reg_info_dummy);						\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|FREE_VARIABLES ()
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
value|((void)0)
end_define

begin_comment
DECL|macro|FREE_VARIABLES ()
comment|/* Do nothing!  But inhibit gcc warning.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MATCH_MAY_ALLOCATE */
end_comment

begin_comment
comment|/* These values must meet several constraints.  They must not be valid    register values; since we have a limit of 255 registers (because    we use only one byte in the pattern for the register number), we can    use numbers larger than 255.  They must differ by 1, because of    NUM_FAILURE_ITEMS above.  And the value for the lowest register must    be larger than the value for the highest register, so we do not try    to actually save any registers when none are active.  */
end_comment

begin_define
DECL|macro|NO_HIGHEST_ACTIVE_REG
define|#
directive|define
name|NO_HIGHEST_ACTIVE_REG
value|(1<< BYTEWIDTH)
end_define

begin_define
DECL|macro|NO_LOWEST_ACTIVE_REG
define|#
directive|define
name|NO_LOWEST_ACTIVE_REG
value|(NO_HIGHEST_ACTIVE_REG + 1)
end_define

begin_escape
end_escape

begin_comment
comment|/* Matching routines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* Emacs never uses this.  */
end_comment

begin_comment
comment|/* re_match is like re_match_2 except it takes only a single string.  */
end_comment

begin_function
name|int
DECL|function|re_match (bufp,string,size,pos,regs)
name|re_match
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pos
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
name|int
name|result
init|=
name|re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|group_match_null_string_p
name|_RE_ARGS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
name|p
operator|,
name|unsigned
name|char
operator|*
name|end
operator|,
name|register_info_type
operator|*
name|reg_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|alt_match_null_string_p
name|_RE_ARGS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|p
operator|,
name|unsigned
name|char
operator|*
name|end
operator|,
name|register_info_type
operator|*
name|reg_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|common_op_match_null_string_p
name|_RE_ARGS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
name|p
operator|,
name|unsigned
name|char
operator|*
name|end
operator|,
name|register_info_type
operator|*
name|reg_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bcmp_translate
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s1
operator|,
specifier|const
name|char
operator|*
name|s2
operator|,
name|int
name|len
operator|,
name|char
operator|*
name|translate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* re_match_2 matches the compiled pattern in BUFP against the    the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1    and SIZE2, respectively).  We start matching at POS, and stop    matching at STOP.     If REGS is non-null and the `no_sub' field of BUFP is nonzero, we    store offsets for the substring each group matched in REGS.  See the    documentation for exactly how many groups we fill.     We return -1 if no match, -2 if an internal error (such as the    failure stack overflowing).  Otherwise, we return the length of the    matched substring.  */
end_comment

begin_function
name|int
DECL|function|re_match_2 (bufp,string1,size1,string2,size2,pos,regs,stop)
name|re_match_2
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|result
init|=
name|re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* This is a separate function so that we can force an alloca cleanup    afterwards.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|re_match_2_internal (bufp,string1,size1,string2,size2,pos,regs,stop)
name|re_match_2_internal
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* General temporaries.  */
name|int
name|mcnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Just past the end of the corresponding string.  */
specifier|const
name|char
modifier|*
name|end1
decl_stmt|,
modifier|*
name|end2
decl_stmt|;
comment|/* Pointers into string1 and string2, just past the last characters in      each to consider matching.  */
specifier|const
name|char
modifier|*
name|end_match_1
decl_stmt|,
modifier|*
name|end_match_2
decl_stmt|;
comment|/* Where we are in the data, and the end of the current string.  */
specifier|const
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|dend
decl_stmt|;
comment|/* Where we are in the pattern, and the end of the pattern.  */
name|unsigned
name|char
modifier|*
name|p
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|p
operator|+
name|bufp
operator|->
name|used
decl_stmt|;
comment|/* Mark the opcode just after a start_memory, so we can test for an      empty subpattern when we get to the stop_memory.  */
name|unsigned
name|char
modifier|*
name|just_past_start_mem
init|=
literal|0
decl_stmt|;
comment|/* We use this to map every character in the string.  */
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* Failure point stack.  Each place that can handle a failure further      down the line pushes a failure point on this stack.  It consists of      restart, regend, and reg_info for all registers corresponding to      the subexpressions we're currently inside, plus the number of such      registers, and, finally, two char *'s.  The first char * is where      to resume scanning the pattern; the second one is where to resume      scanning the strings.  If the latter is zero, the failure point is      a ``dummy''; if a failure happens and the failure point is a dummy,      it gets discarded and the next next one is tried.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, this is global.  */
name|fail_stack_type
name|fail_stack
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|unsigned
name|failure_id
init|=
literal|0
decl_stmt|;
name|unsigned
name|nfailure_points_pushed
init|=
literal|0
decl_stmt|,
name|nfailure_points_popped
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REL_ALLOC
comment|/* This holds the pointer to the failure stack, when      it is allocated relocatably.  */
name|fail_stack_elt_t
modifier|*
name|failure_stack_ptr
decl_stmt|;
endif|#
directive|endif
comment|/* We fill all the registers internally, independent of what we      return, for use in backreferences.  The number here includes      an element for register zero.  */
name|size_t
name|num_regs
init|=
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
decl_stmt|;
comment|/* The currently active registers.  */
name|active_reg_t
name|lowest_active_reg
init|=
name|NO_LOWEST_ACTIVE_REG
decl_stmt|;
name|active_reg_t
name|highest_active_reg
init|=
name|NO_HIGHEST_ACTIVE_REG
decl_stmt|;
comment|/* Information on the contents of registers. These are pointers into      the input strings; they record just what was matched (on this      attempt) by a subexpression part of the pattern, that is, the      regnum-th regstart pointer points to where in the pattern we began      matching and the regnum-th regend points to right after where we      stopped matching the regnum-th subexpression.  (The zeroth register      keeps track of what the whole pattern matches.)  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|char
modifier|*
modifier|*
name|regstart
decl_stmt|,
modifier|*
modifier|*
name|regend
decl_stmt|;
endif|#
directive|endif
comment|/* If a group that's operated upon by a repetition operator fails to      match anything, then the register for its start will need to be      restored because it will have been set to wherever in the string we      are when we last see its open-group operator.  Similarly for a      register's end.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|char
modifier|*
modifier|*
name|old_regstart
decl_stmt|,
modifier|*
modifier|*
name|old_regend
decl_stmt|;
endif|#
directive|endif
comment|/* The is_active field of reg_info helps us keep track of which (possibly      nested) subexpressions we are currently in. The matched_something      field of reg_info[reg_num] helps us tell whether or not we have      matched any of the pattern so far this time through the reg_num-th      subexpression.  These two fields get reset each time through any      loop their register is in.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, this is global.  */
name|register_info_type
modifier|*
name|reg_info
decl_stmt|;
endif|#
directive|endif
comment|/* The following record the register info as found in the above      variables when we find a match better than any we've seen before.      This happens as we backtrack through the failure points, which in      turn happens only if we have not yet matched the entire string. */
name|unsigned
name|best_regs_set
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|char
modifier|*
modifier|*
name|best_regstart
decl_stmt|,
modifier|*
modifier|*
name|best_regend
decl_stmt|;
endif|#
directive|endif
comment|/* Logically, this is `best_regend[0]'.  But we don't want to have to      allocate space for that if we're not allocating space for anything      else (see below).  Also, we never need info about register 0 for      any of the other register vectors, and it seems rather a kludge to      treat `best_regend' differently than the rest.  So we keep track of      the end of the best match so far in a separate variable.  We      initialize this to NULL so that when we backtrack the first time      and need to test it, it's not garbage.  */
specifier|const
name|char
modifier|*
name|match_end
init|=
name|NULL
decl_stmt|;
comment|/* This helps SET_REGS_MATCHED avoid doing redundant work.  */
name|int
name|set_regs_matched_done
init|=
literal|0
decl_stmt|;
comment|/* Used when we pop values we don't care about.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|char
modifier|*
modifier|*
name|reg_dummy
decl_stmt|;
name|register_info_type
modifier|*
name|reg_info_dummy
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Counts the total number of registers pushed.  */
name|unsigned
name|num_regs_pushed
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|DEBUG_PRINT1
argument_list|(
literal|"\n\nEntering re_match_2.\n"
argument_list|)
expr_stmt|;
name|INIT_FAIL_STACK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* Do not bother to initialize all the register variables if there are      no groups in the pattern, as it takes a fair amount of time.  If      there are groups, we include space for register 0 (the whole      pattern), even though we never use it, since it simplifies the      array indexing.  We should fix this.  */
if|if
condition|(
name|bufp
operator|->
name|re_nsub
condition|)
block|{
name|regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|old_regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|old_regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|best_regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|best_regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|reg_info
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
name|register_info_type
argument_list|)
expr_stmt|;
name|reg_dummy
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|reg_info_dummy
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
name|register_info_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|regstart
operator|&&
name|regend
operator|&&
name|old_regstart
operator|&&
name|old_regend
operator|&&
name|reg_info
operator|&&
name|best_regstart
operator|&&
name|best_regend
operator|&&
name|reg_dummy
operator|&&
name|reg_info_dummy
operator|)
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
else|else
block|{
comment|/* We must initialize all our variables to NULL, so that          `FREE_VARIABLES' doesn't try to free them.  */
name|regstart
operator|=
name|regend
operator|=
name|old_regstart
operator|=
name|old_regend
operator|=
name|best_regstart
operator|=
name|best_regend
operator|=
name|reg_dummy
operator|=
name|NULL
expr_stmt|;
name|reg_info
operator|=
name|reg_info_dummy
operator|=
operator|(
name|register_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MATCH_MAY_ALLOCATE */
comment|/* The starting position is bogus.  */
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
name|size1
operator|+
name|size2
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize subexpression text positions to -1 to mark ones that no      start_memory/stop_memory has been seen for. Also initialize the      register information struct.  */
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|=
name|old_regstart
index|[
name|mcnt
index|]
operator|=
name|old_regend
index|[
name|mcnt
index|]
operator|=
name|REG_UNSET_VALUE
expr_stmt|;
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
name|MATCH_NULL_UNSET_VALUE
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We move `string1' into `string2' if the latter's empty -- but not if      `string1' is null.  */
if|if
condition|(
name|size2
operator|==
literal|0
operator|&&
name|string1
operator|!=
name|NULL
condition|)
block|{
name|string2
operator|=
name|string1
expr_stmt|;
name|size2
operator|=
name|size1
expr_stmt|;
name|string1
operator|=
literal|0
expr_stmt|;
name|size1
operator|=
literal|0
expr_stmt|;
block|}
name|end1
operator|=
name|string1
operator|+
name|size1
expr_stmt|;
name|end2
operator|=
name|string2
operator|+
name|size2
expr_stmt|;
comment|/* Compute where to stop matching, within the two strings.  */
if|if
condition|(
name|stop
operator|<=
name|size1
condition|)
block|{
name|end_match_1
operator|=
name|string1
operator|+
name|stop
expr_stmt|;
name|end_match_2
operator|=
name|string2
expr_stmt|;
block|}
else|else
block|{
name|end_match_1
operator|=
name|end1
expr_stmt|;
name|end_match_2
operator|=
name|string2
operator|+
name|stop
operator|-
name|size1
expr_stmt|;
block|}
comment|/* `p' scans through the pattern as `d' scans through the data.      `dend' is the end of the input string that `d' points within.  `d'      is advanced into the following input string whenever necessary, but      this happens before fetching; therefore, at the beginning of the      loop, `d' can be pointing at the end of a string, but it cannot      equal `string2'.  */
if|if
condition|(
name|size1
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|size1
condition|)
block|{
name|d
operator|=
name|string1
operator|+
name|pos
expr_stmt|;
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|string2
operator|+
name|pos
operator|-
name|size1
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
name|DEBUG_PRINT1
argument_list|(
literal|"The compiled pattern is:\n"
argument_list|)
expr_stmt|;
name|DEBUG_PRINT_COMPILED_PATTERN
argument_list|(
name|bufp
argument_list|,
name|p
argument_list|,
name|pend
argument_list|)
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"The string to match is: `"
argument_list|)
expr_stmt|;
name|DEBUG_PRINT_DOUBLE_STRING
argument_list|(
name|d
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|)
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
comment|/* This loops over pattern commands.  It exits by returning from the      function if the match is complete, or it drops through if the match      fails at this starting point in the input data.  */
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"\n%p: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"\n0x%x: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
comment|/* End of pattern means we might have succeeded.  */
name|DEBUG_PRINT1
argument_list|(
literal|"end of pattern ... "
argument_list|)
expr_stmt|;
comment|/* If we haven't matched the entire string, and we want the              longest match, try backtracking.  */
if|if
condition|(
name|d
operator|!=
name|end_match_2
condition|)
block|{
comment|/* 1 if this match ends in the same string (string1 or string2) 		 as the best previous match.  */
name|boolean
name|same_str_p
init|=
operator|(
name|FIRST_STRING_P
argument_list|(
name|match_end
argument_list|)
operator|==
name|MATCHING_IN_FIRST_STRING
operator|)
decl_stmt|;
comment|/* 1 if this match is the best seen so far.  */
name|boolean
name|best_match_p
decl_stmt|;
comment|/* AIX compiler got confused when this was combined 		 with the previous declaration.  */
if|if
condition|(
name|same_str_p
condition|)
name|best_match_p
operator|=
name|d
operator|>
name|match_end
expr_stmt|;
else|else
name|best_match_p
operator|=
operator|!
name|MATCHING_IN_FIRST_STRING
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"backtracking.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
comment|/* More failure points to try.  */
comment|/* If exceeds best match so far, save it.  */
if|if
condition|(
operator|!
name|best_regs_set
operator|||
name|best_match_p
condition|)
block|{
name|best_regs_set
operator|=
name|true
expr_stmt|;
name|match_end
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"\nSAVING match as best so far.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|best_regstart
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|best_regend
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
goto|goto
name|fail
goto|;
block|}
comment|/* If no failure points, don't restore garbage.  And if                  last match is real best match, don't restore second                  best one. */
elseif|else
if|if
condition|(
name|best_regs_set
operator|&&
operator|!
name|best_match_p
condition|)
block|{
name|restore_best_regs
label|:
comment|/* Restore best match.  It may happen that `dend ==                      end_match_1' while the restored d is in string2.                      For example, the pattern `x.*y.*z' against the                      strings `x-' and `y-z-', if the two strings are                      not consecutive in memory.  */
name|DEBUG_PRINT1
argument_list|(
literal|"Restoring best registers.\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|match_end
expr_stmt|;
name|dend
operator|=
operator|(
operator|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
operator|)
condition|?
name|end_match_1
else|:
name|end_match_2
operator|)
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|best_regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|regend
index|[
name|mcnt
index|]
operator|=
name|best_regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* d != end_match_2 */
name|succeed_label
label|:
name|DEBUG_PRINT1
argument_list|(
literal|"Accepting match.\n"
argument_list|)
expr_stmt|;
comment|/* If caller wants register contents data back, do it.  */
if|if
condition|(
name|regs
operator|&&
operator|!
name|bufp
operator|->
name|no_sub
condition|)
block|{
comment|/* Have the register data arrays been allocated?  */
if|if
condition|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_UNALLOCATED
condition|)
block|{
comment|/* No.  So allocate them with malloc.  We need one                      extra element beyond `num_regs' for the `-1' marker                      GNU code uses.  */
name|regs
operator|->
name|num_regs
operator|=
name|MAX
argument_list|(
name|RE_NREGS
argument_list|,
name|num_regs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|TALLOC
argument_list|(
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|TALLOC
argument_list|(
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
name|NULL
operator|||
name|regs
operator|->
name|end
operator|==
name|NULL
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_REALLOCATE
condition|)
block|{
comment|/* Yes.  If we need more elements than were already                      allocated, reallocate them.  If we need fewer, just                      leave it alone.  */
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|<
name|num_regs
operator|+
literal|1
condition|)
block|{
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
operator|+
literal|1
expr_stmt|;
name|RETALLOC
argument_list|(
name|regs
operator|->
name|start
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
name|RETALLOC
argument_list|(
name|regs
operator|->
name|end
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
name|NULL
operator|||
name|regs
operator|->
name|end
operator|==
name|NULL
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* These braces fend off a "empty body in an else-statement" 		     warning under GCC when assert expands to nothing.  */
name|assert
argument_list|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_FIXED
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the pointer data in `regstart' and `regend' to                  indices.  Register zero has to be set differently,                  since we haven't kept track of any info for it.  */
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|>
literal|0
condition|)
block|{
name|regs
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
operator|(
name|MATCHING_IN_FIRST_STRING
condition|?
operator|(
call|(
name|regoff_t
call|)
argument_list|(
name|d
operator|-
name|string1
argument_list|)
operator|)
else|:
operator|(
call|(
name|regoff_t
call|)
argument_list|(
name|d
operator|-
name|string2
operator|+
name|size1
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Go through the first `min (num_regs, regs->num_regs)'                  registers, since that is all we initialized.  */
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|MIN
argument_list|(
name|num_regs
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|)
condition|;
name|mcnt
operator|++
control|)
block|{
if|if
condition|(
name|REG_UNSET
argument_list|(
name|regstart
index|[
name|mcnt
index|]
argument_list|)
operator|||
name|REG_UNSET
argument_list|(
name|regend
index|[
name|mcnt
index|]
argument_list|)
condition|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
operator|(
name|regoff_t
operator|)
name|POINTER_TO_OFFSET
argument_list|(
name|regstart
index|[
name|mcnt
index|]
argument_list|)
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|(
name|regoff_t
operator|)
name|POINTER_TO_OFFSET
argument_list|(
name|regend
index|[
name|mcnt
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the regs structure we return has more elements than                  were in the pattern, set the extra elements to -1.  If                  we (re)allocated the registers, this is the case,                  because we always allocate enough to have at least one                  -1 at the end.  */
for|for
control|(
name|mcnt
operator|=
name|num_regs
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|regs
operator|->
name|num_regs
condition|;
name|mcnt
operator|++
control|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* regs&& !bufp->no_sub */
name|DEBUG_PRINT4
argument_list|(
literal|"%u failure points pushed, %u popped (%u remain).\n"
argument_list|,
name|nfailure_points_pushed
argument_list|,
name|nfailure_points_popped
argument_list|,
name|nfailure_points_pushed
operator|-
name|nfailure_points_popped
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"%u registers pushed.\n"
argument_list|,
name|num_regs_pushed
argument_list|)
expr_stmt|;
name|mcnt
operator|=
name|d
operator|-
name|pos
operator|-
operator|(
name|MATCHING_IN_FIRST_STRING
condition|?
name|string1
else|:
name|string2
operator|-
name|size1
operator|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"Returning %d from re_match_2.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
name|mcnt
return|;
block|}
comment|/* Otherwise match next pattern command.  */
switch|switch
condition|(
name|SWITCH_ENUM_CAST
argument_list|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
comment|/* Ignore these.  Used to ignore the n of succeed_n's which            currently have n == 0.  */
case|case
name|no_op
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING no_op.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|succeed
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING succeed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|succeed_label
goto|;
comment|/* Match the next n pattern characters exactly.  The following            byte in the pattern defines n, and the n bytes after that            are the characters to match.  */
case|case
name|exactn
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING exactn %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
comment|/* This is written out as an if-else so we don't waste time              testing `translate' inside the loop.  */
if|if
condition|(
name|translate
condition|)
block|{
do|do
block|{
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|translate
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
operator|!=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|(
name|char
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
comment|/* Match any character except possibly a newline or a null.  */
case|case
name|anychar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING anychar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
literal|'\000'
operator|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  Matched `%d'.\n"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|boolean
name|not
init|=
operator|(
name|re_opcode_t
operator|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
name|charset_not
decl_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING charset%s.\n"
argument_list|,
name|not
condition|?
literal|"_not"
else|:
literal|""
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
name|c
operator|=
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
comment|/* The character to match.  */
comment|/* Cast to `unsigned' instead of `unsigned char' in case the                bit list is a full 32 bytes long.  */
if|if
condition|(
name|c
operator|<
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|p
operator|*
name|BYTEWIDTH
argument_list|)
operator|&&
name|p
index|[
literal|1
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|not
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
block|}
comment|/* The beginning of a group is represented by start_memory.            The arguments are the register number in the next byte, and the            number of groups inner to this one in the next.  The text            matched within the group is recorded (in the internal            registers data structure) under the register number.  */
case|case
name|start_memory
case|:
name|DEBUG_PRINT3
argument_list|(
literal|"EXECUTING start_memory %d (%d):\n"
argument_list|,
operator|*
name|p
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Find out if this group can match the empty string.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* To send to group_match_null_string_p.  */
if|if
condition|(
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|==
name|MATCH_NULL_UNSET_VALUE
condition|)
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
name|group_match_null_string_p
argument_list|(
operator|&
name|p1
argument_list|,
name|pend
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* Save the position in the string where we were the last time              we were at this open-group operator in case the group is              operated upon by a repetition operator, e.g., with `(a*)*b'              against `ab'; then we want to ignore where we are now in              the string in case this attempt to match fails.  */
name|old_regstart
index|[
operator|*
name|p
index|]
operator|=
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|REG_UNSET
argument_list|(
name|regstart
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|d
else|:
name|regstart
index|[
operator|*
name|p
index|]
else|:
name|regstart
index|[
operator|*
name|p
index|]
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  old_regstart: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|old_regstart
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|regstart
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  regstart: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|regstart
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear this whenever we change the register activity status.  */
name|set_regs_matched_done
operator|=
literal|0
expr_stmt|;
comment|/* This is the new highest active register.  */
name|highest_active_reg
operator|=
operator|*
name|p
expr_stmt|;
comment|/* If nothing was active before, this is the new lowest active              register.  */
if|if
condition|(
name|lowest_active_reg
operator|==
name|NO_LOWEST_ACTIVE_REG
condition|)
name|lowest_active_reg
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Move past the register number and inner group count.  */
name|p
operator|+=
literal|2
expr_stmt|;
name|just_past_start_mem
operator|=
name|p
expr_stmt|;
break|break;
comment|/* The stop_memory opcode represents the end of a group.  Its            arguments are the same as start_memory's: the register            number, and the number of inner groups.  */
case|case
name|stop_memory
case|:
name|DEBUG_PRINT3
argument_list|(
literal|"EXECUTING stop_memory %d (%d):\n"
argument_list|,
operator|*
name|p
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* We need to save the string position the last time we were at              this close-group operator in case the group is operated              upon by a repetition operator, e.g., with `((a*)*(b*)*)*'              against `aba'; then we want to ignore where we are now in              the string in case this attempt to match fails.  */
name|old_regend
index|[
operator|*
name|p
index|]
operator|=
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|REG_UNSET
argument_list|(
name|regend
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|d
else|:
name|regend
index|[
operator|*
name|p
index|]
else|:
name|regend
index|[
operator|*
name|p
index|]
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"      old_regend: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|old_regend
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|regend
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"      regend: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|regend
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This register isn't active anymore.  */
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear this whenever we change the register activity status.  */
name|set_regs_matched_done
operator|=
literal|0
expr_stmt|;
comment|/* If this was the only register active, nothing is active              anymore.  */
if|if
condition|(
name|lowest_active_reg
operator|==
name|highest_active_reg
condition|)
block|{
name|lowest_active_reg
operator|=
name|NO_LOWEST_ACTIVE_REG
expr_stmt|;
name|highest_active_reg
operator|=
name|NO_HIGHEST_ACTIVE_REG
expr_stmt|;
block|}
else|else
block|{
comment|/* We must scan for the new highest active register, since                  it isn't necessarily one less than now: consider                  (a(b)c(d(e)f)g).  When group 3 ends, after the f), the                  new highest active register is 1.  */
name|unsigned
name|char
name|r
init|=
operator|*
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|r
operator|>
literal|0
operator|&&
operator|!
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|r
index|]
argument_list|)
condition|)
name|r
operator|--
expr_stmt|;
comment|/* If we end up at register zero, that means that we saved                  the registers as the result of an `on_failure_jump', not                  a `start_memory', and we jumped to past the innermost                  `stop_memory'.  For example, in ((.)*) we save                  registers 1 and 2 as a result of the *, but when we pop                  back to the second ), we are at the stop_memory 1.                  Thus, nothing is active.  */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|lowest_active_reg
operator|=
name|NO_LOWEST_ACTIVE_REG
expr_stmt|;
name|highest_active_reg
operator|=
name|NO_HIGHEST_ACTIVE_REG
expr_stmt|;
block|}
else|else
name|highest_active_reg
operator|=
name|r
expr_stmt|;
block|}
comment|/* If just failed to match something this time around with a              group that's operated on by a repetition operator, try to              force exit from the ``loop'', and restore the register              information for this group that we had before trying this              last match.  */
if|if
condition|(
operator|(
operator|!
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|||
name|just_past_start_mem
operator|==
name|p
operator|-
literal|1
operator|)
operator|&&
operator|(
name|p
operator|+
literal|2
operator|)
operator|<
name|pend
condition|)
block|{
name|boolean
name|is_a_jump_n
init|=
name|false
decl_stmt|;
name|p1
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|mcnt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|++
condition|)
block|{
case|case
name|jump_n
case|:
name|is_a_jump_n
operator|=
name|true
expr_stmt|;
case|case
name|pop_failure_jump
case|:
case|case
name|maybe_pop_jump
case|:
case|case
name|jump
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_a_jump_n
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
empty_stmt|;
block|}
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* If the next operation is a jump backwards in the pattern 	         to an on_failure_jump right before the start_memory                  corresponding to this stop_memory, exit from the loop                  by forcing a failure after pushing on the stack the                  on_failure_jump's jump in the pattern, and d.  */
if|if
condition|(
name|mcnt
operator|<
literal|0
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|on_failure_jump
operator|&&
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|start_memory
operator|&&
name|p1
index|[
literal|4
index|]
operator|==
operator|*
name|p
condition|)
block|{
comment|/* If this group ever matched anything, then restore                      what its registers were before trying this last                      failed match, e.g., with `(a*)*b' against `ab' for                      regstart[1], and, e.g., with `((a*)*(b*)*)*'                      against `aba' for regend[3].                       Also restore the registers for inner groups for,                      e.g., `((a*)(b*))*' against `aba' (register 3 would                      otherwise get trashed).  */
if|if
condition|(
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|r
decl_stmt|;
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Restore this and inner groups' (if any) registers.  */
for|for
control|(
name|r
operator|=
operator|*
name|p
init|;
name|r
operator|<
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|+
operator|(
name|unsigned
operator|)
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|;
name|r
operator|++
control|)
block|{
name|regstart
index|[
name|r
index|]
operator|=
name|old_regstart
index|[
name|r
index|]
expr_stmt|;
comment|/* xx why this test?  */
if|if
condition|(
name|old_regend
index|[
name|r
index|]
operator|>=
name|regstart
index|[
name|r
index|]
condition|)
name|regend
index|[
name|r
index|]
operator|=
name|old_regend
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p1
operator|+
name|mcnt
argument_list|,
name|d
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Move past the register number and the inner group count.  */
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* \<digit> has been turned into a `duplicate' command which is            followed by the numeric value of<digit> as the register number.  */
case|case
name|duplicate
case|:
block|{
specifier|register
specifier|const
name|char
modifier|*
name|d2
decl_stmt|,
modifier|*
name|dend2
decl_stmt|;
name|int
name|regno
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Get which register to match against.  */
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING duplicate %d.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Can't back reference a group which we've never matched.  */
if|if
condition|(
name|REG_UNSET
argument_list|(
name|regstart
index|[
name|regno
index|]
argument_list|)
operator|||
name|REG_UNSET
argument_list|(
name|regend
index|[
name|regno
index|]
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Where in input to try to start matching.  */
name|d2
operator|=
name|regstart
index|[
name|regno
index|]
expr_stmt|;
comment|/* Where to stop matching; if both the place to start and                the place to stop matching are in the same string, then                set to the place to stop, otherwise, for now have to use                the end of the first string.  */
name|dend2
operator|=
operator|(
operator|(
name|FIRST_STRING_P
argument_list|(
name|regstart
index|[
name|regno
index|]
argument_list|)
operator|==
name|FIRST_STRING_P
argument_list|(
name|regend
index|[
name|regno
index|]
argument_list|)
operator|)
condition|?
name|regend
index|[
name|regno
index|]
else|:
name|end_match_1
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If necessary, advance to next segment in register                    contents.  */
while|while
condition|(
name|d2
operator|==
name|dend2
condition|)
block|{
if|if
condition|(
name|dend2
operator|==
name|end_match_2
condition|)
break|break;
if|if
condition|(
name|dend2
operator|==
name|regend
index|[
name|regno
index|]
condition|)
break|break;
comment|/* End of string1 => advance to string2. */
name|d2
operator|=
name|string2
expr_stmt|;
name|dend2
operator|=
name|regend
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* At end of register contents => success */
if|if
condition|(
name|d2
operator|==
name|dend2
condition|)
break|break;
comment|/* If necessary, advance to next segment in data.  */
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* How many characters left in this segment to match.  */
name|mcnt
operator|=
name|dend
operator|-
name|d
expr_stmt|;
comment|/* Want how many consecutive characters we can match in                    one shot, so, if necessary, adjust the count.  */
if|if
condition|(
name|mcnt
operator|>
name|dend2
operator|-
name|d2
condition|)
name|mcnt
operator|=
name|dend2
operator|-
name|d2
expr_stmt|;
comment|/* Compare that many; failure if mismatch, else move                    past them.  */
if|if
condition|(
name|translate
condition|?
name|bcmp_translate
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|,
name|translate
argument_list|)
else|:
name|bcmp
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|d
operator|+=
name|mcnt
operator|,
name|d2
operator|+=
name|mcnt
expr_stmt|;
comment|/* Do this because we've match some characters.  */
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
comment|/* begline matches the empty string at the beginning of the string            (unless `not_bol' is set in `bufp'), and, if            `newline_anchor' is set, after newlines.  */
case|case
name|begline
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING begline.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bufp
operator|->
name|not_bol
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|bufp
operator|->
name|newline_anchor
condition|)
block|{
break|break;
block|}
comment|/* In all other cases, we fail.  */
goto|goto
name|fail
goto|;
comment|/* endline is the dual of begline.  */
case|case
name|endline
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING endline.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bufp
operator|->
name|not_eol
condition|)
break|break;
block|}
comment|/* We have to ``prefetch'' the next character.  */
elseif|else
if|if
condition|(
operator|(
name|d
operator|==
name|end1
condition|?
operator|*
name|string2
else|:
operator|*
name|d
operator|)
operator|==
literal|'\n'
operator|&&
name|bufp
operator|->
name|newline_anchor
condition|)
block|{
break|break;
block|}
goto|goto
name|fail
goto|;
comment|/* Match at the very beginning of the data.  */
case|case
name|begbuf
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING begbuf.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* Match at the very end of the data.  */
case|case
name|endbuf
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING endbuf.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* on_failure_keep_string_jump is used to optimize `.*\n'.  It            pushes NULL as the value for the string on the stack.  Then            `pop_failure_point' will keep the current value for the            string, instead of restoring it.  To see why, consider            matching `foo\nbar' against `.*\n'.  The .* matches the foo;            then the . fails against the \n.  But the next thing we want            to do is match the \n against the \n; if we restored the            string value, we would be back at the foo.             Because this is used only in specific cases, we don't need to            check all the things that `on_failure_jump' does, to make            sure the right things get saved on the stack.  Hence we don't            share its code.  The only reason to push anything on the            stack at all is that otherwise we would have to change            `anychar's code to do something besides goto fail in this            case; that seems worse than this.  */
case|case
name|on_failure_keep_string_jump
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING on_failure_keep_string_jump"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to %p):\n"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to 0x%x):\n"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH_FAILURE_POINT
argument_list|(
name|p
operator|+
name|mcnt
argument_list|,
name|NULL
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Uses of on_failure_jump:             Each alternative starts with an on_failure_jump that points            to the beginning of the next alternative.  Each alternative            except the last ends with a jump that in effect jumps past            the rest of the alternatives.  (They really jump to the            ending jump of the following alternative, because tensioning            these jumps is a hassle.)             Repeats start with an on_failure_jump that points past both            the repetition text and either the following jump or            pop_failure_jump back to this on_failure_jump.  */
case|case
name|on_failure_jump
case|:
name|on_failure
label|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING on_failure_jump"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to %p)"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to 0x%x)"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this on_failure_jump comes right before a group (i.e.,              the original * applied to a group), save the information              for that group and all inner ones, so that if we fail back              to this point, the group's information will be correct.              For example, in \(a*\)*\1, we need the preceding group,              and in \(zz\(a*\)b*\)\2, we need the inner group.  */
comment|/* We can't use `p' to check ahead because we push              a failure point to `p + mcnt' after we do this.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* We need to skip no_op's before we look for the              start_memory in case this on_failure_jump is happening as              the result of a completed succeed_n, as in \(a\)\{1,3\}b\1              against aba.  */
while|while
condition|(
name|p1
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|no_op
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|start_memory
condition|)
block|{
comment|/* We have a new highest active register now.  This will                  get reset at the start_memory we are about to get to,                  but we will have saved all the registers relevant to                  this repetition op, as described above.  */
name|highest_active_reg
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|+
operator|*
operator|(
name|p1
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|lowest_active_reg
operator|==
name|NO_LOWEST_ACTIVE_REG
condition|)
name|lowest_active_reg
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|DEBUG_PRINT1
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p
operator|+
name|mcnt
argument_list|,
name|d
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* A smart repeat ends with `maybe_pop_jump'. 	   We change it to either `pop_failure_jump' or `jump'.  */
case|case
name|maybe_pop_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING maybe_pop_jump %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
comment|/* Compare the beginning of the repeat with what in the                pattern follows its end. If we can establish that there                is nothing that they would both match, i.e., that we                would have to backtrack because of (as in, e.g., `a*a')                then we can change to pop_failure_jump, because we'll                never have to backtrack.                 This is not true in the case of alternatives: in                `(a|ab)*' we do need to backtrack to the `ab' alternative                (e.g., if the string was `ab').  But instead of trying to                detect that here, the alternative has put on a dummy                failure point which is what we will end up popping.  */
comment|/* Skip over open/close-group commands. 	       If what follows this loop is a ...+ construct, 	       look at what begins its body, since we will have to 	       match at least one of that.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p2
operator|+
literal|2
operator|<
name|pend
operator|&&
operator|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|stop_memory
operator|||
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|start_memory
operator|)
condition|)
name|p2
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|+
literal|6
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|dummy_failure_jump
condition|)
name|p2
operator|+=
literal|6
expr_stmt|;
else|else
break|break;
block|}
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
comment|/* p1[0] ... p1[2] are the `on_failure_jump' corresponding 	       to the `maybe_finalize_jump' of this case.  Examine what 	       follows.  */
comment|/* If we're at the end of the pattern, we can change.  */
if|if
condition|(
name|p2
operator|==
name|pend
condition|)
block|{
comment|/* Consider what happens when matching ":\(.*\)" 		   against ":/".  I don't really understand this code 		   yet.  */
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  End of pattern: change to `pop_failure_jump'.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|exactn
operator|||
operator|(
name|bufp
operator|->
name|newline_anchor
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|endline
operator|)
condition|)
block|{
specifier|register
name|unsigned
name|char
name|c
init|=
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|?
literal|'\n'
else|:
name|p2
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|exactn
operator|&&
name|p1
index|[
literal|5
index|]
operator|!=
name|c
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT3
argument_list|(
literal|"  %c != %c => pop_failure_jump.\n"
argument_list|,
name|c
argument_list|,
name|p1
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset
operator|||
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
condition|)
block|{
name|int
name|not
init|=
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
decl_stmt|;
if|if
condition|(
name|c
operator|<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|p1
index|[
literal|4
index|]
operator|*
name|BYTEWIDTH
argument_list|)
operator|&&
name|p1
index|[
literal|5
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
comment|/* `not' is equal to 1 if c would match, which means                         that we can't change to pop_failure_jump.  */
if|if
condition|(
operator|!
name|not
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|charset
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|register
name|unsigned
name|char
name|c
init|=
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|?
literal|'\n'
else|:
name|p2
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if ((re_opcode_t) p1[3] == exactn&& ! ((int) p2[1] * BYTEWIDTH> (int) p1[5]&& (p2[2 + p1[5] / BYTEWIDTH]& (1<< (p1[5] % BYTEWIDTH)))))
else|#
directive|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|exactn
operator|&&
operator|!
operator|(
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
operator|*
name|BYTEWIDTH
operator|>
operator|(
name|int
operator|)
name|p1
index|[
literal|4
index|]
operator|&&
operator|(
name|p2
index|[
literal|2
operator|+
name|p1
index|[
literal|4
index|]
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|p1
index|[
literal|4
index|]
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT3
argument_list|(
literal|"  %c != %c => pop_failure_jump.\n"
argument_list|,
name|c
argument_list|,
name|p1
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
condition|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* We win if the charset_not inside the loop 		       lists every character listed in the charset after.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
condition|;
name|idx
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|==
literal|0
operator|||
operator|(
name|idx
operator|<
operator|(
name|int
operator|)
name|p1
index|[
literal|4
index|]
operator|&&
operator|(
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|&
operator|~
name|p1
index|[
literal|5
operator|+
name|idx
index|]
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|idx
operator|==
name|p2
index|[
literal|1
index|]
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset
condition|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* We win if the charset inside the loop 		       has no overlap with the one after the loop.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
operator|&&
name|idx
operator|<
operator|(
name|int
operator|)
name|p1
index|[
literal|4
index|]
condition|;
name|idx
operator|++
control|)
if|if
condition|(
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|&
name|p1
index|[
literal|5
operator|+
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|idx
operator|==
name|p2
index|[
literal|1
index|]
operator|||
name|idx
operator|==
name|p1
index|[
literal|4
index|]
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|p
operator|-=
literal|2
expr_stmt|;
comment|/* Point at relative address again.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|pop_failure_jump
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  Match => jump.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
block|}
comment|/* Note fall through.  */
comment|/* The end of a simple repeat has a pop_failure_jump back to            its matching on_failure_jump, where the latter will push a            failure point.  The pop_failure_jump takes off failure            points put on by this pop_failure_jump's matching            on_failure_jump; we got through the pattern to here from the            matching on_failure_jump, so didn't fail.  */
case|case
name|pop_failure_jump
case|:
block|{
comment|/* We need to pass separate storage for the lowest and                highest registers, even though we don't care about the                actual values.  Otherwise, we will restore only one                register from the stack, since lowest will == highest in                `pop_failure_point'.  */
name|active_reg_t
name|dummy_low_reg
decl_stmt|,
name|dummy_high_reg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pdummy
decl_stmt|;
specifier|const
name|char
modifier|*
name|sdummy
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING pop_failure_jump.\n"
argument_list|)
expr_stmt|;
name|POP_FAILURE_POINT
argument_list|(
name|sdummy
argument_list|,
name|pdummy
argument_list|,
name|dummy_low_reg
argument_list|,
name|dummy_high_reg
argument_list|,
name|reg_dummy
argument_list|,
name|reg_dummy
argument_list|,
name|reg_info_dummy
argument_list|)
expr_stmt|;
block|}
comment|/* Note fall through.  */
name|unconditional_jump
label|:
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"\n%p: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"\n0x%x: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note fall through.  */
comment|/* Unconditionally jump (without popping any failure points).  */
case|case
name|jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Get the amount to jump.  */
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING jump %d "
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mcnt
expr_stmt|;
comment|/* Do the jump.  */
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"(to %p).\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"(to 0x%x).\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* We need this opcode so we can detect where alternatives end            in `group_match_null_string_p' et al.  */
case|case
name|jump_past_alt
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING jump_past_alt.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
comment|/* Normally, the on_failure_jump pushes a failure point, which            then gets popped at pop_failure_jump.  We will end up at            pop_failure_jump, also, and with a pattern of, say, `a+', we            are skipping over the on_failure_jump, so we have to push            something meaningless for pop_failure_jump to pop.  */
case|case
name|dummy_failure_jump
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING dummy_failure_jump.\n"
argument_list|)
expr_stmt|;
comment|/* It doesn't matter what we push for the string here.  What              the code at `fail' tests is the value for the pattern.  */
name|PUSH_FAILURE_POINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
comment|/* At the end of an alternative, we need to push a dummy failure            point in case we are followed by a `pop_failure_jump', because            we don't want the failure point for the alternative to be            popped.  For example, matching `(a|ab)*' against `aab'            requires that we match the `ab' alternative.  */
case|case
name|push_dummy_failure
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING push_dummy_failure.\n"
argument_list|)
expr_stmt|;
comment|/* See comments just above at `dummy_failure_jump' about the              two zeroes.  */
name|PUSH_FAILURE_POINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Have to succeed matching what follows at least n times.            After that, handle like `on_failure_jump'.  */
case|case
name|succeed_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING succeed_n %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mcnt
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we HAVE to succeed.  */
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|STORE_NUMBER_AND_INCR
argument_list|(
name|p
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mcnt
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"  Setting two bytes from %p to no_op.\n"
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"  Setting two bytes from 0x%x to no_op.\n"
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|no_op
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|no_op
expr_stmt|;
goto|goto
name|on_failure
goto|;
block|}
break|break;
case|case
name|jump_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING jump_n %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we CAN jump.  */
if|if
condition|(
name|mcnt
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|unconditional_jump
goto|;
block|}
comment|/* If don't have to jump any more, skip over the rest of command.  */
else|else
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|set_number_at
case|:
block|{
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING set_number_at.\n"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STORE_NUMBER
argument_list|(
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* The DEC Alpha C compiler 3.x generates incorrect code for the 	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of 	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the 	   macro and introducing temporary variables works around the bug.  */
block|case wordbound: 	  DEBUG_PRINT1 ("EXECUTING wordbound.\n"); 	  if (AT_WORD_BOUNDARY (d)) 	    break; 	  goto fail;  	case notwordbound: 	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n"); 	  if (AT_WORD_BOUNDARY (d)) 	    goto fail; 	  break;
else|#
directive|else
case|case
name|wordbound
case|:
block|{
name|boolean
name|prevchar
decl_stmt|,
name|thischar
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordbound.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
break|break;
name|prevchar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thischar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevchar
operator|!=
name|thischar
condition|)
break|break;
goto|goto
name|fail
goto|;
block|}
case|case
name|notwordbound
case|:
block|{
name|boolean
name|prevchar
decl_stmt|,
name|thischar
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING notwordbound.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|prevchar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thischar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevchar
operator|!=
name|thischar
condition|)
goto|goto
name|fail
goto|;
break|break;
block|}
endif|#
directive|endif
case|case
name|wordbeg
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordbeg.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
operator|!
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|wordend
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordend.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|&&
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|&&
operator|(
operator|!
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING before_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|>=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|at_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING at_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|!=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|after_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING after_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|<=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|syntaxspec
case|:
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING syntaxspec %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
goto|goto
name|matchsyntax
goto|;
case|case
name|wordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING Emacs wordchar.\n"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|matchsyntax
label|:
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING notsyntaxspec %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
goto|goto
name|matchnotsyntax
goto|;
case|case
name|notwordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING Emacs notwordchar.\n"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|matchnotsyntax
label|:
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
else|#
directive|else
comment|/* not emacs */
case|case
name|wordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING non-Emacs wordchar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING non-Emacs notwordchar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* not emacs */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
continue|continue;
comment|/* Successfully executed one pattern command; keep going.  */
comment|/* We goto here if a matching operation fails. */
name|fail
label|:
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
comment|/* A restart point is known.  Restore to that state.  */
name|DEBUG_PRINT1
argument_list|(
literal|"\nFAIL:\n"
argument_list|)
expr_stmt|;
name|POP_FAILURE_POINT
argument_list|(
name|d
argument_list|,
name|p
argument_list|,
name|lowest_active_reg
argument_list|,
name|highest_active_reg
argument_list|,
name|regstart
argument_list|,
name|regend
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* If this failure point is a dummy, try the next one.  */
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|fail
goto|;
comment|/* If we failed to the end of the pattern, don't examine *p.  */
name|assert
argument_list|(
name|p
operator|<=
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|boolean
name|is_a_jump_n
init|=
name|false
decl_stmt|;
comment|/* If failed to a backwards jump that's part of a repetition                  loop, need to pop this failure point and use the next one.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
condition|)
block|{
case|case
name|jump_n
case|:
name|is_a_jump_n
operator|=
name|true
expr_stmt|;
case|case
name|maybe_pop_jump
case|:
case|case
name|pop_failure_jump
case|:
case|case
name|jump
case|:
name|p1
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
if|if
condition|(
operator|(
name|is_a_jump_n
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|succeed_n
operator|)
operator|||
operator|(
operator|!
name|is_a_jump_n
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|on_failure_jump
operator|)
condition|)
goto|goto
name|fail
goto|;
break|break;
default|default:
comment|/* do nothing */
empty_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
condition|)
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
break|break;
comment|/* Matching at this starting point really fails.  */
block|}
comment|/* for (;;) */
if|if
condition|(
name|best_regs_set
condition|)
goto|goto
name|restore_best_regs
goto|;
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Failure to match.  */
block|}
end_block

begin_comment
comment|/* re_match_2 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutine definitions for re_match_2.  */
end_comment

begin_comment
comment|/* We are passed P pointing to a register number after a start_memory.     Return true if the pattern up to the corresponding stop_memory can    match the empty string, and false otherwise.     If we find the matching stop_memory, sets P to point to one past its number.    Otherwise, sets P to an undefined byte less than or equal to END.     We don't handle duplicates properly (yet).  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|group_match_null_string_p (p,end,reg_info)
name|group_match_null_string_p
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|,
name|reg_info
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|register_info_type
modifier|*
name|reg_info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mcnt
decl_stmt|;
comment|/* Point to after the args to the start_memory.  */
name|unsigned
name|char
modifier|*
name|p1
init|=
operator|*
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
comment|/* Skip over opcodes that can match nothing, and return true or 	 false, as appropriate, when we get to one that can't, or to the          matching stop_memory.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
condition|)
block|{
comment|/* Could be either a loop or a series of alternatives.  */
case|case
name|on_failure_jump
case|:
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* If the next operation is not a jump backwards in the 	     pattern.  */
if|if
condition|(
name|mcnt
operator|>=
literal|0
condition|)
block|{
comment|/* Go through the on_failure_jumps of the alternatives,                  seeing if any of the alternatives cannot match nothing.                  The last alternative starts with only a jump,                  whereas the rest start with on_failure_jump and end                  with a jump, e.g., here is the pattern for `a|b|c':                   /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6                  /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3                  /exactn/1/c                   So, we have to first go through the first (n-1)                  alternatives and then deal with the last one separately.  */
comment|/* Deal with the first (n-1) alternatives, which start                  with an on_failure_jump (see above) that jumps to right                  past a jump_past_alt.  */
while|while
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
name|mcnt
operator|-
literal|3
index|]
operator|==
name|jump_past_alt
condition|)
block|{
comment|/* `mcnt' holds how many bytes long the alternative                      is, including the ending `jump_past_alt' and                      its number.  */
if|if
condition|(
operator|!
name|alt_match_null_string_p
argument_list|(
name|p1
argument_list|,
name|p1
operator|+
name|mcnt
operator|-
literal|3
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Move to right after this alternative, including the 		     jump_past_alt.  */
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* Break if it's the beginning of an n-th alternative                      that doesn't begin with an on_failure_jump.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|!=
name|on_failure_jump
condition|)
break|break;
comment|/* Still have to check that it's not an n-th 		     alternative that starts with an on_failure_jump.  */
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
name|mcnt
operator|-
literal|3
index|]
operator|!=
name|jump_past_alt
condition|)
block|{
comment|/* Get to the beginning of the n-th alternative.  */
name|p1
operator|-=
literal|3
expr_stmt|;
break|break;
block|}
block|}
comment|/* Deal with the last alternative: go back and get number                  of the `jump_past_alt' just before it.  `mcnt' contains                  the length of the alternative.  */
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p1
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt_match_null_string_p
argument_list|(
name|p1
argument_list|,
name|p1
operator|+
name|mcnt
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* Get past the n-th alternative.  */
block|}
comment|/* if mcnt> 0 */
break|break;
case|case
name|stop_memory
case|:
name|assert
argument_list|(
name|p1
index|[
literal|1
index|]
operator|==
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|p1
operator|+
literal|2
expr_stmt|;
return|return
name|true
return|;
default|default:
if|if
condition|(
operator|!
name|common_op_match_null_string_p
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* while p1< end */
return|return
name|false
return|;
block|}
end_block

begin_comment
comment|/* group_match_null_string_p */
end_comment

begin_comment
comment|/* Similar to group_match_null_string_p, but doesn't deal with alternatives:    It expects P to be the first byte of a single alternative and END one    byte past the last. The alternative can contain groups.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|alt_match_null_string_p (p,end,reg_info)
name|alt_match_null_string_p
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|,
name|reg_info
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|register_info_type
modifier|*
name|reg_info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mcnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
comment|/* Skip over opcodes that can match nothing, and break when we get          to one that can't.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
condition|)
block|{
comment|/* It's a loop.  */
case|case
name|on_failure_jump
case|:
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|common_op_match_null_string_p
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* while p1< end */
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* alt_match_null_string_p */
end_comment

begin_comment
comment|/* Deals with the ops common to group_match_null_string_p and    alt_match_null_string_p.     Sets P to one after the op and its arguments, if any.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|common_op_match_null_string_p (p,end,reg_info)
name|common_op_match_null_string_p
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|,
name|reg_info
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|register_info_type
modifier|*
name|reg_info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mcnt
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
name|int
name|reg_no
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|++
condition|)
block|{
case|case
name|no_op
case|:
case|case
name|begline
case|:
case|case
name|endline
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
endif|#
directive|endif
break|break;
case|case
name|start_memory
case|:
name|reg_no
operator|=
operator|*
name|p1
expr_stmt|;
name|assert
argument_list|(
name|reg_no
operator|>
literal|0
operator|&&
name|reg_no
operator|<=
name|MAX_REGNUM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|group_match_null_string_p
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* Have to set this here in case we're checking a group which          contains a group and a back reference to it.  */
if|if
condition|(
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|reg_no
index|]
argument_list|)
operator|==
name|MATCH_NULL_UNSET_VALUE
condition|)
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|reg_no
index|]
argument_list|)
operator|=
name|ret
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|false
return|;
break|break;
comment|/* If this is an optimized succeed_n for zero times, make the jump.  */
case|case
name|jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
literal|0
condition|)
name|p1
operator|+=
name|mcnt
expr_stmt|;
else|else
return|return
name|false
return|;
break|break;
case|case
name|succeed_n
case|:
comment|/* Get to the number of times to succeed.  */
name|p1
operator|+=
literal|2
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|==
literal|0
condition|)
block|{
name|p1
operator|-=
literal|4
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
break|break;
case|case
name|duplicate
case|:
if|if
condition|(
operator|!
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p1
index|]
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|set_number_at
case|:
name|p1
operator|+=
literal|4
expr_stmt|;
default|default:
comment|/* All other opcodes mean we cannot match the empty string.  */
return|return
name|false
return|;
block|}
operator|*
name|p
operator|=
name|p1
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* common_op_match_null_string_p */
end_comment

begin_comment
comment|/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN    bytes; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|bcmp_translate (s1,s2,len,translate)
name|bcmp_translate
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|,
name|translate
parameter_list|)
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RE_TRANSLATE_TYPE
name|translate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|p1
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|p2
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|translate
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|translate
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
name|len
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Entry points for GNU code.  */
end_comment

begin_comment
comment|/* re_compile_pattern is the GNU regular expression compiler: it    compiles PATTERN (of length SIZE) and puts the result in BUFP.    Returns 0 if the pattern was valid, otherwise an error string.     Assumes the `allocated' (and perhaps `buffer') and `translate' fields    are set in BUFP on entry.     We call regex_compile to do the actual compilation.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
DECL|function|re_compile_pattern (pattern,length,bufp)
name|re_compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|length
parameter_list|,
name|bufp
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* GNU code is written to assume at least RE_NREGS registers will be set      (and at least one extra will be -1).  */
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
comment|/* And GNU code determines whether or not to get register information      by passing null for the REGS argument to re_match, etc., not by      setting no_sub.  */
name|bufp
operator|->
name|no_sub
operator|=
literal|0
expr_stmt|;
comment|/* Match anchors at newline.  */
name|bufp
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|regex_compile
argument_list|(
name|pattern
argument_list|,
name|length
argument_list|,
name|re_syntax_options
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
return|return
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|ret
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  We don't define    them unless specifically requested.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_REGEX_RE_COMP
argument_list|)
operator|||
name|defined
argument_list|(
name|_LIBC
argument_list|)
end_if

begin_comment
comment|/* BSD has one and only one pattern buffer.  */
end_comment

begin_decl_stmt
DECL|variable|re_comp_buf
specifier|static
name|struct
name|re_pattern_buffer
name|re_comp_buf
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Make these definitions weak in libc, so POSIX programs can redefine    these names if they don't use our functions, and still use    regcomp/regexec below without link errors.  */
name|weak_function
endif|#
directive|endif
DECL|function|re_comp (s)
name|re_comp
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
return|return
literal|"No previous regular expression"
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
block|{
name|re_comp_buf
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_comp_buf
operator|.
name|buffer
operator|==
name|NULL
condition|)
return|return
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|REG_ESPACE
index|]
return|;
name|re_comp_buf
operator|.
name|allocated
operator|=
literal|200
expr_stmt|;
name|re_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_comp_buf
operator|.
name|fastmap
operator|==
name|NULL
condition|)
return|return
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|REG_ESPACE
index|]
return|;
block|}
comment|/* Since `re_exec' always passes NULL for the `regs' argument, we      don't need to initialize the pattern buffer fields which affect it.  */
comment|/* Match anchors at newlines.  */
name|re_comp_buf
operator|.
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|regex_compile
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|re_syntax_options
argument_list|,
operator|&
name|re_comp_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
comment|/* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
return|return
operator|(
name|char
operator|*
operator|)
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|ret
index|]
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|_LIBC
name|weak_function
endif|#
directive|endif
DECL|function|re_exec (s)
name|re_exec
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _REGEX_RE_COMP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* POSIX.2 functions.  Don't define these for Emacs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* regcomp takes a regular expression as a string and compiles it.     PREG is a regex_t *.  We do not expect any fields to be initialized,    since POSIX says we shouldn't.  Thus, we set       `buffer' to the compiled pattern;      `used' to the length of the compiled pattern;      `syntax' to RE_SYNTAX_POSIX_EXTENDED if the        REG_EXTENDED bit in CFLAGS is set; otherwise, to        RE_SYNTAX_POSIX_BASIC;      `newline_anchor' to REG_NEWLINE being set in CFLAGS;      `fastmap' and `fastmap_accurate' to zero;      `re_nsub' to the number of subexpressions in PATTERN.     PATTERN is the address of the pattern string.     CFLAGS is a series of bits which affect compilation.       If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we      use POSIX basic syntax.       If REG_NEWLINE is set, then . and [^...] don't match newline.      Also, regexec will try a match beginning after every newline.       If REG_ICASE is set, then we considers upper- and lowercase      versions of letters to be equivalent when matching.       If REG_NOSUB is set, then when PREG is passed to regexec, that      routine will report only success or failure, and nothing about the      registers.     It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for    the return codes and their meanings.)  */
end_comment

begin_function
name|int
DECL|function|regcomp (preg,pattern,cflags)
name|regcomp
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|cflags
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|cflags
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|reg_syntax_t
name|syntax
init|=
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
condition|?
name|RE_SYNTAX_POSIX_EXTENDED
else|:
name|RE_SYNTAX_POSIX_BASIC
decl_stmt|;
comment|/* regex_compile will allocate the space for the compiled pattern.  */
name|preg
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Don't bother to use a fastmap when searching.  This simplifies the      REG_NEWLINE case: if we used a fastmap, we'd have to put all the      characters after newlines into the fastmap.  This way, we just try      every character.  */
name|preg
operator|->
name|fastmap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_ICASE
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|preg
operator|->
name|translate
operator|=
operator|(
name|RE_TRANSLATE_TYPE
operator|)
name|malloc
argument_list|(
name|CHAR_SET_SIZE
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|RE_TRANSLATE_TYPE
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|translate
operator|==
name|NULL
condition|)
return|return
operator|(
name|int
operator|)
name|REG_ESPACE
return|;
comment|/* Map uppercase characters to corresponding lowercase ones.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHAR_SET_SIZE
condition|;
name|i
operator|++
control|)
name|preg
operator|->
name|translate
index|[
name|i
index|]
operator|=
name|ISUPPER
argument_list|(
name|i
argument_list|)
condition|?
name|tolower
argument_list|(
name|i
argument_list|)
else|:
name|i
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
if|if
condition|(
name|cflags
operator|&
name|REG_NEWLINE
condition|)
block|{
comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
name|syntax
operator|&=
operator|~
name|RE_DOT_NEWLINE
expr_stmt|;
name|syntax
operator||=
name|RE_HAT_LISTS_NOT_NEWLINE
expr_stmt|;
comment|/* It also changes the matching behavior.  */
name|preg
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|newline_anchor
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|no_sub
operator|=
operator|!
operator|!
operator|(
name|cflags
operator|&
name|REG_NOSUB
operator|)
expr_stmt|;
comment|/* POSIX says a null character in the pattern terminates it, so we      can use strlen here in compiling the pattern.  */
name|ret
operator|=
name|regex_compile
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|syntax
argument_list|,
name|preg
argument_list|)
expr_stmt|;
comment|/* POSIX doesn't distinguish between an unmatched open-group and an      unmatched close-group: both are REG_EPAREN.  */
if|if
condition|(
name|ret
operator|==
name|REG_ERPAREN
condition|)
name|ret
operator|=
name|REG_EPAREN
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* regexec searches for a given pattern, specified by PREG, in the    string STRING.     If NMATCH is zero or REG_NOSUB was set in the cflags argument to    `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at    least NMATCH elements, and we set them to the offsets of the    corresponding matched substrings.     EFLAGS specifies `execution flags' which affect matching: if    REG_NOTBOL is set, then ^ does not match at the beginning of the    string; if REG_NOTEOL is set, then $ does not match at the end.     We return 0 if we find a match and REG_NOMATCH if not.  */
end_comment

begin_function
name|int
DECL|function|regexec (preg,string,nmatch,pmatch,eflags)
name|regexec
parameter_list|(
name|preg
parameter_list|,
name|string
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|eflags
parameter_list|)
specifier|const
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
name|pmatch
index|[]
decl_stmt|;
name|int
name|eflags
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
name|regex_t
name|private_preg
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|boolean
name|want_reg_info
init|=
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|0
decl_stmt|;
name|private_preg
operator|=
operator|*
name|preg
expr_stmt|;
name|private_preg
operator|.
name|not_bol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
expr_stmt|;
name|private_preg
operator|.
name|not_eol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
expr_stmt|;
comment|/* The user has told us exactly how many registers to return      information about, via `nmatch'.  We have to pass that on to the      matching routines.  */
name|private_preg
operator|.
name|regs_allocated
operator|=
name|REGS_FIXED
expr_stmt|;
if|if
condition|(
name|want_reg_info
condition|)
block|{
name|regs
operator|.
name|num_regs
operator|=
name|nmatch
expr_stmt|;
name|regs
operator|.
name|start
operator|=
name|TALLOC
argument_list|(
name|nmatch
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
name|regs
operator|.
name|end
operator|=
name|TALLOC
argument_list|(
name|nmatch
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
operator|==
name|NULL
operator|||
name|regs
operator|.
name|end
operator|==
name|NULL
condition|)
return|return
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
block|}
comment|/* Perform the searching operation.  */
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|private_preg
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
comment|/* start: */
literal|0
argument_list|,
comment|/* range: */
name|len
argument_list|,
name|want_reg_info
condition|?
operator|&
name|regs
else|:
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the register information to the POSIX structure.  */
if|if
condition|(
name|want_reg_info
condition|)
block|{
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|nmatch
condition|;
name|r
operator|++
control|)
block|{
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_so
operator|=
name|regs
operator|.
name|start
index|[
name|r
index|]
expr_stmt|;
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_eo
operator|=
name|regs
operator|.
name|end
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
comment|/* If we needed the temporary register info, free the space now.  */
name|free
argument_list|(
name|regs
operator|.
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* We want zero return to mean success, unlike `re_search'.  */
return|return
name|ret
operator|>=
literal|0
condition|?
operator|(
name|int
operator|)
name|REG_NOERROR
else|:
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
block|}
end_function

begin_comment
comment|/* Returns a message corresponding to an error code, ERRCODE, returned    from either regcomp or regexec.   We don't use PREG here.  */
end_comment

begin_function
name|size_t
DECL|function|regerror (errcode,preg,errbuf,errbuf_size)
name|regerror
parameter_list|(
name|errcode
parameter_list|,
name|preg
parameter_list|,
name|errbuf
parameter_list|,
name|errbuf_size
parameter_list|)
name|int
name|errcode
decl_stmt|;
specifier|const
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|char
modifier|*
name|errbuf
decl_stmt|;
name|size_t
name|errbuf_size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msg_size
decl_stmt|;
if|if
condition|(
name|errcode
operator|<
literal|0
operator|||
name|errcode
operator|>=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|re_error_msgid
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|re_error_msgid
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
comment|/* Only error codes returned by the rest of the code should be passed        to this routine.  If we are given anything else, or if other regex        code generates an invalid error code, then the program has a bug.        Dump core so we can fix it.  */
name|abort
argument_list|()
expr_stmt|;
name|msg
operator|=
name|re_error_msgid
index|[
name|errcode
index|]
expr_stmt|;
name|msg_size
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Includes the null.  */
if|if
condition|(
name|errbuf_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|msg_size
operator|>
name|errbuf_size
condition|)
block|{
name|strncpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|errbuf
index|[
name|errbuf_size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|msg_size
return|;
block|}
end_function

begin_comment
comment|/* Free dynamically allocated space used by PREG.  */
end_comment

begin_function
name|void
DECL|function|regfree (preg)
name|regfree
parameter_list|(
name|preg
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
block|{
if|if
condition|(
name|preg
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|fastmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|translate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|translate
argument_list|)
expr_stmt|;
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs  */
end_comment

end_unit

