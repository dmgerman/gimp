begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"pdb-types.h"
end_include

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"base/temp-buf.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpcoreconfig.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-crop.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-duplicate.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-flip.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-merge.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-pick-color.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-resize.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-rotate.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-scale.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplist.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpunit.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_decl_stmt
DECL|variable|image_list_proc
specifier|static
name|ProcRecord
name|image_list_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_proc
specifier|static
name|ProcRecord
name|image_new_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_duplicate_proc
specifier|static
name|ProcRecord
name|image_duplicate_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_delete_proc
specifier|static
name|ProcRecord
name|image_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_proc
specifier|static
name|ProcRecord
name|image_base_type_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_proc
specifier|static
name|ProcRecord
name|image_width_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_proc
specifier|static
name|ProcRecord
name|image_height_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_free_shadow_proc
specifier|static
name|ProcRecord
name|image_free_shadow_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_proc
specifier|static
name|ProcRecord
name|image_resize_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_to_layers_proc
specifier|static
name|ProcRecord
name|image_resize_to_layers_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_scale_proc
specifier|static
name|ProcRecord
name|image_scale_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_crop_proc
specifier|static
name|ProcRecord
name|image_crop_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flip_proc
specifier|static
name|ProcRecord
name|image_flip_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_rotate_proc
specifier|static
name|ProcRecord
name|image_rotate_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_proc
specifier|static
name|ProcRecord
name|image_get_layers_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_proc
specifier|static
name|ProcRecord
name|image_get_channels_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_vectors_proc
specifier|static
name|ProcRecord
name|image_get_vectors_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_drawable_proc
specifier|static
name|ProcRecord
name|image_get_active_drawable_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_unset_active_channel_proc
specifier|static
name|ProcRecord
name|image_unset_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_floating_sel_proc
specifier|static
name|ProcRecord
name|image_get_floating_sel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_proc
specifier|static
name|ProcRecord
name|image_floating_sel_attached_to_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_color_proc
specifier|static
name|ProcRecord
name|image_pick_color_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_proc
specifier|static
name|ProcRecord
name|image_pick_correlate_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_proc
specifier|static
name|ProcRecord
name|image_add_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_proc
specifier|static
name|ProcRecord
name|image_remove_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_proc
specifier|static
name|ProcRecord
name|image_raise_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_proc
specifier|static
name|ProcRecord
name|image_lower_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_proc
specifier|static
name|ProcRecord
name|image_raise_layer_to_top_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_proc
specifier|static
name|ProcRecord
name|image_lower_layer_to_bottom_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_channel_proc
specifier|static
name|ProcRecord
name|image_add_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_channel_proc
specifier|static
name|ProcRecord
name|image_remove_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_channel_proc
specifier|static
name|ProcRecord
name|image_raise_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_channel_proc
specifier|static
name|ProcRecord
name|image_lower_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_proc
specifier|static
name|ProcRecord
name|image_flatten_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_proc
specifier|static
name|ProcRecord
name|image_merge_visible_layers_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_proc
specifier|static
name|ProcRecord
name|image_merge_down_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_mask_proc
specifier|static
name|ProcRecord
name|image_add_layer_mask_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_mask_proc
specifier|static
name|ProcRecord
name|image_remove_layer_mask_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_colormap_proc
specifier|static
name|ProcRecord
name|image_get_colormap_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_colormap_proc
specifier|static
name|ProcRecord
name|image_set_colormap_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_clean_all_proc
specifier|static
name|ProcRecord
name|image_clean_all_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_is_dirty_proc
specifier|static
name|ProcRecord
name|image_is_dirty_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_thumbnail_proc
specifier|static
name|ProcRecord
name|image_thumbnail_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_proc
specifier|static
name|ProcRecord
name|image_get_active_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_layer_proc
specifier|static
name|ProcRecord
name|image_set_active_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_proc
specifier|static
name|ProcRecord
name|image_get_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_channel_proc
specifier|static
name|ProcRecord
name|image_set_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_proc
specifier|static
name|ProcRecord
name|image_get_selection_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_proc
specifier|static
name|ProcRecord
name|image_get_component_active_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_active_proc
specifier|static
name|ProcRecord
name|image_set_component_active_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_proc
specifier|static
name|ProcRecord
name|image_get_component_visible_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_visible_proc
specifier|static
name|ProcRecord
name|image_set_component_visible_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_proc
specifier|static
name|ProcRecord
name|image_get_filename_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_filename_proc
specifier|static
name|ProcRecord
name|image_set_filename_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_name_proc
specifier|static
name|ProcRecord
name|image_get_name_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_proc
specifier|static
name|ProcRecord
name|image_get_resolution_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_resolution_proc
specifier|static
name|ProcRecord
name|image_set_resolution_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_proc
specifier|static
name|ProcRecord
name|image_get_unit_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_unit_proc
specifier|static
name|ProcRecord
name|image_set_unit_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_tattoo_state_proc
specifier|static
name|ProcRecord
name|image_get_tattoo_state_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_tattoo_state_proc
specifier|static
name|ProcRecord
name|image_set_tattoo_state_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_layer_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_channel_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_image_procs (Gimp * gimp)
name|register_image_procs
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_list_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_new_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_duplicate_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_base_type_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_width_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_height_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_free_shadow_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_resize_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_resize_to_layers_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_scale_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_crop_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_flip_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_rotate_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_layers_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_channels_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_vectors_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_active_drawable_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_unset_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_floating_sel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_floating_sel_attached_to_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_pick_color_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_pick_correlate_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_add_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_remove_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_raise_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_lower_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_raise_layer_to_top_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_lower_layer_to_bottom_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_add_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_remove_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_raise_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_lower_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_flatten_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_merge_visible_layers_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_merge_down_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_add_layer_mask_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_remove_layer_mask_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_colormap_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_colormap_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_clean_all_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_is_dirty_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_thumbnail_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_active_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_active_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_selection_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_component_active_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_component_active_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_component_visible_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_component_visible_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_filename_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_filename_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_name_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_resolution_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_resolution_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_unit_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_unit_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_tattoo_state_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_set_tattoo_state_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_layer_by_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|image_get_channel_by_tattoo_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FINITE
argument_list|)
end_if

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|finite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_ISFINITE
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|isfinite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|G_OS_WIN32
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|_finite(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"no FINITE() implementation available?!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_list_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_list_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gint32
name|num_images
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|image_ids
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimp
operator|->
name|images
argument_list|)
operator|->
name|list
expr_stmt|;
name|num_images
operator|=
name|g_list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_images
condition|)
block|{
name|image_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_images
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_images
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
name|image_ids
index|[
name|i
index|]
operator|=
name|gimp_image_get_ID
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_list_proc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_images
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|image_ids
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_list_outargs
specifier|static
name|ProcArg
name|image_list_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-images"
block|,
literal|"The number of images currently open"
block|}
block|,
block|{
name|GIMP_PDB_INT32ARRAY
block|,
literal|"image-ids"
block|,
literal|"The list of images currently open"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_list_proc
specifier|static
name|ProcRecord
name|image_list_proc
init|=
block|{
literal|"gimp-image-list"
block|,
literal|"gimp-image-list"
block|,
literal|"Returns the list of images currently open."
block|,
literal|"This procedure returns the list of images currently open in the GIMP."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|0
block|,
name|NULL
block|,
literal|2
block|,
name|image_list_outargs
block|,
block|{
block|{
name|image_list_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_new_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_new_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gint32
name|width
decl_stmt|;
name|gint32
name|height
decl_stmt|;
name|gint32
name|type
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|width
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|height
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|GIMP_RGB
operator|||
name|type
operator|>
name|GIMP_INDEXED
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|image
operator|=
name|gimp_create_image
argument_list|(
name|gimp
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|image
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_new_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_ID
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_new_inargs
specifier|static
name|ProcArg
name|image_new_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"width"
block|,
literal|"The width of the image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"height"
block|,
literal|"The height of the image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"type"
block|,
literal|"The type of image: { GIMP_RGB (0), GIMP_GRAY (1), GIMP_INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_outargs
specifier|static
name|ProcArg
name|image_new_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the newly created image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_proc
specifier|static
name|ProcRecord
name|image_new_proc
init|=
block|{
literal|"gimp-image-new"
block|,
literal|"gimp-image-new"
block|,
literal|"Creates a new image with the specified width, height, and type."
block|,
literal|"Creates a new image, undisplayed with the specified extents and type. A layer should be created and added before this image is displayed, or subsequent calls to 'gimp_display_new' with this image as an argument will fail. Layers can be created using the 'gimp_layer_new' commands. They can be added to an image using the 'gimp_image_add_layer' command."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_new_inargs
block|,
literal|1
block|,
name|image_new_outargs
block|,
block|{
block|{
name|image_new_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_duplicate_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_duplicate_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpImage
modifier|*
name|new_image
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|new_image
operator|=
name|gimp_image_duplicate
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_duplicate_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_ID
argument_list|(
name|new_image
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_duplicate_inargs
specifier|static
name|ProcArg
name|image_duplicate_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_duplicate_outargs
specifier|static
name|ProcArg
name|image_duplicate_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"new-image"
block|,
literal|"The new, duplicated image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_duplicate_proc
specifier|static
name|ProcRecord
name|image_duplicate_proc
init|=
block|{
literal|"gimp-image-duplicate"
block|,
literal|"gimp-image-duplicate"
block|,
literal|"Duplicate the specified image"
block|,
literal|"This procedure duplicates the specified image, copying all layers, channels, and image information."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1997"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_duplicate_inargs
block|,
literal|1
block|,
name|image_duplicate_outargs
block|,
block|{
block|{
name|image_duplicate_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_delete_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_delete_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|disp_count
operator|==
literal|0
condition|)
name|g_object_unref
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_delete_inargs
specifier|static
name|ProcArg
name|image_delete_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_delete_proc
specifier|static
name|ProcRecord
name|image_delete_proc
init|=
block|{
literal|"gimp-image-delete"
block|,
literal|"gimp-image-delete"
block|,
literal|"Delete the specified image."
block|,
literal|"If there are no displays associated with this image it will be deleted. This means that you can not delete an image through the PDB that was created by the user. If the associated display was however created through the PDB and you know the display ID, you may delete the display. Removal of the last associated display will then delete the image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_base_type_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_base_type_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|base_type
init|=
literal|0
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|base_type
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_base_type_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|base_type
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_base_type_inargs
specifier|static
name|ProcArg
name|image_base_type_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_outargs
specifier|static
name|ProcArg
name|image_base_type_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"base-type"
block|,
literal|"The image's base type: { GIMP_RGB (0), GIMP_GRAY (1), GIMP_INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_proc
specifier|static
name|ProcRecord
name|image_base_type_proc
init|=
block|{
literal|"gimp-image-base-type"
block|,
literal|"gimp-image-base-type"
block|,
literal|"Get the base type of the image."
block|,
literal|"This procedure returns the image's base type. Layers in the image must be of this subtype, but can have an optional alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_base_type_inargs
block|,
literal|1
block|,
name|image_base_type_outargs
block|,
block|{
block|{
name|image_base_type_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_width_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_width_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_width_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_width_inargs
specifier|static
name|ProcArg
name|image_width_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_outargs
specifier|static
name|ProcArg
name|image_width_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"width"
block|,
literal|"The image's width"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_proc
specifier|static
name|ProcRecord
name|image_width_proc
init|=
block|{
literal|"gimp-image-width"
block|,
literal|"gimp-image-width"
block|,
literal|"Return the width of the image"
block|,
literal|"This procedure returns the image's width. This value is independent of any of the layers in this image. This is the \"canvas\" width."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_width_inargs
block|,
literal|1
block|,
name|image_width_outargs
block|,
block|{
block|{
name|image_width_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_height_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_height_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_height_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_height_inargs
specifier|static
name|ProcArg
name|image_height_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_outargs
specifier|static
name|ProcArg
name|image_height_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"height"
block|,
literal|"The image's height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_proc
specifier|static
name|ProcRecord
name|image_height_proc
init|=
block|{
literal|"gimp-image-height"
block|,
literal|"gimp-image-height"
block|,
literal|"Return the height of the image"
block|,
literal|"This procedure returns the image's height. This value is independent of any of the layers in this image. This is the \"canvas\" height."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_height_inargs
block|,
literal|1
block|,
name|image_height_outargs
block|,
block|{
block|{
name|image_height_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_free_shadow_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_free_shadow_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_free_shadow_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_free_shadow_inargs
specifier|static
name|ProcArg
name|image_free_shadow_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_free_shadow_proc
specifier|static
name|ProcRecord
name|image_free_shadow_proc
init|=
block|{
literal|"gimp-image-free-shadow"
block|,
literal|"gimp-image-free-shadow"
block|,
literal|"Free the specified image's shadow data (if it exists)."
block|,
literal|"This procedure is intended as a memory saving device. If any shadow memory has been allocated, it will be freed automatically on a call to 'gimp_image_delete'."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_free_shadow_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_free_shadow_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_resize_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_resize_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gint32
name|offx
decl_stmt|;
name|gint32
name|offy
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offx
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|offy
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_image_resize
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_resize_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_resize_inargs
specifier|static
name|ProcArg
name|image_resize_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-width"
block|,
literal|"New image width: 0< new_width"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-height"
block|,
literal|"New image height: 0< new_height"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"offx"
block|,
literal|"x offset between upper left corner of old and new images: (new - old)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"offy"
block|,
literal|"y offset between upper left corner of old and new images: (new - old)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_proc
specifier|static
name|ProcRecord
name|image_resize_proc
init|=
block|{
literal|"gimp-image-resize"
block|,
literal|"gimp-image-resize"
block|,
literal|"Resize the image to the specified extents."
block|,
literal|"This procedure resizes the image so that it's new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. No bounds checking is currently provided, so don't supply parameters that are out of bounds. All channels within the image are resized according to the specified parameters; this includes the image selection mask. All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|5
block|,
name|image_resize_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_resize_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_resize_to_layers_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_resize_to_layers_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_image_resize_to_layers
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_resize_to_layers_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_resize_to_layers_inargs
specifier|static
name|ProcArg
name|image_resize_to_layers_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_to_layers_proc
specifier|static
name|ProcRecord
name|image_resize_to_layers_proc
init|=
block|{
literal|"gimp-image-resize-to-layers"
block|,
literal|"gimp-image-resize-to-layers"
block|,
literal|"Resize the image to fit all layers."
block|,
literal|"This procedure resizes the image to the bounding box of all layers of the image. All channels within the image are resized to the new size; this includes the image selection mask. All layers within the image are repositioned to the new image area."
block|,
literal|"Simon Budig"
block|,
literal|"Simon Budig"
block|,
literal|"2004"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_resize_to_layers_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_resize_to_layers_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_scale_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_scale_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_image_scale
argument_list|(
name|gimage
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|gimp
operator|->
name|config
operator|->
name|interpolation_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_scale_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_scale_inargs
specifier|static
name|ProcArg
name|image_scale_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-width"
block|,
literal|"New image width: 0< new_width"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-height"
block|,
literal|"New image height: 0< new_height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_scale_proc
specifier|static
name|ProcRecord
name|image_scale_proc
init|=
block|{
literal|"gimp-image-scale"
block|,
literal|"gimp-image-scale"
block|,
literal|"Scale the image to the specified extents."
block|,
literal|"This procedure scales the image so that its new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. No bounds checking is currently provided, so don't supply parameters that are out of bounds. All channels within the image are scaled according to the specified parameters; this includes the image selection mask. All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_scale_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_scale_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_crop_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_crop_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gint32
name|offx
decl_stmt|;
name|gint32
name|offy
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offx
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|offx
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offy
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|offy
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|new_width
operator|>
name|gimage
operator|->
name|width
operator|||
name|new_height
operator|>
name|gimage
operator|->
name|height
operator|||
name|offx
operator|>
operator|(
name|gimage
operator|->
name|width
operator|-
name|new_width
operator|)
operator|||
name|offy
operator|>
operator|(
name|gimage
operator|->
name|height
operator|-
name|new_height
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|gimp_image_crop
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|offx
operator|+
name|new_width
argument_list|,
name|offy
operator|+
name|new_height
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_crop_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_crop_inargs
specifier|static
name|ProcArg
name|image_crop_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-width"
block|,
literal|"New image width: (0< new_width<= width)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-height"
block|,
literal|"New image height: (0< new_height<= height)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"offx"
block|,
literal|"x offset: (0<= offx<= (width - new_width))"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"offy"
block|,
literal|"y offset: (0<= offy<= (height - new_height))"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_crop_proc
specifier|static
name|ProcRecord
name|image_crop_proc
init|=
block|{
literal|"gimp-image-crop"
block|,
literal|"gimp-image-crop"
block|,
literal|"Crop the image to the specified extents."
block|,
literal|"This procedure crops the image so that it's new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. All channels and layers within the image are cropped to the new image extents; this includes the image selection mask. If any parameters are out of range, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|5
block|,
name|image_crop_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_crop_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_flip_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_flip_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|flip_type
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|flip_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|flip_type
operator|<
name|GIMP_ORIENTATION_HORIZONTAL
operator|||
name|flip_type
operator|>
name|GIMP_ORIENTATION_VERTICAL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_image_flip
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|flip_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_flip_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_flip_inargs
specifier|static
name|ProcArg
name|image_flip_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"flip-type"
block|,
literal|"Type of flip: GIMP_ORIENTATION_HORIZONTAL (0) or GIMP_ORIENTATION_VERTICAL (1)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flip_proc
specifier|static
name|ProcRecord
name|image_flip_proc
init|=
block|{
literal|"gimp-image-flip"
block|,
literal|"gimp-image-flip"
block|,
literal|"Flips the image horizontally or vertically."
block|,
literal|"This procedure flips (mirrors) the image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_flip_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_flip_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_rotate_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_rotate_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|rotate_type
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|rotate_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|rotate_type
operator|<
name|GIMP_ROTATE_90
operator|||
name|rotate_type
operator|>
name|GIMP_ROTATE_270
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_image_rotate
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|rotate_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_rotate_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_rotate_inargs
specifier|static
name|ProcArg
name|image_rotate_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"rotate-type"
block|,
literal|"Angle of rotation: GIMP_ROTATE_90 (0), GIMP_ROTATE_180 (1), GIMP_ROTATE_270 (2)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_rotate_proc
specifier|static
name|ProcRecord
name|image_rotate_proc
init|=
block|{
literal|"gimp-image-rotate"
block|,
literal|"gimp-image-rotate"
block|,
literal|"Rotates the image by the specified degrees."
block|,
literal|"This procedure rotates the image."
block|,
literal|"Michael Natterer"
block|,
literal|"Michael Natterer"
block|,
literal|"2003"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_rotate_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_rotate_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_layers_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_layers_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_layers
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|layer_ids
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
expr_stmt|;
name|num_layers
operator|=
name|g_list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_layers
condition|)
block|{
name|layer_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_layers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_layers
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
name|layer_ids
index|[
name|i
index|]
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_layers
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|layer_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_layers_inargs
specifier|static
name|ProcArg
name|image_get_layers_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_outargs
specifier|static
name|ProcArg
name|image_get_layers_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-layers"
block|,
literal|"The number of layers contained in the image"
block|}
block|,
block|{
name|GIMP_PDB_INT32ARRAY
block|,
literal|"layer-ids"
block|,
literal|"The list of layers contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_proc
specifier|static
name|ProcRecord
name|image_get_layers_proc
init|=
block|{
literal|"gimp-image-get-layers"
block|,
literal|"gimp-image-get-layers"
block|,
literal|"Returns the list of layers contained in the specified image."
block|,
literal|"This procedure returns the list of layers contained in the specified image. The order of layers is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_layers_inargs
block|,
literal|2
block|,
name|image_get_layers_outargs
block|,
block|{
block|{
name|image_get_layers_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_channels_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_channels_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_channels
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|channel_ids
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
expr_stmt|;
name|num_channels
operator|=
name|g_list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_channels
condition|)
block|{
name|channel_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
name|channel_ids
index|[
name|i
index|]
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_channels_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_channels
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|channel_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_channels_inargs
specifier|static
name|ProcArg
name|image_get_channels_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_outargs
specifier|static
name|ProcArg
name|image_get_channels_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-channels"
block|,
literal|"The number of channels contained in the image"
block|}
block|,
block|{
name|GIMP_PDB_INT32ARRAY
block|,
literal|"channel-ids"
block|,
literal|"The list of channels contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_proc
specifier|static
name|ProcRecord
name|image_get_channels_proc
init|=
block|{
literal|"gimp-image-get-channels"
block|,
literal|"gimp-image-get-channels"
block|,
literal|"Returns the list of channels contained in the specified image."
block|,
literal|"This procedure returns the list of channels contained in the specified image. This does not include the selection mask, or layer masks. The order is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_channels_inargs
block|,
literal|2
block|,
name|image_get_channels_outargs
block|,
block|{
block|{
name|image_get_channels_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_vectors_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_vectors_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_vectors
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|vector_ids
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|->
name|list
expr_stmt|;
name|num_vectors
operator|=
name|g_list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_vectors
condition|)
block|{
name|vector_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
name|vector_ids
index|[
name|i
index|]
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_vectors_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_vectors
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|vector_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_vectors_inargs
specifier|static
name|ProcArg
name|image_get_vectors_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_vectors_outargs
specifier|static
name|ProcArg
name|image_get_vectors_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-vectors"
block|,
literal|"The number of vectors contained in the image"
block|}
block|,
block|{
name|GIMP_PDB_INT32ARRAY
block|,
literal|"vector-ids"
block|,
literal|"The list of vectors contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_vectors_proc
specifier|static
name|ProcRecord
name|image_get_vectors_proc
init|=
block|{
literal|"gimp-image-get-vectors"
block|,
literal|"gimp-image-get-vectors"
block|,
literal|"Returns the list of vectors contained in the specified image."
block|,
literal|"This procedure returns the list of vectors contained in the specified image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_vectors_inargs
block|,
literal|2
block|,
name|image_get_vectors_outargs
block|,
block|{
block|{
name|image_get_vectors_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_active_drawable_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_active_drawable_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_active_drawable_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_active_drawable_inargs
specifier|static
name|ProcArg
name|image_get_active_drawable_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_drawable_outargs
specifier|static
name|ProcArg
name|image_get_active_drawable_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The active drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_drawable_proc
specifier|static
name|ProcRecord
name|image_get_active_drawable_proc
init|=
block|{
literal|"gimp-image-get-active-drawable"
block|,
literal|"gimp-image-get-active-drawable"
block|,
literal|"Get the image's active drawable"
block|,
literal|"This procedure returns the ID of the image's active drawable. This can be either a layer, a channel, or a layer mask. The active drawable is specified by the active image channel. If that is -1, then by the active image layer. If the active image layer has a layer mask and the layer mask is in edit mode, then the layer mask is the active drawable."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_active_drawable_inargs
block|,
literal|1
block|,
name|image_get_active_drawable_outargs
block|,
block|{
block|{
name|image_get_active_drawable_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_unset_active_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_unset_active_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_unset_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_unset_active_channel_inargs
specifier|static
name|ProcArg
name|image_unset_active_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_unset_active_channel_proc
specifier|static
name|ProcRecord
name|image_unset_active_channel_proc
init|=
block|{
literal|"gimp-image-unset-active-channel"
block|,
literal|"gimp-image-unset-active-channel"
block|,
literal|"Unsets the active channel in the specified image."
block|,
literal|"If an active channel exists, it is unset. There then exists no active channel, and if desired, one can be set through a call to 'Set Active Channel'. No error is returned in the case of no existing active channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_unset_active_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_unset_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_floating_sel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_floating_sel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_sel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|floating_sel
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_floating_sel_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|floating_sel
condition|?
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|floating_sel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_floating_sel_inargs
specifier|static
name|ProcArg
name|image_get_floating_sel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_floating_sel_outargs
specifier|static
name|ProcArg
name|image_get_floating_sel_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"floating-sel"
block|,
literal|"The image's floating selection"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_floating_sel_proc
specifier|static
name|ProcRecord
name|image_get_floating_sel_proc
init|=
block|{
literal|"gimp-image-get-floating-sel"
block|,
literal|"gimp-image-get-floating-sel"
block|,
literal|"Return the floating selection of the image."
block|,
literal|"This procedure returns the image's floating selection, if it exists. If it doesn't exist, -1 is returned as the layer ID."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_floating_sel_inargs
block|,
literal|1
block|,
name|image_get_floating_sel_outargs
block|,
block|{
block|{
name|image_get_floating_sel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_floating_sel_attached_to_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_floating_sel_attached_to_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|floating_sel
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_sel
condition|)
name|drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|GIMP_LAYER
argument_list|(
name|floating_sel
argument_list|)
operator|->
name|fs
operator|.
name|drawable
argument_list|)
expr_stmt|;
else|else
name|drawable
operator|=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_floating_sel_attached_to_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable
condition|?
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_inargs
specifier|static
name|ProcArg
name|image_floating_sel_attached_to_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_outargs
specifier|static
name|ProcArg
name|image_floating_sel_attached_to_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable the floating selection is attached to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_proc
specifier|static
name|ProcRecord
name|image_floating_sel_attached_to_proc
init|=
block|{
literal|"gimp-image-floating-sel-attached-to"
block|,
literal|"gimp-image-floating-sel-attached-to"
block|,
literal|"Return the drawable the floating selection is attached to."
block|,
literal|"This procedure returns the drawable the image's floating selection is attached to, if it exists. If it doesn't exist, -1 is returned as the drawable ID."
block|,
literal|"Wolfgang Hofer"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_floating_sel_attached_to_inargs
block|,
literal|1
block|,
name|image_floating_sel_attached_to_outargs
block|,
block|{
block|{
name|image_floating_sel_attached_to_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_pick_color_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_pick_color_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|gboolean
name|sample_average
decl_stmt|;
name|gdouble
name|average_radius
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|sample_average
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|average_radius
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|sample_average
operator|&&
operator|(
name|average_radius
operator|<=
literal|0.0
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|sample_merged
condition|)
if|if
condition|(
operator|!
name|drawable
operator|||
operator|(
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|!=
name|gimage
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_pick_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|(
name|gint
operator|)
name|x
argument_list|,
operator|(
name|gint
operator|)
name|y
argument_list|,
name|sample_merged
argument_list|,
name|sample_average
argument_list|,
name|average_radius
argument_list|,
name|NULL
argument_list|,
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_pick_color_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_color
operator|=
name|color
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_pick_color_inargs
specifier|static
name|ProcArg
name|image_pick_color_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to pick from"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"sample-merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"sample-average"
block|,
literal|"Average the color of all the pixels in a specified radius"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"average-radius"
block|,
literal|"The radius of pixels to average"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_color_outargs
specifier|static
name|ProcArg
name|image_pick_color_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_COLOR
block|,
literal|"color"
block|,
literal|"The return color"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_color_proc
specifier|static
name|ProcRecord
name|image_pick_color_proc
init|=
block|{
literal|"gimp-image-pick-color"
block|,
literal|"gimp-image-pick-color"
block|,
literal|"Determine the color at the given drawable coordinates"
block|,
literal|"This tool determines the color at the specified coordinates. The returned color is an RGB triplet even for grayscale and indexed drawables. If the coordinates lie outside of the extents of the specified drawable, then an error is returned. If the drawable has an alpha channel, the algorithm examines the alpha value of the drawable at the coordinates. If the alpha value is completely transparent (0), then an error is returned. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of a merged sampling, the supplied drawable is ignored except for finding the image it belongs to."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|7
block|,
name|image_pick_color_inargs
block|,
literal|1
block|,
name|image_pick_color_outargs
block|,
block|{
block|{
name|image_pick_color_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_pick_correlate_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_pick_correlate_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|x
decl_stmt|;
name|gint32
name|y
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|layer
operator|=
name|gimp_image_pick_correlate_layer
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_pick_correlate_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_inargs
specifier|static
name|ProcArg
name|image_pick_correlate_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"x"
block|,
literal|"The x coordinate for the pick"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"y"
block|,
literal|"The y coordinate for the pick"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_outargs
specifier|static
name|ProcArg
name|image_pick_correlate_layer_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer found at the specified coordinates"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_proc
specifier|static
name|ProcRecord
name|image_pick_correlate_layer_proc
init|=
block|{
literal|"gimp-image-pick-correlate-layer"
block|,
literal|"gimp-image-pick-correlate-layer"
block|,
literal|"Find the layer visible at the specified coordinates."
block|,
literal|"This procedure finds the layer which is visible at the specified coordinates. Layers which do not qualify are those whose extents do not pass within the specified coordinates, or which are transparent at the specified coordinates. This procedure will return -1 if no layer is found."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_pick_correlate_layer_inargs
block|,
literal|1
block|,
name|image_pick_correlate_layer_outargs
block|,
block|{
block|{
name|image_pick_correlate_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_add_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|position
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|gimp_item_is_floating
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|||
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|MAX
argument_list|(
name|position
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_layer_inargs
specifier|static
name|ProcArg
name|image_add_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"position"
block|,
literal|"The layer position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_proc
specifier|static
name|ProcRecord
name|image_add_layer_proc
init|=
block|{
literal|"gimp-image-add-layer"
block|,
literal|"gimp-image-add-layer"
block|,
literal|"Add the specified layer to the image."
block|,
literal|"This procedure adds the specified layer to the gimage at the given position. If the position is specified as -1, then the layer is inserted at the top of the layer stack. If the layer to be added has no alpha channel, it must be added at position 0. The layer type must be compatible with the image base type."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_add_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_remove_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_layer_inargs
specifier|static
name|ProcArg
name|image_remove_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_proc
specifier|static
name|ProcRecord
name|image_remove_layer_proc
init|=
block|{
literal|"gimp-image-remove-layer"
block|,
literal|"gimp-image-remove-layer"
block|,
literal|"Remove the specified layer from the image."
block|,
literal|"This procedure removes the specified layer from the image. If the layer doesn't exist, an error is returned. If there are no layers left in the image, this call will fail. If this layer is the last layer remaining, the image will become empty and have no active layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_remove_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_raise_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_raise_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_layer_inargs
specifier|static
name|ProcArg
name|image_raise_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_proc
specifier|static
name|ProcRecord
name|image_raise_layer_proc
init|=
block|{
literal|"gimp-image-raise-layer"
block|,
literal|"gimp-image-raise-layer"
block|,
literal|"Raise the specified layer in the image's layer stack"
block|,
literal|"This procedure raises the specified layer one step in the existing layer stack. It will not move the layer if there is no layer above it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_raise_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_lower_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_lower_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_layer_inargs
specifier|static
name|ProcArg
name|image_lower_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_proc
specifier|static
name|ProcRecord
name|image_lower_layer_proc
init|=
block|{
literal|"gimp-image-lower-layer"
block|,
literal|"gimp-image-lower-layer"
block|,
literal|"Lower the specified layer in the image's layer stack"
block|,
literal|"This procedure lowers the specified layer one step in the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_lower_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_layer_to_top_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_raise_layer_to_top_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_raise_layer_to_top
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_layer_to_top_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_inargs
specifier|static
name|ProcArg
name|image_raise_layer_to_top_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to raise to top"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_proc
specifier|static
name|ProcRecord
name|image_raise_layer_to_top_proc
init|=
block|{
literal|"gimp-image-raise-layer-to-top"
block|,
literal|"gimp-image-raise-layer-to-top"
block|,
literal|"Raise the specified layer in the image's layer stack to top of stack"
block|,
literal|"This procedure raises the specified layer to top of the existing layer stack. It will not move the layer if there is no layer above it, or the layer has no alpha channel."
block|,
literal|"Wolfgang Hofer, Sven Neumann"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_raise_layer_to_top_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_layer_to_top_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_layer_to_bottom_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_lower_layer_to_bottom_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_lower_layer_to_bottom
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_layer_to_bottom_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_inargs
specifier|static
name|ProcArg
name|image_lower_layer_to_bottom_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower to bottom"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_proc
specifier|static
name|ProcRecord
name|image_lower_layer_to_bottom_proc
init|=
block|{
literal|"gimp-image-lower-layer-to-bottom"
block|,
literal|"gimp-image-lower-layer-to-bottom"
block|,
literal|"Lower the specified layer in the image's layer stack to bottom of stack"
block|,
literal|"This procedure lowers the specified layer to bottom of the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Wolfgang Hofer, Sven Neumann"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_lower_layer_to_bottom_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_layer_to_bottom_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_add_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|position
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_floating
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_add_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|MAX
argument_list|(
name|position
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_channel_inargs
specifier|static
name|ProcArg
name|image_add_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"position"
block|,
literal|"The channel position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_channel_proc
specifier|static
name|ProcRecord
name|image_add_channel_proc
init|=
block|{
literal|"gimp-image-add-channel"
block|,
literal|"gimp-image-add-channel"
block|,
literal|"Add the specified channel to the image."
block|,
literal|"This procedure adds the specified channel to the image. The position channel is not currently used, so the channel is always inserted at the top of the channel stack."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_add_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_remove_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_remove_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_channel_inargs
specifier|static
name|ProcArg
name|image_remove_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_channel_proc
specifier|static
name|ProcRecord
name|image_remove_channel_proc
init|=
block|{
literal|"gimp-image-remove-channel"
block|,
literal|"gimp-image-remove-channel"
block|,
literal|"Remove the specified channel from the image."
block|,
literal|"This procedure removes the specified channel from the image. If the channel doesn't exist, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_remove_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_raise_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_raise_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_channel_inargs
specifier|static
name|ProcArg
name|image_raise_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_channel_proc
specifier|static
name|ProcRecord
name|image_raise_channel_proc
init|=
block|{
literal|"gimp-image-raise-channel"
block|,
literal|"gimp-image-raise-channel"
block|,
literal|"Raise the specified channel in the image's channel stack"
block|,
literal|"This procedure raises the specified channel one step in the existing channel stack. It will not move the channel if there is no channel above it."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_raise_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_lower_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimp_image_lower_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_channel_inargs
specifier|static
name|ProcArg
name|image_lower_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_channel_proc
specifier|static
name|ProcRecord
name|image_lower_channel_proc
init|=
block|{
literal|"gimp-image-lower-channel"
block|,
literal|"gimp-image-lower-channel"
block|,
literal|"Lower the specified layer in the image's layer stack"
block|,
literal|"This procedure lowers the specified layer one step in the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_lower_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_flatten_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_flatten_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|layer
operator|=
name|gimp_image_flatten
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_flatten_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_flatten_inargs
specifier|static
name|ProcArg
name|image_flatten_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_outargs
specifier|static
name|ProcArg
name|image_flatten_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_proc
specifier|static
name|ProcRecord
name|image_flatten_proc
init|=
block|{
literal|"gimp-image-flatten"
block|,
literal|"gimp-image-flatten"
block|,
literal|"Flatten all visible layers into a single layer. Discard all invisible layers."
block|,
literal|"This procedure combines the visible layers in a manner analogous to merging with the CLIP_TO_IMAGE merge type. Non-visible layers are discarded, and the resulting image is stripped of its alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_flatten_inargs
block|,
literal|1
block|,
name|image_flatten_outargs
block|,
block|{
block|{
name|image_flatten_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_merge_visible_layers_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_merge_visible_layers_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|merge_type
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|merge_type
operator|<
name|GIMP_EXPAND_AS_NECESSARY
operator|||
name|merge_type
operator|>
name|GIMP_CLIP_TO_BOTTOM_LAYER
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_image_merge_visible_layers
argument_list|(
name|gimage
argument_list|,
name|context
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_merge_visible_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_merge_visible_layers_inargs
specifier|static
name|ProcArg
name|image_merge_visible_layers_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"merge-type"
block|,
literal|"The type of merge: { GIMP_EXPAND_AS_NECESSARY (0), GIMP_CLIP_TO_IMAGE (1), GIMP_CLIP_TO_BOTTOM_LAYER (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_outargs
specifier|static
name|ProcArg
name|image_merge_visible_layers_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_proc
specifier|static
name|ProcRecord
name|image_merge_visible_layers_proc
init|=
block|{
literal|"gimp-image-merge-visible-layers"
block|,
literal|"gimp-image-merge-visible-layers"
block|,
literal|"Merge the visible image layers into one."
block|,
literal|"This procedure combines the visible layers into a single layer using the specified merge type. A merge type of EXPAND_AS_NECESSARY expands the final layer to encompass the areas of the visible layers. A merge type of CLIP_TO_IMAGE clips the final layer to the extents of the image. A merge type of CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the bottommost layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_merge_visible_layers_inargs
block|,
literal|1
block|,
name|image_merge_visible_layers_outargs
block|,
block|{
block|{
name|image_merge_visible_layers_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_merge_down_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_merge_down_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|merge_layer
decl_stmt|;
name|gint32
name|merge_type
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|merge_layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|merge_type
operator|<
name|GIMP_EXPAND_AS_NECESSARY
operator|||
name|merge_type
operator|>
name|GIMP_CLIP_TO_BOTTOM_LAYER
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_image_merge_down
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|context
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_merge_down_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_merge_down_inargs
specifier|static
name|ProcArg
name|image_merge_down_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"merge-layer"
block|,
literal|"The layer to merge down from"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"merge-type"
block|,
literal|"The type of merge: { GIMP_EXPAND_AS_NECESSARY (0), GIMP_CLIP_TO_IMAGE (1), GIMP_CLIP_TO_BOTTOM_LAYER (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_outargs
specifier|static
name|ProcArg
name|image_merge_down_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_proc
specifier|static
name|ProcRecord
name|image_merge_down_proc
init|=
block|{
literal|"gimp-image-merge-down"
block|,
literal|"gimp-image-merge-down"
block|,
literal|"Merge the layer passed and the first visible layer below."
block|,
literal|"This procedure combines the passed layer and the first visible layer below it using the specified merge type. A merge type of EXPAND_AS_NECESSARY expands the final layer to encompass the areas of the visible layers. A merge type of CLIP_TO_IMAGE clips the final layer to the extents of the image. A merge type of CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the bottommost layer."
block|,
literal|"Larry Ewing"
block|,
literal|"Larry Ewing"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_merge_down_inargs
block|,
literal|1
block|,
name|image_merge_down_outargs
block|,
block|{
block|{
name|image_merge_down_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_layer_mask_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_add_layer_mask_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayerMask
modifier|*
name|mask
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|mask
operator|=
operator|(
name|GimpLayerMask
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER_MASK
argument_list|(
name|mask
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|,
name|TRUE
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_layer_mask_inargs
specifier|static
name|ProcArg
name|image_add_layer_mask_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to receive the mask"
block|}
block|,
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"mask"
block|,
literal|"The mask to add to the layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_mask_proc
specifier|static
name|ProcRecord
name|image_add_layer_mask_proc
init|=
block|{
literal|"gimp-image-add-layer-mask"
block|,
literal|"gimp-image-add-layer-mask"
block|,
literal|"This procedure is deprecated! Use 'gimp-layer-add-mask' instead."
block|,
literal|"This procedure is deprecated! Use 'gimp-layer-add-mask' instead."
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"gimp-layer-add-mask"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_add_layer_mask_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_layer_mask_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_layer_mask_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_remove_layer_mask_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint32
name|mode
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|mode
operator|<
name|GIMP_MASK_APPLY
operator|||
name|mode
operator|>
name|GIMP_MASK_DISCARD
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_layer_apply_mask
argument_list|(
name|layer
argument_list|,
name|mode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_layer_mask_inargs
specifier|static
name|ProcArg
name|image_remove_layer_mask_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer from which to remove mask"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"mode"
block|,
literal|"Removal mode: { GIMP_MASK_APPLY (0), GIMP_MASK_DISCARD (1) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_mask_proc
specifier|static
name|ProcRecord
name|image_remove_layer_mask_proc
init|=
block|{
literal|"gimp-image-remove-layer-mask"
block|,
literal|"gimp-image-remove-layer-mask"
block|,
literal|"This procedure is deprecated! Use 'gimp-layer-remove-mask' instead."
block|,
literal|"This procedure is deprecated! Use 'gimp-layer-remove-mask' instead."
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"gimp-layer-remove-mask"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_remove_layer_mask_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_layer_mask_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_colormap_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_colormap_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_bytes
init|=
literal|0
decl_stmt|;
name|guint8
modifier|*
name|colormap
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|num_bytes
operator|=
literal|3
operator|*
name|gimp_image_get_colormap_size
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|colormap
operator|=
name|g_memdup
argument_list|(
name|gimp_image_get_colormap
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_colormap_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_bytes
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|colormap
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_colormap_inargs
specifier|static
name|ProcArg
name|image_get_colormap_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_colormap_outargs
specifier|static
name|ProcArg
name|image_get_colormap_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-bytes"
block|,
literal|"Number of bytes in the colormap array: 0< num_bytes"
block|}
block|,
block|{
name|GIMP_PDB_INT8ARRAY
block|,
literal|"colormap"
block|,
literal|"The image's colormap"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_colormap_proc
specifier|static
name|ProcRecord
name|image_get_colormap_proc
init|=
block|{
literal|"gimp-image-get-colormap"
block|,
literal|"gimp-image-get-colormap"
block|,
literal|"Returns the image's colormap"
block|,
literal|"This procedure returns an actual pointer to the image's colormap, as well as the number of bytes contained in the colormap. The actual number of colors in the transmitted colormap will be \"num_bytes\" / 3. If the image is not of base type GIMP_INDEXED, this pointer will be NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_colormap_inargs
block|,
literal|2
block|,
name|image_get_colormap_outargs
block|,
block|{
block|{
name|image_get_colormap_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_colormap_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_colormap_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_bytes
decl_stmt|;
name|guint8
modifier|*
name|colormap
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_bytes
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|num_bytes
operator|<
literal|0
operator|||
name|num_bytes
operator|>
literal|768
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|colormap
operator|=
operator|(
name|guint8
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_colormap
argument_list|(
name|gimage
argument_list|,
name|colormap
argument_list|,
name|num_bytes
operator|/
literal|3
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_colormap_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_colormap_inargs
specifier|static
name|ProcArg
name|image_set_colormap_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"num-bytes"
block|,
literal|"Number of bytes in the colormap array: 0<= num_bytes<= 768"
block|}
block|,
block|{
name|GIMP_PDB_INT8ARRAY
block|,
literal|"colormap"
block|,
literal|"The new colormap values"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_colormap_proc
specifier|static
name|ProcRecord
name|image_set_colormap_proc
init|=
block|{
literal|"gimp-image-set-colormap"
block|,
literal|"gimp-image-set-colormap"
block|,
literal|"Sets the entries in the image's colormap."
block|,
literal|"This procedure sets the entries in the specified image's colormap. The number of entries is specified by the \"num_bytes\" parameter and corresponds to the number of INT8 triples that must be contained in the \"colormap\" array. The actual number of colors in the transmitted colormap is \"num_bytes\" / 3."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_set_colormap_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_colormap_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_clean_all_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_clean_all_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_clean_all
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_clean_all_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_clean_all_inargs
specifier|static
name|ProcArg
name|image_clean_all_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_clean_all_proc
specifier|static
name|ProcRecord
name|image_clean_all_proc
init|=
block|{
literal|"gimp-image-clean-all"
block|,
literal|"gimp-image-clean-all"
block|,
literal|"Set the image dirty count to 0."
block|,
literal|"This procedure sets the specified image's dirty count to 0, allowing operations to occur without having a 'dirtied' image. This is especially useful for creating and loading images which should not initially be considered dirty, even though layers must be created, filled, and installed in the image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_clean_all_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_clean_all_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_is_dirty_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_is_dirty_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gboolean
name|dirty
init|=
name|FALSE
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|dirty
operator|=
operator|(
name|gimage
operator|->
name|dirty
operator|!=
literal|0
operator|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_is_dirty_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|dirty
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_is_dirty_inargs
specifier|static
name|ProcArg
name|image_is_dirty_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_is_dirty_outargs
specifier|static
name|ProcArg
name|image_is_dirty_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"dirty"
block|,
literal|"True if the image has unsaved changes."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_is_dirty_proc
specifier|static
name|ProcRecord
name|image_is_dirty_proc
init|=
block|{
literal|"gimp-image-is-dirty"
block|,
literal|"gimp-image-is-dirty"
block|,
literal|"Checks if the image has unsaved changes."
block|,
literal|"This procedure checks the specified image's dirty count to see if it needs to be saved."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_is_dirty_inargs
block|,
literal|1
block|,
name|image_is_dirty_outargs
block|,
block|{
block|{
name|image_is_dirty_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_thumbnail_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_thumbnail_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|req_width
decl_stmt|;
name|gint32
name|req_height
decl_stmt|;
name|gint32
name|width
init|=
literal|0
decl_stmt|;
name|gint32
name|height
init|=
literal|0
decl_stmt|;
name|gint32
name|bpp
init|=
literal|0
decl_stmt|;
name|gint32
name|num_bytes
init|=
literal|0
decl_stmt|;
name|guint8
modifier|*
name|thumbnail_data
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|req_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|req_width
operator|<=
literal|0
operator|||
name|req_width
operator|>
literal|1024
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|req_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|req_height
operator|<=
literal|0
operator|||
name|req_height
operator|>
literal|1024
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|TempBuf
modifier|*
name|buf
decl_stmt|;
name|gint
name|dwidth
decl_stmt|,
name|dheight
decl_stmt|;
name|g_assert
argument_list|(
name|GIMP_VIEWABLE_MAX_PREVIEW_SIZE
operator|>=
literal|1024
argument_list|)
expr_stmt|;
comment|/* Adjust the width/height ratio */
name|dwidth
operator|=
name|gimp_image_get_width
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|dheight
operator|=
name|gimp_image_get_height
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwidth
operator|>
name|dheight
condition|)
name|req_height
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|req_width
operator|*
name|dheight
operator|)
operator|/
name|dwidth
argument_list|)
expr_stmt|;
else|else
name|req_width
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|req_height
operator|*
name|dwidth
operator|)
operator|/
name|dheight
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|gimp
operator|->
name|config
operator|->
name|layer_previews
condition|)
name|buf
operator|=
name|gimp_viewable_get_new_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|req_width
argument_list|,
name|req_height
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|gimp_viewable_get_dummy_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|req_width
argument_list|,
name|req_height
argument_list|,
name|gimp_image_has_alpha
argument_list|(
name|gimage
argument_list|)
condition|?
literal|4
else|:
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|num_bytes
operator|=
name|buf
operator|->
name|height
operator|*
name|buf
operator|->
name|width
operator|*
name|buf
operator|->
name|bytes
expr_stmt|;
name|thumbnail_data
operator|=
name|g_memdup
argument_list|(
name|temp_buf_data
argument_list|(
name|buf
argument_list|)
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|width
operator|=
name|buf
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|buf
operator|->
name|height
expr_stmt|;
name|bpp
operator|=
name|buf
operator|->
name|bytes
expr_stmt|;
name|temp_buf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_thumbnail_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|width
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|height
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|bpp
expr_stmt|;
name|return_args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_bytes
expr_stmt|;
name|return_args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|thumbnail_data
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_thumbnail_inargs
specifier|static
name|ProcArg
name|image_thumbnail_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"width"
block|,
literal|"The thumbnail width"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"height"
block|,
literal|"The thumbnail height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_thumbnail_outargs
specifier|static
name|ProcArg
name|image_thumbnail_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"width"
block|,
literal|"The previews width"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"height"
block|,
literal|"The previews height"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"bpp"
block|,
literal|"The previews bpp"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"thumbnail-data-count"
block|,
literal|"The number of bytes in thumbnail data"
block|}
block|,
block|{
name|GIMP_PDB_INT8ARRAY
block|,
literal|"thumbnail-data"
block|,
literal|"The thumbnail data"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_thumbnail_proc
specifier|static
name|ProcRecord
name|image_thumbnail_proc
init|=
block|{
literal|"gimp-image-thumbnail"
block|,
literal|"gimp-image-thumbnail"
block|,
literal|"Get a thumbnail of an image."
block|,
literal|"This function gets data from which a thumbnail of an image preview can be created. Maximum x or y dimension is 1024 pixels. The pixels are returned in RGB[A] or GRAY[A] format. The bpp return value gives the number of bits per pixel in the image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_thumbnail_inargs
block|,
literal|5
block|,
name|image_thumbnail_outargs
block|,
block|{
block|{
name|image_thumbnail_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_active_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_active_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|active_layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|active_layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_active_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|active_layer
condition|?
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|active_layer
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_active_layer_inargs
specifier|static
name|ProcArg
name|image_get_active_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_outargs
specifier|static
name|ProcArg
name|image_get_active_layer_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"active-layer"
block|,
literal|"The active layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_proc
specifier|static
name|ProcRecord
name|image_get_active_layer_proc
init|=
block|{
literal|"gimp-image-get-active-layer"
block|,
literal|"gimp-image-get-active-layer"
block|,
literal|"Returns the specified image's active layer."
block|,
literal|"If there is an active layer, its ID will be returned, otherwise, -1. If a channel is currently active, then no layer will be. If a layer mask is active, then this will return the associated layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_active_layer_inargs
block|,
literal|1
block|,
name|image_get_active_layer_outargs
block|,
block|{
block|{
name|image_get_active_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_active_layer_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_active_layer_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|active_layer
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active_layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_LAYER
argument_list|(
name|active_layer
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|active_layer
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|active_layer
argument_list|)
operator|==
name|active_layer
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_active_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_active_layer_inargs
specifier|static
name|ProcArg
name|image_set_active_layer_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_LAYER
block|,
literal|"active-layer"
block|,
literal|"The new image active layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_layer_proc
specifier|static
name|ProcRecord
name|image_set_active_layer_proc
init|=
block|{
literal|"gimp-image-set-active-layer"
block|,
literal|"gimp-image-set-active-layer"
block|,
literal|"Sets the specified image's active layer."
block|,
literal|"If the layer exists, it is set as the active layer in the image. Any previous active layer or channel is set to inactive. An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_set_active_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_active_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_active_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_active_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|active_channel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|active_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_active_channel_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|active_channel
condition|?
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|active_channel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_active_channel_inargs
specifier|static
name|ProcArg
name|image_get_active_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_outargs
specifier|static
name|ProcArg
name|image_get_active_channel_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"active-channel"
block|,
literal|"The active channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_proc
specifier|static
name|ProcRecord
name|image_get_active_channel_proc
init|=
block|{
literal|"gimp-image-get-active-channel"
block|,
literal|"gimp-image-get-active-channel"
block|,
literal|"Returns the specified image's active channel."
block|,
literal|"If there is an active channel, this will return the channel ID, otherwise, -1."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_active_channel_inargs
block|,
literal|1
block|,
name|image_get_active_channel_outargs
block|,
block|{
block|{
name|image_get_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_active_channel_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_active_channel_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|active_channel
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active_channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_CHANNEL
argument_list|(
name|active_channel
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|active_channel
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|active_channel
argument_list|)
operator|==
name|active_channel
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_active_channel_inargs
specifier|static
name|ProcArg
name|image_set_active_channel_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"active-channel"
block|,
literal|"The new image active channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_channel_proc
specifier|static
name|ProcRecord
name|image_set_active_channel_proc
init|=
block|{
literal|"gimp-image-set-active-channel"
block|,
literal|"gimp-image-set-active-channel"
block|,
literal|"Sets the specified image's active channel."
block|,
literal|"If the channel exists, it is set as the active channel in the image. Any previous active channel or channel is set to inactive. An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_set_active_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_selection_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_selection_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpChannel
modifier|*
name|selection
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|selection
operator|=
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_selection_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_selection_inargs
specifier|static
name|ProcArg
name|image_get_selection_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_outargs
specifier|static
name|ProcArg
name|image_get_selection_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_SELECTION
block|,
literal|"selection"
block|,
literal|"The selection channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_proc
specifier|static
name|ProcRecord
name|image_get_selection_proc
init|=
block|{
literal|"gimp-image-get-selection"
block|,
literal|"gimp-image-get-selection"
block|,
literal|"Returns the specified image's selection."
block|,
literal|"This will always return a valid ID for a selection -- which is represented as a channel internally."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_selection_inargs
block|,
literal|1
block|,
name|image_get_selection_outargs
block|,
block|{
block|{
name|image_get_selection_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_component_active_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_component_active_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|GIMP_RED_CHANNEL
operator|||
name|component
operator|>
name|GIMP_ALPHA_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GIMP_GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|GIMP_INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_RGB
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_component_active_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_component_active
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_component_active_inargs
specifier|static
name|ProcArg
name|image_get_component_active_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { GIMP_RED_CHANNEL (0), GIMP_GREEN_CHANNEL (1), GIMP_BLUE_CHANNEL (2), GIMP_GRAY_CHANNEL (3), GIMP_INDEXED_CHANNEL (4), GIMP_ALPHA_CHANNEL (5) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_outargs
specifier|static
name|ProcArg
name|image_get_component_active_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"active"
block|,
literal|"Component is active (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_proc
specifier|static
name|ProcRecord
name|image_get_component_active_proc
init|=
block|{
literal|"gimp-image-get-component-active"
block|,
literal|"gimp-image-get-component-active"
block|,
literal|"Returns if the specified image's image component is active."
block|,
literal|"This procedure returns if the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is active or inactive -- whether or not it can be modified. If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_get_component_active_inargs
block|,
literal|1
block|,
name|image_get_component_active_outargs
block|,
block|{
block|{
name|image_get_component_active_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_component_active_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_component_active_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gboolean
name|active
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|GIMP_RED_CHANNEL
operator|||
name|component
operator|>
name|GIMP_ALPHA_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GIMP_GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|GIMP_INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_RGB
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_component_active
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_component_active_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_component_active_inargs
specifier|static
name|ProcArg
name|image_set_component_active_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { GIMP_RED_CHANNEL (0), GIMP_GREEN_CHANNEL (1), GIMP_BLUE_CHANNEL (2), GIMP_GRAY_CHANNEL (3), GIMP_INDEXED_CHANNEL (4), GIMP_ALPHA_CHANNEL (5) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"active"
block|,
literal|"Component is active (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_active_proc
specifier|static
name|ProcRecord
name|image_set_component_active_proc
init|=
block|{
literal|"gimp-image-set-component-active"
block|,
literal|"gimp-image-set-component-active"
block|,
literal|"Sets if the specified image's image component is active."
block|,
literal|"This procedure sets if the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is active or inactive -- whether or not it can be modified. If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_set_component_active_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_component_active_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_component_visible_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_component_visible_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|GIMP_RED_CHANNEL
operator|||
name|component
operator|>
name|GIMP_ALPHA_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GIMP_GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|GIMP_INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_RGB
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_component_visible_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_component_visible_inargs
specifier|static
name|ProcArg
name|image_get_component_visible_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { GIMP_RED_CHANNEL (0), GIMP_GREEN_CHANNEL (1), GIMP_BLUE_CHANNEL (2), GIMP_GRAY_CHANNEL (3), GIMP_INDEXED_CHANNEL (4), GIMP_ALPHA_CHANNEL (5) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_outargs
specifier|static
name|ProcArg
name|image_get_component_visible_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"visible"
block|,
literal|"Component is visible (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_proc
specifier|static
name|ProcRecord
name|image_get_component_visible_proc
init|=
block|{
literal|"gimp-image-get-component-visible"
block|,
literal|"gimp-image-get-component-visible"
block|,
literal|"Returns if the specified image's image component is visible."
block|,
literal|"This procedure returns if the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is visible or invisible -- whether or not it can be seen. If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_get_component_visible_inargs
block|,
literal|1
block|,
name|image_get_component_visible_outargs
block|,
block|{
block|{
name|image_get_component_visible_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_component_visible_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_component_visible_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gboolean
name|visible
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|GIMP_RED_CHANNEL
operator|||
name|component
operator|>
name|GIMP_ALPHA_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|visible
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GIMP_GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|GIMP_INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_RGB
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_component_visible
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|,
name|visible
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_component_visible_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_component_visible_inargs
specifier|static
name|ProcArg
name|image_set_component_visible_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { GIMP_RED_CHANNEL (0), GIMP_GREEN_CHANNEL (1), GIMP_BLUE_CHANNEL (2), GIMP_GRAY_CHANNEL (3), GIMP_INDEXED_CHANNEL (4), GIMP_ALPHA_CHANNEL (5) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"visible"
block|,
literal|"Component is visible (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_visible_proc
specifier|static
name|ProcRecord
name|image_set_component_visible_proc
init|=
block|{
literal|"gimp-image-set-component-visible"
block|,
literal|"gimp-image-set-component-visible"
block|,
literal|"Sets if the specified image's image component is visible."
block|,
literal|"This procedure sets if the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is visible or invisible -- whether or not it can be seen. If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_set_component_visible_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_component_visible_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_filename_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_filename_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_filename_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|gimp_image_get_filename
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_filename_inargs
specifier|static
name|ProcArg
name|image_get_filename_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_outargs
specifier|static
name|ProcArg
name|image_get_filename_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_proc
specifier|static
name|ProcRecord
name|image_get_filename_proc
init|=
block|{
literal|"gimp-image-get-filename"
block|,
literal|"gimp-image-get-filename"
block|,
literal|"Returns the specified image's filename."
block|,
literal|"This procedure returns the specified image's filename in the filesystem encoding. The image has a filename only if it was loaded or has since been saved. Otherwise, this function returns %NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_filename_inargs
block|,
literal|1
block|,
name|image_get_filename_outargs
block|,
block|{
block|{
name|image_get_filename_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_filename_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_filename_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|filename
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/*  verify that the filename can be converted to UTF-8 and back  */
name|gchar
modifier|*
name|utf8
init|=
name|g_filename_to_utf8
argument_list|(
name|filename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|utf8
condition|)
block|{
name|gchar
modifier|*
name|tmp
init|=
name|g_filename_from_utf8
argument_list|(
name|utf8
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|g_free
argument_list|(
name|utf8
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_filename
argument_list|(
name|gimage
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_filename_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_filename_inargs
specifier|static
name|ProcArg
name|image_set_filename_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The new image filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_filename_proc
specifier|static
name|ProcRecord
name|image_set_filename_proc
init|=
block|{
literal|"gimp-image-set-filename"
block|,
literal|"gimp-image-set-filename"
block|,
literal|"Sets the specified image's filename."
block|,
literal|"This procedure sets the specified image's filename. The filename should be in the filesystem encoding."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_set_filename_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_filename_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_name_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_name_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|filename
operator|=
name|gimp_image_get_filename
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|name
operator|=
name|g_filename_display_basename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|g_strdup
argument_list|(
name|_
argument_list|(
literal|"Untitled"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_name_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|name
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_name_inargs
specifier|static
name|ProcArg
name|image_get_name_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_name_outargs
specifier|static
name|ProcArg
name|image_get_name_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The name"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_name_proc
specifier|static
name|ProcRecord
name|image_get_name_proc
init|=
block|{
literal|"gimp-image-get-name"
block|,
literal|"gimp-image-get-name"
block|,
literal|"Returns the specified image's name."
block|,
literal|"This procedure returns the specified image's name."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_name_inargs
block|,
literal|1
block|,
name|image_get_name_outargs
block|,
block|{
block|{
name|image_get_name_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_resolution_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_resolution_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_resolution_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_resolution_inargs
specifier|static
name|ProcArg
name|image_get_resolution_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_outargs
specifier|static
name|ProcArg
name|image_get_resolution_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"xresolution"
block|,
literal|"The resolutionin the x-axis, in dots per inch"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"yresolution"
block|,
literal|"The resolutionin the y-axis, in dots per inch"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_proc
specifier|static
name|ProcRecord
name|image_get_resolution_proc
init|=
block|{
literal|"gimp-image-get-resolution"
block|,
literal|"gimp-image-get-resolution"
block|,
literal|"Returns the specified image's resolution."
block|,
literal|"This procedure returns the specified image's resolution in dots per inch. This value is independent of any of the layers in this image."
block|,
literal|"Austin Donnelly"
block|,
literal|"Austin Donnelly"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_resolution_inargs
block|,
literal|2
block|,
name|image_get_resolution_outargs
block|,
block|{
block|{
name|image_get_resolution_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_resolution_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_resolution_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gdouble
name|xresolution
decl_stmt|;
name|gdouble
name|yresolution
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|xresolution
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|yresolution
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|FINITE
argument_list|(
name|xresolution
argument_list|)
operator|||
name|xresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xresolution
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
operator|!
name|FINITE
argument_list|(
name|yresolution
argument_list|)
operator|||
name|yresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yresolution
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Image resolution is out of bounds, "
literal|"using the default resolution instead."
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_set_resolution
argument_list|(
name|gimage
argument_list|,
name|xresolution
argument_list|,
name|yresolution
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_resolution_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_resolution_inargs
specifier|static
name|ProcArg
name|image_set_resolution_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"xresolution"
block|,
literal|"The new image resolution (xresolution)in the x-axis, in dots per inch"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"yresolution"
block|,
literal|"The new image resolution (yresolution)in the y-axis, in dots per inch"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_resolution_proc
specifier|static
name|ProcRecord
name|image_set_resolution_proc
init|=
block|{
literal|"gimp-image-set-resolution"
block|,
literal|"gimp-image-set-resolution"
block|,
literal|"Sets the specified image's resolution."
block|,
literal|"This procedure sets the specified image's resolution in dots per inch. This value is independent of any of the layers in this image. No scaling or resizing is performed."
block|,
literal|"Austin Donnelly"
block|,
literal|"Austin Donnelly"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|image_set_resolution_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_resolution_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_unit_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_unit_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_unit_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_unit
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_unit_inargs
specifier|static
name|ProcArg
name|image_get_unit_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_outargs
specifier|static
name|ProcArg
name|image_get_unit_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"unit"
block|,
literal|"The unit"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_proc
specifier|static
name|ProcRecord
name|image_get_unit_proc
init|=
block|{
literal|"gimp-image-get-unit"
block|,
literal|"gimp-image-get-unit"
block|,
literal|"Returns the specified image's unit."
block|,
literal|"This procedure returns the specified image's unit. This value is independent of any of the layers in this image. See the gimp_unit_* procedure definitions for the valid range of unit IDs and a description of the unit system."
block|,
literal|"Michael Natterer"
block|,
literal|"Michael Natterer"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_unit_inargs
block|,
literal|1
block|,
name|image_get_unit_outargs
block|,
block|{
block|{
name|image_get_unit_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_unit_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_unit_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpUnit
name|unit
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|unit
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|unit
operator|<
name|GIMP_UNIT_INCH
operator|||
name|unit
operator|>=
name|_gimp_unit_get_number_of_units
argument_list|(
name|gimp
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_unit
argument_list|(
name|gimage
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_unit_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_unit_inargs
specifier|static
name|ProcArg
name|image_set_unit_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"unit"
block|,
literal|"The new image unit"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_unit_proc
specifier|static
name|ProcRecord
name|image_set_unit_proc
init|=
block|{
literal|"gimp-image-set-unit"
block|,
literal|"gimp-image-set-unit"
block|,
literal|"Sets the specified image's unit."
block|,
literal|"This procedure sets the specified image's unit. No scaling or resizing is performed. This value is independent of any of the layers in this image. See the gimp_unit_* procedure definitions for the valid range of unit IDs and a description of the unit system."
block|,
literal|"Michael Natterer"
block|,
literal|"Michael Natterer"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_set_unit_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_unit_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_tattoo_state_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_tattoo_state_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_tattoo_state_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_image_get_tattoo_state
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_tattoo_state_inargs
specifier|static
name|ProcArg
name|image_get_tattoo_state_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_tattoo_state_outargs
specifier|static
name|ProcArg
name|image_get_tattoo_state_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo-state"
block|,
literal|"The tattoo_state"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_tattoo_state_proc
specifier|static
name|ProcRecord
name|image_get_tattoo_state_proc
init|=
block|{
literal|"gimp-image-get-tattoo-state"
block|,
literal|"gimp-image-get-tattoo-state"
block|,
literal|"Returns the tattoo state associated with the image."
block|,
literal|"This procedure returns the tattoo state of the image. Use only by save/load plugins that wish to preserve an images tattoo state. Using this function at other times will produce unexpected results."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"2000"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|image_get_tattoo_state_inargs
block|,
literal|1
block|,
name|image_get_tattoo_state_outargs
block|,
block|{
block|{
name|image_get_tattoo_state_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_tattoo_state_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_set_tattoo_state_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo_state
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo_state
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimp_image_set_tattoo_state
argument_list|(
name|gimage
argument_list|,
name|tattoo_state
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_tattoo_state_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_tattoo_state_inargs
specifier|static
name|ProcArg
name|image_set_tattoo_state_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo-state"
block|,
literal|"The new image tattoo_state"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_tattoo_state_proc
specifier|static
name|ProcRecord
name|image_set_tattoo_state_proc
init|=
block|{
literal|"gimp-image-set-tattoo-state"
block|,
literal|"gimp-image-set-tattoo-state"
block|,
literal|"Set the tattoo state associated with the image."
block|,
literal|"This procedure sets the tattoo state of the image. Use only by save/load plugins that wish to preserve an images tattoo state. Using this function at other times will produce unexpected results. A full check of uniqueness of states in layers, channels and paths will be performed by this procedure and a execution failure will be returned if this fails. A failure will also be returned if the new tattoo state value is less than the maximum tattoo value from all of the tattoos from the paths, layers and channels. After the image data has been loaded and all the tattoos have been set then this is the last procedure that should be called. If effectively does a status check on the tattoo values that have been set to make sure that all is OK."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"2000"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_set_tattoo_state_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_tattoo_state_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_layer_by_tattoo_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_layer_by_tattoo_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|tattoo
operator|==
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_image_get_layer_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_layer_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_inargs
specifier|static
name|ProcArg
name|image_get_layer_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the layer to find"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_outargs
specifier|static
name|ProcArg
name|image_get_layer_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_layer_by_tattoo_proc
init|=
block|{
literal|"gimp-image-get-layer-by-tattoo"
block|,
literal|"gimp-image-get-layer-by-tattoo"
block|,
literal|"Find a layer with a given tattoo in an image."
block|,
literal|"This procedure returns the layer with the given tattoo in the specified image."
block|,
literal|"Jay Cox"
block|,
literal|"Jay Cox"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_get_layer_by_tattoo_inargs
block|,
literal|1
block|,
name|image_get_layer_by_tattoo_outargs
block|,
block|{
block|{
name|image_get_layer_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_channel_by_tattoo_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|image_get_channel_by_tattoo_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|tattoo
operator|==
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|channel
operator|=
name|gimp_image_get_channel_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
name|success
operator|=
name|channel
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_channel_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_inargs
specifier|static
name|ProcArg
name|image_get_channel_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the channel to find"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_outargs
specifier|static
name|ProcArg
name|image_get_channel_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_channel_by_tattoo_proc
init|=
block|{
literal|"gimp-image-get-channel-by-tattoo"
block|,
literal|"gimp-image-get-channel-by-tattoo"
block|,
literal|"Find a channel with a given tattoo in an image."
block|,
literal|"This procedure returns the channel with the given tattoo in the specified image."
block|,
literal|"Jay Cox"
block|,
literal|"Jay Cox"
block|,
literal|"1998"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|image_get_channel_by_tattoo_inargs
block|,
literal|1
block|,
name|image_get_channel_by_tattoo_outargs
block|,
block|{
block|{
name|image_get_channel_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

