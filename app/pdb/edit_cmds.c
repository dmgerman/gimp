begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"pdb-types.h"
end_include

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp-edit.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable-blend.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable-bucket-fill.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpstrokedesc.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_decl_stmt
DECL|variable|edit_cut_proc
specifier|static
name|ProcRecord
name|edit_cut_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_copy_proc
specifier|static
name|ProcRecord
name|edit_copy_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_paste_proc
specifier|static
name|ProcRecord
name|edit_paste_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_clear_proc
specifier|static
name|ProcRecord
name|edit_clear_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_fill_proc
specifier|static
name|ProcRecord
name|edit_fill_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_bucket_fill_proc
specifier|static
name|ProcRecord
name|edit_bucket_fill_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_blend_proc
specifier|static
name|ProcRecord
name|edit_blend_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_stroke_proc
specifier|static
name|ProcRecord
name|edit_stroke_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_edit_procs (Gimp * gimp)
name|register_edit_procs
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_cut_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_copy_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_paste_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_clear_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_fill_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_bucket_fill_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_blend_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|edit_stroke_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_cut_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_cut_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|non_empty
init|=
name|FALSE
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|non_empty
operator|=
name|gimp_edit_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_cut_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|non_empty
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_cut_inargs
specifier|static
name|ProcArg
name|edit_cut_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to cut from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_cut_outargs
specifier|static
name|ProcArg
name|edit_cut_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"non_empty"
block|,
literal|"TRUE if the cut was successful, FALSE if the selection contained only transparent pixels"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_cut_proc
specifier|static
name|ProcRecord
name|edit_cut_proc
init|=
block|{
literal|"gimp_edit_cut"
block|,
literal|"Cut from the specified drawable."
block|,
literal|"If there is a selection in the image, then the area specified by the selection is cut from the specified drawable and placed in an internal GIMP edit buffer. It can subsequently be retrieved using the 'gimp-edit-paste' command. If there is no selection, then the specified drawable will be removed and its contents stored in the internal GIMP edit buffer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|edit_cut_inargs
block|,
literal|1
block|,
name|edit_cut_outargs
block|,
block|{
block|{
name|edit_cut_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_copy_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_copy_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|non_empty
init|=
name|FALSE
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|non_empty
operator|=
name|gimp_edit_copy
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_copy_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|non_empty
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_copy_inargs
specifier|static
name|ProcArg
name|edit_copy_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to copy from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_copy_outargs
specifier|static
name|ProcArg
name|edit_copy_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"non_empty"
block|,
literal|"TRUE if the copy was successful, FALSE if the selection contained only transparent pixels"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_copy_proc
specifier|static
name|ProcRecord
name|edit_copy_proc
init|=
block|{
literal|"gimp_edit_copy"
block|,
literal|"Copy from the specified drawable."
block|,
literal|"If there is a selection in the image, then the area specified by the selection is copied from the specified drawable and placed in an internal GIMP edit buffer. It can subsequently be retrieved using the 'gimp-edit-paste' command. If there is no selection, then the specified drawable's contents will be stored in the internal GIMP edit buffer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|edit_copy_inargs
block|,
literal|1
block|,
name|edit_copy_outargs
block|,
block|{
block|{
name|edit_copy_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_paste_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_paste_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|paste_into
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|paste_into
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
operator|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|&&
name|gimp
operator|->
name|global_buffer
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_edit_paste
argument_list|(
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|gimp
operator|->
name|global_buffer
argument_list|,
name|paste_into
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_paste_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimp_item_get_ID
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_paste_inargs
specifier|static
name|ProcArg
name|edit_paste_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to paste to"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"paste_into"
block|,
literal|"Clear selection, or paste behind it?"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_paste_outargs
specifier|static
name|ProcArg
name|edit_paste_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_LAYER
block|,
literal|"floating_sel"
block|,
literal|"The new floating selection"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_paste_proc
specifier|static
name|ProcRecord
name|edit_paste_proc
init|=
block|{
literal|"gimp_edit_paste"
block|,
literal|"Paste buffer to the specified drawable."
block|,
literal|"This procedure pastes a copy of the internal GIMP edit buffer to the specified drawable. The GIMP edit buffer will be empty unless a call was previously made to either 'gimp-edit-cut' or 'gimp-edit-copy'. The \"paste_into\" option specifies whether to clear the current image selection, or to paste the buffer \"behind\" the selection. This allows the selection to act as a mask for the pasted buffer. Anywhere that the selection mask is non-zero, the pasted buffer will show through. The pasted buffer will be a new layer in the image which is designated as the image floating selection. If the image has a floating selection at the time of pasting, the old floating selection will be anchored to it's drawable before the new floating selection is added. This procedure returns the new floating layer. The resulting floating selection will already be attached to the specified drawable, and a subsequent call to floating_sel_attach is not needed."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|edit_paste_inargs
block|,
literal|1
block|,
name|edit_paste_outargs
block|,
block|{
block|{
name|edit_paste_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_clear_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_clear_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|success
operator|=
name|gimp_edit_clear
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_clear_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_clear_inargs
specifier|static
name|ProcArg
name|edit_clear_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to clear from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_clear_proc
specifier|static
name|ProcRecord
name|edit_clear_proc
init|=
block|{
literal|"gimp_edit_clear"
block|,
literal|"Clear selected area of drawable."
block|,
literal|"This procedure clears the specified drawable. If the drawable has an alpha channel, the cleared pixels will become transparent. If the drawable does not have an alpha channel, cleared pixels will be set to the background color. This procedure only affects regions within a selection if there is a selection active."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|edit_clear_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|edit_clear_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_fill_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_fill_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|fill_type
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|fill_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|fill_type
operator|<
name|GIMP_FOREGROUND_FILL
operator|||
name|fill_type
operator|>
name|GIMP_PATTERN_FILL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|success
operator|=
name|gimp_edit_fill
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
operator|(
name|GimpFillType
operator|)
name|fill_type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_fill_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_fill_inargs
specifier|static
name|ProcArg
name|edit_fill_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to fill to"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"fill_type"
block|,
literal|"The type of fill: GIMP_FOREGROUND_FILL (0), GIMP_BACKGROUND_FILL (1), GIMP_WHITE_FILL (2), GIMP_TRANSPARENT_FILL (3), GIMP_PATTERN_FILL (4)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_fill_proc
specifier|static
name|ProcRecord
name|edit_fill_proc
init|=
block|{
literal|"gimp_edit_fill"
block|,
literal|"Fill selected area of drawable."
block|,
literal|"This procedure fills the specified drawable with the fill mode. If the fill mode is foreground, the current foreground color is used. If the fill mode is background, the current background color is used. Other fill modes should not be used. This procedure only affects regions within a selection if there is a selection active. If you want to fill the whole drawable, regardless of the selection, use gimp_drawable_fill()."
block|,
literal|"Spencer Kimball& Peter Mattis& Raphael Quinet"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-2000"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|edit_fill_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|edit_fill_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_bucket_fill_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_bucket_fill_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|fill_mode
decl_stmt|;
name|gint32
name|paint_mode
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|gdouble
name|threshold
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|fill_mode
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|fill_mode
operator|<
name|GIMP_FG_BUCKET_FILL
operator|||
name|fill_mode
operator|>
name|GIMP_PATTERN_BUCKET_FILL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|paint_mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|paint_mode
operator|<
name|GIMP_NORMAL_MODE
operator|||
name|paint_mode
operator|>
name|GIMP_COLOR_ERASE_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|0.0
operator|||
name|threshold
operator|>
literal|255.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gboolean
name|do_seed_fill
decl_stmt|;
name|do_seed_fill
operator|=
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_drawable_bucket_fill
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|fill_mode
argument_list|,
name|paint_mode
argument_list|,
name|opacity
operator|/
literal|100.0
argument_list|,
name|do_seed_fill
argument_list|,
name|FALSE
comment|/* don't fill transparent */
argument_list|,
name|threshold
argument_list|,
name|sample_merged
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_bucket_fill_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_bucket_fill_inargs
specifier|static
name|ProcArg
name|edit_bucket_fill_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"fill_mode"
block|,
literal|"The type of fill: { GIMP_FG_BUCKET_FILL (0), GIMP_BG_BUCKET_FILL (1), GIMP_PATTERN_BUCKET_FILL (2) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"paint_mode"
block|,
literal|"The paint application mode: { GIMP_NORMAL_MODE (0), GIMP_DISSOLVE_MODE (1), GIMP_BEHIND_MODE (2), GIMP_MULTIPLY_MODE (3), GIMP_SCREEN_MODE (4), GIMP_OVERLAY_MODE (5), GIMP_DIFFERENCE_MODE (6), GIMP_ADDITION_MODE (7), GIMP_SUBTRACT_MODE (8), GIMP_DARKEN_ONLY_MODE (9), GIMP_LIGHTEN_ONLY_MODE (10), GIMP_HUE_MODE (11), GIMP_SATURATION_MODE (12), GIMP_COLOR_MODE (13), GIMP_VALUE_MODE (14), GIMP_DIVIDE_MODE (15), GIMP_DODGE_MODE (16), GIMP_BURN_MODE (17), GIMP_HARDLIGHT_MODE (18), GIMP_SOFTLIGHT_MODE (19), GIMP_GRAIN_EXTRACT_MODE (20), GIMP_GRAIN_MERGE_MODE (21), GIMP_COLOR_ERASE_MODE (22) }"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the final bucket fill (0<= opacity<= 100)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"threshold"
block|,
literal|"The threshold determines how extensive the seed fill will be. It's value is specified in terms of intensity levels (0<= threshold<= 255). This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"x"
block|,
literal|"The x coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"y"
block|,
literal|"The y coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_bucket_fill_proc
specifier|static
name|ProcRecord
name|edit_bucket_fill_proc
init|=
block|{
literal|"gimp_edit_bucket_fill"
block|,
literal|"Fill the area specified either by the current selection if there is one, or by a seed fill starting at the specified coordinates."
block|,
literal|"This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern. If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter. If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of merged sampling, the x and y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|8
block|,
name|edit_bucket_fill_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|edit_bucket_fill_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_blend_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_blend_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|blend_mode
decl_stmt|;
name|gint32
name|paint_mode
decl_stmt|;
name|gint32
name|gradient_type
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|gdouble
name|offset
decl_stmt|;
name|gint32
name|repeat
decl_stmt|;
name|gboolean
name|reverse
decl_stmt|;
name|gboolean
name|supersample
decl_stmt|;
name|gint32
name|max_depth
decl_stmt|;
name|gdouble
name|threshold
decl_stmt|;
name|gboolean
name|dither
decl_stmt|;
name|gdouble
name|x1
decl_stmt|;
name|gdouble
name|y1
decl_stmt|;
name|gdouble
name|x2
decl_stmt|;
name|gdouble
name|y2
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|blend_mode
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|blend_mode
operator|<
name|GIMP_FG_BG_RGB_MODE
operator|||
name|blend_mode
operator|>
name|GIMP_CUSTOM_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|paint_mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|paint_mode
operator|<
name|GIMP_NORMAL_MODE
operator|||
name|paint_mode
operator|>
name|GIMP_COLOR_ERASE_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|gradient_type
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|gradient_type
operator|<
name|GIMP_GRADIENT_LINEAR
operator|||
name|gradient_type
operator|>
name|GIMP_GRADIENT_SPIRAL_ANTICLOCKWISE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offset
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|repeat
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|repeat
operator|<
name|GIMP_REPEAT_NONE
operator|||
name|repeat
operator|>
name|GIMP_REPEAT_TRIANGULAR
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|reverse
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|supersample
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|max_depth
operator|=
name|args
index|[
literal|9
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|supersample
operator|&&
operator|(
name|max_depth
operator|<
literal|1
operator|||
name|max_depth
operator|>
literal|9
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|10
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|supersample
operator|&&
operator|(
name|threshold
operator|<
literal|0.0
operator|||
name|threshold
operator|>
literal|4.0
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|dither
operator|=
name|args
index|[
literal|11
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|x1
operator|=
name|args
index|[
literal|12
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y1
operator|=
name|args
index|[
literal|13
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|x2
operator|=
name|args
index|[
literal|14
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y2
operator|=
name|args
index|[
literal|15
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|progress
condition|)
name|gimp_progress_start
argument_list|(
name|progress
argument_list|,
name|_
argument_list|(
literal|"Blending..."
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_drawable_blend
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|blend_mode
argument_list|,
name|paint_mode
argument_list|,
name|gradient_type
argument_list|,
name|opacity
operator|/
literal|100.0
argument_list|,
name|offset
argument_list|,
name|repeat
argument_list|,
name|reverse
argument_list|,
name|supersample
argument_list|,
name|max_depth
argument_list|,
name|threshold
argument_list|,
name|dither
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress
condition|)
name|gimp_progress_end
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_blend_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_blend_inargs
specifier|static
name|ProcArg
name|edit_blend_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"blend_mode"
block|,
literal|"The type of blend: { GIMP_FG_BG_RGB_MODE (0), GIMP_FG_BG_HSV_MODE (1), GIMP_FG_TRANSPARENT_MODE (2), GIMP_CUSTOM_MODE (3) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"paint_mode"
block|,
literal|"The paint application mode: { GIMP_NORMAL_MODE (0), GIMP_DISSOLVE_MODE (1), GIMP_BEHIND_MODE (2), GIMP_MULTIPLY_MODE (3), GIMP_SCREEN_MODE (4), GIMP_OVERLAY_MODE (5), GIMP_DIFFERENCE_MODE (6), GIMP_ADDITION_MODE (7), GIMP_SUBTRACT_MODE (8), GIMP_DARKEN_ONLY_MODE (9), GIMP_LIGHTEN_ONLY_MODE (10), GIMP_HUE_MODE (11), GIMP_SATURATION_MODE (12), GIMP_COLOR_MODE (13), GIMP_VALUE_MODE (14), GIMP_DIVIDE_MODE (15), GIMP_DODGE_MODE (16), GIMP_BURN_MODE (17), GIMP_HARDLIGHT_MODE (18), GIMP_SOFTLIGHT_MODE (19), GIMP_GRAIN_EXTRACT_MODE (20), GIMP_GRAIN_MERGE_MODE (21), GIMP_COLOR_ERASE_MODE (22) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"gradient_type"
block|,
literal|"The type of gradient: { GIMP_GRADIENT_LINEAR (0), GIMP_GRADIENT_BILINEAR (1), GIMP_GRADIENT_RADIAL (2), GIMP_GRADIENT_SQUARE (3), GIMP_GRADIENT_CONICAL_SYMMETRIC (4), GIMP_GRADIENT_CONICAL_ASYMMETRIC (5), GIMP_GRADIENT_SHAPEBURST_ANGULAR (6), GIMP_GRADIENT_SHAPEBURST_SPHERICAL (7), GIMP_GRADIENT_SHAPEBURST_DIMPLED (8), GIMP_GRADIENT_SPIRAL_CLOCKWISE (9), GIMP_GRADIENT_SPIRAL_ANTICLOCKWISE (10) }"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the final blend (0<= opacity<= 100)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"offset"
block|,
literal|"Offset relates to the starting and ending coordinates specified for the blend. This parameter is mode dependent (0<= offset)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"repeat"
block|,
literal|"Repeat mode: { GIMP_REPEAT_NONE (0), GIMP_REPEAT_SAWTOOTH (1), GIMP_REPEAT_TRIANGULAR (2) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"reverse"
block|,
literal|"Use the reverse gradient (TRUE or FALSE)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"supersample"
block|,
literal|"Do adaptive supersampling (TRUE or FALSE)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"max_depth"
block|,
literal|"Maximum recursion levels for supersampling"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"threshold"
block|,
literal|"Supersampling threshold"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"dither"
block|,
literal|"Use dithering to reduce banding (TRUE or FALSE)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"x1"
block|,
literal|"The x coordinate of this blend's starting point"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"y1"
block|,
literal|"The y coordinate of this blend's starting point"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"x2"
block|,
literal|"The x coordinate of this blend's ending point"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"y2"
block|,
literal|"The y coordinate of this blend's ending point"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_blend_proc
specifier|static
name|ProcRecord
name|edit_blend_proc
init|=
block|{
literal|"gimp_edit_blend"
block|,
literal|"Blend between the starting and ending coordinates with the specified blend mode and gradient type."
block|,
literal|"This tool requires information on the paint application mode, the blend mode, and the gradient type. It creates the specified variety of blend using the starting and ending coordinates as defined for each gradient type."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|16
block|,
name|edit_blend_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|edit_blend_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|edit_stroke_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|edit_stroke_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
operator|(
name|GimpDrawable
operator|*
operator|)
name|gimp_item_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|!
name|gimp_item_is_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|GimpStrokeDesc
modifier|*
name|desc
init|=
name|gimp_stroke_desc_new
argument_list|(
name|gimp
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|g_object_set
argument_list|(
name|desc
argument_list|,
literal|"method"
argument_list|,
name|GIMP_STROKE_METHOD_PAINT_CORE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|success
operator|=
name|gimp_item_stroke
argument_list|(
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|desc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|edit_stroke_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|edit_stroke_inargs
specifier|static
name|ProcArg
name|edit_stroke_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable to stroke to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|edit_stroke_proc
specifier|static
name|ProcRecord
name|edit_stroke_proc
init|=
block|{
literal|"gimp_edit_stroke"
block|,
literal|"Stroke the current selection"
block|,
literal|"This procedure strokes the current selection, painting along the selection boundary with the active brush and foreground color. The paint is applied to the specified drawable regardless of the active selection."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|NULL
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|edit_stroke_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|edit_stroke_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

