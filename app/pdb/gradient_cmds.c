begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"pdb-types.h"
end_include

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontainer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdatafactory.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpgradient.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplist.h"
end_include

begin_decl_stmt
DECL|variable|gradient_new_proc
specifier|static
name|ProcRecord
name|gradient_new_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_duplicate_proc
specifier|static
name|ProcRecord
name|gradient_duplicate_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_rename_proc
specifier|static
name|ProcRecord
name|gradient_rename_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_delete_proc
specifier|static
name|ProcRecord
name|gradient_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_left_color_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_left_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_left_color_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_right_color_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_right_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_right_color_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_left_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_left_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_left_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_middle_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_middle_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_middle_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_middle_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_right_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_right_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_right_pos_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_blending_function_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_blending_function_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_coloring_type_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_coloring_type_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_set_blending_function_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_set_blending_function_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_set_coloring_type_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_set_coloring_type_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_flip_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_flip_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_replicate_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_replicate_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_split_midpoint_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_split_midpoint_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_split_uniform_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_split_uniform_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_delete_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_redistribute_handles_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_redistribute_handles_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_colors_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_blend_colors_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_opacity_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_blend_opacity_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_move_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_move_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_gradient_procs (Gimp * gimp)
name|register_gradient_procs
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_new_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_duplicate_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_rename_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_left_color_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_set_left_color_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_right_color_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_set_right_color_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_left_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_set_left_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_middle_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_set_middle_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_right_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_set_right_pos_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_blending_function_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_get_coloring_type_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_set_blending_function_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_set_coloring_type_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_flip_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_replicate_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_split_midpoint_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_split_uniform_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_redistribute_handles_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_blend_colors_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_blend_opacity_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|gradient_segment_range_move_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_new_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_new_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpData
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
name|data
operator|=
name|gimp_data_factory_data_new
argument_list|(
name|gimp
operator|->
name|gradient_factory
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|data
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_new_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|data
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_new_inargs
specifier|static
name|ProcArg
name|gradient_new_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The requested name of the new gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_new_outargs
specifier|static
name|ProcArg
name|gradient_new_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The actual new gradient name"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_new_proc
specifier|static
name|ProcRecord
name|gradient_new_proc
init|=
block|{
literal|"gimp_gradient_new"
block|,
literal|"Creates a new gradient"
block|,
literal|"This procedure creates a new, uninitialized gradient"
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|gradient_new_inargs
block|,
literal|1
block|,
name|gradient_new_outargs
block|,
block|{
block|{
name|gradient_new_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_duplicate_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_duplicate_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient_copy
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|gradient_copy
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_data_factory_data_duplicate
argument_list|(
name|gimp
operator|->
name|gradient_factory
argument_list|,
name|GIMP_DATA
argument_list|(
name|gradient
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|gradient_copy
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_duplicate_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gradient_copy
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_duplicate_inargs
specifier|static
name|ProcArg
name|gradient_duplicate_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_duplicate_outargs
specifier|static
name|ProcArg
name|gradient_duplicate_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The name of the gradient's copy"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_duplicate_proc
specifier|static
name|ProcRecord
name|gradient_duplicate_proc
init|=
block|{
literal|"gimp_gradient_duplicate"
block|,
literal|"Duplicates a gradient"
block|,
literal|"This procedure creates an identical gradient by a different name"
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|gradient_duplicate_inargs
block|,
literal|1
block|,
name|gradient_duplicate_outargs
block|,
block|{
block|{
name|gradient_duplicate_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_rename_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_rename_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gchar
modifier|*
name|new_name
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
operator|||
operator|!
name|g_utf8_validate
argument_list|(
name|new_name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
operator|&&
name|GIMP_DATA
argument_list|(
name|gradient
argument_list|)
operator|->
name|writable
condition|)
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gradient
argument_list|)
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_rename_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gradient
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_rename_inargs
specifier|static
name|ProcArg
name|gradient_rename_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"new_name"
block|,
literal|"The new name of the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_rename_outargs
specifier|static
name|ProcArg
name|gradient_rename_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The actual new name of the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_rename_proc
specifier|static
name|ProcRecord
name|gradient_rename_proc
init|=
block|{
literal|"gimp_gradient_rename"
block|,
literal|"Rename a gradient"
block|,
literal|"This procedure renames a gradient"
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_rename_inargs
block|,
literal|1
block|,
name|gradient_rename_outargs
block|,
block|{
block|{
name|gradient_rename_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_delete_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_delete_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
operator|&&
name|GIMP_DATA
argument_list|(
name|gradient
argument_list|)
operator|->
name|deletable
condition|)
block|{
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|success
operator|=
name|gimp_data_factory_data_delete
argument_list|(
name|gimp
operator|->
name|gradient_factory
argument_list|,
name|GIMP_DATA
argument_list|(
name|gradient
argument_list|)
argument_list|,
name|TRUE
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|g_message
argument_list|(
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_delete_inargs
specifier|static
name|ProcArg
name|gradient_delete_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_delete_proc
specifier|static
name|ProcRecord
name|gradient_delete_proc
init|=
block|{
literal|"gimp_gradient_delete"
block|,
literal|"Deletes a gradient"
block|,
literal|"This procedure deletes a gradient"
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|gradient_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_left_color_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_left_color_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gdouble
name|opacity
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_gradient_segment_get_left_color
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|opacity
operator|=
name|color
operator|.
name|a
operator|*
literal|100.0
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_left_color_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_color
operator|=
name|color
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|opacity
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_left_color_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_left_color_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_color_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_left_color_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_COLOR
block|,
literal|"color"
block|,
literal|"The return color"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the endpoint"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_left_color_proc
init|=
block|{
literal|"gimp_gradient_segment_get_left_color"
block|,
literal|"Retrieves the left endpoint color of the specified gradient and segment"
block|,
literal|"This procedure retrieves the left endpoint color of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_left_color_inargs
block|,
literal|2
block|,
name|gradient_segment_get_left_color_outargs
block|,
block|{
block|{
name|gradient_segment_get_left_color_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_set_left_color_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_set_left_color_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|color
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_color
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|color
operator|.
name|a
operator|=
name|opacity
operator|/
literal|100.0
expr_stmt|;
name|gimp_gradient_segment_set_left_color
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_set_left_color_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_set_left_color_inargs
specifier|static
name|ProcArg
name|gradient_segment_set_left_color_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|,
block|{
name|GIMP_PDB_COLOR
block|,
literal|"color"
block|,
literal|"The color to set"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity to set for the endpoint"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_left_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_left_color_proc
init|=
block|{
literal|"gimp_gradient_segment_set_left_color"
block|,
literal|"Retrieves the left endpoint color of the specified gradient and segment"
block|,
literal|"This procedure retrieves the left endpoint color of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_set_left_color_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_set_left_color_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_right_color_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_right_color_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gdouble
name|opacity
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_gradient_segment_get_right_color
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|opacity
operator|=
name|color
operator|.
name|a
operator|*
literal|100.0
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_right_color_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_color
operator|=
name|color
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|opacity
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_right_color_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_right_color_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_color_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_right_color_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_COLOR
block|,
literal|"color"
block|,
literal|"The return color"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the endpoint"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_right_color_proc
init|=
block|{
literal|"gimp_gradient_segment_get_right_color"
block|,
literal|"Retrieves the right endpoint color of the specified gradient and segment"
block|,
literal|"This procedure retrieves the right endpoint color of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_right_color_inargs
block|,
literal|2
block|,
name|gradient_segment_get_right_color_outargs
block|,
block|{
block|{
name|gradient_segment_get_right_color_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_set_right_color_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_set_right_color_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|color
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_color
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|color
operator|.
name|a
operator|=
name|opacity
operator|/
literal|100.0
expr_stmt|;
name|gimp_gradient_segment_set_right_color
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_set_right_color_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_set_right_color_inargs
specifier|static
name|ProcArg
name|gradient_segment_set_right_color_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|,
block|{
name|GIMP_PDB_COLOR
block|,
literal|"color"
block|,
literal|"The color to set"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity to set for the endpoint"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_right_color_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_right_color_proc
init|=
block|{
literal|"gimp_gradient_segment_set_right_color"
block|,
literal|"Retrieves the right endpoint color of the specified gradient and segment"
block|,
literal|"This procedure retrieves the right endpoint color of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_set_right_color_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_set_right_color_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_left_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_left_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|pos
operator|=
name|gimp_gradient_segment_get_left_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_left_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_left_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_left_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_left_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_left_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_left_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_get_left_pos"
block|,
literal|"Retrieves the left endpoint position of the specified gradient and segment"
block|,
literal|"This procedure retrieves the left endpoint position of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_left_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_get_left_pos_outargs
block|,
block|{
block|{
name|gradient_segment_get_left_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_set_left_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_set_left_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
decl_stmt|;
name|gdouble
name|final_pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pos
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0.0
operator|||
name|pos
operator|>
literal|1.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|final_pos
operator|=
name|gimp_gradient_segment_set_left_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_set_left_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|final_pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_set_left_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_set_left_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The position to set the guidepoint in."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_left_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_set_left_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"final_pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_left_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_left_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_set_left_pos"
block|,
literal|"Sets the left endpoint position of the specified gradient and segment"
block|,
literal|"This procedure sets the left endpoint position of the specified segment of the specified gradient. The final position will be between the position of the middle point to the left to the middle point of the current segement. This procedure returns the final position."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_set_left_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_set_left_pos_outargs
block|,
block|{
block|{
name|gradient_segment_set_left_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_middle_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_middle_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|pos
operator|=
name|gimp_gradient_segment_get_middle_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_middle_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_middle_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_middle_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_middle_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_middle_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_middle_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_middle_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_get_middle_pos"
block|,
literal|"Retrieves the middle point position of the specified gradient and segment"
block|,
literal|"This procedure retrieves the middle point position of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_middle_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_get_middle_pos_outargs
block|,
block|{
block|{
name|gradient_segment_get_middle_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_set_middle_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_set_middle_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
decl_stmt|;
name|gdouble
name|final_pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pos
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0.0
operator|||
name|pos
operator|>
literal|1.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|final_pos
operator|=
name|gimp_gradient_segment_set_middle_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_set_middle_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|final_pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_set_middle_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_set_middle_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The position to set the guidepoint in."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_middle_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_set_middle_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"final_pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_middle_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_middle_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_set_middle_pos"
block|,
literal|"Sets the middle point position of the specified gradient and segment"
block|,
literal|"This procedure sets the middle point position of the specified segment of the specified gradient. The final position will be between the two endpoints of the segment. This procedure returns the final position."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_set_middle_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_set_middle_pos_outargs
block|,
block|{
block|{
name|gradient_segment_set_middle_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_right_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_right_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|pos
operator|=
name|gimp_gradient_segment_get_right_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_right_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_right_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_right_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_right_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_right_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_right_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_get_right_pos"
block|,
literal|"Retrieves the right endpoint position of the specified gradient and segment"
block|,
literal|"This procedure retrieves the right endpoint position of the specified segment of the specified gradient."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_right_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_get_right_pos_outargs
block|,
block|{
block|{
name|gradient_segment_get_right_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_set_right_pos_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_set_right_pos_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gdouble
name|pos
decl_stmt|;
name|gdouble
name|final_pos
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pos
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0.0
operator|||
name|pos
operator|>
literal|1.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|final_pos
operator|=
name|gimp_gradient_segment_set_right_pos
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_set_right_pos_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|final_pos
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_set_right_pos_inargs
specifier|static
name|ProcArg
name|gradient_segment_set_right_pos_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"pos"
block|,
literal|"The position to set the guidepoint in."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_right_pos_outargs
specifier|static
name|ProcArg
name|gradient_segment_set_right_pos_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"final_pos"
block|,
literal|"The return position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_set_right_pos_proc
specifier|static
name|ProcRecord
name|gradient_segment_set_right_pos_proc
init|=
block|{
literal|"gimp_gradient_segment_set_right_pos"
block|,
literal|"Sets the right endpoint position of the specified gradient and segment"
block|,
literal|"This procedure sets the right endpoint position of the specified segment of the specified gradient. The final position will be between the position of the middle point of the current segment and the middle point of the segment to the right. This procedure returns the final position."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_set_right_pos_inargs
block|,
literal|1
block|,
name|gradient_segment_set_right_pos_outargs
block|,
block|{
block|{
name|gradient_segment_set_right_pos_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_blending_function_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_blending_function_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gint32
name|blend_func
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|blend_func
operator|=
name|gimp_gradient_segment_get_blending_function
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_blending_function_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|blend_func
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_blending_function_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_blending_function_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_blending_function_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_blending_function_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"blend_func"
block|,
literal|"The blending function of the segment: { GIMP_GRADIENT_SEGMENT_LINEAR (0), GIMP_GRADIENT_SEGMENT_CURVED (1), GIMP_GRADIENT_SEGMENT_SINE (2), GIMP_GRADIENT_SEGMENT_SPHERE_INCREASING (3), GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_blending_function_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_blending_function_proc
init|=
block|{
literal|"gimp_gradient_segment_get_blending_function"
block|,
literal|"Retrieves the gradient segment's blending function"
block|,
literal|"This procedure retrieves the blending function of the segment at the specified gradient name and segment index."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_blending_function_inargs
block|,
literal|1
block|,
name|gradient_segment_get_blending_function_outargs
block|,
block|{
block|{
name|gradient_segment_get_blending_function_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_get_coloring_type_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_get_coloring_type_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|segment
decl_stmt|;
name|gint32
name|coloring_type
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
operator|(
name|gradient
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|seg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|coloring_type
operator|=
name|gimp_gradient_segment_get_coloring_type
argument_list|(
name|gradient
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_get_coloring_type_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|coloring_type
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_get_coloring_type_inargs
specifier|static
name|ProcArg
name|gradient_segment_get_coloring_type_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"segment"
block|,
literal|"The index of the segment within the gradient"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_coloring_type_outargs
specifier|static
name|ProcArg
name|gradient_segment_get_coloring_type_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"coloring_type"
block|,
literal|"The coloring type of the segment: { GIMP_GRADIENT_SEGMENT_RGB (0), GIMP_GRADIENT_SEGMENT_HSV_CCW (1), GIMP_GRADIENT_SEGMENT_HSV_CW (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_get_coloring_type_proc
specifier|static
name|ProcRecord
name|gradient_segment_get_coloring_type_proc
init|=
block|{
literal|"gimp_gradient_segment_get_coloring_type"
block|,
literal|"Retrieves the gradient segment's coloring type"
block|,
literal|"This procedure retrieves the coloring type of the segment at the specified gradient name and segment index."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|gradient_segment_get_coloring_type_inargs
block|,
literal|1
block|,
name|gradient_segment_get_coloring_type_outargs
block|,
block|{
block|{
name|gradient_segment_get_coloring_type_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_set_blending_function_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_set_blending_function_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|gint32
name|blending_function
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|blending_function
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|blending_function
operator|<
name|GIMP_GRADIENT_SEGMENT_LINEAR
operator|||
name|blending_function
operator|>
name|GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_set_blending_function
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|blending_function
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_set_blending_function_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_set_blending_function_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_set_blending_function_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"blending_function"
block|,
literal|"The Blending Function: { GIMP_GRADIENT_SEGMENT_LINEAR (0), GIMP_GRADIENT_SEGMENT_CURVED (1), GIMP_GRADIENT_SEGMENT_SINE (2), GIMP_GRADIENT_SEGMENT_SPHERE_INCREASING (3), GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_set_blending_function_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_set_blending_function_proc
init|=
block|{
literal|"gimp_gradient_segment_range_set_blending_function"
block|,
literal|"Change the blending function of a segments range"
block|,
literal|"This function changes the blending function of a segment range to the specified blending function."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_range_set_blending_function_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_set_blending_function_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_set_coloring_type_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_set_coloring_type_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|gint32
name|coloring_type
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|coloring_type
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|coloring_type
operator|<
name|GIMP_GRADIENT_SEGMENT_RGB
operator|||
name|coloring_type
operator|>
name|GIMP_GRADIENT_SEGMENT_HSV_CW
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_set_coloring_type
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|coloring_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_set_coloring_type_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_set_coloring_type_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_set_coloring_type_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"coloring_type"
block|,
literal|"The Coloring Type: { GIMP_GRADIENT_SEGMENT_RGB (0), GIMP_GRADIENT_SEGMENT_HSV_CCW (1), GIMP_GRADIENT_SEGMENT_HSV_CW (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_set_coloring_type_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_set_coloring_type_proc
init|=
block|{
literal|"gimp_gradient_segment_range_set_coloring_type"
block|,
literal|"Change the coloring type of a segments range"
block|,
literal|"This function changes the coloring type of a segment range to the specified coloring type."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_range_set_coloring_type_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_set_coloring_type_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_flip_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_flip_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_flip
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_flip_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_flip_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_flip_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_flip_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_flip_proc
init|=
block|{
literal|"gimp_gradient_segment_range_flip"
block|,
literal|"Flip the segment range"
block|,
literal|"This function flips a segment range."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_flip_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_flip_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_replicate_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_replicate_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|gint32
name|replicate_times
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|replicate_times
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|replicate_times
operator|<
literal|2
operator|||
name|replicate_times
operator|>
literal|20
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_replicate
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|replicate_times
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_replicate_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_replicate_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_replicate_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"replicate_times"
block|,
literal|"The number of times to replicate"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_replicate_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_replicate_proc
init|=
block|{
literal|"gimp_gradient_segment_range_replicate"
block|,
literal|"Replicate the segment range"
block|,
literal|"This function replicates a segment range a given number of times. Instead of the original segment range, several smaller scaled copies of it will appear in equal widths."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_range_replicate_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_replicate_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_split_midpoint_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_split_midpoint_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_split_midpoint
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_split_midpoint_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_split_midpoint_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_split_midpoint_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_split_midpoint_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_split_midpoint_proc
init|=
block|{
literal|"gimp_gradient_segment_range_split_midpoint"
block|,
literal|"Splits each segment in the segment range at midpoint"
block|,
literal|"This function splits each segment in the segment range at its midpoint."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_split_midpoint_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_split_midpoint_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_split_uniform_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_split_uniform_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|gint32
name|split_parts
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|split_parts
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|split_parts
operator|<
literal|2
operator|||
name|split_parts
operator|>
literal|20
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_split_uniform
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|split_parts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_split_uniform_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_split_uniform_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_split_uniform_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"split_parts"
block|,
literal|"The number of uniform divisions to split each segment to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_split_uniform_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_split_uniform_proc
init|=
block|{
literal|"gimp_gradient_segment_range_split_uniform"
block|,
literal|"Splits each segment in the segment range uniformly"
block|,
literal|"This function splits each segment in the segment range uniformly according to the number of times specified by the parameter."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|4
block|,
name|gradient_segment_range_split_uniform_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_split_uniform_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_delete_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_delete_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_delete
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_delete_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_delete_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_delete_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_delete_proc
init|=
block|{
literal|"gimp_gradient_segment_range_delete"
block|,
literal|"Delete the segment range"
block|,
literal|"This function deletes a segment range."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_redistribute_handles_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_redistribute_handles_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_redistribute_handles
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_redistribute_handles_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_redistribute_handles_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_redistribute_handles_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_redistribute_handles_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_redistribute_handles_proc
init|=
block|{
literal|"gimp_gradient_segment_range_redistribute_handles"
block|,
literal|"Uniformly redistribute the segment range's handles"
block|,
literal|"This function redistributes the handles of the specified segment range of the specified gradient, so they'll be evenly spaced."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_redistribute_handles_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_redistribute_handles_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_blend_colors_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_blend_colors_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_blend
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
operator|&
name|start_seg
operator|->
name|left_color
argument_list|,
operator|&
name|end_seg
operator|->
name|right_color
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_blend_colors_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_colors_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_blend_colors_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_colors_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_blend_colors_proc
init|=
block|{
literal|"gimp_gradient_segment_range_blend_colors"
block|,
literal|"Blend the colors of the segment range."
block|,
literal|"This function blends the colors (but not the opacity) of the segments' range of the gradient. Using it, the colors' transition will be uniform across the range."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_blend_colors_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_blend_colors_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_blend_opacity_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_blend_opacity_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|gimp_gradient_segment_range_blend
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
operator|&
name|start_seg
operator|->
name|left_color
argument_list|,
operator|&
name|end_seg
operator|->
name|right_color
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_blend_opacity_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_opacity_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_blend_opacity_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_blend_opacity_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_blend_opacity_proc
init|=
block|{
literal|"gimp_gradient_segment_range_blend_opacity"
block|,
literal|"Blend the opacity of the segment range."
block|,
literal|"This function blends the opacity (but not the colors) of the segments' range of the gradient. Using it, the opacity's transition will be uniform across the range."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|gradient_segment_range_blend_opacity_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|gradient_segment_range_blend_opacity_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gradient_segment_range_move_invoker (Gimp * gimp,GimpContext * context,GimpProgress * progress,Argument * args)
name|gradient_segment_range_move_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|gint32
name|start_segment
decl_stmt|;
name|gint32
name|end_segment
decl_stmt|;
name|gdouble
name|delta
decl_stmt|;
name|gboolean
name|control_compress
decl_stmt|;
name|gdouble
name|final_delta
init|=
literal|0
decl_stmt|;
name|GimpGradient
modifier|*
name|gradient
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|g_utf8_validate
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|start_segment
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|start_segment
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|end_segment
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|delta
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
literal|1.0
operator|||
name|delta
operator|>
literal|1.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|control_compress
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gradient
operator|=
operator|(
name|GimpGradient
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|gradient_factory
operator|->
name|container
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradient
operator|=
name|gimp_context_get_gradient
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gradient
condition|)
block|{
name|GimpGradientSegment
modifier|*
name|start_seg
decl_stmt|,
modifier|*
name|end_seg
decl_stmt|;
name|start_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|gradient
operator|->
name|segments
argument_list|,
name|start_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_seg
condition|)
block|{
if|if
condition|(
operator|(
name|end_segment
operator|<
name|start_segment
operator|)
operator|&&
operator|(
name|end_segment
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Do Nothing */
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_segment
operator|<
literal|0
condition|)
block|{
name|end_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|end_seg
operator|=
name|gimp_gradient_segment_get_nth
argument_list|(
name|start_seg
argument_list|,
name|end_segment
operator|-
name|start_segment
argument_list|)
expr_stmt|;
block|}
comment|/* Success */
name|final_delta
operator|=
name|gimp_gradient_segment_range_move
argument_list|(
name|gradient
argument_list|,
name|start_seg
argument_list|,
name|end_seg
argument_list|,
name|delta
argument_list|,
name|control_compress
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gradient_segment_range_move_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|final_delta
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|gradient_segment_range_move_inargs
specifier|static
name|ProcArg
name|gradient_segment_range_move_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"name"
block|,
literal|"The gradient name (\"\" means currently active gradient)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"start_segment"
block|,
literal|"The index of the first segment to operate on"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"end_segment"
block|,
literal|"The index of the last segment to operate on. If negative, the selection will extend to the end of the string."
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"delta"
block|,
literal|"The delta to move the segment range"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"control_compress"
block|,
literal|"Whether or not to compress the neighboring segments"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_move_outargs
specifier|static
name|ProcArg
name|gradient_segment_range_move_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"final_delta"
block|,
literal|"The final delta by which the range moved"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gradient_segment_range_move_proc
specifier|static
name|ProcRecord
name|gradient_segment_range_move_proc
init|=
block|{
literal|"gimp_gradient_segment_range_move"
block|,
literal|"Move the position of an entire segment range by a delta."
block|,
literal|"This funtions moves the position of an entire segment range by a delta. The actual delta (which is returned) will be limited by the control points of the neighboring segments."
block|,
literal|"Shlomi Fish"
block|,
literal|"Shlomi Fish"
block|,
literal|"2003"
block|,
name|GIMP_INTERNAL
block|,
literal|5
block|,
name|gradient_segment_range_move_inargs
block|,
literal|1
block|,
name|gradient_segment_range_move_outargs
block|,
block|{
block|{
name|gradient_segment_range_move_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

