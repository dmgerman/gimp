begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* NOTE: This file is auto-generated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<cairo.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gdk-pixbuf/gdk-pixbuf.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpconfig/gimpconfig.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"pdb-types.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpcoreconfig.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable-operation.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-crop.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-resize.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-rotate.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpparamspecs.h"
end_include

begin_include
include|#
directive|include
file|"core/gimppickable-auto-shrink.h"
end_include

begin_include
include|#
directive|include
file|"core/gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-babl.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-gegl-utils.h"
end_include

begin_include
include|#
directive|include
file|"gimppdb.h"
end_include

begin_include
include|#
directive|include
file|"gimppdberror.h"
end_include

begin_include
include|#
directive|include
file|"gimppdb-utils.h"
end_include

begin_include
include|#
directive|include
file|"gimpprocedure.h"
end_include

begin_include
include|#
directive|include
file|"internal-procs.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_function
specifier|static
name|GeglNode
modifier|*
DECL|function|wrap_in_selection_bounds (GeglNode * node,GimpDrawable * drawable)
name|wrap_in_selection_bounds
parameter_list|(
name|GeglNode
modifier|*
name|node
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
if|if
condition|(
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|new_node
decl_stmt|;
name|GeglNode
modifier|*
name|input
decl_stmt|;
name|GeglNode
modifier|*
name|output
decl_stmt|;
name|GeglNode
modifier|*
name|translate_before
decl_stmt|;
name|GeglNode
modifier|*
name|crop
decl_stmt|;
name|GeglNode
modifier|*
name|translate_after
decl_stmt|;
name|new_node
operator|=
name|gegl_node_new
argument_list|()
expr_stmt|;
name|gegl_node_add_child
argument_list|(
name|new_node
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|input
operator|=
name|gegl_node_get_input_proxy
argument_list|(
name|new_node
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|output
operator|=
name|gegl_node_get_output_proxy
argument_list|(
name|new_node
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
name|translate_before
operator|=
name|gegl_node_new_child
argument_list|(
name|new_node
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:translate"
argument_list|,
literal|"x"
argument_list|,
operator|(
name|gdouble
operator|)
operator|-
name|x
argument_list|,
literal|"y"
argument_list|,
operator|(
name|gdouble
operator|)
operator|-
name|y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crop
operator|=
name|gegl_node_new_child
argument_list|(
name|new_node
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:crop"
argument_list|,
literal|"width"
argument_list|,
operator|(
name|gdouble
operator|)
name|width
argument_list|,
literal|"height"
argument_list|,
operator|(
name|gdouble
operator|)
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|translate_after
operator|=
name|gegl_node_new_child
argument_list|(
name|new_node
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:translate"
argument_list|,
literal|"x"
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
literal|"y"
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_node_link_many
argument_list|(
name|input
argument_list|,
name|translate_before
argument_list|,
name|crop
argument_list|,
name|node
argument_list|,
name|translate_after
argument_list|,
name|output
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new_node
return|;
block|}
else|else
block|{
return|return
name|node
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GeglNode
modifier|*
DECL|function|wrap_in_gamma_cast (GeglNode * node,GimpDrawable * drawable)
name|wrap_in_gamma_cast
parameter_list|(
name|GeglNode
modifier|*
name|node
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
if|if
condition|(
name|gimp_drawable_get_trc
argument_list|(
name|drawable
argument_list|)
operator|!=
name|GIMP_TRC_LINEAR
condition|)
block|{
specifier|const
name|Babl
modifier|*
name|drawable_format
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|cast_format
decl_stmt|;
name|GeglNode
modifier|*
name|new_node
decl_stmt|;
name|GeglNode
modifier|*
name|input
decl_stmt|;
name|GeglNode
modifier|*
name|output
decl_stmt|;
name|GeglNode
modifier|*
name|cast_before
decl_stmt|;
name|GeglNode
modifier|*
name|cast_after
decl_stmt|;
name|drawable_format
operator|=
name|gimp_drawable_get_format
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|cast_format
operator|=
name|gimp_babl_format
argument_list|(
name|gimp_babl_format_get_base_type
argument_list|(
name|drawable_format
argument_list|)
argument_list|,
name|gimp_babl_precision
argument_list|(
name|gimp_babl_format_get_component_type
argument_list|(
name|drawable_format
argument_list|)
argument_list|,
name|GIMP_TRC_LINEAR
argument_list|)
argument_list|,
name|babl_format_has_alpha
argument_list|(
name|drawable_format
argument_list|)
argument_list|,
name|babl_format_get_space
argument_list|(
name|drawable_format
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|=
name|gegl_node_new
argument_list|()
expr_stmt|;
name|gegl_node_add_child
argument_list|(
name|new_node
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|input
operator|=
name|gegl_node_get_input_proxy
argument_list|(
name|new_node
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|output
operator|=
name|gegl_node_get_output_proxy
argument_list|(
name|new_node
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
name|cast_before
operator|=
name|gegl_node_new_child
argument_list|(
name|new_node
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:cast-format"
argument_list|,
literal|"input-format"
argument_list|,
name|drawable_format
argument_list|,
literal|"output-format"
argument_list|,
name|cast_format
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cast_after
operator|=
name|gegl_node_new_child
argument_list|(
name|new_node
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:cast-format"
argument_list|,
literal|"input-format"
argument_list|,
name|cast_format
argument_list|,
literal|"output-format"
argument_list|,
name|drawable_format
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_node_link_many
argument_list|(
name|input
argument_list|,
name|cast_before
argument_list|,
name|node
argument_list|,
name|cast_after
argument_list|,
name|output
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new_node
return|;
block|}
else|else
block|{
return|return
name|node
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GeglNode
modifier|*
DECL|function|create_buffer_source_node (GeglNode * parent,GimpDrawable * drawable)
name|create_buffer_source_node
parameter_list|(
name|GeglNode
modifier|*
name|parent
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GeglNode
modifier|*
name|new_node
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|new_node
operator|=
name|gegl_node_new_child
argument_list|(
name|parent
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:buffer-source"
argument_list|,
literal|"buffer"
argument_list|,
name|buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|new_node
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|bump_map (GimpDrawable * drawable,GimpDrawable * bump_map,gdouble azimuth,gdouble elevation,gint depth,gint offset_x,gint offset_y,gdouble waterlevel,gdouble ambient,gboolean compensate,gboolean invert,gint type,gboolean tiled,GimpProgress * progress,GError ** error)
name|bump_map
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpDrawable
modifier|*
name|bump_map
parameter_list|,
name|gdouble
name|azimuth
parameter_list|,
name|gdouble
name|elevation
parameter_list|,
name|gint
name|depth
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gdouble
name|waterlevel
parameter_list|,
name|gdouble
name|ambient
parameter_list|,
name|gboolean
name|compensate
parameter_list|,
name|gboolean
name|invert
parameter_list|,
name|gint
name|type
parameter_list|,
name|gboolean
name|tiled
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglNode
modifier|*
name|src_node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:bump-map"
argument_list|,
literal|"tiled"
argument_list|,
name|tiled
argument_list|,
literal|"type"
argument_list|,
name|type
argument_list|,
literal|"compensate"
argument_list|,
name|compensate
argument_list|,
literal|"invert"
argument_list|,
name|invert
argument_list|,
literal|"azimuth"
argument_list|,
name|azimuth
argument_list|,
literal|"elevation"
argument_list|,
name|elevation
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
literal|"offset_x"
argument_list|,
name|offset_x
argument_list|,
literal|"offset_y"
argument_list|,
name|offset_y
argument_list|,
literal|"waterlevel"
argument_list|,
name|waterlevel
argument_list|,
literal|"ambient"
argument_list|,
name|ambient
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|src_node
operator|=
name|create_buffer_source_node
argument_list|(
name|node
argument_list|,
name|bump_map
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|src_node
argument_list|,
literal|"output"
argument_list|,
name|node
argument_list|,
literal|"aux"
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Bump Map"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|displace (GimpDrawable * drawable,gdouble amount_x,gdouble amount_y,gboolean do_x,gboolean do_y,GimpDrawable * displace_map_x,GimpDrawable * displace_map_y,gint displace_type,gint displace_mode,GimpProgress * progress,GError ** error)
name|displace
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|amount_x
parameter_list|,
name|gdouble
name|amount_y
parameter_list|,
name|gboolean
name|do_x
parameter_list|,
name|gboolean
name|do_y
parameter_list|,
name|GimpDrawable
modifier|*
name|displace_map_x
parameter_list|,
name|GimpDrawable
modifier|*
name|displace_map_y
parameter_list|,
name|gint
name|displace_type
parameter_list|,
name|gint
name|displace_mode
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_x
operator|||
name|do_y
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglAbyssPolicy
name|abyss_policy
init|=
name|GEGL_ABYSS_NONE
decl_stmt|;
switch|switch
condition|(
name|displace_type
condition|)
block|{
case|case
literal|1
case|:
name|abyss_policy
operator|=
name|GEGL_ABYSS_LOOP
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|abyss_policy
operator|=
name|GEGL_ABYSS_CLAMP
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|abyss_policy
operator|=
name|GEGL_ABYSS_BLACK
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:displace"
argument_list|,
literal|"displace_mode"
argument_list|,
name|displace_mode
argument_list|,
literal|"sampler_type"
argument_list|,
name|GEGL_SAMPLER_CUBIC
argument_list|,
literal|"abyss_policy"
argument_list|,
name|abyss_policy
argument_list|,
literal|"amount_x"
argument_list|,
name|amount_x
argument_list|,
literal|"amount_y"
argument_list|,
name|amount_y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_x
condition|)
block|{
name|GeglNode
modifier|*
name|src_node
decl_stmt|;
name|src_node
operator|=
name|create_buffer_source_node
argument_list|(
name|node
argument_list|,
name|displace_map_x
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|src_node
argument_list|,
literal|"output"
argument_list|,
name|node
argument_list|,
literal|"aux"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_y
condition|)
block|{
name|GeglNode
modifier|*
name|src_node
decl_stmt|;
name|src_node
operator|=
name|create_buffer_source_node
argument_list|(
name|node
argument_list|,
name|displace_map_y
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|src_node
argument_list|,
literal|"output"
argument_list|,
name|node
argument_list|,
literal|"aux2"
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Displace"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gaussian_blur (GimpDrawable * drawable,gdouble horizontal,gdouble vertical,GimpProgress * progress,GError ** error)
name|gaussian_blur
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|horizontal
parameter_list|,
name|gdouble
name|vertical
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:gaussian-blur"
argument_list|,
literal|"std-dev-x"
argument_list|,
name|horizontal
operator|*
literal|0.32
argument_list|,
literal|"std-dev-y"
argument_list|,
name|vertical
operator|*
literal|0.32
argument_list|,
literal|"abyss-policy"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Gaussian Blur"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|newsprint_color_model (gint colorspace)
name|newsprint_color_model
parameter_list|(
name|gint
name|colorspace
parameter_list|)
block|{
switch|switch
condition|(
name|colorspace
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|1
return|;
comment|/* black on white */
case|case
literal|1
case|:
return|return
literal|2
return|;
comment|/* rgb */
case|case
literal|2
case|:
return|return
literal|3
return|;
comment|/* cmyk */
case|case
literal|3
case|:
return|return
literal|1
return|;
comment|/* black on white */
block|}
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|newsprint_pattern (gint spotfn)
name|newsprint_pattern
parameter_list|(
name|gint
name|spotfn
parameter_list|)
block|{
switch|switch
condition|(
name|spotfn
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|1
return|;
comment|/* circle */
case|case
literal|1
case|:
return|return
literal|0
return|;
comment|/* line */
case|case
literal|2
case|:
return|return
literal|2
return|;
comment|/* diamond */
case|case
literal|3
case|:
return|return
literal|4
return|;
comment|/* ps circle */
case|case
literal|4
case|:
return|return
literal|2
return|;
comment|/* FIXME postscript diamond */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|gdouble
DECL|function|newsprint_angle (gdouble angle)
name|newsprint_angle
parameter_list|(
name|gdouble
name|angle
parameter_list|)
block|{
while|while
condition|(
name|angle
operator|>
literal|180.0
condition|)
name|angle
operator|-=
literal|360.0
expr_stmt|;
while|while
condition|(
name|angle
operator|<
operator|-
literal|180.0
condition|)
name|angle
operator|+=
literal|360.0
expr_stmt|;
return|return
name|angle
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_alienmap2_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_alienmap2_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|redfrequency
decl_stmt|;
name|gdouble
name|redangle
decl_stmt|;
name|gdouble
name|greenfrequency
decl_stmt|;
name|gdouble
name|greenangle
decl_stmt|;
name|gdouble
name|bluefrequency
decl_stmt|;
name|gdouble
name|blueangle
decl_stmt|;
name|guint8
name|colormodel
decl_stmt|;
name|guint8
name|redmode
decl_stmt|;
name|guint8
name|greenmode
decl_stmt|;
name|guint8
name|bluemode
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|redfrequency
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|redangle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|greenfrequency
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|greenangle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|bluefrequency
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|blueangle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|colormodel
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|redmode
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|greenmode
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|bluemode
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:alien-map"
argument_list|,
literal|"color-model"
argument_list|,
operator|(
name|gint
operator|)
name|colormodel
argument_list|,
literal|"cpn-1-frequency"
argument_list|,
operator|(
name|gdouble
operator|)
name|redfrequency
argument_list|,
literal|"cpn-2-frequency"
argument_list|,
operator|(
name|gdouble
operator|)
name|greenfrequency
argument_list|,
literal|"cpn-3-frequency"
argument_list|,
operator|(
name|gdouble
operator|)
name|bluefrequency
argument_list|,
literal|"cpn-1-phaseshift"
argument_list|,
operator|(
name|gdouble
operator|)
name|redangle
argument_list|,
literal|"cpn-2-phaseshift"
argument_list|,
operator|(
name|gdouble
operator|)
name|greenangle
argument_list|,
literal|"cpn-3-phaseshift"
argument_list|,
operator|(
name|gdouble
operator|)
name|blueangle
argument_list|,
literal|"cpn-1-keep"
argument_list|,
operator|(
name|gboolean
operator|)
operator|!
name|redmode
argument_list|,
literal|"cpn-2-keep"
argument_list|,
operator|(
name|gboolean
operator|)
operator|!
name|greenmode
argument_list|,
literal|"cpn-3-keep"
argument_list|,
operator|(
name|gboolean
operator|)
operator|!
name|bluemode
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Alien Map"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_antialias_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_antialias_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:antialias"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Antialias"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_apply_canvas_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_apply_canvas_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|direction
decl_stmt|;
name|gint
name|depth
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|direction
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:texturize-canvas"
argument_list|,
literal|"direction"
argument_list|,
name|direction
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Apply Canvas"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_applylens_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_applylens_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|refraction
decl_stmt|;
name|gboolean
name|keep_surroundings
decl_stmt|;
name|gboolean
name|set_background
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|refraction
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|keep_surroundings
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|set_background
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
decl_stmt|;
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|set_background
condition|)
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
else|else
name|gimp_rgba_set
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gegl_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:apply-lens"
argument_list|,
literal|"refraction-index"
argument_list|,
name|refraction
argument_list|,
literal|"keep-surroundings"
argument_list|,
name|keep_surroundings
argument_list|,
literal|"background-color"
argument_list|,
name|gegl_color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_selection_bounds
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Apply Lens"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_autocrop_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_autocrop_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|image
operator|=
name|gimp_value_get_image
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_pickable_auto_shrink
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x
operator|+=
name|off_x
expr_stmt|;
name|y
operator|+=
name|off_y
expr_stmt|;
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_ITEM_RESIZE
argument_list|,
name|_
argument_list|(
literal|"Autocrop image"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|y
operator|<
literal|0
operator|||
name|x
operator|+
name|width
operator|>
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|||
name|y
operator|+
name|height
operator|>
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
condition|)
block|{
comment|/*                * partially outside the image area, we need to                * resize the image to be able to crop properly.                */
name|gimp_image_resize
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
operator|-
name|x
argument_list|,
operator|-
name|y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
block|}
name|gimp_image_crop
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|GIMP_FILL_TRANSPARENT
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_autocrop_layer_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_autocrop_layer_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|image
operator|=
name|gimp_value_get_image
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
switch|switch
condition|(
name|gimp_pickable_auto_shrink
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
condition|)
block|{
case|case
name|GIMP_AUTO_SHRINK_SHRINK
case|:
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_ITEM_RESIZE
argument_list|,
name|_
argument_list|(
literal|"Autocrop layer"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_resize
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|context
argument_list|,
name|GIMP_FILL_TRANSPARENT
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
operator|-
name|x
argument_list|,
operator|-
name|y
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_autostretch_hsv_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_autostretch_hsv_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:stretch-contrast-hsv"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Stretch Contrast HSV"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_bump_map_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_bump_map_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpDrawable
modifier|*
name|bumpmap
decl_stmt|;
name|gdouble
name|azimuth
decl_stmt|;
name|gdouble
name|elevation
decl_stmt|;
name|gint
name|depth
decl_stmt|;
name|gint
name|xofs
decl_stmt|;
name|gint
name|yofs
decl_stmt|;
name|gdouble
name|waterlevel
decl_stmt|;
name|gdouble
name|ambient
decl_stmt|;
name|gboolean
name|compensate
decl_stmt|;
name|gboolean
name|invert
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|bumpmap
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|azimuth
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|elevation
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|xofs
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|yofs
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|waterlevel
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|ambient
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|compensate
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|invert
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|bump_map
argument_list|(
name|drawable
argument_list|,
name|bumpmap
argument_list|,
name|azimuth
argument_list|,
name|elevation
argument_list|,
name|depth
argument_list|,
name|xofs
argument_list|,
name|yofs
argument_list|,
name|waterlevel
argument_list|,
name|ambient
argument_list|,
name|compensate
argument_list|,
name|invert
argument_list|,
name|type
argument_list|,
name|FALSE
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_bump_map_tiled_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_bump_map_tiled_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpDrawable
modifier|*
name|bumpmap
decl_stmt|;
name|gdouble
name|azimuth
decl_stmt|;
name|gdouble
name|elevation
decl_stmt|;
name|gint
name|depth
decl_stmt|;
name|gint
name|xofs
decl_stmt|;
name|gint
name|yofs
decl_stmt|;
name|gdouble
name|waterlevel
decl_stmt|;
name|gdouble
name|ambient
decl_stmt|;
name|gboolean
name|compensate
decl_stmt|;
name|gboolean
name|invert
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|bumpmap
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|azimuth
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|elevation
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|xofs
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|yofs
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|waterlevel
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|ambient
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|compensate
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|invert
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|bump_map
argument_list|(
name|drawable
argument_list|,
name|bumpmap
argument_list|,
name|azimuth
argument_list|,
name|elevation
argument_list|,
name|depth
argument_list|,
name|xofs
argument_list|,
name|yofs
argument_list|,
name|waterlevel
argument_list|,
name|ambient
argument_list|,
name|compensate
argument_list|,
name|invert
argument_list|,
name|type
argument_list|,
name|TRUE
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_c_astretch_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_c_astretch_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:stretch-contrast"
argument_list|,
literal|"keep-colors"
argument_list|,
operator|(
name|gboolean
operator|)
name|FALSE
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Stretch Contrast"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_cartoon_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_cartoon_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|mask_radius
decl_stmt|;
name|gdouble
name|pct_black
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|mask_radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|pct_black
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:cartoon"
argument_list|,
literal|"mask-radius"
argument_list|,
name|mask_radius
argument_list|,
literal|"pct-black"
argument_list|,
name|pct_black
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Cartoon"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_colors_channel_mixer_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_colors_channel_mixer_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|monochrome
decl_stmt|;
name|gdouble
name|rr_gain
decl_stmt|;
name|gdouble
name|rg_gain
decl_stmt|;
name|gdouble
name|rb_gain
decl_stmt|;
name|gdouble
name|gr_gain
decl_stmt|;
name|gdouble
name|gg_gain
decl_stmt|;
name|gdouble
name|gb_gain
decl_stmt|;
name|gdouble
name|br_gain
decl_stmt|;
name|gdouble
name|bg_gain
decl_stmt|;
name|gdouble
name|bb_gain
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|monochrome
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|rr_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|rg_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|rb_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|gr_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|gg_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|gb_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|br_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|bg_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|bb_gain
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|monochrome
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:mono-mixer"
argument_list|,
literal|"red"
argument_list|,
name|rr_gain
argument_list|,
literal|"green"
argument_list|,
name|rg_gain
argument_list|,
literal|"blue"
argument_list|,
name|rb_gain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:channel-mixer"
argument_list|,
literal|"rr-gain"
argument_list|,
name|rr_gain
argument_list|,
literal|"rg-gain"
argument_list|,
name|rg_gain
argument_list|,
literal|"rb-gain"
argument_list|,
name|rb_gain
argument_list|,
literal|"gr-gain"
argument_list|,
name|gr_gain
argument_list|,
literal|"gg-gain"
argument_list|,
name|gg_gain
argument_list|,
literal|"gb-gain"
argument_list|,
name|gb_gain
argument_list|,
literal|"br-gain"
argument_list|,
name|br_gain
argument_list|,
literal|"bg-gain"
argument_list|,
name|bg_gain
argument_list|,
literal|"bb-gain"
argument_list|,
name|bb_gain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Channel Mixer"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_colortoalpha_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_colortoalpha_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|gimp_value_get_rgb
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
comment|/* XXX: fixme disable for gray, and add alpha when needed */
name|GeglColor
modifier|*
name|gegl_color
init|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:color-to-alpha"
argument_list|,
literal|"color"
argument_list|,
name|gegl_color
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Color to Alpha"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_convmatrix_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_convmatrix_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|argc_matrix
decl_stmt|;
specifier|const
name|gdouble
modifier|*
name|matrix
decl_stmt|;
name|gboolean
name|alpha_alg
decl_stmt|;
name|gdouble
name|divisor
decl_stmt|;
name|gdouble
name|offset
decl_stmt|;
name|gint
name|argc_channels
decl_stmt|;
specifier|const
name|gint32
modifier|*
name|channels
decl_stmt|;
name|gint
name|bmode
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|argc_matrix
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|matrix
operator|=
name|gimp_value_get_float_array
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|alpha_alg
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|divisor
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|argc_channels
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|channels
operator|=
name|gimp_value_get_int32_array
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|bmode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|argc_matrix
operator|!=
literal|25
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|GIMP_PDB_ERROR
argument_list|,
name|GIMP_PDB_ERROR_INVALID_ARGUMENT
argument_list|,
name|_
argument_list|(
literal|"Array 'matrix' has only %d members, must have 25"
argument_list|)
argument_list|,
name|argc_matrix
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
name|argc_channels
operator|!=
literal|5
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|GIMP_PDB_ERROR
argument_list|,
name|GIMP_PDB_ERROR_INVALID_ARGUMENT
argument_list|,
name|_
argument_list|(
literal|"Array 'channels' has only %d members, must have 5"
argument_list|)
argument_list|,
name|argc_channels
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglAbyssPolicy
name|border
init|=
name|GEGL_ABYSS_CLAMP
decl_stmt|;
name|gboolean
name|r
init|=
name|channels
index|[
literal|1
index|]
decl_stmt|;
name|gboolean
name|g
init|=
name|channels
index|[
literal|2
index|]
decl_stmt|;
name|gboolean
name|b
init|=
name|channels
index|[
literal|3
index|]
decl_stmt|;
name|gboolean
name|a
init|=
name|channels
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|r
operator|=
name|channels
index|[
literal|0
index|]
expr_stmt|;
name|g
operator|=
name|channels
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|channels
index|[
literal|0
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|bmode
condition|)
block|{
case|case
literal|0
case|:
name|border
operator|=
name|GEGL_ABYSS_CLAMP
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|border
operator|=
name|GEGL_ABYSS_LOOP
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|border
operator|=
name|GEGL_ABYSS_NONE
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:convolution-matrix"
argument_list|,
literal|"a1"
argument_list|,
name|matrix
index|[
literal|0
index|]
argument_list|,
literal|"a2"
argument_list|,
name|matrix
index|[
literal|1
index|]
argument_list|,
literal|"a3"
argument_list|,
name|matrix
index|[
literal|2
index|]
argument_list|,
literal|"a4"
argument_list|,
name|matrix
index|[
literal|3
index|]
argument_list|,
literal|"a5"
argument_list|,
name|matrix
index|[
literal|4
index|]
argument_list|,
literal|"b1"
argument_list|,
name|matrix
index|[
literal|5
index|]
argument_list|,
literal|"b2"
argument_list|,
name|matrix
index|[
literal|6
index|]
argument_list|,
literal|"b3"
argument_list|,
name|matrix
index|[
literal|7
index|]
argument_list|,
literal|"b4"
argument_list|,
name|matrix
index|[
literal|8
index|]
argument_list|,
literal|"b5"
argument_list|,
name|matrix
index|[
literal|9
index|]
argument_list|,
literal|"c1"
argument_list|,
name|matrix
index|[
literal|10
index|]
argument_list|,
literal|"c2"
argument_list|,
name|matrix
index|[
literal|11
index|]
argument_list|,
literal|"c3"
argument_list|,
name|matrix
index|[
literal|12
index|]
argument_list|,
literal|"c4"
argument_list|,
name|matrix
index|[
literal|13
index|]
argument_list|,
literal|"c5"
argument_list|,
name|matrix
index|[
literal|14
index|]
argument_list|,
literal|"d1"
argument_list|,
name|matrix
index|[
literal|15
index|]
argument_list|,
literal|"d2"
argument_list|,
name|matrix
index|[
literal|16
index|]
argument_list|,
literal|"d3"
argument_list|,
name|matrix
index|[
literal|17
index|]
argument_list|,
literal|"d4"
argument_list|,
name|matrix
index|[
literal|18
index|]
argument_list|,
literal|"d5"
argument_list|,
name|matrix
index|[
literal|19
index|]
argument_list|,
literal|"e1"
argument_list|,
name|matrix
index|[
literal|20
index|]
argument_list|,
literal|"e2"
argument_list|,
name|matrix
index|[
literal|21
index|]
argument_list|,
literal|"e3"
argument_list|,
name|matrix
index|[
literal|22
index|]
argument_list|,
literal|"e4"
argument_list|,
name|matrix
index|[
literal|23
index|]
argument_list|,
literal|"e5"
argument_list|,
name|matrix
index|[
literal|24
index|]
argument_list|,
literal|"divisor"
argument_list|,
name|divisor
argument_list|,
literal|"offset"
argument_list|,
name|offset
argument_list|,
literal|"red"
argument_list|,
name|r
argument_list|,
literal|"green"
argument_list|,
name|g
argument_list|,
literal|"blue"
argument_list|,
name|b
argument_list|,
literal|"alpha"
argument_list|,
name|a
argument_list|,
literal|"normalize"
argument_list|,
name|FALSE
argument_list|,
literal|"alpha-weight"
argument_list|,
name|alpha_alg
argument_list|,
literal|"border"
argument_list|,
name|border
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Convolution Matrix"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_cubism_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_cubism_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|tile_size
decl_stmt|;
name|gdouble
name|tile_saturation
decl_stmt|;
name|gint
name|bg_color
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|tile_size
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|tile_saturation
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|bg_color
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
decl_stmt|;
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|bg_color
condition|)
block|{
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_rgba_set
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
name|gegl_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:cubism"
argument_list|,
literal|"tile-size"
argument_list|,
name|tile_size
argument_list|,
literal|"tile-saturation"
argument_list|,
name|tile_saturation
argument_list|,
literal|"bg-color"
argument_list|,
name|gegl_color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Cubism"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_deinterlace_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_deinterlace_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|evenodd
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|evenodd
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:deinterlace"
argument_list|,
literal|"keep"
argument_list|,
name|evenodd
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|"orientation"
argument_list|,
literal|0
argument_list|,
comment|/* HORIZONTAL */
literal|"size"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Deinterlace"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_diffraction_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_diffraction_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|lam_r
decl_stmt|;
name|gdouble
name|lam_g
decl_stmt|;
name|gdouble
name|lam_b
decl_stmt|;
name|gdouble
name|contour_r
decl_stmt|;
name|gdouble
name|contour_g
decl_stmt|;
name|gdouble
name|contour_b
decl_stmt|;
name|gdouble
name|edges_r
decl_stmt|;
name|gdouble
name|edges_g
decl_stmt|;
name|gdouble
name|edges_b
decl_stmt|;
name|gdouble
name|brightness
decl_stmt|;
name|gdouble
name|scattering
decl_stmt|;
name|gdouble
name|polarization
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|lam_r
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|lam_g
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|lam_b
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|contour_r
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|contour_g
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|contour_b
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|edges_r
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|edges_g
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|edges_b
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|brightness
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|scattering
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|polarization
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|14
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:diffraction-patterns"
argument_list|,
literal|"red-frequency"
argument_list|,
name|lam_r
argument_list|,
literal|"green-frequency"
argument_list|,
name|lam_g
argument_list|,
literal|"blue-frequency"
argument_list|,
name|lam_b
argument_list|,
literal|"red-contours"
argument_list|,
name|contour_r
argument_list|,
literal|"green-contours"
argument_list|,
name|contour_g
argument_list|,
literal|"blue-contours"
argument_list|,
name|contour_b
argument_list|,
literal|"red-sedges"
argument_list|,
name|edges_r
argument_list|,
literal|"green-sedges"
argument_list|,
name|edges_g
argument_list|,
literal|"blue-sedges"
argument_list|,
name|edges_b
argument_list|,
literal|"brightness"
argument_list|,
name|brightness
argument_list|,
literal|"scattering"
argument_list|,
name|scattering
argument_list|,
literal|"polarization"
argument_list|,
name|polarization
argument_list|,
literal|"width"
argument_list|,
name|width
argument_list|,
literal|"height"
argument_list|,
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Diffraction Patterns"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_displace_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_displace_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|amount_x
decl_stmt|;
name|gdouble
name|amount_y
decl_stmt|;
name|gboolean
name|do_x
decl_stmt|;
name|gboolean
name|do_y
decl_stmt|;
name|GimpDrawable
modifier|*
name|displace_map_x
decl_stmt|;
name|GimpDrawable
modifier|*
name|displace_map_y
decl_stmt|;
name|gint
name|displace_type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|amount_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|amount_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|do_x
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|do_y
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|displace_map_x
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|displace_map_y
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|displace_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|displace
argument_list|(
name|drawable
argument_list|,
name|amount_x
argument_list|,
name|amount_y
argument_list|,
name|do_x
argument_list|,
name|do_y
argument_list|,
name|displace_map_x
argument_list|,
name|displace_map_y
argument_list|,
name|displace_type
argument_list|,
literal|0
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_displace_polar_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_displace_polar_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|amount_x
decl_stmt|;
name|gdouble
name|amount_y
decl_stmt|;
name|gboolean
name|do_x
decl_stmt|;
name|gboolean
name|do_y
decl_stmt|;
name|GimpDrawable
modifier|*
name|displace_map_x
decl_stmt|;
name|GimpDrawable
modifier|*
name|displace_map_y
decl_stmt|;
name|gint
name|displace_type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|amount_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|amount_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|do_x
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|do_y
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|displace_map_x
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|displace_map_y
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|displace_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|displace
argument_list|(
name|drawable
argument_list|,
name|amount_x
argument_list|,
name|amount_y
argument_list|,
name|do_x
argument_list|,
name|do_y
argument_list|,
name|displace_map_x
argument_list|,
name|displace_map_y
argument_list|,
name|displace_type
argument_list|,
literal|1
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_dog_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_dog_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|inner
decl_stmt|;
name|gdouble
name|outer
decl_stmt|;
name|gboolean
name|normalize
decl_stmt|;
name|gboolean
name|invert
decl_stmt|;
name|image
operator|=
name|gimp_value_get_image
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|inner
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|outer
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|normalize
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|invert
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|normalize
operator|||
name|invert
condition|)
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_MISC
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"DoG Edge Detect"
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:difference-of-gaussians"
argument_list|,
literal|"radius1"
argument_list|,
name|inner
operator|*
literal|0.32
argument_list|,
literal|"radius2"
argument_list|,
name|outer
operator|*
literal|0.32
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"DoG Edge Detect"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalize
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:stretch-contrast"
argument_list|,
literal|"keep-colors"
argument_list|,
name|TRUE
argument_list|,
literal|"perceptual"
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Normalize"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
name|gimp_drawable_apply_operation_by_name
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Invert"
argument_list|)
argument_list|,
literal|"gegl:invert-gamma"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalize
operator|||
name|invert
condition|)
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_edge_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_edge_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|amount
decl_stmt|;
name|gint
name|warpmode
decl_stmt|;
name|gint
name|edgemode
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|amount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|warpmode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|edgemode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglAbyssPolicy
name|border_behavior
init|=
name|GEGL_ABYSS_NONE
decl_stmt|;
switch|switch
condition|(
name|warpmode
condition|)
block|{
case|case
literal|0
case|:
name|border_behavior
operator|=
name|GEGL_ABYSS_NONE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|border_behavior
operator|=
name|GEGL_ABYSS_LOOP
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|border_behavior
operator|=
name|GEGL_ABYSS_CLAMP
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|border_behavior
operator|=
name|GEGL_ABYSS_BLACK
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:edge"
argument_list|,
literal|"algorithm"
argument_list|,
name|edgemode
argument_list|,
literal|"amount"
argument_list|,
name|amount
argument_list|,
literal|"border-behavior"
argument_list|,
name|border_behavior
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Edge"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_emboss_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_emboss_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|azimuth
decl_stmt|;
name|gdouble
name|elevation
decl_stmt|;
name|gint
name|depth
decl_stmt|;
name|gboolean
name|emboss
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|azimuth
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|elevation
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|emboss
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:emboss"
argument_list|,
literal|"type"
argument_list|,
name|emboss
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|"azimuth"
argument_list|,
name|azimuth
argument_list|,
literal|"elevation"
argument_list|,
name|elevation
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Emboss"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_engrave_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_engrave_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gboolean
name|limit
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|height
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|limit
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:engrave"
argument_list|,
literal|"row-height"
argument_list|,
name|height
argument_list|,
literal|"limit"
argument_list|,
name|limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Engrave"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_exchange_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_exchange_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|guint8
name|from_red
decl_stmt|;
name|guint8
name|from_green
decl_stmt|;
name|guint8
name|from_blue
decl_stmt|;
name|guint8
name|to_red
decl_stmt|;
name|guint8
name|to_green
decl_stmt|;
name|guint8
name|to_blue
decl_stmt|;
name|guint8
name|red_threshold
decl_stmt|;
name|guint8
name|green_threshold
decl_stmt|;
name|guint8
name|blue_threshold
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|from_red
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|from_green
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|from_blue
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|to_red
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|to_green
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|to_blue
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|red_threshold
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|green_threshold
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|blue_threshold
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GimpRGB
name|from
decl_stmt|;
name|GimpRGB
name|to
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_from
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_to
decl_stmt|;
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gimp_rgb_set_uchar
argument_list|(
operator|&
name|from
argument_list|,
name|from_red
argument_list|,
name|from_green
argument_list|,
name|from_blue
argument_list|)
expr_stmt|;
name|gimp_rgb_set_uchar
argument_list|(
operator|&
name|to
argument_list|,
name|to_red
argument_list|,
name|to_green
argument_list|,
name|to_blue
argument_list|)
expr_stmt|;
name|gegl_from
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_to
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:color-exchange"
argument_list|,
literal|"from-color"
argument_list|,
name|gegl_from
argument_list|,
literal|"to-color"
argument_list|,
name|gegl_to
argument_list|,
literal|"red-threshold"
argument_list|,
name|red_threshold
operator|/
literal|255.0
argument_list|,
literal|"green-threshold"
argument_list|,
name|green_threshold
operator|/
literal|255.0
argument_list|,
literal|"blue-threshold"
argument_list|,
name|blue_threshold
operator|/
literal|255.0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_from
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_to
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Color Exchange"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_flarefx_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_flarefx_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|pos_x
decl_stmt|;
name|gint
name|pos_y
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|pos_x
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|pos_y
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gint
name|width
init|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gdouble
name|x
init|=
operator|(
name|gdouble
operator|)
name|pos_x
operator|/
operator|(
name|gdouble
operator|)
name|width
decl_stmt|;
name|gdouble
name|y
init|=
operator|(
name|gdouble
operator|)
name|pos_y
operator|/
operator|(
name|gdouble
operator|)
name|height
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:lens-flare"
argument_list|,
literal|"pos-x"
argument_list|,
name|x
argument_list|,
literal|"pos-y"
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Lens Flare"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_fractal_trace_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_fractal_trace_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|xmin
decl_stmt|;
name|gdouble
name|xmax
decl_stmt|;
name|gdouble
name|ymin
decl_stmt|;
name|gdouble
name|ymax
decl_stmt|;
name|gint
name|depth
decl_stmt|;
name|gint
name|outside_type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|outside_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglAbyssPolicy
name|abyss
init|=
name|GEGL_ABYSS_LOOP
decl_stmt|;
switch|switch
condition|(
name|outside_type
condition|)
block|{
case|case
literal|0
case|:
name|abyss
operator|=
name|GEGL_ABYSS_LOOP
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|abyss
operator|=
name|GEGL_ABYSS_NONE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|abyss
operator|=
name|GEGL_ABYSS_BLACK
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|abyss
operator|=
name|GEGL_ABYSS_WHITE
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:fractal-trace"
argument_list|,
literal|"X1"
argument_list|,
name|xmin
argument_list|,
literal|"X2"
argument_list|,
name|xmax
argument_list|,
literal|"Y1"
argument_list|,
name|ymin
argument_list|,
literal|"Y2"
argument_list|,
name|ymax
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
literal|"abyss-policy"
argument_list|,
name|abyss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Fractal Trace"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_gauss_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_gauss_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|horizontal
decl_stmt|;
name|gdouble
name|vertical
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gaussian_blur
argument_list|(
name|drawable
argument_list|,
name|horizontal
argument_list|,
name|vertical
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_gauss_iir_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_gauss_iir_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|gboolean
name|horizontal
decl_stmt|;
name|gboolean
name|vertical
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gaussian_blur
argument_list|(
name|drawable
argument_list|,
name|horizontal
condition|?
name|radius
else|:
literal|0.0
argument_list|,
name|vertical
condition|?
name|radius
else|:
literal|0.0
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_gauss_iir2_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_gauss_iir2_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|horizontal
decl_stmt|;
name|gdouble
name|vertical
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gaussian_blur
argument_list|(
name|drawable
argument_list|,
name|horizontal
argument_list|,
name|vertical
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_gauss_rle_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_gauss_rle_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|gboolean
name|horizontal
decl_stmt|;
name|gboolean
name|vertical
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gaussian_blur
argument_list|(
name|drawable
argument_list|,
name|horizontal
condition|?
name|radius
else|:
literal|0.0
argument_list|,
name|vertical
condition|?
name|radius
else|:
literal|0.0
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_gauss_rle2_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_gauss_rle2_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|horizontal
decl_stmt|;
name|gdouble
name|vertical
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|success
operator|=
name|gaussian_blur
argument_list|(
name|drawable
argument_list|,
name|horizontal
argument_list|,
name|vertical
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_glasstile_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_glasstile_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|tilex
decl_stmt|;
name|gint
name|tiley
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|tilex
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|tiley
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:tile-glass"
argument_list|,
literal|"tile-width"
argument_list|,
name|tilex
argument_list|,
literal|"tile-height"
argument_list|,
name|tiley
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Glass Tile"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_hsv_noise_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_hsv_noise_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|holdness
decl_stmt|;
name|gint
name|hue_distance
decl_stmt|;
name|gint
name|saturation_distance
decl_stmt|;
name|gint
name|value_distance
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|holdness
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|hue_distance
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|saturation_distance
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|value_distance
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gdouble
name|saturation
init|=
name|saturation_distance
operator|/
literal|255.0
decl_stmt|;
name|gdouble
name|value
init|=
name|value_distance
operator|/
literal|255.0
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-hsv"
argument_list|,
literal|"holdness"
argument_list|,
operator|(
name|gint
operator|)
name|holdness
argument_list|,
literal|"hue-distance"
argument_list|,
operator|(
name|gdouble
operator|)
name|hue_distance
argument_list|,
literal|"saturation-distance"
argument_list|,
operator|(
name|gdouble
operator|)
name|saturation
argument_list|,
literal|"value-distance"
argument_list|,
operator|(
name|gdouble
operator|)
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Noise HSV"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_illusion_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_illusion_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|division
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|division
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:illusion"
argument_list|,
literal|"division"
argument_list|,
operator|(
name|gint
operator|)
name|division
argument_list|,
literal|"illusion-type"
argument_list|,
operator|(
name|gint
operator|)
name|type
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Illusion"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_laplace_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_laplace_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:edge-laplace"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Laplace"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_lens_distortion_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_lens_distortion_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|offset_x
decl_stmt|;
name|gdouble
name|offset_y
decl_stmt|;
name|gdouble
name|main_adjust
decl_stmt|;
name|gdouble
name|edge_adjust
decl_stmt|;
name|gdouble
name|rescale
decl_stmt|;
name|gdouble
name|brighten
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|offset_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|offset_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|main_adjust
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|edge_adjust
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|rescale
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|brighten
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
decl_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
name|gegl_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:lens-distortion"
argument_list|,
literal|"main"
argument_list|,
operator|(
name|gdouble
operator|)
name|main_adjust
argument_list|,
literal|"edge"
argument_list|,
operator|(
name|gdouble
operator|)
name|edge_adjust
argument_list|,
literal|"zoom"
argument_list|,
operator|(
name|gdouble
operator|)
name|rescale
argument_list|,
literal|"x-shift"
argument_list|,
operator|(
name|gdouble
operator|)
name|offset_x
argument_list|,
literal|"y-shift"
argument_list|,
operator|(
name|gdouble
operator|)
name|offset_y
argument_list|,
literal|"brighten"
argument_list|,
operator|(
name|gdouble
operator|)
name|brighten
argument_list|,
literal|"background"
argument_list|,
name|gegl_color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_selection_bounds
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Lens Distortion"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_make_seamless_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_make_seamless_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:tile-seamless"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|node
operator|=
name|wrap_in_selection_bounds
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Tile Seamless"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_maze_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_maze_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint16
name|width
decl_stmt|;
name|gint16
name|height
decl_stmt|;
name|guint8
name|tileable
decl_stmt|;
name|guint8
name|algorithm
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|width
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|height
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|tileable
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|algorithm
operator|=
name|g_value_get_uchar
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglColor
modifier|*
name|fg_color
decl_stmt|;
name|GeglColor
modifier|*
name|bg_color
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|fg_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|bg_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:maze"
argument_list|,
literal|"x"
argument_list|,
name|width
argument_list|,
literal|"y"
argument_list|,
name|height
argument_list|,
literal|"algorithm-type"
argument_list|,
name|algorithm
argument_list|,
literal|"tileable"
argument_list|,
name|tileable
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"fg-color"
argument_list|,
name|fg_color
argument_list|,
literal|"bg-color"
argument_list|,
name|bg_color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|fg_color
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|bg_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Maze"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_mblur_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_mblur_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gdouble
name|length
decl_stmt|;
name|gdouble
name|angle
decl_stmt|;
name|gdouble
name|center_x
decl_stmt|;
name|gdouble
name|center_y
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|angle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|center_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|center_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|gint
name|width
init|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|center_x
operator|/=
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|center_y
operator|/=
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
if|if
condition|(
name|angle
operator|>
literal|180.0
condition|)
name|angle
operator|-=
literal|360.0
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-linear"
argument_list|,
literal|"length"
argument_list|,
name|length
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-circular"
argument_list|,
literal|"center-x"
argument_list|,
name|center_x
argument_list|,
literal|"center-y"
argument_list|,
name|center_y
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|gdouble
name|factor
init|=
name|CLAMP
argument_list|(
name|length
operator|/
literal|256.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-zoom"
argument_list|,
literal|"center-x"
argument_list|,
name|center_x
argument_list|,
literal|"center-y"
argument_list|,
name|center_y
argument_list|,
literal|"factor"
argument_list|,
name|factor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Motion Blur"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_mblur_inward_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_mblur_inward_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gdouble
name|length
decl_stmt|;
name|gdouble
name|angle
decl_stmt|;
name|gdouble
name|center_x
decl_stmt|;
name|gdouble
name|center_y
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|angle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|center_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|center_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|gint
name|width
init|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|center_x
operator|/=
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|center_y
operator|/=
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-linear"
argument_list|,
literal|"length"
argument_list|,
name|length
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-circular"
argument_list|,
literal|"center-x"
argument_list|,
name|center_x
argument_list|,
literal|"center-y"
argument_list|,
name|center_y
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|gdouble
name|factor
init|=
name|CLAMP
argument_list|(
operator|-
name|length
operator|/
operator|(
literal|256.0
operator|-
name|length
operator|)
argument_list|,
operator|-
literal|10.0
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:motion-blur-zoom"
argument_list|,
literal|"center-x"
argument_list|,
name|center_x
argument_list|,
literal|"center-y"
argument_list|,
name|center_y
argument_list|,
literal|"factor"
argument_list|,
name|factor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Motion Blur"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_mosaic_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_mosaic_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|tile_size
decl_stmt|;
name|gdouble
name|tile_height
decl_stmt|;
name|gdouble
name|tile_spacing
decl_stmt|;
name|gdouble
name|tile_neatness
decl_stmt|;
name|gint
name|tile_allow_split
decl_stmt|;
name|gdouble
name|light_dir
decl_stmt|;
name|gdouble
name|color_variation
decl_stmt|;
name|gint
name|antialiasing
decl_stmt|;
name|gint
name|color_averaging
decl_stmt|;
name|gint
name|tile_type
decl_stmt|;
name|gint
name|tile_surface
decl_stmt|;
name|gint
name|grout_color
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|tile_size
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|tile_height
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|tile_spacing
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|tile_neatness
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|tile_allow_split
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|light_dir
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|color_variation
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|antialiasing
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|color_averaging
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|tile_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|tile_surface
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|grout_color
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|14
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglColor
modifier|*
name|fg_color
decl_stmt|;
name|GeglColor
modifier|*
name|bg_color
decl_stmt|;
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|grout_color
condition|)
block|{
name|GimpRGB
name|fgcolor
decl_stmt|,
name|bgcolor
decl_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|bgcolor
argument_list|)
expr_stmt|;
name|bg_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|bgcolor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|fgcolor
argument_list|)
expr_stmt|;
name|fg_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|fgcolor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* sic */
name|fg_color
operator|=
name|gegl_color_new
argument_list|(
literal|"white"
argument_list|)
expr_stmt|;
name|bg_color
operator|=
name|gegl_color_new
argument_list|(
literal|"black"
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:mosaic"
argument_list|,
literal|"tile-size"
argument_list|,
operator|(
name|gdouble
operator|)
name|tile_size
argument_list|,
literal|"tile-height"
argument_list|,
operator|(
name|gdouble
operator|)
name|tile_height
argument_list|,
literal|"tile-spacing"
argument_list|,
operator|(
name|gdouble
operator|)
name|tile_spacing
argument_list|,
literal|"tile-neatness"
argument_list|,
operator|(
name|gdouble
operator|)
name|tile_neatness
argument_list|,
literal|"tile-allow-split"
argument_list|,
operator|(
name|gboolean
operator|)
name|tile_allow_split
argument_list|,
literal|"light-dir"
argument_list|,
operator|(
name|gdouble
operator|)
name|light_dir
argument_list|,
literal|"color-variation"
argument_list|,
operator|(
name|gfloat
operator|)
name|color_variation
argument_list|,
literal|"antialiasing"
argument_list|,
operator|(
name|gboolean
operator|)
name|antialiasing
argument_list|,
literal|"color-averaging"
argument_list|,
operator|(
name|gboolean
operator|)
name|color_averaging
argument_list|,
literal|"tile-type"
argument_list|,
operator|(
name|gint
operator|)
name|tile_type
argument_list|,
literal|"tile-surface"
argument_list|,
operator|(
name|gboolean
operator|)
name|tile_surface
argument_list|,
literal|"light-color"
argument_list|,
name|fg_color
argument_list|,
literal|"joints-color"
argument_list|,
name|bg_color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|fg_color
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|bg_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Mosaic"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_neon_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_neon_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|gdouble
name|amount
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|amount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:edge-neon"
argument_list|,
literal|"radius"
argument_list|,
name|radius
argument_list|,
literal|"amount"
argument_list|,
name|amount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Neon"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_newsprint_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_newsprint_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|cell_width
decl_stmt|;
name|gint
name|colorspace
decl_stmt|;
name|gint
name|k_pullout
decl_stmt|;
name|gdouble
name|gry_ang
decl_stmt|;
name|gint
name|gry_spotfn
decl_stmt|;
name|gdouble
name|red_ang
decl_stmt|;
name|gint
name|red_spotfn
decl_stmt|;
name|gdouble
name|grn_ang
decl_stmt|;
name|gint
name|grn_spotfn
decl_stmt|;
name|gdouble
name|blu_ang
decl_stmt|;
name|gint
name|blu_spotfn
decl_stmt|;
name|gint
name|oversample
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|cell_width
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|colorspace
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|k_pullout
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|gry_ang
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|gry_spotfn
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|red_ang
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|red_spotfn
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|grn_ang
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|grn_spotfn
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|blu_ang
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|blu_spotfn
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|oversample
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|14
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gint
name|color_model
init|=
name|newsprint_color_model
argument_list|(
name|colorspace
argument_list|)
decl_stmt|;
name|gint
name|pattern
init|=
name|newsprint_pattern
argument_list|(
name|gry_spotfn
argument_list|)
decl_stmt|;
name|gint
name|pattern2
init|=
name|newsprint_pattern
argument_list|(
name|red_spotfn
argument_list|)
decl_stmt|;
name|gint
name|pattern3
init|=
name|newsprint_pattern
argument_list|(
name|grn_spotfn
argument_list|)
decl_stmt|;
name|gint
name|pattern4
init|=
name|newsprint_pattern
argument_list|(
name|blu_spotfn
argument_list|)
decl_stmt|;
name|gdouble
name|angle
init|=
name|newsprint_angle
argument_list|(
name|gry_ang
argument_list|)
decl_stmt|;
name|gdouble
name|angle2
init|=
name|newsprint_angle
argument_list|(
name|red_ang
argument_list|)
decl_stmt|;
name|gdouble
name|angle3
init|=
name|newsprint_angle
argument_list|(
name|grn_ang
argument_list|)
decl_stmt|;
name|gdouble
name|angle4
init|=
name|newsprint_angle
argument_list|(
name|blu_ang
argument_list|)
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:newsprint"
argument_list|,
literal|"color-model"
argument_list|,
name|color_model
argument_list|,
literal|"black-pullout"
argument_list|,
operator|(
name|gdouble
operator|)
name|k_pullout
operator|/
literal|100.0
argument_list|,
literal|"period"
argument_list|,
operator|(
name|gdouble
operator|)
name|cell_width
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
literal|"pattern"
argument_list|,
name|pattern
argument_list|,
literal|"period2"
argument_list|,
operator|(
name|gdouble
operator|)
name|cell_width
argument_list|,
literal|"angle2"
argument_list|,
name|angle2
argument_list|,
literal|"pattern2"
argument_list|,
name|pattern2
argument_list|,
literal|"period3"
argument_list|,
operator|(
name|gdouble
operator|)
name|cell_width
argument_list|,
literal|"angle3"
argument_list|,
name|angle3
argument_list|,
literal|"pattern3"
argument_list|,
name|pattern3
argument_list|,
literal|"period4"
argument_list|,
operator|(
name|gdouble
operator|)
name|cell_width
argument_list|,
literal|"angle4"
argument_list|,
name|angle4
argument_list|,
literal|"pattern4"
argument_list|,
name|pattern4
argument_list|,
literal|"aa-samples"
argument_list|,
name|oversample
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Newsprint"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_normalize_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_normalize_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:stretch-contrast"
argument_list|,
literal|"keep-colors"
argument_list|,
name|TRUE
argument_list|,
literal|"perceptual"
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Normalize"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_nova_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_nova_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|xcenter
decl_stmt|;
name|gint
name|ycenter
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gint
name|radius
decl_stmt|;
name|gint
name|nspoke
decl_stmt|;
name|gint
name|randomhue
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|xcenter
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|ycenter
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_value_get_rgb
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|nspoke
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|randomhue
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
init|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gdouble
name|center_x
init|=
operator|(
name|gdouble
operator|)
name|xcenter
operator|/
operator|(
name|gdouble
operator|)
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gdouble
name|center_y
init|=
operator|(
name|gdouble
operator|)
name|ycenter
operator|/
operator|(
name|gdouble
operator|)
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:supernova"
argument_list|,
literal|"center-x"
argument_list|,
name|center_x
argument_list|,
literal|"center-y"
argument_list|,
name|center_y
argument_list|,
literal|"radius"
argument_list|,
name|radius
argument_list|,
literal|"spokes-count"
argument_list|,
name|nspoke
argument_list|,
literal|"random-hue"
argument_list|,
name|randomhue
argument_list|,
literal|"color"
argument_list|,
name|gegl_color
argument_list|,
literal|"seed"
argument_list|,
name|g_random_int
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Supernova"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_oilify_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_oilify_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|mask_size
decl_stmt|;
name|gint
name|mode
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|mask_size
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:oilify"
argument_list|,
literal|"mask-radius"
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|mask_size
operator|/
literal|2
argument_list|)
argument_list|,
literal|"use-inten"
argument_list|,
name|mode
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Oilify"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_oilify_enhanced_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_oilify_enhanced_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|mode
decl_stmt|;
name|gint
name|mask_size
decl_stmt|;
name|GimpDrawable
modifier|*
name|mask_size_map
decl_stmt|;
name|gint
name|exponent
decl_stmt|;
name|GimpDrawable
modifier|*
name|exponent_map
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|mask_size
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mask_size_map
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|exponent_map
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:oilify"
argument_list|,
literal|"mask-radius"
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|mask_size
operator|/
literal|2
argument_list|)
argument_list|,
literal|"use-inten"
argument_list|,
name|mode
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
literal|"exponent"
argument_list|,
name|exponent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask_size_map
condition|)
block|{
name|GeglNode
modifier|*
name|src_node
decl_stmt|;
name|src_node
operator|=
name|create_buffer_source_node
argument_list|(
name|node
argument_list|,
name|mask_size_map
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|src_node
argument_list|,
literal|"output"
argument_list|,
name|node
argument_list|,
literal|"aux"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exponent_map
condition|)
block|{
name|GeglNode
modifier|*
name|src_node
decl_stmt|;
name|src_node
operator|=
name|create_buffer_source_node
argument_list|(
name|node
argument_list|,
name|exponent_map
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|src_node
argument_list|,
literal|"output"
argument_list|,
name|node
argument_list|,
literal|"aux2"
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Oilify"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_papertile_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_papertile_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|tile_size
decl_stmt|;
name|gdouble
name|move_max
decl_stmt|;
name|gint
name|fractional_type
decl_stmt|;
name|gboolean
name|wrap_around
decl_stmt|;
name|gboolean
name|centering
decl_stmt|;
name|gint
name|background_type
decl_stmt|;
name|GimpRGB
name|background_color
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|tile_size
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|move_max
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|fractional_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_around
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|centering
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|background_type
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_value_get_rgb
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|,
operator|&
name|background_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
decl_stmt|;
name|gint
name|bg_type
decl_stmt|;
switch|switch
condition|(
name|background_type
condition|)
block|{
default|default:
name|bg_type
operator|=
name|background_type
expr_stmt|;
name|gimp_rgba_set
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bg_type
operator|=
literal|3
expr_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bg_type
operator|=
literal|3
expr_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|bg_type
operator|=
literal|3
expr_stmt|;
name|color
operator|=
name|background_color
expr_stmt|;
break|break;
block|}
name|gegl_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:tile-paper"
argument_list|,
literal|"tile-width"
argument_list|,
name|tile_size
argument_list|,
literal|"tile-height"
argument_list|,
name|tile_size
argument_list|,
literal|"move-rate"
argument_list|,
name|move_max
argument_list|,
literal|"bg-color"
argument_list|,
name|gegl_color
argument_list|,
literal|"centering"
argument_list|,
name|centering
argument_list|,
literal|"wrap-around"
argument_list|,
name|wrap_around
argument_list|,
literal|"background-type"
argument_list|,
name|bg_type
argument_list|,
literal|"fractional-type"
argument_list|,
name|fractional_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Paper Tile"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_photocopy_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_photocopy_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|mask_radius
decl_stmt|;
name|gdouble
name|sharpness
decl_stmt|;
name|gdouble
name|pct_black
decl_stmt|;
name|gdouble
name|pct_white
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|mask_radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|sharpness
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|pct_black
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|pct_white
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:photocopy"
argument_list|,
literal|"mask-radius"
argument_list|,
name|mask_radius
argument_list|,
literal|"sharpness"
argument_list|,
name|sharpness
argument_list|,
literal|"black"
argument_list|,
name|pct_black
argument_list|,
literal|"white"
argument_list|,
name|pct_white
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Photocopy"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_pixelize_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_pixelize_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|pixel_width
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|pixel_width
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:pixelize"
argument_list|,
literal|"size-x"
argument_list|,
name|pixel_width
argument_list|,
literal|"size-y"
argument_list|,
name|pixel_width
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Pixelize"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_pixelize2_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_pixelize2_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|pixel_width
decl_stmt|;
name|gint
name|pixel_height
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|pixel_width
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_height
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:pixelize"
argument_list|,
literal|"size-x"
argument_list|,
name|pixel_width
argument_list|,
literal|"size-y"
argument_list|,
name|pixel_height
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Pixelize"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_plasma_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_plasma_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|gdouble
name|turbulence
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|turbulence
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:plasma"
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"turbulence"
argument_list|,
name|turbulence
argument_list|,
literal|"x"
argument_list|,
name|x
argument_list|,
literal|"y"
argument_list|,
name|y
argument_list|,
literal|"width"
argument_list|,
name|width
argument_list|,
literal|"height"
argument_list|,
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Plasma"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_polar_coords_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_polar_coords_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|circle
decl_stmt|;
name|gdouble
name|angle
decl_stmt|;
name|gboolean
name|backwards
decl_stmt|;
name|gboolean
name|inverse
decl_stmt|;
name|gboolean
name|polrec
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|circle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|angle
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|backwards
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|inverse
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|polrec
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:polar-coordinates"
argument_list|,
literal|"depth"
argument_list|,
name|circle
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
literal|"bw"
argument_list|,
name|backwards
argument_list|,
comment|/* XXX name */
literal|"top"
argument_list|,
name|inverse
argument_list|,
literal|"polar"
argument_list|,
name|polrec
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|node
operator|=
name|wrap_in_selection_bounds
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Polar Coordinates"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_red_eye_removal_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_red_eye_removal_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|threshold
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|threshold
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:red-eye-removal"
argument_list|,
literal|"threshold"
argument_list|,
call|(
name|gdouble
call|)
argument_list|(
name|threshold
operator|-
literal|50
argument_list|)
operator|/
literal|50.0
operator|*
literal|0.2
operator|+
literal|0.4
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Red Eye Removal"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_randomize_hurl_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_randomize_hurl_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|rndm_pct
decl_stmt|;
name|gdouble
name|rndm_rcount
decl_stmt|;
name|gboolean
name|randomize
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|rndm_pct
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|rndm_rcount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|randomize
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|randomize
condition|)
name|seed
operator|=
operator|(
name|gint32
operator|)
name|g_random_int
argument_list|()
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-hurl"
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"pct-random"
argument_list|,
name|rndm_pct
argument_list|,
literal|"repeat"
argument_list|,
operator|(
name|gint
operator|)
name|rndm_rcount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Random Hurl"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_randomize_pick_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_randomize_pick_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|rndm_pct
decl_stmt|;
name|gdouble
name|rndm_rcount
decl_stmt|;
name|gboolean
name|randomize
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|rndm_pct
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|rndm_rcount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|randomize
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|randomize
condition|)
name|seed
operator|=
operator|(
name|gint32
operator|)
name|g_random_int
argument_list|()
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-pick"
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"pct-random"
argument_list|,
name|rndm_pct
argument_list|,
literal|"repeat"
argument_list|,
operator|(
name|gint
operator|)
name|rndm_rcount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Random Pick"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_randomize_slur_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_randomize_slur_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|rndm_pct
decl_stmt|;
name|gdouble
name|rndm_rcount
decl_stmt|;
name|gboolean
name|randomize
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|rndm_pct
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|rndm_rcount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|randomize
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|randomize
condition|)
name|seed
operator|=
operator|(
name|gint32
operator|)
name|g_random_int
argument_list|()
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-slur"
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"pct-random"
argument_list|,
name|rndm_pct
argument_list|,
literal|"repeat"
argument_list|,
operator|(
name|gint
operator|)
name|rndm_rcount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Random Slur"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_rgb_noise_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_rgb_noise_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|independent
decl_stmt|;
name|gboolean
name|correlated
decl_stmt|;
name|gdouble
name|noise_1
decl_stmt|;
name|gdouble
name|noise_2
decl_stmt|;
name|gdouble
name|noise_3
decl_stmt|;
name|gdouble
name|noise_4
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|independent
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|correlated
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|noise_1
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|noise_2
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|noise_3
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|noise_4
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gdouble
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|r
operator|=
name|noise_1
expr_stmt|;
name|g
operator|=
name|noise_1
expr_stmt|;
name|b
operator|=
name|noise_1
expr_stmt|;
name|a
operator|=
name|noise_2
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|noise_1
expr_stmt|;
name|g
operator|=
name|noise_2
expr_stmt|;
name|b
operator|=
name|noise_3
expr_stmt|;
name|a
operator|=
name|noise_4
expr_stmt|;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-rgb"
argument_list|,
literal|"correlated"
argument_list|,
name|correlated
argument_list|,
literal|"independent"
argument_list|,
name|independent
argument_list|,
literal|"red"
argument_list|,
name|r
argument_list|,
literal|"green"
argument_list|,
name|g
argument_list|,
literal|"blue"
argument_list|,
name|b
argument_list|,
literal|"alpha"
argument_list|,
name|a
argument_list|,
literal|"seed"
argument_list|,
name|g_random_int
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"RGB Noise"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_ripple_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_ripple_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|period
decl_stmt|;
name|gint
name|amplitude
decl_stmt|;
name|gint
name|orientation
decl_stmt|;
name|gint
name|edges
decl_stmt|;
name|gint
name|waveform
decl_stmt|;
name|gboolean
name|antialias
decl_stmt|;
name|gboolean
name|tile
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|period
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|amplitude
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|orientation
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|edges
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|waveform
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|antialias
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|tile
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gdouble
name|angle
decl_stmt|,
name|phi
decl_stmt|;
name|angle
operator|=
name|orientation
condition|?
literal|0.0
else|:
literal|90.0
expr_stmt|;
name|phi
operator|=
name|waveform
condition|?
literal|0.0
else|:
literal|0.75
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
literal|0
operator|&&
name|waveform
operator|==
literal|1
condition|)
name|phi
operator|=
literal|0.5
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:ripple"
argument_list|,
literal|"amplitude"
argument_list|,
operator|(
name|gdouble
operator|)
name|amplitude
argument_list|,
literal|"period"
argument_list|,
operator|(
name|gdouble
operator|)
name|period
argument_list|,
literal|"phi"
argument_list|,
name|phi
argument_list|,
literal|"angle"
argument_list|,
name|angle
argument_list|,
literal|"sampler_type"
argument_list|,
name|antialias
condition|?
name|GEGL_SAMPLER_CUBIC
else|:
name|GEGL_SAMPLER_NEAREST
argument_list|,
literal|"wave_type"
argument_list|,
name|waveform
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|"abyss_policy"
argument_list|,
name|edges
operator|==
literal|0
condition|?
name|GEGL_ABYSS_CLAMP
else|:
name|edges
operator|==
literal|1
condition|?
name|GEGL_ABYSS_LOOP
else|:
name|GEGL_ABYSS_NONE
argument_list|,
literal|"tileable"
argument_list|,
name|tile
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Ripple"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_rotate_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_rotate_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|angle
decl_stmt|;
name|gboolean
name|everything
decl_stmt|;
name|image
operator|=
name|gimp_value_get_image
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|angle
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|everything
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpRotationType
name|rotate_type
init|=
name|angle
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|everything
condition|)
block|{
name|gimp_image_rotate
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|rotate_type
argument_list|,
name|progress
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gdouble
name|center_x
decl_stmt|,
name|center_y
decl_stmt|;
name|gimp_item_get_offset
argument_list|(
name|item
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|center_x
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|off_x
operator|+
operator|(
name|gdouble
operator|)
name|gimp_item_get_width
argument_list|(
name|item
argument_list|)
operator|/
literal|2.0
operator|)
expr_stmt|;
name|center_y
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|off_y
operator|+
operator|(
name|gdouble
operator|)
name|gimp_item_get_height
argument_list|(
name|item
argument_list|)
operator|/
literal|2.0
operator|)
expr_stmt|;
name|gimp_item_rotate
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_noisify_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_noisify_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|independent
decl_stmt|;
name|gdouble
name|noise_1
decl_stmt|;
name|gdouble
name|noise_2
decl_stmt|;
name|gdouble
name|noise_3
decl_stmt|;
name|gdouble
name|noise_4
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|independent
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|noise_1
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|noise_2
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|noise_3
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|noise_4
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gdouble
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|r
operator|=
name|noise_1
expr_stmt|;
name|g
operator|=
name|noise_1
expr_stmt|;
name|b
operator|=
name|noise_1
expr_stmt|;
name|a
operator|=
name|noise_2
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|noise_1
expr_stmt|;
name|g
operator|=
name|noise_2
expr_stmt|;
name|b
operator|=
name|noise_3
expr_stmt|;
name|a
operator|=
name|noise_4
expr_stmt|;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-rgb"
argument_list|,
literal|"correlated"
argument_list|,
name|FALSE
argument_list|,
literal|"independent"
argument_list|,
name|independent
argument_list|,
literal|"red"
argument_list|,
name|r
argument_list|,
literal|"green"
argument_list|,
name|g
argument_list|,
literal|"blue"
argument_list|,
name|b
argument_list|,
literal|"alpha"
argument_list|,
name|a
argument_list|,
literal|"seed"
argument_list|,
name|g_random_int
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Noisify"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_sel_gauss_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_sel_gauss_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|gint
name|max_delta
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|max_delta
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:gaussian-blur-selective"
argument_list|,
literal|"blur-radius"
argument_list|,
name|radius
argument_list|,
literal|"max-delta"
argument_list|,
operator|(
name|gdouble
operator|)
name|max_delta
operator|/
literal|255.0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Selective Gaussian Blur"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_semiflatten_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_semiflatten_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gimp:semi-flatten"
argument_list|,
literal|"color"
argument_list|,
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Semi-Flatten"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_shift_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_shift_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|shift_amount
decl_stmt|;
name|gint
name|orientation
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|shift_amount
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|orientation
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:shift"
argument_list|,
literal|"shift"
argument_list|,
name|shift_amount
operator|/
literal|2
argument_list|,
literal|"direction"
argument_list|,
name|orientation
condition|?
literal|0
else|:
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Shift"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_sinus_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_sinus_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|xscale
decl_stmt|;
name|gdouble
name|yscale
decl_stmt|;
name|gdouble
name|complex
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|gboolean
name|tiling
decl_stmt|;
name|gboolean
name|perturb
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|GimpRGB
name|col1
decl_stmt|;
name|GimpRGB
name|col2
decl_stmt|;
name|gdouble
name|alpha1
decl_stmt|;
name|gdouble
name|alpha2
decl_stmt|;
name|gint
name|blend
decl_stmt|;
name|gdouble
name|blend_power
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|xscale
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|yscale
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|complex
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|tiling
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|perturb
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|colors
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_value_get_rgb
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|10
argument_list|)
argument_list|,
operator|&
name|col1
argument_list|)
expr_stmt|;
name|gimp_value_get_rgb
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|11
argument_list|)
argument_list|,
operator|&
name|col2
argument_list|)
expr_stmt|;
name|alpha1
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|alpha2
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|blend
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|14
argument_list|)
argument_list|)
expr_stmt|;
name|blend_power
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color1
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color2
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
switch|switch
condition|(
name|colors
condition|)
block|{
case|case
literal|0
case|:
name|gimp_rgb_set
argument_list|(
operator|&
name|col1
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gimp_rgb_set
argument_list|(
operator|&
name|col2
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|col1
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|col2
argument_list|)
expr_stmt|;
break|break;
block|}
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|col1
argument_list|,
name|alpha1
argument_list|)
expr_stmt|;
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|col2
argument_list|,
name|alpha2
argument_list|)
expr_stmt|;
name|gegl_color1
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|col1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_color2
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|col2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:sinus"
argument_list|,
literal|"x_scale"
argument_list|,
name|xscale
argument_list|,
literal|"y-scale"
argument_list|,
name|yscale
argument_list|,
literal|"complexity"
argument_list|,
name|complex
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"tiling"
argument_list|,
name|tiling
argument_list|,
literal|"perturbation"
argument_list|,
name|perturb
argument_list|,
literal|"color1"
argument_list|,
name|gegl_color1
argument_list|,
literal|"color2"
argument_list|,
name|gegl_color2
argument_list|,
literal|"blend-mode"
argument_list|,
name|blend
argument_list|,
literal|"blend-power"
argument_list|,
name|blend_power
argument_list|,
literal|"width"
argument_list|,
name|width
argument_list|,
literal|"height"
argument_list|,
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color1
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|gegl_color2
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Sinus"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_sobel_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_sobel_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|horizontal
decl_stmt|;
name|gboolean
name|vertical
decl_stmt|;
name|gboolean
name|keep_sign
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|horizontal
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|vertical
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|keep_sign
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:edge-sobel"
argument_list|,
literal|"horizontal"
argument_list|,
name|horizontal
argument_list|,
literal|"vertical"
argument_list|,
name|vertical
argument_list|,
literal|"keep-sign"
argument_list|,
name|keep_sign
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Sobel"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_softglow_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_softglow_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|glow_radius
decl_stmt|;
name|gdouble
name|brightness
decl_stmt|;
name|gdouble
name|sharpness
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|glow_radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|brightness
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|sharpness
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:softglow"
argument_list|,
literal|"glow-radius"
argument_list|,
name|glow_radius
argument_list|,
literal|"brightness"
argument_list|,
name|brightness
argument_list|,
literal|"sharpness"
argument_list|,
name|sharpness
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|node
operator|=
name|wrap_in_gamma_cast
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Softglow"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_solid_noise_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_solid_noise_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|tileable
decl_stmt|;
name|gboolean
name|turbulent
decl_stmt|;
name|gint
name|seed
decl_stmt|;
name|gint
name|detail
decl_stmt|;
name|gdouble
name|xsize
decl_stmt|;
name|gdouble
name|ysize
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|tileable
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|turbulent
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|seed
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|detail
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|xsize
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|ysize
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-solid"
argument_list|,
literal|"x-size"
argument_list|,
name|xsize
argument_list|,
literal|"y-size"
argument_list|,
name|ysize
argument_list|,
literal|"detail"
argument_list|,
name|detail
argument_list|,
literal|"tileable"
argument_list|,
name|tileable
argument_list|,
literal|"turbulent"
argument_list|,
name|turbulent
argument_list|,
literal|"seed"
argument_list|,
name|seed
argument_list|,
literal|"width"
argument_list|,
name|width
argument_list|,
literal|"height"
argument_list|,
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Solid Noise"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_spread_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_spread_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|spread_amount_x
decl_stmt|;
name|gdouble
name|spread_amount_y
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|spread_amount_x
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|spread_amount_y
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:noise-spread"
argument_list|,
literal|"amount-x"
argument_list|,
operator|(
name|gint
operator|)
name|spread_amount_x
argument_list|,
literal|"amount-y"
argument_list|,
operator|(
name|gint
operator|)
name|spread_amount_y
argument_list|,
literal|"seed"
argument_list|,
name|g_random_int
argument_list|()
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Spread"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_threshold_alpha_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_threshold_alpha_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|threshold
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|threshold
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gimp:threshold-alpha"
argument_list|,
literal|"value"
argument_list|,
name|threshold
operator|/
literal|255.0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Threshold Alpha"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_unsharp_mask_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_unsharp_mask_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|gdouble
name|amount
decl_stmt|;
name|gint
name|threshold
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|amount
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|threshold
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:unsharp-mask"
argument_list|,
literal|"std-dev"
argument_list|,
name|radius
argument_list|,
literal|"scale"
argument_list|,
name|amount
argument_list|,
literal|"threshold"
argument_list|,
name|threshold
operator|/
literal|255.0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Sharpen (Unsharp Mask)"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_video_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_video_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|pattern_number
decl_stmt|;
name|gboolean
name|additive
decl_stmt|;
name|gboolean
name|rotated
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|pattern_number
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|additive
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|rotated
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:video-degradation"
argument_list|,
literal|"pattern"
argument_list|,
name|pattern_number
argument_list|,
literal|"additive"
argument_list|,
name|additive
argument_list|,
literal|"rotated"
argument_list|,
name|rotated
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Video"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_vinvert_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_vinvert_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:value-invert"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Value Invert"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_vpropagate_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_vpropagate_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|propagate_mode
decl_stmt|;
name|gint
name|propagating_channel
decl_stmt|;
name|gdouble
name|propagating_rate
decl_stmt|;
name|gint
name|direction_mask
decl_stmt|;
name|gint
name|lower_limit
decl_stmt|;
name|gint
name|upper_limit
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|propagate_mode
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|propagating_channel
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|propagating_rate
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|direction_mask
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|lower_limit
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|upper_limit
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|GeglColor
modifier|*
name|gegl_color
init|=
name|NULL
decl_stmt|;
name|gint
name|gegl_mode
init|=
literal|0
decl_stmt|;
name|gboolean
name|to_left
init|=
operator|(
name|direction_mask
operator|&
operator|(
literal|0x1
operator|<<
literal|0
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|gboolean
name|to_top
init|=
operator|(
name|direction_mask
operator|&
operator|(
literal|0x1
operator|<<
literal|1
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|gboolean
name|to_right
init|=
operator|(
name|direction_mask
operator|&
operator|(
literal|0x1
operator|<<
literal|2
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|gboolean
name|to_bottom
init|=
operator|(
name|direction_mask
operator|&
operator|(
literal|0x1
operator|<<
literal|3
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|gboolean
name|value
init|=
operator|(
name|propagating_channel
operator|&
operator|(
literal|0x1
operator|<<
literal|0
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|gboolean
name|alpha
init|=
operator|(
name|propagating_channel
operator|&
operator|(
literal|0x1
operator|<<
literal|1
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
switch|switch
condition|(
name|propagate_mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
name|gegl_mode
operator|=
name|propagate_mode
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|gegl_mode
operator|=
name|propagate_mode
expr_stmt|;
comment|/* fall thru */
case|case
literal|4
case|:
case|case
literal|5
case|:
name|gegl_mode
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|propagate_mode
operator|!=
literal|3
condition|)
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
else|else
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gegl_color
operator|=
name|gimp_gegl_color_new
argument_list|(
operator|&
name|color
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|gegl_mode
operator|=
name|propagate_mode
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:value-propagate"
argument_list|,
literal|"mode"
argument_list|,
name|gegl_mode
argument_list|,
literal|"lower-threshold"
argument_list|,
operator|(
name|gdouble
operator|)
name|lower_limit
operator|/
literal|255.0
argument_list|,
literal|"upper-threshold"
argument_list|,
operator|(
name|gdouble
operator|)
name|upper_limit
operator|/
literal|255.0
argument_list|,
literal|"rate"
argument_list|,
name|propagating_rate
argument_list|,
literal|"color"
argument_list|,
name|gegl_color
argument_list|,
literal|"top"
argument_list|,
name|to_top
argument_list|,
literal|"left"
argument_list|,
name|to_left
argument_list|,
literal|"right"
argument_list|,
name|to_right
argument_list|,
literal|"bottom"
argument_list|,
name|to_bottom
argument_list|,
literal|"value"
argument_list|,
name|value
argument_list|,
literal|"alpha"
argument_list|,
name|alpha
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gegl_color
condition|)
name|g_object_unref
argument_list|(
name|gegl_color
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Value Propagate"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_dilate_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_dilate_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:value-propagate"
argument_list|,
literal|"mode"
argument_list|,
literal|0
argument_list|,
comment|/* GEGL_VALUE_PROPAGATE_MODE_WHITE */
literal|"lower-threshold"
argument_list|,
literal|0.0
argument_list|,
literal|"upper-threshold"
argument_list|,
literal|1.0
argument_list|,
literal|"rate"
argument_list|,
literal|1.0
argument_list|,
literal|"top"
argument_list|,
name|TRUE
argument_list|,
literal|"left"
argument_list|,
name|TRUE
argument_list|,
literal|"right"
argument_list|,
name|TRUE
argument_list|,
literal|"bottom"
argument_list|,
name|TRUE
argument_list|,
literal|"value"
argument_list|,
name|TRUE
argument_list|,
literal|"alpha"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Dilate"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_erode_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_erode_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:value-propagate"
argument_list|,
literal|"mode"
argument_list|,
literal|1
argument_list|,
comment|/* GEGL_VALUE_PROPAGATE_MODE_BLACK */
literal|"lower-threshold"
argument_list|,
literal|0.0
argument_list|,
literal|"upper-threshold"
argument_list|,
literal|1.0
argument_list|,
literal|"rate"
argument_list|,
literal|1.0
argument_list|,
literal|"top"
argument_list|,
name|TRUE
argument_list|,
literal|"left"
argument_list|,
name|TRUE
argument_list|,
literal|"right"
argument_list|,
name|TRUE
argument_list|,
literal|"bottom"
argument_list|,
name|TRUE
argument_list|,
literal|"value"
argument_list|,
name|TRUE
argument_list|,
literal|"alpha"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Erode"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_waves_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_waves_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|amplitude
decl_stmt|;
name|gdouble
name|phase
decl_stmt|;
name|gdouble
name|wavelength
decl_stmt|;
name|gboolean
name|type
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|amplitude
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|phase
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|wavelength
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|g_value_get_boolean
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
decl_stmt|;
name|gdouble
name|width
init|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gdouble
name|height
init|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gdouble
name|aspect
decl_stmt|;
while|while
condition|(
name|phase
operator|<
literal|0
condition|)
name|phase
operator|+=
literal|360.0
expr_stmt|;
name|phase
operator|=
name|fmod
argument_list|(
name|phase
argument_list|,
literal|360.0
argument_list|)
expr_stmt|;
name|aspect
operator|=
name|CLAMP
argument_list|(
name|width
operator|/
name|height
argument_list|,
literal|0.1
argument_list|,
literal|10.0
argument_list|)
expr_stmt|;
name|node
operator|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:waves"
argument_list|,
literal|"x"
argument_list|,
literal|0.5
argument_list|,
literal|"y"
argument_list|,
literal|0.5
argument_list|,
literal|"amplitude"
argument_list|,
name|amplitude
argument_list|,
literal|"phi"
argument_list|,
operator|(
name|phase
operator|-
literal|180.0
operator|)
operator|/
literal|180.0
argument_list|,
literal|"period"
argument_list|,
name|wavelength
operator|*
literal|2.0
argument_list|,
literal|"aspect"
argument_list|,
name|aspect
argument_list|,
literal|"clamp"
argument_list|,
operator|!
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Waves"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_whirl_pinch_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_whirl_pinch_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|whirl
decl_stmt|;
name|gdouble
name|pinch
decl_stmt|;
name|gdouble
name|radius
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|whirl
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|pinch
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|radius
operator|=
name|g_value_get_double
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:whirl-pinch"
argument_list|,
literal|"whirl"
argument_list|,
name|whirl
argument_list|,
literal|"pinch"
argument_list|,
name|pinch
argument_list|,
literal|"radius"
argument_list|,
name|radius
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|node
operator|=
name|wrap_in_selection_bounds
argument_list|(
name|node
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Whirl and Pinch"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|plug_in_wind_invoker (GimpProcedure * procedure,Gimp * gimp,GimpContext * context,GimpProgress * progress,const GimpValueArray * args,GError ** error)
name|plug_in_wind_invoker
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|threshold
decl_stmt|;
name|gint
name|direction
decl_stmt|;
name|gint
name|strength
decl_stmt|;
name|gint
name|algorithm
decl_stmt|;
name|gint
name|edge
decl_stmt|;
name|drawable
operator|=
name|gimp_value_get_drawable
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gimp
argument_list|)
expr_stmt|;
name|threshold
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|direction
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|strength
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|algorithm
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|edge
operator|=
name|g_value_get_int
argument_list|(
name|gimp_value_array_index
argument_list|(
name|args
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimp_pdb_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PDB_ITEM_CONTENT
argument_list|,
name|error
argument_list|)
operator|&&
name|gimp_pdb_item_is_not_group
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|GeglNode
modifier|*
name|node
init|=
name|gegl_node_new_child
argument_list|(
name|NULL
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:wind"
argument_list|,
literal|"threshold"
argument_list|,
name|threshold
argument_list|,
literal|"direction"
argument_list|,
name|direction
argument_list|,
literal|"strength"
argument_list|,
name|strength
argument_list|,
literal|"style"
argument_list|,
name|algorithm
argument_list|,
literal|"edge"
argument_list|,
name|edge
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gimp_drawable_apply_operation
argument_list|(
name|drawable
argument_list|,
name|progress
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Wind"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|gimp_procedure_get_return_values
argument_list|(
name|procedure
argument_list|,
name|success
argument_list|,
name|error
condition|?
operator|*
name|error
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|register_plug_in_compat_procs (GimpPDB * pdb)
name|register_plug_in_compat_procs
parameter_list|(
name|GimpPDB
modifier|*
name|pdb
parameter_list|)
block|{
name|GimpProcedure
modifier|*
name|procedure
decl_stmt|;
comment|/*    * gimp-plug-in-alienmap2    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_alienmap2_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-alienmap2"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-alienmap2"
argument_list|,
literal|"Alter colors in various psychedelic ways"
argument_list|,
literal|"No help yet. Just try it and you'll see!"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:alien-map' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:alien-map' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"redfrequency"
argument_list|,
literal|"redfrequency"
argument_list|,
literal|"Red/hue component frequency factor"
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"redangle"
argument_list|,
literal|"redangle"
argument_list|,
literal|"Red/hue component angle factor (0-360)"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"greenfrequency"
argument_list|,
literal|"greenfrequency"
argument_list|,
literal|"Green/saturation component frequency factor"
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"greenangle"
argument_list|,
literal|"greenangle"
argument_list|,
literal|"Green/saturation component angle factor (0-360)"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"bluefrequency"
argument_list|,
literal|"bluefrequency"
argument_list|,
literal|"Blue/luminance component frequency factor"
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"blueangle"
argument_list|,
literal|"blueangle"
argument_list|,
literal|"Blue/luminance component angle factor (0-360)"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"colormodel"
argument_list|,
literal|"colormodel"
argument_list|,
literal|"Color model { RGB-MODEL (0), HSL-MODEL (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"redmode"
argument_list|,
literal|"redmode"
argument_list|,
literal|"Red/hue application mode { TRUE, FALSE }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"greenmode"
argument_list|,
literal|"greenmode"
argument_list|,
literal|"Green/saturation application mode { TRUE, FALSE }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"bluemode"
argument_list|,
literal|"bluemode"
argument_list|,
literal|"Blue/luminance application mode { TRUE, FALSE }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-antialias    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_antialias_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-antialias"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-antialias"
argument_list|,
literal|"Antialias using the Scale3X edge-extrapolation algorithm"
argument_list|,
literal|"No more help."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:antialias' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:antialias' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-apply-canvas    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_apply_canvas_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-apply-canvas"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-apply-canvas"
argument_list|,
literal|"Add a canvas texture to the image"
argument_list|,
literal|"This function applies a canvas texture map to the drawable."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:texturize-canvas' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:texturize-canvas' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"direction"
argument_list|,
literal|"direction"
argument_list|,
literal|"Light direction (0 - 3)"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"depth"
argument_list|,
literal|"depth"
argument_list|,
literal|"Texture depth (1 - 50)"
argument_list|,
literal|1
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-applylens    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_applylens_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-applylens"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-applylens"
argument_list|,
literal|"Simulate an elliptical lens over the image"
argument_list|,
literal|"This plug-in uses Snell's law to draw an ellipsoid lens over the image."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:apply-lens' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:apply-lens' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"refraction"
argument_list|,
literal|"refraction"
argument_list|,
literal|"Lens refraction index"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"keep-surroundings"
argument_list|,
literal|"keep surroundings"
argument_list|,
literal|"Keep lens surroundings"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"set-background"
argument_list|,
literal|"set background"
argument_list|,
literal|"Set lens surroundings to BG value"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"set-transparent"
argument_list|,
literal|"set transparent"
argument_list|,
literal|"Set lens surroundings transparent"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-autocrop    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_autocrop_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-autocrop"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-autocrop"
argument_list|,
literal|"Remove empty borders from the image"
argument_list|,
literal|"Remove empty borders from the image."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-autocrop-layer    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_autocrop_layer_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-autocrop-layer"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-autocrop-layer"
argument_list|,
literal|"Crop the active layer based on empty borders of the input drawable"
argument_list|,
literal|"Crop the active layer of the input \"image\" based on empty borders of the input \"drawable\". \n\nThe input drawable serves as a base for detecting cropping extents (transparency or background color), and is not necessarily the cropped layer (the current active layer)."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-autostretch-hsv    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_autostretch_hsv_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-autostretch-hsv"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-autostretch-hsv"
argument_list|,
literal|"Stretch contrast to cover the maximum possible range"
argument_list|,
literal|"This simple plug-in does an automatic contrast stretch. For each channel in the image, it finds the minimum and maximum values... it uses those values to stretch the individual histograms to the full contrast range. For some images it may do just what you want; for others it may be total crap :). This version differs from Contrast Autostretch in that it works in HSV space, and preserves hue."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast-hsv' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast-hsv' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-bump-map    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_bump_map_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-bump-map"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-bump-map"
argument_list|,
literal|"Create an embossing effect using a bump map"
argument_list|,
literal|"This plug-in uses the algorithm described by John Schlag, \"Fast Embossing Effects on Raster Image Data\" in Graphics GEMS IV (ISBN 0-12-336155-9). It takes a drawable to be applied as a bump map to another image and produces a nice embossing effect."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:bump-map' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:bump-map' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"bumpmap"
argument_list|,
literal|"bumpmap"
argument_list|,
literal|"Bump map drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"azimuth"
argument_list|,
literal|"azimuth"
argument_list|,
literal|"Azimuth"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"elevation"
argument_list|,
literal|"elevation"
argument_list|,
literal|"Elevation"
argument_list|,
literal|0.5
argument_list|,
literal|90.0
argument_list|,
literal|0.5
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"depth"
argument_list|,
literal|"depth"
argument_list|,
literal|"Depth"
argument_list|,
literal|1
argument_list|,
literal|65
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"xofs"
argument_list|,
literal|"xofs"
argument_list|,
literal|"X offset"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"yofs"
argument_list|,
literal|"yofs"
argument_list|,
literal|"Y offset"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"waterlevel"
argument_list|,
literal|"waterlevel"
argument_list|,
literal|"Level that full transparency should represent"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"ambient"
argument_list|,
literal|"ambient"
argument_list|,
literal|"Ambient lighting factor"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"compensate"
argument_list|,
literal|"compensate"
argument_list|,
literal|"Compensate for darkening"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"invert"
argument_list|,
literal|"invert"
argument_list|,
literal|"Invert bumpmap"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Type of map { LINEAR (0), SPHERICAL (1), SINUSOIDAL (2) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-bump-map-tiled    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_bump_map_tiled_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-bump-map-tiled"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-bump-map-tiled"
argument_list|,
literal|"Create an embossing effect using a tiled image as a bump map"
argument_list|,
literal|"This plug-in uses the algorithm described by John Schlag, \"Fast Embossing Effects on Raster Image Data\" in Graphics GEMS IV (ISBN 0-12-336155-9). It takes a drawable to be tiled and applied as a bump map to another image and produces a nice embossing effect."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:bump-map' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:bump-map' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"bumpmap"
argument_list|,
literal|"bumpmap"
argument_list|,
literal|"Bump map drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"azimuth"
argument_list|,
literal|"azimuth"
argument_list|,
literal|"Azimuth"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"elevation"
argument_list|,
literal|"elevation"
argument_list|,
literal|"Elevation"
argument_list|,
literal|0.5
argument_list|,
literal|90.0
argument_list|,
literal|0.5
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"depth"
argument_list|,
literal|"depth"
argument_list|,
literal|"Depth"
argument_list|,
literal|1
argument_list|,
literal|65
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"xofs"
argument_list|,
literal|"xofs"
argument_list|,
literal|"X offset"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"yofs"
argument_list|,
literal|"yofs"
argument_list|,
literal|"Y offset"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"waterlevel"
argument_list|,
literal|"waterlevel"
argument_list|,
literal|"Level that full transparency should represent"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"ambient"
argument_list|,
literal|"ambient"
argument_list|,
literal|"Ambient lighting factor"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"compensate"
argument_list|,
literal|"compensate"
argument_list|,
literal|"Compensate for darkening"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"invert"
argument_list|,
literal|"invert"
argument_list|,
literal|"Invert bumpmap"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Type of map { LINEAR (0), SPHERICAL (1), SINUSOIDAL (2) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-c-astretch    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_c_astretch_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-c-astretch"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-c-astretch"
argument_list|,
literal|"Stretch contrast to cover the maximum possible range"
argument_list|,
literal|"This simple plug-in does an automatic contrast stretch. For each channel in the image, it finds the minimum and maximum values... it uses those values to stretch the individual histograms to the full contrast range. For some images it may do just what you want; for others it may not work that well."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-cartoon    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_cartoon_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-cartoon"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-cartoon"
argument_list|,
literal|"Simulate a cartoon by enhancing edges"
argument_list|,
literal|"Propagates dark values in an image based on each pixel's relative darkness to a neighboring average. The idea behind this filter is to give the look of a black felt pen drawing subsequently shaded with color. This is achieved by darkening areas of the image which are measured to be darker than a neighborhood average. In this way, sufficiently large shifts in intensity are darkened to black. The rate at which they are darkened to black is determined by the second pct_black parameter. The mask_radius parameter controls the size of the pixel neighborhood over which the average intensity is computed and then compared to each pixel in the neighborhood to decide whether or not to darken it to black. Large values for mask_radius result in very thick black areas bordering the shaded regions of color and much less detail for black areas everywhere including inside regions of color. Small values result in more subtle pen strokes and detail everywhere. Small values for the pct_black make the\n"
literal|"blend from the color regions to the black border lines smoother and the lines themselves thinner and less noticeable; larger values achieve the opposite effect."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:cartoon' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:cartoon' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"mask-radius"
argument_list|,
literal|"mask radius"
argument_list|,
literal|"Cartoon mask radius (radius of pixel neighborhood)"
argument_list|,
literal|1.0
argument_list|,
literal|50.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"pct-black"
argument_list|,
literal|"pct black"
argument_list|,
literal|"Percentage of darkened pixels to set to black"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-colors-channel-mixer    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_colors_channel_mixer_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-colors-channel-mixer"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-colors-channel-mixer"
argument_list|,
literal|"Alter colors by mixing RGB Channels"
argument_list|,
literal|"This plug-in mixes the RGB channels."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:channel-mixer' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:channel-mixer' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"monochrome"
argument_list|,
literal|"monochrome"
argument_list|,
literal|"Monochrome { TRUE, FALSE }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rr-gain"
argument_list|,
literal|"rr gain"
argument_list|,
literal|"Set the red gain for the red channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rg-gain"
argument_list|,
literal|"rg gain"
argument_list|,
literal|"Set the green gain for the red channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rb-gain"
argument_list|,
literal|"rb gain"
argument_list|,
literal|"Set the blue gain for the red channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"gr-gain"
argument_list|,
literal|"gr gain"
argument_list|,
literal|"Set the red gain for the green channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"gg-gain"
argument_list|,
literal|"gg gain"
argument_list|,
literal|"Set the green gain for the green channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"gb-gain"
argument_list|,
literal|"gb gain"
argument_list|,
literal|"Set the blue gain for the green channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"br-gain"
argument_list|,
literal|"br gain"
argument_list|,
literal|"Set the red gain for the blue channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"bg-gain"
argument_list|,
literal|"bg gain"
argument_list|,
literal|"Set the green gain for the blue channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"bb-gain"
argument_list|,
literal|"bb gain"
argument_list|,
literal|"Set the blue gain for the blue channel"
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-colortoalpha    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_colortoalpha_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-colortoalpha"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-colortoalpha"
argument_list|,
literal|"Convert a specified color to transparency"
argument_list|,
literal|"This replaces as much of a given color as possible in each pixel with a corresponding amount of alpha, then readjusts the color accordingly."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1999"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_rgb
argument_list|(
literal|"color"
argument_list|,
literal|"color"
argument_list|,
literal|"Color to remove"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-convmatrix    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_convmatrix_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-convmatrix"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-convmatrix"
argument_list|,
literal|"Apply a generic 5x5 convolution matrix"
argument_list|,
literal|"Apply a generic 5x5 convolution matrix."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:convolution-matrix' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:convolution-matrix' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"argc-matrix"
argument_list|,
literal|"argc matrix"
argument_list|,
literal|"The number of elements in the following array, must always be 25"
argument_list|,
literal|0
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_float_array
argument_list|(
literal|"matrix"
argument_list|,
literal|"matrix"
argument_list|,
literal|"The 5x5 convolution matrix"
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"alpha-alg"
argument_list|,
literal|"alpha alg"
argument_list|,
literal|"Enable weighting by alpha channel"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"divisor"
argument_list|,
literal|"divisor"
argument_list|,
literal|"Divisor"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"offset"
argument_list|,
literal|"offset"
argument_list|,
literal|"Offset"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"argc-channels"
argument_list|,
literal|"argc channels"
argument_list|,
literal|"The number of elements in following array, must always be 5"
argument_list|,
literal|0
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_int32_array
argument_list|(
literal|"channels"
argument_list|,
literal|"channels"
argument_list|,
literal|"Mask of the channels to be filtered"
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"bmode"
argument_list|,
literal|"bmode"
argument_list|,
literal|"Mode for treating image borders { EXTEND (0), WRAP (1), CLEAR (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-cubism    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_cubism_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-cubism"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-cubism"
argument_list|,
literal|"Convert the image into randomly rotated square blobs"
argument_list|,
literal|"Convert the image into randomly rotated square blobs."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:cubism' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:cubism' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-size"
argument_list|,
literal|"tile size"
argument_list|,
literal|"Average diameter of each tile (in pixels)"
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-saturation"
argument_list|,
literal|"tile saturation"
argument_list|,
literal|"Expand tiles by this amount"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"bg-color"
argument_list|,
literal|"bg color"
argument_list|,
literal|"Background color { BLACK (0), BG (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-deinterlace    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_deinterlace_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-deinterlace"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-deinterlace"
argument_list|,
literal|"Fix images where every other row is missing"
argument_list|,
literal|"Deinterlace is useful for processing images from video capture cards. When only the odd or even fields get captured, deinterlace can be used to interpolate between the existing fields to correct this."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:deinterlace' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:deinterlace' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"evenodd"
argument_list|,
literal|"evenodd"
argument_list|,
literal|"Which lines to keep { KEEP-ODD (0), KEEP-EVEN (1)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-diffraction    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_diffraction_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-diffraction"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-diffraction"
argument_list|,
literal|"Generate diffraction patterns"
argument_list|,
literal|"Help? What help?"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:diffraction-patterns' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:diffraction-patterns' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"lam-r"
argument_list|,
literal|"lam r"
argument_list|,
literal|"Light frequency (red)"
argument_list|,
literal|0.0
argument_list|,
literal|20.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"lam-g"
argument_list|,
literal|"lam g"
argument_list|,
literal|"Light frequency (green)"
argument_list|,
literal|0.0
argument_list|,
literal|20.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"lam-b"
argument_list|,
literal|"lam b"
argument_list|,
literal|"Light frequency (blue)"
argument_list|,
literal|0.0
argument_list|,
literal|20.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"contour-r"
argument_list|,
literal|"contour r"
argument_list|,
literal|"Number of contours (red)"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"contour-g"
argument_list|,
literal|"contour g"
argument_list|,
literal|"Number of contours (green)"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"contour-b"
argument_list|,
literal|"contour b"
argument_list|,
literal|"Number of contours (blue)"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"edges-r"
argument_list|,
literal|"edges r"
argument_list|,
literal|"Number of sharp edges (red)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"edges-g"
argument_list|,
literal|"edges g"
argument_list|,
literal|"Number of sharp edges (green)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"edges-b"
argument_list|,
literal|"edges b"
argument_list|,
literal|"Number of sharp edges (blue)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"brightness"
argument_list|,
literal|"brightness"
argument_list|,
literal|"Brightness and shifting/fattening of contours"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"scattering"
argument_list|,
literal|"scattering"
argument_list|,
literal|"Scattering (Speed vs. quality)"
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"polarization"
argument_list|,
literal|"polarization"
argument_list|,
literal|"Polarization"
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-displace    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_displace_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-displace"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-displace"
argument_list|,
literal|"Displace pixels as indicated by displacement maps"
argument_list|,
literal|"Displaces the contents of the specified drawable by the amounts specified by 'amount-x' and 'amount-y' multiplied by the luminance of corresponding pixels in the 'displace-map' drawables."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:displace' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:displace' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount-x"
argument_list|,
literal|"amount x"
argument_list|,
literal|"Displace multiplier for x direction"
argument_list|,
operator|-
literal|500.0
argument_list|,
literal|500.0
argument_list|,
operator|-
literal|500.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount-y"
argument_list|,
literal|"amount y"
argument_list|,
literal|"Displace multiplier for y direction"
argument_list|,
operator|-
literal|500.0
argument_list|,
literal|500.0
argument_list|,
operator|-
literal|500.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"do-x"
argument_list|,
literal|"do x"
argument_list|,
literal|"Displace in x direction ?"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"do-y"
argument_list|,
literal|"do y"
argument_list|,
literal|"Displace in y direction ?"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"displace-map-x"
argument_list|,
literal|"displace map x"
argument_list|,
literal|"Displacement map for x direction"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"displace-map-y"
argument_list|,
literal|"displace map y"
argument_list|,
literal|"Displacement map for y direction"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"displace-type"
argument_list|,
literal|"displace type"
argument_list|,
literal|"Edge behavior { WRAP (1), SMEAR (2), BLACK (3) }"
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-displace-polar    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_displace_polar_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-displace-polar"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-displace-polar"
argument_list|,
literal|"Displace pixels as indicated by displacement maps"
argument_list|,
literal|"Just like plug-in-displace but working in polar coordinates. The drawable is whirled and pinched according to the map."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:displace' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:displace' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount-x"
argument_list|,
literal|"amount x"
argument_list|,
literal|"Displace multiplier for radial direction"
argument_list|,
operator|-
literal|500.0
argument_list|,
literal|500.0
argument_list|,
operator|-
literal|500.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount-y"
argument_list|,
literal|"amount y"
argument_list|,
literal|"Displace multiplier for tangent direction"
argument_list|,
operator|-
literal|500.0
argument_list|,
literal|500.0
argument_list|,
operator|-
literal|500.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"do-x"
argument_list|,
literal|"do x"
argument_list|,
literal|"Displace in radial direction ?"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"do-y"
argument_list|,
literal|"do y"
argument_list|,
literal|"Displace in tangent direction ?"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"displace-map-x"
argument_list|,
literal|"displace map x"
argument_list|,
literal|"Displacement map for radial direction"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"displace-map-y"
argument_list|,
literal|"displace map y"
argument_list|,
literal|"Displacement map for tangent direction"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"displace-type"
argument_list|,
literal|"displace type"
argument_list|,
literal|"Edge behavior { WRAP (1), SMEAR (2), BLACK (3) }"
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-dog    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_dog_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-dog"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-dog"
argument_list|,
literal|"Edge detection with control of edge thickness"
argument_list|,
literal|"Applies two Gaussian blurs to the drawable, and subtracts the results. This is robust and widely used method for detecting edges."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:difference-of-gaussians' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:difference-of-gaussians' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"inner"
argument_list|,
literal|"inner"
argument_list|,
literal|"Radius of inner gaussian blur in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"outer"
argument_list|,
literal|"outer"
argument_list|,
literal|"Radius of outer gaussian blur in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|10.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"normalize"
argument_list|,
literal|"normalize"
argument_list|,
literal|"Normalize"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"invert"
argument_list|,
literal|"invert"
argument_list|,
literal|"Invert"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-edge    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_edge_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-edge"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-edge"
argument_list|,
literal|"Several simple methods for detecting edges"
argument_list|,
literal|"Perform edge detection on the contents of the specified drawable. AMOUNT is an arbitrary constant, WRAPMODE is like displace plug-in (useful for tileable image). EDGEMODE sets the kind of matrix transform applied to the pixels, SOBEL was the method used in older versions."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount"
argument_list|,
literal|"amount"
argument_list|,
literal|"Edge detection amount"
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"warpmode"
argument_list|,
literal|"warpmode"
argument_list|,
literal|"Edge detection behavior { NONE (0), WRAP (1), SMEAR (2), BLACK (3) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"edgemode"
argument_list|,
literal|"edgemode"
argument_list|,
literal|"Edge detection algorithm { SOBEL (0), PREWITT (1), GRADIENT (2), ROBERTS (3), DIFFERENTIAL (4), LAPLACE (5) }"
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-emboss    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_emboss_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-emboss"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-emboss"
argument_list|,
literal|"Simulate an image created by embossing"
argument_list|,
literal|"Emboss or Bumpmap the given drawable, specifying the angle and elevation for the light source."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:emboss' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:emboss' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"azimuth"
argument_list|,
literal|"azimuth"
argument_list|,
literal|"The Light Angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"elevation"
argument_list|,
literal|"elevation"
argument_list|,
literal|"The Elevation Angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|180
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"depth"
argument_list|,
literal|"depth"
argument_list|,
literal|"The Filter Width"
argument_list|,
literal|1
argument_list|,
literal|99
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"emboss"
argument_list|,
literal|"emboss"
argument_list|,
literal|"Emboss (TRUE), Bumpmap (FALSE)"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-engrave    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_engrave_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-engrave"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-engrave"
argument_list|,
literal|"Simulate an antique engraving"
argument_list|,
literal|"Creates a black-and-white 'engraved' version of an image as seen in old illustrations."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:engrave' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:engrave' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"height"
argument_list|,
literal|"height"
argument_list|,
literal|"Resolution in pixels"
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"limit"
argument_list|,
literal|"limit"
argument_list|,
literal|"Limit line width"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-exchange    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_exchange_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-exchange"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-exchange"
argument_list|,
literal|"Swap one color with another"
argument_list|,
literal|"Exchange one color with another, optionally setting a threshold to convert from one shade to another."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:color-exchange' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:color-exchange' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"from-red"
argument_list|,
literal|"from red"
argument_list|,
literal|"Red value (from)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"from-green"
argument_list|,
literal|"from green"
argument_list|,
literal|"Green value (from)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"from-blue"
argument_list|,
literal|"from blue"
argument_list|,
literal|"Blue value (from)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"to-red"
argument_list|,
literal|"to red"
argument_list|,
literal|"Red value (to)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"to-green"
argument_list|,
literal|"to green"
argument_list|,
literal|"Green value (to)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"to-blue"
argument_list|,
literal|"to blue"
argument_list|,
literal|"Blue value (to)"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"red-threshold"
argument_list|,
literal|"red threshold"
argument_list|,
literal|"Red threshold"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"green-threshold"
argument_list|,
literal|"green threshold"
argument_list|,
literal|"Green threshold"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"blue-threshold"
argument_list|,
literal|"blue threshold"
argument_list|,
literal|"Blue threshold"
argument_list|,
literal|0
argument_list|,
name|G_MAXUINT8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-flarefx    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_flarefx_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-flarefx"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-flarefx"
argument_list|,
literal|"Add a lens flare effect"
argument_list|,
literal|"Adds a lens flare effects. Makes your image look like it was snapped with a cheap camera with a lot of lens :)"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:lens-flare' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:lens-flare' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pos-x"
argument_list|,
literal|"pos x"
argument_list|,
literal|"X-Position"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pos-y"
argument_list|,
literal|"pos y"
argument_list|,
literal|"Y-Position"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-fractal-trace    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_fractal_trace_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-fractal-trace"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-fractal-trace"
argument_list|,
literal|"Transform image with the Mandelbrot Fractal"
argument_list|,
literal|"Transform image with the Mandelbrot Fractal"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:fractal-trace' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:fractal-trace' for credits."
argument_list|,
literal|"2018"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"xmin"
argument_list|,
literal|"xmin"
argument_list|,
literal|"xmin fractal image delimiter"
argument_list|,
operator|-
literal|50.0
argument_list|,
literal|50.0
argument_list|,
operator|-
literal|50.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"xmax"
argument_list|,
literal|"xmax"
argument_list|,
literal|"xmax fractal image delimiter"
argument_list|,
operator|-
literal|50.0
argument_list|,
literal|50.0
argument_list|,
operator|-
literal|50.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"ymin"
argument_list|,
literal|"ymin"
argument_list|,
literal|"ymin fractal image delimiter"
argument_list|,
operator|-
literal|50.0
argument_list|,
literal|50.0
argument_list|,
operator|-
literal|50.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"ymax"
argument_list|,
literal|"ymax"
argument_list|,
literal|"ymax fractal image delimiter"
argument_list|,
operator|-
literal|50.0
argument_list|,
literal|50.0
argument_list|,
operator|-
literal|50.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"depth"
argument_list|,
literal|"depth"
argument_list|,
literal|"Trace depth"
argument_list|,
literal|1
argument_list|,
literal|65536
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"outside-type"
argument_list|,
literal|"outside type"
argument_list|,
literal|"Outside type { WRAP (0), TRANS (1), BLACK (2), WHITE (3) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-gauss    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_gauss_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-gauss"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-gauss"
argument_list|,
literal|"Simplest, most commonly used way of blurring"
argument_list|,
literal|"Applies a gaussian blur to the drawable, with specified radius of affect. The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius. Horizontal and vertical blurring can be independently invoked by specifying only one to run. The 'method' parameter is ignored."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Horizontal radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Vertical radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"method"
argument_list|,
literal|"method"
argument_list|,
literal|"Blur method { IIR (0), RLE (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-gauss-iir    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_gauss_iir_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-gauss-iir"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-gauss-iir"
argument_list|,
literal|"Apply a gaussian blur"
argument_list|,
literal|"Applies a gaussian blur to the drawable, with specified radius of affect. The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius. Horizontal and vertical blurring can be independently invoked by specifying only one to run."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Blur in horizontal direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Blur in vertical direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-gauss-iir2    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_gauss_iir2_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-gauss-iir2"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-gauss-iir2"
argument_list|,
literal|"Apply a gaussian blur"
argument_list|,
literal|"Applies a gaussian blur to the drawable, with specified radius of affect. The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius. Horizontal and vertical blurring can be independently invoked by specifying only one to run."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Horizontal radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Vertical radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-gauss-rle    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_gauss_rle_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-gauss-rle"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-gauss-rle"
argument_list|,
literal|"Apply a gaussian blur"
argument_list|,
literal|"Applies a gaussian blur to the drawable, with specified radius of affect. The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius. Horizontal and vertical blurring can be independently invoked by specifying only one to run."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Blur in horizontal direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Blur in vertical direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-gauss-rle2    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_gauss_rle2_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-gauss-rle2"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-gauss-rle2"
argument_list|,
literal|"Apply a gaussian blur"
argument_list|,
literal|"Applies a gaussian blur to the drawable, with specified radius of affect. The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius. Horizontal and vertical blurring can be independently invoked by specifying only one to run."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Horizontal radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Vertical radius of gaussian blur (in pixels"
argument_list|,
literal|0.0
argument_list|,
literal|500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-glasstile    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_glasstile_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-glasstile"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-glasstile"
argument_list|,
literal|"Simulate distortion caused by square glass tiles"
argument_list|,
literal|"Divide the image into square glassblocks in which the image is refracted."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-glass' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-glass' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tilex"
argument_list|,
literal|"tilex"
argument_list|,
literal|"Tile width"
argument_list|,
literal|10
argument_list|,
literal|500
argument_list|,
literal|10
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tiley"
argument_list|,
literal|"tiley"
argument_list|,
literal|"Tile height"
argument_list|,
literal|10
argument_list|,
literal|500
argument_list|,
literal|10
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-hsv-noise    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_hsv_noise_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-hsv-noise"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-hsv-noise"
argument_list|,
literal|"Randomize hue, saturation and value independently"
argument_list|,
literal|"Scattering pixel values in HSV space"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-hsv' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-hsv' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"holdness"
argument_list|,
literal|"holdness"
argument_list|,
literal|"Convolution strength"
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"hue-distance"
argument_list|,
literal|"hue distance"
argument_list|,
literal|"Scattering of hue angle"
argument_list|,
literal|0
argument_list|,
literal|180
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"saturation-distance"
argument_list|,
literal|"saturation distance"
argument_list|,
literal|"Distribution distance on saturation axis"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"value-distance"
argument_list|,
literal|"value distance"
argument_list|,
literal|"Distribution distance on value axis"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-illusion    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_illusion_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-illusion"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-illusion"
argument_list|,
literal|"Superimpose many altered copies of the image"
argument_list|,
literal|"Produce illusion."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:illusion' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:illusion' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"division"
argument_list|,
literal|"division"
argument_list|,
literal|"The number of divisions"
argument_list|,
literal|0
argument_list|,
literal|64
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Illusion type { TYPE1 (0), TYPE2 (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-laplace    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_laplace_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-laplace"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-laplace"
argument_list|,
literal|"High-resolution edge detection"
argument_list|,
literal|"This plug-in creates one-pixel wide edges from the image, with the value proportional to the gradient. It uses the Laplace operator (a 3x3 kernel with -8 in the middle). The image has to be laplacered to get useful results, a gauss_iir with 1.5 - 5.0 depending on the noise in the image is best."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-laplace' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-laplace' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-lens-distortion    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_lens_distortion_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-lens-distortion"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-lens-distortion"
argument_list|,
literal|"Corrects lens distortion"
argument_list|,
literal|"Corrects barrel or pincushion lens distortion."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:lens-distortion' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:lens-distortion' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"offset-x"
argument_list|,
literal|"offset x"
argument_list|,
literal|"Effect centre offset in X"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"offset-y"
argument_list|,
literal|"offset y"
argument_list|,
literal|"Effect centre offset in Y"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"main-adjust"
argument_list|,
literal|"main adjust"
argument_list|,
literal|"Amount of second-order distortion"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"edge-adjust"
argument_list|,
literal|"edge adjust"
argument_list|,
literal|"Amount of fourth-order distortion"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rescale"
argument_list|,
literal|"rescale"
argument_list|,
literal|"Rescale overall image size"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"brighten"
argument_list|,
literal|"brighten"
argument_list|,
literal|"Adjust brightness in corners"
argument_list|,
operator|-
literal|100
argument_list|,
literal|100
argument_list|,
operator|-
literal|100
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-make-seamless    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_make_seamless_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-make-seamless"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-make-seamless"
argument_list|,
literal|"Alters edges to make the image seamlessly tileable"
argument_list|,
literal|"This plug-in creates a seamless tileable from the input drawable."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-seamless' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-seamless' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-maze    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_maze_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-maze"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-maze"
argument_list|,
literal|"Draw a labyrinth"
argument_list|,
literal|"Generates a maze using either the depth-first search method or Prim's algorithm. Can make tileable mazes too."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:maze' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:maze' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"width"
argument_list|,
literal|"width"
argument_list|,
literal|"Width of the passages"
argument_list|,
literal|1
argument_list|,
literal|1024
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"height"
argument_list|,
literal|"height"
argument_list|,
literal|"Height of the passages"
argument_list|,
literal|1
argument_list|,
literal|1024
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"tileable"
argument_list|,
literal|"tileable"
argument_list|,
literal|"Tileable maze? (TRUE or FALSE)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_uchar
argument_list|(
literal|"algorithm"
argument_list|,
literal|"algorithm"
argument_list|,
literal|"Generation algorithm (0 = DEPTH FIRST, 1 = PRIM'S ALGORITHM)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Random Seed"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"multiple"
argument_list|,
literal|"multiple"
argument_list|,
literal|"Multiple (use 57)"
argument_list|,
name|G_MININT16
argument_list|,
name|G_MAXINT16
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"offset"
argument_list|,
literal|"offset"
argument_list|,
literal|"Offset (use 1)"
argument_list|,
name|G_MININT16
argument_list|,
name|G_MAXINT16
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-mblur    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_mblur_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-mblur"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-mblur"
argument_list|,
literal|"Simulate movement using directional blur"
argument_list|,
literal|"This plug-in simulates the effect seen when photographing a moving object at a slow shutter speed. Done by adding multiple displaced copies."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:motion-blur-linear, -zoom, -cirular' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:motion-blur-linear, -zoom, -cirular' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Type of motion blur { LINEAR (0), RADIAL (1), ZOOM (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"length"
argument_list|,
literal|"length"
argument_list|,
literal|"Length"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"angle"
argument_list|,
literal|"angle"
argument_list|,
literal|"Angle"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"center-x"
argument_list|,
literal|"center x"
argument_list|,
literal|"Center X"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"center-y"
argument_list|,
literal|"center y"
argument_list|,
literal|"Center Y"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-mblur-inward    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_mblur_inward_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-mblur-inward"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-mblur-inward"
argument_list|,
literal|"Simulate movement using directional blur"
argument_list|,
literal|"This procedure is equivalent to plug-in-mblur but performs the zoom blur inward instead of outward."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:motion-blur-linear, -zoom, -cirular' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:motion-blur-linear, -zoom, -cirular' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Type of motion blur { LINEAR (0), RADIAL (1), ZOOM (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"length"
argument_list|,
literal|"length"
argument_list|,
literal|"Length"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"angle"
argument_list|,
literal|"angle"
argument_list|,
literal|"Angle"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"center-x"
argument_list|,
literal|"center x"
argument_list|,
literal|"Center X"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"center-y"
argument_list|,
literal|"center y"
argument_list|,
literal|"Center Y"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-mosaic    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_mosaic_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-mosaic"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-mosaic"
argument_list|,
literal|"Convert the image into irregular tiles"
argument_list|,
literal|"Mosaic is a filter which transforms an image into what appears to be a mosaic, composed of small primitives, each of constant color and of an approximate size."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:mosaic' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:mosaic' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-size"
argument_list|,
literal|"tile size"
argument_list|,
literal|"Average diameter of each tile (in pixels)"
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-height"
argument_list|,
literal|"tile height"
argument_list|,
literal|"Apparent height of each tile (in pixels)"
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-spacing"
argument_list|,
literal|"tile spacing"
argument_list|,
literal|"Inter_tile spacing (in pixels)"
argument_list|,
literal|0.1
argument_list|,
literal|1000
argument_list|,
literal|0.1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"tile-neatness"
argument_list|,
literal|"tile neatness"
argument_list|,
literal|"Deviation from perfectly formed tiles"
argument_list|,
literal|0
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tile-allow-split"
argument_list|,
literal|"tile allow split"
argument_list|,
literal|"Allows splitting tiles at hard edges"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"light-dir"
argument_list|,
literal|"light dir"
argument_list|,
literal|"Direction of light_source (in degrees)"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"color-variation"
argument_list|,
literal|"color variation"
argument_list|,
literal|"Magnitude of random color variations"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"antialiasing"
argument_list|,
literal|"antialiasing"
argument_list|,
literal|"Enables smoother tile output at the cost of speed"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"color-averaging"
argument_list|,
literal|"color averaging"
argument_list|,
literal|"Tile color based on average of subsumed pixels"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tile-type"
argument_list|,
literal|"tile type"
argument_list|,
literal|"Tile geometry { SQUARES (0), HEXAGONS (1), OCTAGONS (2), TRIANGLES (3) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tile-surface"
argument_list|,
literal|"tile surface"
argument_list|,
literal|"Surface characteristics { SMOOTH (0), ROUGH (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"grout-color"
argument_list|,
literal|"grout color"
argument_list|,
literal|"Grout color (black/white or fore/background) { BW (0), FG-BG (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-neon    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_neon_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-neon"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-neon"
argument_list|,
literal|"Simulate the glowing boundary of a neon light"
argument_list|,
literal|"This filter works in a manner similar to the edge plug-in, but uses the first derivative of the gaussian operator to achieve resolution independence. The IIR method of calculating the effect is utilized to keep the processing time constant between large and small standard deviations."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-neon' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-neon' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of neon effect (in pixels)"
argument_list|,
literal|0.0
argument_list|,
literal|1500.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount"
argument_list|,
literal|"amount"
argument_list|,
literal|"Effect enhancement variable"
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-newsprint    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_newsprint_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-newsprint"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-newsprint"
argument_list|,
literal|"Halftone the image to give newspaper-like effect"
argument_list|,
literal|"Halftone the image to give newspaper-like effect"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:newsprint' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:newsprint' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"cell-width"
argument_list|,
literal|"cell width"
argument_list|,
literal|"Screen cell width in pixels"
argument_list|,
literal|0
argument_list|,
literal|1500
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"colorspace"
argument_list|,
literal|"colorspace"
argument_list|,
literal|"Separate to { GRAYSCALE (0), RGB (1), CMYK (2), LUMINANCE (3) }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"k-pullout"
argument_list|,
literal|"k pullout"
argument_list|,
literal|"Percentage of black to pullout (CMYK only)"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"gry-ang"
argument_list|,
literal|"gry ang"
argument_list|,
literal|"Grey/black screen angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"gry-spotfn"
argument_list|,
literal|"gry spotfn"
argument_list|,
literal|"Grey/black spot function { DOTS (0), LINES (1), DIAMONDS (2), EUCLIDIAN-DOT (3), PS-DIAMONDS (4) }"
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"red-ang"
argument_list|,
literal|"red ang"
argument_list|,
literal|"Red/cyan screen angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"red-spotfn"
argument_list|,
literal|"red spotfn"
argument_list|,
literal|"Red/cyan spot function { DOTS (0), LINES (1), DIAMONDS (2), EUCLIDIAN-DOT (3), PS-DIAMONDS (4) }"
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"grn-ang"
argument_list|,
literal|"grn ang"
argument_list|,
literal|"Green/magenta screen angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"grn-spotfn"
argument_list|,
literal|"grn spotfn"
argument_list|,
literal|"Green/magenta spot function { DOTS (0), LINES (1), DIAMONDS (2), EUCLIDIAN-DOT (3), PS-DIAMONDS (4) }"
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"blu-ang"
argument_list|,
literal|"blu ang"
argument_list|,
literal|"Blue/yellow screen angle (degrees)"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"blu-spotfn"
argument_list|,
literal|"blu spotfn"
argument_list|,
literal|"Blue/yellow spot function { DOTS (0), LINES (1), DIAMONDS (2), EUCLIDIAN-DOT (3), PS-DIAMONDS (4) }"
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"oversample"
argument_list|,
literal|"oversample"
argument_list|,
literal|"how many times to oversample spot fn"
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-normalize    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_normalize_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-normalize"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-normalize"
argument_list|,
literal|"Stretch brightness values to cover the full range"
argument_list|,
literal|"This plug-in performs almost the same operation as the 'contrast autostretch' plug-in, except that it won't allow the color channels to normalize independently. This is actually what most people probably want instead of contrast-autostretch; use c-a only if you wish to remove an undesirable color-tint from a source image which is supposed to contain pure-white and pure-black."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:stretch-contrast' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-nova    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_nova_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-nova"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-nova"
argument_list|,
literal|"Add a starburst to the image"
argument_list|,
literal|"This plug-in produces an effect like a supernova burst. The amount of the light effect is approximately in proportion to 1/r, where r is the distance from the center of the star."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:supernova' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:supernova' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"xcenter"
argument_list|,
literal|"xcenter"
argument_list|,
literal|"X coordinates of the center of supernova"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"ycenter"
argument_list|,
literal|"ycenter"
argument_list|,
literal|"Y coordinates of the center of supernova"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_rgb
argument_list|(
literal|"color"
argument_list|,
literal|"color"
argument_list|,
literal|"Color of supernova"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of supernova"
argument_list|,
literal|1
argument_list|,
literal|3000
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"nspoke"
argument_list|,
literal|"nspoke"
argument_list|,
literal|"Number of spokes"
argument_list|,
literal|1
argument_list|,
literal|1024
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"randomhue"
argument_list|,
literal|"randomhue"
argument_list|,
literal|"Random hue"
argument_list|,
literal|0
argument_list|,
literal|360
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-oilify    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_oilify_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-oilify"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-oilify"
argument_list|,
literal|"Smear colors to simulate an oil painting"
argument_list|,
literal|"This function performs the well-known oil-paint effect on the specified drawable."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:oilify' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:oilify' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"mask-size"
argument_list|,
literal|"mask size"
argument_list|,
literal|"Oil paint mask size"
argument_list|,
literal|1
argument_list|,
literal|200
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"mode"
argument_list|,
literal|"mode"
argument_list|,
literal|"Algorithm { RGB (0), INTENSITY (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-oilify-enhanced    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_oilify_enhanced_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-oilify-enhanced"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-oilify-enhanced"
argument_list|,
literal|"Smear colors to simulate an oil painting"
argument_list|,
literal|"This function performs the well-known oil-paint effect on the specified drawable."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:oilify' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:oilify' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"mode"
argument_list|,
literal|"mode"
argument_list|,
literal|"Algorithm { RGB (0), INTENSITY (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"mask-size"
argument_list|,
literal|"mask size"
argument_list|,
literal|"Oil paint mask size"
argument_list|,
literal|1
argument_list|,
literal|200
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"mask-size-map"
argument_list|,
literal|"mask size map"
argument_list|,
literal|"Mask size control map"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|TRUE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"exponent"
argument_list|,
literal|"exponent"
argument_list|,
literal|"Oil paint exponent"
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"exponent-map"
argument_list|,
literal|"exponent map"
argument_list|,
literal|"Exponent control map"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|TRUE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-papertile    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_papertile_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-papertile"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-papertile"
argument_list|,
literal|"Cut image into paper tiles, and slide them"
argument_list|,
literal|"This plug-in cuts an image into paper tiles and slides each paper tile."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-paper' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:tile-paper' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"tile-size"
argument_list|,
literal|"tile size"
argument_list|,
literal|"Tile size (pixels)"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"move-max"
argument_list|,
literal|"move max"
argument_list|,
literal|"Max move rate (%)"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"fractional-type"
argument_list|,
literal|"fractional type"
argument_list|,
literal|"Fractional type { BACKGROUND (0), IGNORE (1), FORCE (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"wrap-around"
argument_list|,
literal|"wrap around"
argument_list|,
literal|"Wrap around"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"centering"
argument_list|,
literal|"centering"
argument_list|,
literal|"Centering"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"background-type"
argument_list|,
literal|"background type"
argument_list|,
literal|"Background type { TRANSPARENT (0), INVERTED (1), IMAGE (2), FG (3), BG (4), COLOR (5) }"
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_rgb
argument_list|(
literal|"background-color"
argument_list|,
literal|"background color"
argument_list|,
literal|"Background color (for background-type == 5)"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"background-alpha"
argument_list|,
literal|"background alpha"
argument_list|,
literal|"Background alpha (unused)"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-photocopy    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_photocopy_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-photocopy"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-photocopy"
argument_list|,
literal|"Simulate color distortion produced by a copy machine"
argument_list|,
literal|"Propagates dark values in an image based on each pixel's relative darkness to a neighboring average. The idea behind this filter is to give the look of a photocopied version of the image, with toner transferred based on the relative darkness of a particular region. This is achieved by darkening areas of the image which are measured to be darker than a neighborhood average and setting other pixels to white. In this way, sufficiently large shifts in intensity are darkened to black. The rate at which they are darkened to black is determined by the second pct_black parameter. The mask_radius parameter controls the size of the pixel neighborhood over which the average intensity is computed and then compared to each pixel in the neighborhood to decide whether or not to darken it to black. Large values for mask_radius result in very thick black areas bordering the regions of white and much less detail for black areas everywhere including inside regions of color. Small values result in\n"
literal|"less toner overall and more detail everywhere. Small values for the pct_black make the blend from the white regions to the black border lines smoother and the toner regions themselves thinner and less noticeable; larger values achieve the opposite effect."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:photocopy' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:photocopy' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"mask-radius"
argument_list|,
literal|"mask radius"
argument_list|,
literal|"Photocopy mask radius (radius of pixel neighborhood)"
argument_list|,
literal|3.0
argument_list|,
literal|50.0
argument_list|,
literal|3.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"sharpness"
argument_list|,
literal|"sharpness"
argument_list|,
literal|"Sharpness (detail level)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"pct-black"
argument_list|,
literal|"pct black"
argument_list|,
literal|"Percentage of darkened pixels to set to black"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"pct-white"
argument_list|,
literal|"pct white"
argument_list|,
literal|"Percentage of non-darkened pixels left white"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-pixelize    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_pixelize_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-pixelize"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-pixelize"
argument_list|,
literal|"Simplify image into an array of solid-colored squares"
argument_list|,
literal|"Pixelize the contents of the specified drawable with specified pixelizing width."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pixel-width"
argument_list|,
literal|"pixel width"
argument_list|,
literal|"Pixel width (the decrease in resolution)"
argument_list|,
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-pixelize2    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_pixelize2_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-pixelize2"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-pixelize2"
argument_list|,
literal|"Simplify image into an array of solid-colored rectangles"
argument_list|,
literal|"Pixelize the contents of the specified drawable with specified pixelizing width and height."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pixel-width"
argument_list|,
literal|"pixel width"
argument_list|,
literal|"Pixel width (the decrease in horizontal resolution)"
argument_list|,
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pixel-height"
argument_list|,
literal|"pixel height"
argument_list|,
literal|"Pixel height (the decrease in vertical resolution)"
argument_list|,
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-plasma    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_plasma_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-plasma"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-plasma"
argument_list|,
literal|"Create a random plasma texture"
argument_list|,
literal|"This plug-in produces plasma fractal images."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:plasma' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:plasma' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Random seed"
argument_list|,
operator|-
literal|1
argument_list|,
name|G_MAXINT
argument_list|,
operator|-
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"turbulence"
argument_list|,
literal|"turbulence"
argument_list|,
literal|"The value of the turbulence"
argument_list|,
literal|0.0
argument_list|,
literal|7.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-polar-coords    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_polar_coords_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-polar-coords"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-polar-coords"
argument_list|,
literal|"Convert image to or from polar coordinates"
argument_list|,
literal|"Remaps and image from rectangular coordinates to polar coordinates or vice versa."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"circle"
argument_list|,
literal|"circle"
argument_list|,
literal|"Circle depth in %"
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"angle"
argument_list|,
literal|"angle"
argument_list|,
literal|"Offset angle"
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"backwards"
argument_list|,
literal|"backwards"
argument_list|,
literal|"Map backwards"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"inverse"
argument_list|,
literal|"inverse"
argument_list|,
literal|"Map from top"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"polrec"
argument_list|,
literal|"polrec"
argument_list|,
literal|"Polar to rectangular"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-red-eye-removal    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_red_eye_removal_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-red-eye-removal"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-red-eye-removal"
argument_list|,
literal|"Remove the red eye effect caused by camera flashes"
argument_list|,
literal|"This procedure removes the red eye effect caused by camera flashes by using a percentage based red color threshold. Make a selection containing the eyes, and apply the filter while adjusting the threshold to accurately remove the red eyes."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:red-eye-removal' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:red-eye-removal' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"threshold"
argument_list|,
literal|"threshold"
argument_list|,
literal|"Red eye threshold in percent"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-randomize-hurl    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_randomize_hurl_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-randomize-hurl"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-randomize-hurl"
argument_list|,
literal|"Completely randomize a fraction of pixels"
argument_list|,
literal|"This plug-in \"hurls\" randomly-valued pixels onto the selection or image. You may select the percentage of pixels to modify and the number of times to repeat the process."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-hurl' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-hurl' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-pct"
argument_list|,
literal|"rndm pct"
argument_list|,
literal|"Randomization percentage"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-rcount"
argument_list|,
literal|"rndm rcount"
argument_list|,
literal|"Repeat count"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"randomize"
argument_list|,
literal|"randomize"
argument_list|,
literal|"Use random seed"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Seed value (used only if randomize is FALSE)"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-randomize-pick    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_randomize_pick_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-randomize-pick"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-randomize-pick"
argument_list|,
literal|"Randomly interchange some pixels with neighbors"
argument_list|,
literal|"This plug-in replaces a pixel with a random adjacent pixel. You may select the percentage of pixels to modify and the number of times to repeat the process."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-pick' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-pick' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-pct"
argument_list|,
literal|"rndm pct"
argument_list|,
literal|"Randomization percentage"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-rcount"
argument_list|,
literal|"rndm rcount"
argument_list|,
literal|"Repeat count"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"randomize"
argument_list|,
literal|"randomize"
argument_list|,
literal|"Use random seed"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Seed value (used only if randomize is FALSE)"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-randomize-slur    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_randomize_slur_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-randomize-slur"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-randomize-slur"
argument_list|,
literal|"Randomly slide some pixels downward (similar to melting"
argument_list|,
literal|"This plug-in \"slurs\" (melts like a bunch of icicles) an image. You may select the percentage of pixels to modify and the number of times to repeat the process."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-slur' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-slur' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-pct"
argument_list|,
literal|"rndm pct"
argument_list|,
literal|"Randomization percentage"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"rndm-rcount"
argument_list|,
literal|"rndm rcount"
argument_list|,
literal|"Repeat count"
argument_list|,
literal|1.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"randomize"
argument_list|,
literal|"randomize"
argument_list|,
literal|"Use random seed"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Seed value (used only if randomize is FALSE)"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-rgb-noise    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_rgb_noise_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-rgb-noise"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-rgb-noise"
argument_list|,
literal|"Distort colors by random amounts"
argument_list|,
literal|"Add normally distributed (zero mean) random values to image channels. Noise may be additive (uncorrelated) or multiplicative (correlated - also known as speckle noise). For color images color channels may be treated together or independently."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-rgb' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-rgb' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"independent"
argument_list|,
literal|"independent"
argument_list|,
literal|"Noise in channels independent"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"correlated"
argument_list|,
literal|"correlated"
argument_list|,
literal|"Noise correlated (i.e. multiplicative not additive)"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-1"
argument_list|,
literal|"noise 1"
argument_list|,
literal|"Noise in the first channel (red, gray)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-2"
argument_list|,
literal|"noise 2"
argument_list|,
literal|"Noise in the second channel (green, gray_alpha)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-3"
argument_list|,
literal|"noise 3"
argument_list|,
literal|"Noise in the third channel (blue)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-4"
argument_list|,
literal|"noise 4"
argument_list|,
literal|"Noise in the fourth channel (alpha)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-ripple    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_ripple_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-ripple"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-ripple"
argument_list|,
literal|"Displace pixels in a ripple pattern"
argument_list|,
literal|"Ripples the pixels of the specified drawable. Each row or column will be displaced a certain number of pixels coinciding with the given wave form."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:ripple' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:ripple' for credits."
argument_list|,
literal|"2018"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"period"
argument_list|,
literal|"period"
argument_list|,
literal|"Period: number of pixels for one wave to complete"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"amplitude"
argument_list|,
literal|"amplitude"
argument_list|,
literal|"Amplitude: maximum displacement of wave"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"orientation"
argument_list|,
literal|"orientation"
argument_list|,
literal|"Orientation { ORIENTATION-HORIZONTAL (0), ORIENTATION-VERTICAL (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"edges"
argument_list|,
literal|"edges"
argument_list|,
literal|"Edges { SMEAR (0), WRAP (1), BLANK (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"waveform"
argument_list|,
literal|"waveform"
argument_list|,
literal|"Waveform { SAWTOOTH (0), SINE (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"antialias"
argument_list|,
literal|"antialias"
argument_list|,
literal|"Antialias { TRUE, FALSE }"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"tile"
argument_list|,
literal|"tile"
argument_list|,
literal|"Tileable { TRUE, FALSE }"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-rotate    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_rotate_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-rotate"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-rotate"
argument_list|,
literal|"Rotates a layer or the whole image by 90, 180 or 270 degrees"
argument_list|,
literal|"This plug-in does rotate the active layer or the whole image clockwise by multiples of 90 degrees. When the whole image is chosen, the image is resized if necessary."
argument_list|,
literal|"Sven Neumann<sven@gimp.org>"
argument_list|,
literal|"Sven Neumann"
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"angle"
argument_list|,
literal|"angle"
argument_list|,
literal|"Angle { 90 (1), 180 (2), 270 (3) } degrees"
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"everything"
argument_list|,
literal|"everything"
argument_list|,
literal|"Rotate the whole image"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-noisify    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_noisify_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-noisify"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-noisify"
argument_list|,
literal|"Adds random noise to image channels"
argument_list|,
literal|"Add normally distributed random values to image channels. For color images each color channel may be treated together or independently."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-rgb' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-rgb' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"independent"
argument_list|,
literal|"independent"
argument_list|,
literal|"Noise in channels independent"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-1"
argument_list|,
literal|"noise 1"
argument_list|,
literal|"Noise in the first channel (red, gray)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-2"
argument_list|,
literal|"noise 2"
argument_list|,
literal|"Noise in the second channel (green, gray_alpha)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-3"
argument_list|,
literal|"noise 3"
argument_list|,
literal|"Noise in the third channel (blue)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"noise-4"
argument_list|,
literal|"noise 4"
argument_list|,
literal|"Noise in the fourth channel (alpha)"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-sel-gauss    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_sel_gauss_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-sel-gauss"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-sel-gauss"
argument_list|,
literal|"Blur neighboring pixels, but only in low-contrast areas"
argument_list|,
literal|"This filter functions similar to the regular gaussian blur filter except that neighbouring pixels that differ more than the given maxdelta parameter will not be blended with. This way with the correct parameters, an image can be smoothed out without losing details. However, this filter can be rather slow."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur-selective' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:gaussian-blur-selective' for credits."
argument_list|,
literal|"2099"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of gaussian blur (in pixels)"
argument_list|,
literal|0.0
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"max-delta"
argument_list|,
literal|"max delta"
argument_list|,
literal|"Maximum delta"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-semiflatten    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_semiflatten_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-semiflatten"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-semiflatten"
argument_list|,
literal|"Replace partial transparency with the current background color"
argument_list|,
literal|"This plug-in flattens pixels in an RGBA image that aren't completely transparent against the current GIMP background color."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-shift    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_shift_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-shift"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-shift"
argument_list|,
literal|"Shift each row or column of pixels by a random amount"
argument_list|,
literal|"Shifts the pixels of the specified drawable. Each row or column will be displaced a random value of pixels."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:shift' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:shift' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"shift-amount"
argument_list|,
literal|"shift amount"
argument_list|,
literal|"Shift amount"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"orientation"
argument_list|,
literal|"orientation"
argument_list|,
literal|"Orientation { ORIENTATION-VERTICAL (0), ORIENTATION-HORIZONTAL (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-sinus    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_sinus_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-sinus"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-sinus"
argument_list|,
literal|"Generate complex sinusoidal textures"
argument_list|,
literal|"FIXME: sinus help"
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:sinus' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:sinus' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"xscale"
argument_list|,
literal|"xscale"
argument_list|,
literal|"Scale value for x axis"
argument_list|,
literal|0
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"yscale"
argument_list|,
literal|"yscale"
argument_list|,
literal|"Scale value for y axis"
argument_list|,
literal|0
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"complex"
argument_list|,
literal|"complex"
argument_list|,
literal|"Complexity factor"
argument_list|,
literal|0
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Seed value for random number generator"
argument_list|,
literal|0
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"tiling"
argument_list|,
literal|"tiling"
argument_list|,
literal|"If set, the pattern generated will tile"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"perturb"
argument_list|,
literal|"perturb"
argument_list|,
literal|"If set, the pattern is a little more distorted..."
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"colors"
argument_list|,
literal|"colors"
argument_list|,
literal|"where to take the colors (0=B&W, 1=fg/bg, 2=col1/col2)"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_rgb
argument_list|(
literal|"col1"
argument_list|,
literal|"col1"
argument_list|,
literal|"fist color (sometimes unused)"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_rgb
argument_list|(
literal|"col2"
argument_list|,
literal|"col2"
argument_list|,
literal|"second color (sometimes unused)"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"alpha1"
argument_list|,
literal|"alpha1"
argument_list|,
literal|"alpha for the first color (used if the drawable has an alpha channel)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"alpha2"
argument_list|,
literal|"alpha2"
argument_list|,
literal|"alpha for the second color (used if the drawable has an alpha channel)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"blend"
argument_list|,
literal|"blend"
argument_list|,
literal|"0=linear, 1=bilinear, 2=sinusoidal"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"blend-power"
argument_list|,
literal|"blend power"
argument_list|,
literal|"Power used to stretch the blend"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-sobel    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_sobel_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-sobel"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-sobel"
argument_list|,
literal|"Specialized direction-dependent edge detection"
argument_list|,
literal|"This plug-in calculates the gradient with a sobel operator. The user can specify which direction to use. When both directions are used, the result is the RMS of the two gradients; if only one direction is used, the result either the absolute value of the gradient, or 127 + gradient (if the 'keep sign' switch is on). This way, information about the direction of the gradient is preserved. Resulting images are not autoscaled.\""
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-sobel' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:edge-sobel' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"horizontal"
argument_list|,
literal|"horizontal"
argument_list|,
literal|"Sobel in horizontal direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"vertical"
argument_list|,
literal|"vertical"
argument_list|,
literal|"Sobel in vertical direction"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"keep-sign"
argument_list|,
literal|"keep sign"
argument_list|,
literal|"Keep sign of result (one direction only)"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-softglow    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_softglow_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-softglow"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-softglow"
argument_list|,
literal|"Simulate glow by making highlights intense and fuzzy"
argument_list|,
literal|"Gives an image a softglow effect by intensifying the highlights in the image. This is done by screening a modified version of the drawable with itself. The modified version is desaturated and then a sigmoidal transfer function is applied to force the distribution of intensities into very small and very large only. This desaturated version is then blurred to give it a fuzzy 'vaseline-on-the-lens' effect. The glow radius parameter controls the sharpness of the glow effect. The brightness parameter controls the degree of intensification applied to image highlights. The sharpness parameter controls how defined or alternatively, diffuse, the glow effect should be."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:softglow' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:softglow' for credits."
argument_list|,
literal|"2019"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"glow-radius"
argument_list|,
literal|"glow radius"
argument_list|,
literal|"Glow radius in pixels"
argument_list|,
literal|0
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"brightness"
argument_list|,
literal|"brightness"
argument_list|,
literal|"Glow brightness"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"sharpness"
argument_list|,
literal|"sharpness"
argument_list|,
literal|"Glow sharpness"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-solid-noise    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_solid_noise_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-solid-noise"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-solid-noise"
argument_list|,
literal|"Create a random cloud-like texture"
argument_list|,
literal|"Generates 2D textures using Perlin's classic solid noise function."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-solid' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-solid' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"tileable"
argument_list|,
literal|"tileable"
argument_list|,
literal|"Create a tileable output"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"turbulent"
argument_list|,
literal|"turbulent"
argument_list|,
literal|"Make a turbulent noise"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"seed"
argument_list|,
literal|"seed"
argument_list|,
literal|"Random seed"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"detail"
argument_list|,
literal|"detail"
argument_list|,
literal|"Detail level"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"xsize"
argument_list|,
literal|"xsize"
argument_list|,
literal|"Horizontal texture size"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"ysize"
argument_list|,
literal|"ysize"
argument_list|,
literal|"Vertical texture size"
argument_list|,
operator|-
name|G_MAXDOUBLE
argument_list|,
name|G_MAXDOUBLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-spread    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_spread_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-spread"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-spread"
argument_list|,
literal|"Move pixels around randomly"
argument_list|,
literal|"Spreads the pixels of the specified drawable. Pixels are randomly moved to another location whose distance varies from the original by the horizontal and vertical spread amounts."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-spread' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:noise-spread' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"spread-amount-x"
argument_list|,
literal|"spread amount x"
argument_list|,
literal|"Horizontal spread amount"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"spread-amount-y"
argument_list|,
literal|"spread amount y"
argument_list|,
literal|"Vertical spread amount"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-threshold-alpha    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_threshold_alpha_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-threshold-alpha"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-threshold-alpha"
argument_list|,
literal|"Make transparency all-or-nothing"
argument_list|,
literal|"Make transparency all-or-nothing."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"threshold"
argument_list|,
literal|"threshold"
argument_list|,
literal|"Threshold"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-unsharp-mask    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_unsharp_mask_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-unsharp-mask"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-unsharp-mask"
argument_list|,
literal|"The most widely useful method for sharpening an image"
argument_list|,
literal|"The unsharp mask is a sharpening filter that works by comparing using the difference of the image and a blurred version of the image. It is commonly used on photographic images, and is provides a much more pleasing result than the standard sharpen filter."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:unsharp-mask' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:unsharp-mask' for credits."
argument_list|,
literal|"2018"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius of gaussian blur"
argument_list|,
literal|0.0
argument_list|,
literal|300.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amount"
argument_list|,
literal|"amount"
argument_list|,
literal|"Strength of effect"
argument_list|,
literal|0.0
argument_list|,
literal|300.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"threshold"
argument_list|,
literal|"threshold"
argument_list|,
literal|"Threshold"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-video    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_video_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-video"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-video"
argument_list|,
literal|"Simulate distortion produced by a fuzzy or low-res monitor"
argument_list|,
literal|"This function simulates the degradation of being on an old low-dotpitch RGB video monitor to the specified drawable."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:video-degradation' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:video-degradation' for credits."
argument_list|,
literal|"2014"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"pattern-number"
argument_list|,
literal|"pattern number"
argument_list|,
literal|"Type of RGB pattern to use"
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"additive"
argument_list|,
literal|"additive"
argument_list|,
literal|"Whether the function adds the result to the original image"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"rotated"
argument_list|,
literal|"rotated"
argument_list|,
literal|"Whether to rotate the RGB pattern by ninety degrees"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-vinvert    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_vinvert_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-vinvert"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-vinvert"
argument_list|,
literal|"Invert the brightness of each pixel"
argument_list|,
literal|"This function takes an indexed/RGB image and inverts its 'value' in HSV space. The upshot of this is that the color and saturation at any given point remains the same, but its brightness is effectively inverted. Quite strange. Sometimes produces unpleasant color artifacts on images from lossy sources (ie. JPEG)."
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-vpropagate    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_vpropagate_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-vpropagate"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-vpropagate"
argument_list|,
literal|"Propagate certain colors to neighboring pixels"
argument_list|,
literal|"Propagate values of the layer."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagate-mode"
argument_list|,
literal|"propagate mode"
argument_list|,
literal|"Propagate mode { 0:white, 1:black, 2:middle value 3:foreground to peak, 4:foreground, 5:background, 6:opaque, 7:transparent }"
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagating-channel"
argument_list|,
literal|"propagating channel"
argument_list|,
literal|"Channels which values are propagated"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"propagating-rate"
argument_list|,
literal|"propagating rate"
argument_list|,
literal|"Propagating rate"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"direction-mask"
argument_list|,
literal|"direction mask"
argument_list|,
literal|"Direction mask"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"lower-limit"
argument_list|,
literal|"lower limit"
argument_list|,
literal|"Lower limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"upper-limit"
argument_list|,
literal|"upper limit"
argument_list|,
literal|"Upper limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-dilate    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_dilate_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-dilate"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-dilate"
argument_list|,
literal|"Grow lighter areas of the image"
argument_list|,
literal|"Dilate image."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagate-mode"
argument_list|,
literal|"propagate mode"
argument_list|,
literal|"Propagate mode { 0:white, 1:black, 2:middle value 3:foreground to peak, 4:foreground, 5:background, 6:opaque, 7:transparent }"
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagating-channel"
argument_list|,
literal|"propagating channel"
argument_list|,
literal|"Channels which values are propagated"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"propagating-rate"
argument_list|,
literal|"propagating rate"
argument_list|,
literal|"Propagating rate"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"direction-mask"
argument_list|,
literal|"direction mask"
argument_list|,
literal|"Direction mask"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"lower-limit"
argument_list|,
literal|"lower limit"
argument_list|,
literal|"Lower limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"upper-limit"
argument_list|,
literal|"upper limit"
argument_list|,
literal|"Upper limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-erode    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_erode_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-erode"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-erode"
argument_list|,
literal|"Shrink lighter areas of the image"
argument_list|,
literal|"Erode image."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:value-propagate' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagate-mode"
argument_list|,
literal|"propagate mode"
argument_list|,
literal|"Propagate mode { 0:white, 1:black, 2:middle value 3:foreground to peak, 4:foreground, 5:background, 6:opaque, 7:transparent }"
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"propagating-channel"
argument_list|,
literal|"propagating channel"
argument_list|,
literal|"Channels which values are propagated"
argument_list|,
name|G_MININT32
argument_list|,
name|G_MAXINT32
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"propagating-rate"
argument_list|,
literal|"propagating rate"
argument_list|,
literal|"Propagating rate"
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"direction-mask"
argument_list|,
literal|"direction mask"
argument_list|,
literal|"Direction mask"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"lower-limit"
argument_list|,
literal|"lower limit"
argument_list|,
literal|"Lower limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"upper-limit"
argument_list|,
literal|"upper limit"
argument_list|,
literal|"Upper limit"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-waves    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_waves_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-waves"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-waves"
argument_list|,
literal|"Distort the image with waves"
argument_list|,
literal|"Distort the image with waves."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:waves' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:waves' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"amplitude"
argument_list|,
literal|"amplitude"
argument_list|,
literal|"The Amplitude of the Waves"
argument_list|,
literal|0
argument_list|,
literal|101
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"phase"
argument_list|,
literal|"phase"
argument_list|,
literal|"The Phase of the Waves"
argument_list|,
operator|-
literal|360
argument_list|,
literal|360
argument_list|,
operator|-
literal|360
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"wavelength"
argument_list|,
literal|"wavelength"
argument_list|,
literal|"The Wavelength of the Waves"
argument_list|,
literal|0.1
argument_list|,
literal|50
argument_list|,
literal|0.1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"type"
argument_list|,
literal|"type"
argument_list|,
literal|"Type of waves: { 0 = smeared, 1 = black }"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"reflective"
argument_list|,
literal|"reflective"
argument_list|,
literal|"Use Reflection (not implemented)"
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-whirl-pinch    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_whirl_pinch_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-whirl-pinch"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-whirl-pinch"
argument_list|,
literal|"Distort an image by whirling and pinching"
argument_list|,
literal|"Distorts the image by whirling and pinching, which are two common center-based, circular distortions. Whirling is like projecting the image onto the surface of water in a toilet and flushing. Pinching is similar to projecting the image onto an elastic surface and pressing or pulling on the center of the surface."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:whirl-pinch' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:whirl-pinch' for credits."
argument_list|,
literal|"2013"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"whirl"
argument_list|,
literal|"whirl"
argument_list|,
literal|"Whirl angle (degrees)"
argument_list|,
operator|-
literal|720
argument_list|,
literal|720
argument_list|,
operator|-
literal|720
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"pinch"
argument_list|,
literal|"pinch"
argument_list|,
literal|"Pinch amount"
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"radius"
argument_list|,
literal|"radius"
argument_list|,
literal|"Radius (1.0 is the largest circle that fits in the image, and 2.0 goes all the way to the corners)"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/*    * gimp-plug-in-wind    */
name|procedure
operator|=
name|gimp_procedure_new
argument_list|(
name|plug_in_wind_invoker
argument_list|)
expr_stmt|;
name|gimp_object_set_static_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"plug-in-wind"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_static_strings
argument_list|(
name|procedure
argument_list|,
literal|"plug-in-wind"
argument_list|,
literal|"Smear image to give windblown effect"
argument_list|,
literal|"Renders a wind effect."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:wind' for credits."
argument_list|,
literal|"Compatibility procedure. Please see 'gegl:wind' for credits."
argument_list|,
literal|"2015"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"run-mode"
argument_list|,
literal|"run mode"
argument_list|,
literal|"The run mode"
argument_list|,
name|GIMP_TYPE_RUN_MODE
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_image_id
argument_list|(
literal|"image"
argument_list|,
literal|"image"
argument_list|,
literal|"Input image (unused)"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|gimp_param_spec_drawable_id
argument_list|(
literal|"drawable"
argument_list|,
literal|"drawable"
argument_list|,
literal|"Input drawable"
argument_list|,
name|pdb
operator|->
name|gimp
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"threshold"
argument_list|,
literal|"threshold"
argument_list|,
literal|"Controls where blending will be done"
argument_list|,
literal|0
argument_list|,
literal|50
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"direction"
argument_list|,
literal|"direction"
argument_list|,
literal|"Wind direction { 0:left, 1:right, 2:top, 3:bottom }"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"strength"
argument_list|,
literal|"strength"
argument_list|,
literal|"Controls the extent of the blending"
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"algorithm"
argument_list|,
literal|"algorithm"
argument_list|,
literal|"Algorithm { WIND (0), BLAST (1) }"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_add_argument
argument_list|(
name|procedure
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"edge"
argument_list|,
literal|"edge"
argument_list|,
literal|"Affected edge { BOTH (0), LEADING (1), TRAILING (2) }"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pdb_register_procedure
argument_list|(
name|pdb
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

