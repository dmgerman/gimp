begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbasetypes.h"
end_include

begin_include
include|#
directive|include
file|"pdb-types.h"
end_include

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplist.h"
end_include

begin_include
include|#
directive|include
file|"core/gimppaintinfo.h"
end_include

begin_include
include|#
directive|include
file|"core/gimptoolinfo.h"
end_include

begin_include
include|#
directive|include
file|"paint/gimppaintcore-stroke.h"
end_include

begin_include
include|#
directive|include
file|"paint/gimppaintoptions.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpanchor.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpbezierstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors-compat.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_decl_stmt
DECL|variable|path_list_proc
specifier|static
name|ProcRecord
name|path_list_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_proc
specifier|static
name|ProcRecord
name|path_get_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_current_proc
specifier|static
name|ProcRecord
name|path_set_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_delete_proc
specifier|static
name|ProcRecord
name|path_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_proc
specifier|static
name|ProcRecord
name|path_get_points_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_points_proc
specifier|static
name|ProcRecord
name|path_set_points_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_stroke_current_proc
specifier|static
name|ProcRecord
name|path_stroke_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_proc
specifier|static
name|ProcRecord
name|path_get_point_at_dist_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_proc
specifier|static
name|ProcRecord
name|path_get_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_tattoo_proc
specifier|static
name|ProcRecord
name|path_set_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_proc
specifier|static
name|ProcRecord
name|get_path_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_proc
specifier|static
name|ProcRecord
name|path_get_locked_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_locked_proc
specifier|static
name|ProcRecord
name|path_set_locked_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_paths_procs (Gimp * gimp)
name|register_paths_procs
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_list_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_get_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_set_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_get_points_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_set_points_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_stroke_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_get_point_at_dist_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_get_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_set_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|get_path_by_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_get_locked_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
name|gimp
argument_list|,
operator|&
name|path_set_locked_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_list_invoker (Gimp * gimp,Argument * args)
name|path_list_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_paths
init|=
literal|0
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|path_list
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|num_paths
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_paths
operator|>
literal|0
condition|)
block|{
name|gint
name|count
init|=
literal|0
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|path_list
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
name|num_paths
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|path_list
index|[
name|count
operator|++
index|]
operator|=
name|g_strdup
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_list_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_paths
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|path_list
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_list_inargs
specifier|static
name|ProcArg
name|path_list_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list the paths from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_outargs
specifier|static
name|ProcArg
name|path_list_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"num_paths"
block|,
literal|"The number of paths returned"
block|}
block|,
block|{
name|GIMP_PDB_STRINGARRAY
block|,
literal|"path_list"
block|,
literal|"List of the paths belonging to this image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_proc
specifier|static
name|ProcRecord
name|path_list_proc
init|=
block|{
literal|"gimp_path_list"
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|path_list_inargs
block|,
literal|2
block|,
name|path_list_outargs
block|,
block|{
block|{
name|path_list_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_current_invoker (Gimp * gimp,Argument * args)
name|path_get_current_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
init|=
name|NULL
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|pname
operator|=
name|g_strdup
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_current_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|pname
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_current_inargs
specifier|static
name|ProcArg
name|path_get_current_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to get the current paths from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_outargs
specifier|static
name|ProcArg
name|path_get_current_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"current_path_name"
block|,
literal|"The name of the current path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_proc
specifier|static
name|ProcRecord
name|path_get_current_proc
init|=
block|{
literal|"gimp_path_get_current"
block|,
literal|"The name of the current path. Error if no paths."
block|,
literal|"The name of the current path. Error if no paths."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|path_get_current_inargs
block|,
literal|1
block|,
name|path_get_current_outargs
block|,
block|{
block|{
name|path_get_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_current_invoker (Gimp * gimp,Argument * args)
name|path_set_current_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_vectors_by_name
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|gimp_image_set_active_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_current_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_current_inargs
specifier|static
name|ProcArg
name|path_set_current_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list set the paths in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"set_current_path_name"
block|,
literal|"The name of the path to set the current path to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_current_proc
specifier|static
name|ProcRecord
name|path_set_current_proc
init|=
block|{
literal|"gimp_path_set_current"
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_set_current_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_delete_invoker (Gimp * gimp,Argument * args)
name|path_delete_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|gimp_image_remove_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_delete_inargs
specifier|static
name|ProcArg
name|path_delete_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list delete the paths from"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"path_name_to_del"
block|,
literal|"The name of the path to delete"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_delete_proc
specifier|static
name|ProcRecord
name|path_delete_proc
init|=
block|{
literal|"gimp_path_delete"
block|,
literal|"Delete the named paths associated with the passed image."
block|,
literal|"Delete the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_points_invoker (Gimp * gimp,Argument * args)
name|path_get_points_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|path_type
init|=
literal|0
decl_stmt|;
name|gint32
name|path_closed
init|=
literal|0
decl_stmt|;
name|gint32
name|num_points
init|=
literal|0
decl_stmt|;
name|gdouble
modifier|*
name|points_pairs
init|=
name|NULL
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
block|{
name|GimpVectorsCompatPoint
modifier|*
name|points
decl_stmt|;
name|path_type
operator|=
literal|1
expr_stmt|;
comment|/* BEZIER (1.2 compat) */
name|points
operator|=
name|gimp_vectors_compat_get_points
argument_list|(
name|vectors
argument_list|,
operator|&
name|num_points
argument_list|,
operator|&
name|path_closed
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
condition|)
block|{
name|gdouble
modifier|*
name|curr_point
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|points_pairs
operator|=
name|g_new0
argument_list|(
name|gdouble
argument_list|,
name|num_points
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|curr_point
operator|=
name|points_pairs
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
operator|,
name|curr_point
operator|+=
literal|3
control|)
block|{
name|curr_point
index|[
literal|0
index|]
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|curr_point
index|[
literal|1
index|]
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|curr_point
index|[
literal|2
index|]
operator|=
name|points
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|path_type
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|path_closed
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_points
expr_stmt|;
name|return_args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|points_pairs
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_points_inargs
specifier|static
name|ProcArg
name|path_get_points_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list the paths from"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose points should be listed"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_outargs
specifier|static
name|ProcArg
name|path_get_points_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"path_type"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"path_closed"
block|,
literal|"Return if the path is closed. (0 = path open, 1 = path closed)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"num_path_point_details"
block|,
literal|"The number of points returned. Each point is made up of (x, y, pnt_type) of floats"
block|}
block|,
block|{
name|GIMP_PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 3 floats. The first is the x pos, next is the y pos, last is the type of the pnt. The type field is dependant on the path type. For beziers (type 1 paths) the type can either be (1.0 = BEZIER_ANCHOR, 2.0 = BEZIER_CONTROL). Note all points are returned in pixel resolution"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_proc
specifier|static
name|ProcRecord
name|path_get_points_proc
init|=
block|{
literal|"gimp_path_get_points"
block|,
literal|"List the points associated with the named path."
block|,
literal|"List the points associated with the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_get_points_inargs
block|,
literal|4
block|,
name|path_get_points_outargs
block|,
block|{
block|{
name|path_get_points_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_points_invoker (Gimp * gimp,Argument * args)
name|path_set_points_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
init|=
name|NULL
decl_stmt|;
name|gint32
name|ptype
decl_stmt|;
name|gint32
name|num_path_points
init|=
literal|0
decl_stmt|;
name|gdouble
modifier|*
name|points_pairs
decl_stmt|;
name|gboolean
name|closed
init|=
name|FALSE
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|ptype
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|num_path_points
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|num_path_points
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|points_pairs
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|(
name|num_path_points
operator|/
literal|3
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
name|closed
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|num_path_points
operator|/
literal|3
operator|)
operator|%
literal|3
operator|!=
literal|2
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gdouble
modifier|*
name|curr_point_pair
decl_stmt|;
name|GimpVectorsCompatPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|n_points
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|n_points
operator|=
name|num_path_points
operator|/
literal|3
expr_stmt|;
name|points
operator|=
name|g_new0
argument_list|(
name|GimpVectorsCompatPoint
argument_list|,
name|n_points
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|curr_point_pair
operator|=
name|points_pairs
init|;
name|i
operator|<
name|n_points
condition|;
name|i
operator|++
operator|,
name|curr_point_pair
operator|+=
literal|3
control|)
block|{
name|points
index|[
name|i
index|]
operator|.
name|x
operator|=
name|curr_point_pair
index|[
literal|0
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|y
operator|=
name|curr_point_pair
index|[
literal|1
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|type
operator|=
name|curr_point_pair
index|[
literal|2
index|]
expr_stmt|;
block|}
name|vectors
operator|=
name|gimp_vectors_compat_new
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|,
name|points
argument_list|,
name|n_points
argument_list|,
name|closed
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|gimp_image_add_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_points_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_points_inargs
specifier|static
name|ProcArg
name|path_set_points_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to set the paths in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"The name of the path to create (if it exists then a unique name will be created - query the list of paths if you want to make sure that the name of the path you create is unique. This will be set as the current path."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"ptype"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"num_path_points"
block|,
literal|"The number of points in the path. Each point is made up of (x, y, type) of floats. Currently only the creation of bezier curves is allowed. The type parameter must be set to (1) to indicate a BEZIER type curve. For BEZIERS. Note the that points must be given in the following order... ACCACCAC ... If the path is not closed the last control point is missed off. Points consist of three control points (control/anchor/control) so for a curve that is not closed there must be at least two points passed (2 x,y pairs). If num_path_pnts % 3 = 0 then the path is assumed to be closed and the points are ACCACCACCACC."
block|}
block|,
block|{
name|GIMP_PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 3 floats. The first is the x pos, next is the y pos, last is the type of the pnt. The type field is dependant on the path type. For beziers (type 1 paths) the type can either be (1.0 = BEZIER_ANCHOR, 2.0 = BEZIER_CONTROL). Note all points are returned in pixel resolution"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_points_proc
specifier|static
name|ProcRecord
name|path_set_points_proc
init|=
block|{
literal|"gimp_path_set_points"
block|,
literal|"Set the points associated with the named path."
block|,
literal|"Set the points associated with the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|5
block|,
name|path_set_points_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_points_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_stroke_current_invoker (Gimp * gimp,Argument * args)
name|path_stroke_current_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
operator|&&
name|drawable
condition|)
block|{
name|GimpToolInfo
modifier|*
name|tool_info
decl_stmt|;
name|GimpPaintOptions
modifier|*
name|paint_options
decl_stmt|;
name|GimpPaintCore
modifier|*
name|core
decl_stmt|;
name|tool_info
operator|=
name|gimp_context_get_tool
argument_list|(
name|gimp_get_current_context
argument_list|(
name|gimp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tool_info
operator|&&
name|GIMP_IS_PAINT_OPTIONS
argument_list|(
name|tool_info
operator|->
name|tool_options
argument_list|)
operator|)
condition|)
block|{
name|tool_info
operator|=
operator|(
name|GimpToolInfo
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimp
operator|->
name|tool_info_list
argument_list|,
literal|"gimp-paintbrush-tool"
argument_list|)
expr_stmt|;
block|}
name|paint_options
operator|=
name|GIMP_PAINT_OPTIONS
argument_list|(
name|tool_info
operator|->
name|tool_options
argument_list|)
expr_stmt|;
name|core
operator|=
name|g_object_new
argument_list|(
name|tool_info
operator|->
name|paint_info
operator|->
name|paint_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_paint_core_stroke_vectors
argument_list|(
name|core
argument_list|,
name|drawable
argument_list|,
name|paint_options
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_stroke_current_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_stroke_current_inargs
specifier|static
name|ProcArg
name|path_stroke_current_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image which contains the path to stroke"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_stroke_current_proc
specifier|static
name|ProcRecord
name|path_stroke_current_proc
init|=
block|{
literal|"gimp_path_stroke_current"
block|,
literal|"Stroke the current path in the passed image."
block|,
literal|"Stroke the current path in the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|1
block|,
name|path_stroke_current_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_stroke_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_point_at_dist_invoker (Gimp * gimp,Argument * args)
name|path_get_point_at_dist_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gdouble
name|distance
decl_stmt|;
name|gint32
name|x_point
init|=
literal|0
decl_stmt|;
name|gint32
name|y_point
init|=
literal|0
decl_stmt|;
name|gdouble
name|gradient
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|distance
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
block|{
name|g_warning
argument_list|(
literal|"FIXME: path_get_point_at_dist() is unimplemented"
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_point_at_dist_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|x_point
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|y_point
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gradient
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_point_at_dist_inargs
specifier|static
name|ProcArg
name|path_get_point_at_dist_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image the paths belongs to"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"distance"
block|,
literal|"The distance along the path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_outargs
specifier|static
name|ProcArg
name|path_get_point_at_dist_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"x_point"
block|,
literal|"The x position of the point"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"y_point"
block|,
literal|"The y position of the point"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"gradient"
block|,
literal|"The gradient at the specified point"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_proc
specifier|static
name|ProcRecord
name|path_get_point_at_dist_proc
init|=
block|{
literal|"gimp_path_get_point_at_dist"
block|,
literal|"Get point on a path at a specified distance along the path."
block|,
literal|"This will return the x,y position of a point at a given distance along the bezier curve. The distance will the obtained by first digitizing the curve internally an then walking along the curve. For a closed curve the start of the path is the first point on the path that was created. This might not be obvious. Note the current path is used."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_get_point_at_dist_inargs
block|,
literal|3
block|,
name|path_get_point_at_dist_outargs
block|,
block|{
block|{
name|path_get_point_at_dist_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_tattoo_invoker (Gimp * gimp,Argument * args)
name|path_get_tattoo_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|tattoo
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|tattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|tattoo
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_tattoo_inargs
specifier|static
name|ProcArg
name|path_get_tattoo_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose tattoo should be obtained"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_outargs
specifier|static
name|ProcArg
name|path_get_tattoo_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo associated with the name path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_proc
specifier|static
name|ProcRecord
name|path_get_tattoo_proc
init|=
block|{
literal|"gimp_path_get_tattoo"
block|,
literal|"Returns the tattoo associated with the name path."
block|,
literal|"This procedure returns the tattoo associated with the specified path. A tattoo is a unique and permanent identifier attached to a path that can be used to uniquely identify a path within an image even between sessions."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_get_tattoo_inargs
block|,
literal|1
block|,
name|path_get_tattoo_outargs
block|,
block|{
block|{
name|path_get_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_tattoo_invoker (Gimp * gimp,Argument * args)
name|path_set_tattoo_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|tattovalue
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattovalue
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|gimp_item_set_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|tattovalue
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_tattoo_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_tattoo_inargs
specifier|static
name|ProcArg
name|path_set_tattoo_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose tattoo should be set"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattovalue"
block|,
literal|"The tattoo associated with the name path. Only values returned from 'path_get_tattoo' should be used here"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_tattoo_proc
specifier|static
name|ProcRecord
name|path_set_tattoo_proc
init|=
block|{
literal|"gimp_path_set_tattoo"
block|,
literal|"Sets the tattoo associated with the name path."
block|,
literal|"This procedure sets the tattoo associated with the specified path. A tattoo is a unique and permenant identifier attached to a path that can be used to uniquely identify a path within an image even between sessions. Note that the value passed to this function must have been obtained from a previous call to path_get_tattoo."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|path_set_tattoo_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|get_path_by_tattoo_invoker (Gimp * gimp,Argument * args)
name|get_path_by_tattoo_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|gchar
modifier|*
name|path_name
init|=
name|NULL
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
name|gimp_image_get_vectors_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|path_name
operator|=
name|g_strdup
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|get_path_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|path_name
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|get_path_by_tattoo_inargs
specifier|static
name|ProcArg
name|get_path_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the required path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_outargs
specifier|static
name|ProcArg
name|get_path_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"path_name"
block|,
literal|"The name of the path with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_proc
specifier|static
name|ProcRecord
name|get_path_by_tattoo_proc
init|=
block|{
literal|"gimp_get_path_by_tattoo"
block|,
literal|"Return the name of the path with the given tattoo."
block|,
literal|"The procedure returns the name of the path in the specified image which has the passed tattoo. The tattoos are unique within the image and will be preserved across sessions and through renaming of the path. An error is returned if no path woth the specified tattoo can be found."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|get_path_by_tattoo_inargs
block|,
literal|1
block|,
name|get_path_by_tattoo_outargs
block|,
block|{
block|{
name|get_path_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_locked_invoker (Gimp * gimp,Argument * args)
name|path_get_locked_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|lockstatus
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|lockstatus
operator|=
name|gimp_item_get_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_locked_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|lockstatus
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_locked_inargs
specifier|static
name|ProcArg
name|path_get_locked_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose locked status should be obtained"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_outargs
specifier|static
name|ProcArg
name|path_get_locked_outargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"lockstatus"
block|,
literal|"The lock status associated with the name path. 0 returned if the path is not locked. 1 is returned if the path is locked"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_proc
specifier|static
name|ProcRecord
name|path_get_locked_proc
init|=
block|{
literal|"gimp_path_get_locked"
block|,
literal|"Returns the locked status associated with the name path."
block|,
literal|"This procedure returns the lock status associated with the specified path. A path can be \"locked\" which means that the transformation tool operations will also apply to the path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|2
block|,
name|path_get_locked_inargs
block|,
literal|1
block|,
name|path_get_locked_outargs
block|,
block|{
block|{
name|path_get_locked_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_locked_invoker (Gimp * gimp,Argument * args)
name|path_set_locked_invoker
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|lockstatus
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gimage
operator|=
name|gimp_image_get_by_ID
argument_list|(
name|gimp
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|lockstatus
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
condition|)
name|gimp_item_set_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|lockstatus
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_locked_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_locked_inargs
specifier|static
name|ProcArg
name|path_set_locked_inargs
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose locked status should be set"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"lockstatus"
block|,
literal|"The lock status associated with the name path. 0 if the path is not locked. 1 if the path is to be locked"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_locked_proc
specifier|static
name|ProcRecord
name|path_set_locked_proc
init|=
block|{
literal|"gimp_path_set_locked"
block|,
literal|"Set the locked status associated with the name path."
block|,
literal|"This procedure sets the lock status associated with the specified path. A path can be \"locked\" which means that the transformation tool operations will also apply to the path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|GIMP_INTERNAL
block|,
literal|3
block|,
name|path_set_locked_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_locked_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

