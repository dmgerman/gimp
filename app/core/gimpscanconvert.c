begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|<libart_lgpl/libart.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpscanconvert.h"
end_include

begin_struct
DECL|struct|_GimpScanConvert
struct|struct
name|_GimpScanConvert
block|{
DECL|member|width
name|guint
name|width
decl_stmt|;
DECL|member|height
name|guint
name|height
decl_stmt|;
DECL|member|antialias
name|guint
name|antialias
decl_stmt|;
comment|/* how much to oversample by */
comment|/* currently only used as boolean value */
comment|/* record the first and last points so we can close the current polygon. */
DECL|member|got_first
name|gboolean
name|got_first
decl_stmt|;
DECL|member|first
name|GimpVector2
name|first
decl_stmt|;
DECL|member|prev
name|GimpVector2
name|prev
decl_stmt|;
DECL|member|got_last
name|gboolean
name|got_last
decl_stmt|;
DECL|member|last
name|GimpVector2
name|last
decl_stmt|;
DECL|member|num_nodes
name|guint
name|num_nodes
decl_stmt|;
DECL|member|vpath
name|ArtVpath
modifier|*
name|vpath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|GimpScanConvert
modifier|*
DECL|function|gimp_scan_convert_new (guint width,guint height,guint antialias)
name|gimp_scan_convert_new
parameter_list|(
name|guint
name|width
parameter_list|,
name|guint
name|height
parameter_list|,
name|guint
name|antialias
parameter_list|)
block|{
name|GimpScanConvert
modifier|*
name|sc
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|width
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|height
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|antialias
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_new0
argument_list|(
name|GimpScanConvert
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|antialias
operator|=
name|antialias
expr_stmt|;
name|sc
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|sc
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vpath
operator|=
name|NULL
expr_stmt|;
return|return
name|sc
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_scan_convert_free (GimpScanConvert * sc)
name|gimp_scan_convert_free
parameter_list|(
name|GimpScanConvert
modifier|*
name|sc
parameter_list|)
block|{
name|art_free
argument_list|(
name|sc
operator|->
name|vpath
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add "n_points" from "points" to the polygon currently being  * described by "scan_converter".  */
end_comment

begin_function
name|void
DECL|function|gimp_scan_convert_add_points (GimpScanConvert * sc,guint n_points,GimpVector2 * points,gboolean new_polygon)
name|gimp_scan_convert_add_points
parameter_list|(
name|GimpScanConvert
modifier|*
name|sc
parameter_list|,
name|guint
name|n_points
parameter_list|,
name|GimpVector2
modifier|*
name|points
parameter_list|,
name|gboolean
name|new_polygon
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|points
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We need up to three extra nodes later to close and finish the path */
name|sc
operator|->
name|vpath
operator|=
name|art_renew
argument_list|(
name|sc
operator|->
name|vpath
argument_list|,
name|ArtVpath
argument_list|,
name|sc
operator|->
name|num_nodes
operator|+
name|n_points
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* if we need to start a new polygon check, if we need to close the    * previous.    */
if|if
condition|(
name|new_polygon
condition|)
block|{
comment|/* close the last polygon if necessary */
if|if
condition|(
name|sc
operator|->
name|got_first
operator|&&
name|sc
operator|->
name|got_last
operator|&&
operator|(
name|sc
operator|->
name|first
operator|.
name|x
operator|!=
name|sc
operator|->
name|last
operator|.
name|x
operator|||
name|sc
operator|->
name|first
operator|.
name|y
operator|!=
name|sc
operator|->
name|last
operator|.
name|y
operator|)
condition|)
block|{
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|code
operator|=
name|ART_LINETO
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|x
operator|=
name|sc
operator|->
name|first
operator|.
name|x
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|y
operator|=
name|sc
operator|->
name|first
operator|.
name|y
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|got_first
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|got_last
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|got_first
operator|&&
name|n_points
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|got_first
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|first
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|code
operator|=
operator|(
name|sc
operator|->
name|num_nodes
operator|==
literal|0
operator|||
name|new_polygon
operator|)
condition|?
name|ART_MOVETO
else|:
name|ART_LINETO
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|x
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|y
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|++
expr_stmt|;
name|sc
operator|->
name|prev
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|prev
operator|.
name|x
operator|!=
name|points
index|[
name|i
index|]
operator|.
name|x
operator|||
name|sc
operator|->
name|prev
operator|.
name|y
operator|!=
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
block|{
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|code
operator|=
name|ART_LINETO
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|x
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|y
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|++
expr_stmt|;
name|sc
operator|->
name|prev
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_points
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|got_last
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|last
operator|=
name|points
index|[
name|n_points
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan convert the polygon described by the list of points passed to  * scan_convert_add_points, and return a channel with a bits set if  * they fall within the polygon defined.  The polygon is filled  * according to the even-odd rule.  The polygon is closed by  * joining the final point to the initial point.  */
end_comment

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_scan_convert_to_channel (GimpScanConvert * sc,GimpImage * gimage)
name|gimp_scan_convert_to_channel
parameter_list|(
name|GimpScanConvert
modifier|*
name|sc
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|PixelRegion
name|maskPR
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|ArtVpath
modifier|*
name|pert_vpath
decl_stmt|;
name|ArtSVP
modifier|*
name|svp
decl_stmt|,
modifier|*
name|svp2
decl_stmt|,
modifier|*
name|svp3
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/*  do we need to close the polygon? */
if|if
condition|(
name|sc
operator|->
name|got_first
operator|&&
name|sc
operator|->
name|got_last
operator|&&
operator|(
name|sc
operator|->
name|first
operator|.
name|x
operator|!=
name|sc
operator|->
name|last
operator|.
name|x
operator|||
name|sc
operator|->
name|first
operator|.
name|y
operator|!=
name|sc
operator|->
name|last
operator|.
name|y
operator|)
condition|)
block|{
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|code
operator|=
name|ART_LINETO
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|x
operator|=
name|sc
operator|->
name|first
operator|.
name|x
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|y
operator|=
name|sc
operator|->
name|first
operator|.
name|y
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|++
expr_stmt|;
block|}
name|mask
operator|=
name|gimp_channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|sc
operator|->
name|width
argument_list|,
name|sc
operator|->
name|height
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|code
operator|=
name|ART_END
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|x
operator|=
name|sc
operator|->
name|first
operator|.
name|x
expr_stmt|;
name|sc
operator|->
name|vpath
index|[
name|sc
operator|->
name|num_nodes
index|]
operator|.
name|y
operator|=
name|sc
operator|->
name|first
operator|.
name|y
expr_stmt|;
name|sc
operator|->
name|num_nodes
operator|++
expr_stmt|;
comment|/*    * Current Libart (2.3.8) recommends a slight random distorsion    * of the path, because art_svp_uncross and art_svp_rewind_uncrossed    * are not yet numerically stable. It is actually possible to construct    * worst case scenarios. The slight perturbation should not have any    * visible effect.    */
comment|/* Debug output of libart path   for (i=0; i< sc->num_nodes ; i++)     {       g_printerr ("X: %f, Y: %f, Type: %d\n", sc->vpath[i].x, sc->vpath[i].y,                                               sc->vpath[i].code );     }   */
name|pert_vpath
operator|=
name|art_vpath_perturb
argument_list|(
name|sc
operator|->
name|vpath
argument_list|)
expr_stmt|;
name|svp
operator|=
name|art_svp_from_vpath
argument_list|(
name|pert_vpath
argument_list|)
expr_stmt|;
name|svp2
operator|=
name|art_svp_uncross
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|svp3
operator|=
name|art_svp_rewind_uncrossed
argument_list|(
name|svp2
argument_list|,
name|ART_WIND_RULE_ODDEVEN
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|maskPR
operator|.
name|bytes
operator|==
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|maskPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|art_gray_svp_aa
argument_list|(
name|svp3
argument_list|,
name|maskPR
operator|.
name|x
argument_list|,
name|maskPR
operator|.
name|y
argument_list|,
name|maskPR
operator|.
name|x
operator|+
name|maskPR
operator|.
name|w
argument_list|,
name|maskPR
operator|.
name|y
operator|+
name|maskPR
operator|.
name|h
argument_list|,
name|maskPR
operator|.
name|data
argument_list|,
name|maskPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|antialias
condition|)
block|{
comment|/*            * Ok, the user didn't want to have antialiasing, so just            * remove the results from lots of CPU-Power...            */
name|dest
operator|=
name|maskPR
operator|.
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|maskPR
operator|.
name|h
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maskPR
operator|.
name|w
condition|;
name|i
operator|++
control|)
block|{
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|d
index|[
literal|0
index|]
operator|>=
literal|127
operator|)
condition|?
literal|255
else|:
literal|0
expr_stmt|;
name|d
operator|+=
name|maskPR
operator|.
name|bytes
expr_stmt|;
block|}
name|dest
operator|+=
name|maskPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
block|}
name|art_free
argument_list|(
name|svp3
argument_list|)
expr_stmt|;
name|art_free
argument_list|(
name|svp2
argument_list|)
expr_stmt|;
name|art_free
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|art_free
argument_list|(
name|pert_vpath
argument_list|)
expr_stmt|;
name|mask
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

end_unit

