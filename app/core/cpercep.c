begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1999-2002 Adam D. Moss (the "Author").  All Rights Reserved.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is fur- nished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT- NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON- NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the Author of the Software shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the Author. */
end_comment

begin_comment
comment|/*   cpercep.c: The CPercep Functions v0.9: 2002-02-10   Adam D. Moss: adam@gimp.org<http://www.foxbox.org/adam/code/cpercep/>    This code module concerns itself with conversion from a hard-coded   RGB colour space (sRGB by default) to CIE L*a*b* and back again with   (primarily) precision and (secondarily) speed, oriented largely   towards the purposes of quantifying the PERCEPTUAL difference between   two arbitrary RGB colours with a minimum of fuss.    Motivation One: The author is disheartened at the amount of graphics   processing software around which uses weighted or non-weighted   Euclidean distance between co-ordinates within a (poorly-defined) RGB   space as the basis of what should really be an estimate of perceptual   difference to the human eye.  Certainly it's fast to do it that way,   but please think carefully about whether your particular application   should be tolerating sloppy results for the sake of real-time response.    Motivation Two: Lack of tested, re-usable and free code available   for this purpose.  The difficulty in finding something similar to   CPercep with a free license motivated this project; I hope that this   code also serves to illustrate how to perform the   R'G'B'->XYZ->L*a*b*->XYZ->R'G'B' transformation correctly since I   was distressed to note how many of the equations and code snippets   on the net were omitting the reverse transform and/or were using   incorrectly-derived or just plain wrong constants.    TODO: document functions, rename erroneously-named arguments */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__GLIBC__
end_ifndef

begin_comment
comment|/* cbrt() is a GNU extension */
end_comment

begin_define
DECL|macro|cbrt (x)
define|#
directive|define
name|cbrt
parameter_list|(
name|x
parameter_list|)
value|(pow(x, 1.0/3.0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GIMP_COMPILATION
end_ifdef

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_comment
comment|/* to get working 'inline' */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defines:     SANITY: emits warnings when passed non-sane colours (and usually    corrects them) -- useful when debugging.     APPROX: speeds up the conversion from RGB to the colourspace by    assuming that the RGB values passed in are integral and definitely    in the range 0->255     SRGB: assumes that the RGB values being passed in (and out) are    destined for an sRGB-alike display device (a typical modern monitor)    -- if you change this then you'll probably want to change ASSUMED_GAMMA,    the phosphor colours and the white point definition. */
end_comment

begin_comment
comment|/* #define SANITY */
end_comment

begin_define
DECL|macro|APPROX
define|#
directive|define
name|APPROX
end_define

begin_define
DECL|macro|SRGB
define|#
directive|define
name|SRGB
end_define

begin_include
include|#
directive|include
file|"cpercep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SRGB
end_ifdef

begin_define
DECL|macro|ASSUMED_GAMMA
define|#
directive|define
name|ASSUMED_GAMMA
value|(2.2F)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*#define ASSUMED_GAMMA (2.591F)*/
end_comment

begin_define
DECL|macro|ASSUMED_GAMMA
define|#
directive|define
name|ASSUMED_GAMMA
value|(2.2F)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|REV_GAMMA
define|#
directive|define
name|REV_GAMMA
value|((1.0F / ASSUMED_GAMMA))
end_define

begin_comment
comment|/* define characteristics of the source RGB space (and the space    within which we try to behave linearly). */
end_comment

begin_comment
comment|/* Phosphor colours: */
end_comment

begin_comment
comment|/* sRGB/HDTV phosphor colours */
end_comment

begin_decl_stmt
DECL|variable|pxr
specifier|static
specifier|const
name|double
name|pxr
init|=
literal|0.64F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pyr
specifier|static
specifier|const
name|double
name|pyr
init|=
literal|0.33F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pxg
specifier|static
specifier|const
name|double
name|pxg
init|=
literal|0.30F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pyg
specifier|static
specifier|const
name|double
name|pyg
init|=
literal|0.60F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pxb
specifier|static
specifier|const
name|double
name|pxb
init|=
literal|0.15F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pyb
specifier|static
specifier|const
name|double
name|pyb
init|=
literal|0.06F
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* White point: */
end_comment

begin_comment
comment|/* D65 (6500K) (recommended but not a common display default) */
end_comment

begin_decl_stmt
DECL|variable|lxn
specifier|static
specifier|const
name|double
name|lxn
init|=
literal|0.312713F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lyn
specifier|static
specifier|const
name|double
name|lyn
init|=
literal|0.329016F
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* D50 (5000K) */
end_comment

begin_comment
comment|/*static const double lxn = 0.3457F; */
end_comment

begin_comment
comment|/*static const double lyn = 0.3585F; */
end_comment

begin_comment
comment|/* D55 (5500K) */
end_comment

begin_comment
comment|/*static const double lxn = 0.3324F; */
end_comment

begin_comment
comment|/*static const double lyn = 0.3474F; */
end_comment

begin_comment
comment|/* D93 (9300K) (a common monitor default, but poor colour reproduction) */
end_comment

begin_comment
comment|/* static const double lxn = 0.2848F; */
end_comment

begin_comment
comment|/* static const double lyn = 0.2932F; */
end_comment

begin_comment
comment|/* illum E (normalized) */
end_comment

begin_comment
comment|/*static const double lxn = 1.0/3.0F; */
end_comment

begin_comment
comment|/*static const double lyn = 1.0/3.0F; */
end_comment

begin_comment
comment|/* illum C (average sunlight) */
end_comment

begin_comment
comment|/*static const double lxn = 0.3101F; */
end_comment

begin_comment
comment|/*static const double lyn = 0.3162F; */
end_comment

begin_comment
comment|/* illum B (direct sunlight) */
end_comment

begin_comment
comment|/*static const double lxn = 0.3484F; */
end_comment

begin_comment
comment|/*static const double lyn = 0.3516F; */
end_comment

begin_comment
comment|/* illum A (tungsten lamp) */
end_comment

begin_comment
comment|/*static const double lxn = 0.4476F; */
end_comment

begin_comment
comment|/*static const double lyn = 0.4074F; */
end_comment

begin_decl_stmt
DECL|variable|LRAMP
specifier|static
specifier|const
name|double
name|LRAMP
init|=
literal|7.99959199F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xnn
DECL|variable|znn
specifier|static
name|double
name|xnn
decl_stmt|,
name|znn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|powtable
specifier|static
name|double
name|powtable
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CLAMP
end_ifndef

begin_define
DECL|macro|CLAMP (x,l,u)
define|#
directive|define
name|CLAMP
parameter_list|(
name|x
parameter_list|,
name|l
parameter_list|,
name|u
parameter_list|)
value|((x)<(l)?(l):((x)>(u)?(u):(x)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|init_powtable (const double gamma)
name|init_powtable
parameter_list|(
specifier|const
name|double
name|gamma
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|SRGB
comment|/* pure gamma function */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|powtable
index|[
name|i
index|]
operator|=
name|pow
argument_list|(
operator|(
name|i
operator|)
operator|/
literal|255.0F
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* sRGB gamma curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
comment|/* 0.03928 * 255 */
condition|;
name|i
operator|++
control|)
block|{
name|powtable
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|)
operator|/
operator|(
literal|255.0F
operator|*
literal|12.92F
operator|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|powtable
index|[
name|i
index|]
operator|=
name|pow
argument_list|(
operator|(
operator|(
operator|(
name|i
operator|)
operator|/
literal|255.0F
operator|)
operator|+
literal|0.055F
operator|)
operator|/
literal|1.055F
argument_list|,
literal|2.4F
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_typedef
DECL|typedef|CMatrix
typedef|typedef
name|double
name|CMatrix
index|[
literal|3
index|]
index|[
literal|3
index|]
typedef|;
end_typedef

begin_typedef
DECL|typedef|CVector
typedef|typedef
name|double
name|CVector
index|[
literal|3
index|]
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|Mrgb_to_xyz
DECL|variable|Mxyz_to_rgb
specifier|static
name|CMatrix
name|Mrgb_to_xyz
decl_stmt|,
name|Mxyz_to_rgb
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|Minvert (CMatrix src,CMatrix dest)
name|Minvert
parameter_list|(
name|CMatrix
name|src
parameter_list|,
name|CMatrix
name|dest
parameter_list|)
block|{
name|double
name|det
decl_stmt|;
name|dest
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|src
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|src
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|src
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|src
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|src
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|det
operator|=
name|src
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|dest
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|src
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|dest
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|src
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|dest
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|det
operator|<=
literal|0.0F
condition|)
block|{
ifdef|#
directive|ifdef
name|SANITY
name|g_printerr
argument_list|(
literal|"\n\007 XXXX det: %f\n"
argument_list|,
name|det
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|dest
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|/=
name|det
expr_stmt|;
name|dest
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|/=
name|det
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|rgbxyzrgb_init (void)
name|rgbxyzrgb_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_powtable
argument_list|(
name|ASSUMED_GAMMA
argument_list|)
expr_stmt|;
name|xnn
operator|=
name|lxn
operator|/
name|lyn
expr_stmt|;
comment|/* ynn taken as 1.0 */
name|znn
operator|=
operator|(
literal|1.0F
operator|-
operator|(
name|lxn
operator|+
name|lyn
operator|)
operator|)
operator|/
name|lyn
expr_stmt|;
block|{
name|CMatrix
name|MRC
decl_stmt|,
name|MRCi
decl_stmt|;
name|double
name|C1
decl_stmt|,
name|C2
decl_stmt|,
name|C3
decl_stmt|;
name|MRC
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|pxr
expr_stmt|;
name|MRC
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|pxg
expr_stmt|;
name|MRC
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|pxb
expr_stmt|;
name|MRC
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|pyr
expr_stmt|;
name|MRC
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|pyg
expr_stmt|;
name|MRC
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|pyb
expr_stmt|;
name|MRC
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|1.0F
operator|-
operator|(
name|pxr
operator|+
name|pyr
operator|)
expr_stmt|;
name|MRC
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|1.0F
operator|-
operator|(
name|pxg
operator|+
name|pyg
operator|)
expr_stmt|;
name|MRC
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0F
operator|-
operator|(
name|pxb
operator|+
name|pyb
operator|)
expr_stmt|;
name|Minvert
argument_list|(
name|MRC
argument_list|,
name|MRCi
argument_list|)
expr_stmt|;
name|C1
operator|=
name|MRCi
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|xnn
operator|+
name|MRCi
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|MRCi
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|znn
expr_stmt|;
name|C2
operator|=
name|MRCi
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|xnn
operator|+
name|MRCi
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|MRCi
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|znn
expr_stmt|;
name|C3
operator|=
name|MRCi
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|xnn
operator|+
name|MRCi
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|MRCi
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|znn
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|MRC
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|C1
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|MRC
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|C2
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|MRC
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|C3
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|MRC
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|C1
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|MRC
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|C2
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|MRC
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|C3
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|MRC
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|C1
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|MRC
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|C2
expr_stmt|;
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|MRC
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|C3
expr_stmt|;
name|Minvert
argument_list|(
name|Mrgb_to_xyz
argument_list|,
name|Mxyz_to_rgb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xyz_to_rgb (double * inx_outr,double * iny_outg,double * inz_outb)
name|xyz_to_rgb
parameter_list|(
name|double
modifier|*
name|inx_outr
parameter_list|,
name|double
modifier|*
name|iny_outg
parameter_list|,
name|double
modifier|*
name|inz_outb
parameter_list|)
block|{
specifier|const
name|double
name|x
init|=
operator|*
name|inx_outr
decl_stmt|;
specifier|const
name|double
name|y
init|=
operator|*
name|iny_outg
decl_stmt|;
specifier|const
name|double
name|z
init|=
operator|*
name|inz_outb
decl_stmt|;
operator|*
name|inx_outr
operator|=
name|Mxyz_to_rgb
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|Mxyz_to_rgb
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|Mxyz_to_rgb
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
operator|*
name|iny_outg
operator|=
name|Mxyz_to_rgb
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|Mxyz_to_rgb
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|Mxyz_to_rgb
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
operator|*
name|inz_outb
operator|=
name|Mxyz_to_rgb
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|Mxyz_to_rgb
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|Mxyz_to_rgb
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|rgb_to_xyz (double * inr_outx,double * ing_outy,double * inb_outz)
name|rgb_to_xyz
parameter_list|(
name|double
modifier|*
name|inr_outx
parameter_list|,
name|double
modifier|*
name|ing_outy
parameter_list|,
name|double
modifier|*
name|inb_outz
parameter_list|)
block|{
specifier|const
name|double
name|r
init|=
operator|*
name|inr_outx
decl_stmt|;
specifier|const
name|double
name|g
init|=
operator|*
name|ing_outy
decl_stmt|;
specifier|const
name|double
name|b
init|=
operator|*
name|inb_outz
decl_stmt|;
operator|*
name|inr_outx
operator|=
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|r
operator|+
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|g
operator|+
name|Mrgb_to_xyz
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|b
expr_stmt|;
operator|*
name|ing_outy
operator|=
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|r
operator|+
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|g
operator|+
name|Mrgb_to_xyz
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|b
expr_stmt|;
operator|*
name|inb_outz
operator|=
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|r
operator|+
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|g
operator|+
name|Mrgb_to_xyz
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|b
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|double
DECL|function|ffunc (const double t)
name|ffunc
parameter_list|(
specifier|const
name|double
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|>
literal|0.008856F
condition|)
block|{
return|return
operator|(
name|cbrt
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|7.787F
operator|*
name|t
operator|+
literal|16.0F
operator|/
literal|116.0F
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|double
DECL|function|ffunc_inv (const double t)
name|ffunc_inv
parameter_list|(
specifier|const
name|double
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|>
literal|0.206893F
condition|)
block|{
return|return
operator|(
name|t
operator|*
name|t
operator|*
name|t
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|t
operator|-
literal|16.0F
operator|/
literal|116.0F
operator|)
operator|/
literal|7.787F
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xyz_to_lab (double * inx,double * iny,double * inz)
name|xyz_to_lab
parameter_list|(
name|double
modifier|*
name|inx
parameter_list|,
name|double
modifier|*
name|iny
parameter_list|,
name|double
modifier|*
name|inz
parameter_list|)
block|{
name|double
name|L
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|double
name|ffuncY
decl_stmt|;
specifier|const
name|double
name|X
init|=
operator|*
name|inx
decl_stmt|;
specifier|const
name|double
name|Y
init|=
operator|*
name|iny
decl_stmt|;
specifier|const
name|double
name|Z
init|=
operator|*
name|inz
decl_stmt|;
if|if
condition|(
name|Y
operator|>
literal|0.0F
condition|)
block|{
if|if
condition|(
name|Y
operator|>
literal|0.008856F
condition|)
block|{
name|L
operator|=
operator|(
literal|116.0F
operator|*
name|cbrt
argument_list|(
name|Y
argument_list|)
operator|)
operator|-
literal|16.0F
expr_stmt|;
block|}
else|else
block|{
name|L
operator|=
operator|(
name|Y
operator|*
literal|903.3F
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SANITY
if|if
condition|(
name|L
operator|<
literal|0.0F
condition|)
block|{
name|g_printerr
argument_list|(
literal|"<eek1>%f \007"
argument_list|,
operator|(
name|float
operator|)
name|L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|L
operator|>
literal|100.0F
condition|)
block|{
name|g_printerr
argument_list|(
literal|"<eek2>%f \007"
argument_list|,
operator|(
name|float
operator|)
name|L
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|L
operator|=
literal|0.0
expr_stmt|;
block|}
name|ffuncY
operator|=
name|ffunc
argument_list|(
name|Y
argument_list|)
expr_stmt|;
name|a
operator|=
literal|500.0F
operator|*
operator|(
name|ffunc
argument_list|(
name|X
operator|/
name|xnn
argument_list|)
operator|-
name|ffuncY
operator|)
expr_stmt|;
name|b
operator|=
literal|200.0F
operator|*
operator|(
name|ffuncY
operator|-
name|ffunc
argument_list|(
name|Z
operator|/
name|znn
argument_list|)
operator|)
expr_stmt|;
operator|*
name|inx
operator|=
name|L
expr_stmt|;
operator|*
name|iny
operator|=
name|a
expr_stmt|;
operator|*
name|inz
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|lab_to_xyz (double * inl,double * ina,double * inb)
name|lab_to_xyz
parameter_list|(
name|double
modifier|*
name|inl
parameter_list|,
name|double
modifier|*
name|ina
parameter_list|,
name|double
modifier|*
name|inb
parameter_list|)
block|{
name|double
name|X
decl_stmt|,
name|Y
decl_stmt|,
name|Z
decl_stmt|;
name|double
name|P
decl_stmt|;
specifier|const
name|double
name|L
init|=
operator|*
name|inl
decl_stmt|;
specifier|const
name|double
name|a
init|=
operator|*
name|ina
decl_stmt|;
specifier|const
name|double
name|b
init|=
operator|*
name|inb
decl_stmt|;
if|if
condition|(
name|L
operator|>
name|LRAMP
condition|)
block|{
name|P
operator|=
name|Y
operator|=
operator|(
name|L
operator|+
literal|16.0F
operator|)
operator|/
literal|116.0F
expr_stmt|;
name|Y
operator|=
name|Y
operator|*
name|Y
operator|*
name|Y
expr_stmt|;
block|}
else|else
block|{
name|Y
operator|=
name|L
operator|/
literal|903.3F
expr_stmt|;
name|P
operator|=
literal|7.787F
operator|*
name|Y
operator|+
literal|16.0F
operator|/
literal|116.0F
expr_stmt|;
block|}
name|X
operator|=
operator|(
name|P
operator|+
name|a
operator|/
literal|500.0F
operator|)
expr_stmt|;
name|X
operator|=
name|xnn
operator|*
name|ffunc_inv
argument_list|(
name|X
argument_list|)
expr_stmt|;
name|Z
operator|=
operator|(
name|P
operator|-
name|b
operator|/
literal|200.0F
operator|)
expr_stmt|;
name|Z
operator|=
name|znn
operator|*
name|ffunc_inv
argument_list|(
name|Z
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANITY
if|if
condition|(
name|X
operator|<
operator|-
literal|0.00000F
condition|)
block|{
if|if
condition|(
name|X
operator|<
operator|-
literal|0.0001F
condition|)
name|g_printerr
argument_list|(
literal|"{badX %f {%f,%f,%f}}"
argument_list|,
name|X
argument_list|,
name|L
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|X
operator|=
literal|0.0F
expr_stmt|;
block|}
if|if
condition|(
name|Y
operator|<
operator|-
literal|0.00000F
condition|)
block|{
if|if
condition|(
name|Y
operator|<
operator|-
literal|0.0001F
condition|)
name|g_printerr
argument_list|(
literal|"{badY %f}"
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|Y
operator|=
literal|0.0F
expr_stmt|;
block|}
if|if
condition|(
name|Z
operator|<
operator|-
literal|0.00000F
condition|)
block|{
if|if
condition|(
name|Z
operator|<
operator|-
literal|0.1F
condition|)
name|g_printerr
argument_list|(
literal|"{badZ %f}"
argument_list|,
name|Z
argument_list|)
expr_stmt|;
name|Z
operator|=
literal|0.0F
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|inl
operator|=
name|X
expr_stmt|;
operator|*
name|ina
operator|=
name|Y
expr_stmt|;
operator|*
name|inb
operator|=
name|Z
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this before using the CPercep function */
end_comment

begin_function
name|void
DECL|function|cpercep_init (void)
name|cpercep_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|gboolean
name|initialized
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|rgbxyzrgb_init
argument_list|()
expr_stmt|;
name|initialized
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|cpercep_rgb_to_space (double inr,double ing,double inb,double * outr,double * outg,double * outb)
name|cpercep_rgb_to_space
parameter_list|(
name|double
name|inr
parameter_list|,
name|double
name|ing
parameter_list|,
name|double
name|inb
parameter_list|,
name|double
modifier|*
name|outr
parameter_list|,
name|double
modifier|*
name|outg
parameter_list|,
name|double
modifier|*
name|outb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|APPROX
ifdef|#
directive|ifdef
name|SANITY
comment|/* ADM extra sanity */
if|if
condition|(
operator|(
name|inr
operator|)
operator|>
literal|255.0F
operator|||
operator|(
name|ing
operator|)
operator|>
literal|255.0F
operator|||
operator|(
name|inb
operator|)
operator|>
literal|255.0F
operator|||
operator|(
name|inr
operator|)
operator|<
operator|-
literal|0.0F
operator|||
operator|(
name|ing
operator|)
operator|<
operator|-
literal|0.0F
operator|||
operator|(
name|inb
operator|)
operator|<
operator|-
literal|0.0F
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SANITY */
name|inr
operator|=
name|powtable
index|[
operator|(
name|int
operator|)
name|inr
index|]
expr_stmt|;
name|ing
operator|=
name|powtable
index|[
operator|(
name|int
operator|)
name|ing
index|]
expr_stmt|;
name|inb
operator|=
name|powtable
index|[
operator|(
name|int
operator|)
name|inb
index|]
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SRGB
comment|/* sRGB gamma curve */
if|if
condition|(
name|inr
operator|<=
operator|(
literal|0.03928F
operator|*
literal|255.0F
operator|)
condition|)
name|inr
operator|=
name|inr
operator|/
operator|(
literal|255.0F
operator|*
literal|12.92F
operator|)
expr_stmt|;
else|else
name|inr
operator|=
name|pow
argument_list|(
operator|(
name|inr
operator|+
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
operator|)
operator|/
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
argument_list|,
literal|2.4F
argument_list|)
expr_stmt|;
if|if
condition|(
name|ing
operator|<=
operator|(
literal|0.03928F
operator|*
literal|255.0F
operator|)
condition|)
name|ing
operator|=
name|ing
operator|/
operator|(
literal|255.0F
operator|*
literal|12.92F
operator|)
expr_stmt|;
else|else
name|ing
operator|=
name|pow
argument_list|(
operator|(
name|ing
operator|+
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
operator|)
operator|/
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
argument_list|,
literal|2.4F
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
operator|<=
operator|(
literal|0.03928F
operator|*
literal|255.0F
operator|)
condition|)
name|inb
operator|=
name|inb
operator|/
operator|(
literal|255.0F
operator|*
literal|12.92F
operator|)
expr_stmt|;
else|else
name|inb
operator|=
name|pow
argument_list|(
operator|(
name|inb
operator|+
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
operator|)
operator|/
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
argument_list|,
literal|2.4F
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* pure gamma function */
name|inr
operator|=
name|pow
argument_list|(
operator|(
name|inr
operator|)
operator|/
literal|255.0F
argument_list|,
name|ASSUMED_GAMMA
argument_list|)
expr_stmt|;
name|ing
operator|=
name|pow
argument_list|(
operator|(
name|ing
operator|)
operator|/
literal|255.0F
argument_list|,
name|ASSUMED_GAMMA
argument_list|)
expr_stmt|;
name|inb
operator|=
name|pow
argument_list|(
operator|(
name|inb
operator|)
operator|/
literal|255.0F
argument_list|,
name|ASSUMED_GAMMA
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SRGB */
endif|#
directive|endif
comment|/* APPROX */
ifdef|#
directive|ifdef
name|SANITY
comment|/* ADM extra sanity */
if|if
condition|(
operator|(
name|inr
operator|)
operator|>
literal|1.0F
operator|||
operator|(
name|ing
operator|)
operator|>
literal|1.0F
operator|||
operator|(
name|inb
operator|)
operator|>
literal|1.0F
operator|||
operator|(
name|inr
operator|)
operator|<
literal|0.0F
operator|||
operator|(
name|ing
operator|)
operator|<
literal|0.0F
operator|||
operator|(
name|inb
operator|)
operator|<
literal|0.0F
condition|)
block|{
name|g_printerr
argument_list|(
literal|"%%"
argument_list|)
expr_stmt|;
comment|/* abort(); */
block|}
endif|#
directive|endif
comment|/* SANITY */
name|rgb_to_xyz
argument_list|(
operator|&
name|inr
argument_list|,
operator|&
name|ing
argument_list|,
operator|&
name|inb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANITY
if|if
condition|(
name|inr
operator|<
literal|0.0F
operator|||
name|ing
operator|<
literal|0.0F
operator|||
name|inb
operator|<
literal|0.0F
condition|)
block|{
name|g_printerr
argument_list|(
literal|" [BAD2 XYZ: %f,%f,%f]\007 "
argument_list|,
name|inr
argument_list|,
name|ing
argument_list|,
name|inb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SANITY */
name|xyz_to_lab
argument_list|(
operator|&
name|inr
argument_list|,
operator|&
name|ing
argument_list|,
operator|&
name|inb
argument_list|)
expr_stmt|;
operator|*
name|outr
operator|=
name|inr
expr_stmt|;
operator|*
name|outg
operator|=
name|ing
expr_stmt|;
operator|*
name|outb
operator|=
name|inb
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|cpercep_space_to_rgb (double inr,double ing,double inb,double * outr,double * outg,double * outb)
name|cpercep_space_to_rgb
parameter_list|(
name|double
name|inr
parameter_list|,
name|double
name|ing
parameter_list|,
name|double
name|inb
parameter_list|,
name|double
modifier|*
name|outr
parameter_list|,
name|double
modifier|*
name|outg
parameter_list|,
name|double
modifier|*
name|outb
parameter_list|)
block|{
name|lab_to_xyz
argument_list|(
operator|&
name|inr
argument_list|,
operator|&
name|ing
argument_list|,
operator|&
name|inb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANITY
if|if
condition|(
name|inr
operator|<
operator|-
literal|0.0F
operator|||
name|ing
operator|<
operator|-
literal|0.0F
operator|||
name|inb
operator|<
operator|-
literal|0.0F
condition|)
block|{
name|g_printerr
argument_list|(
literal|" [BAD1 XYZ: %f,%f,%f]\007 "
argument_list|,
name|inr
argument_list|,
name|ing
argument_list|,
name|inb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xyz_to_rgb
argument_list|(
operator|&
name|inr
argument_list|,
operator|&
name|ing
argument_list|,
operator|&
name|inb
argument_list|)
expr_stmt|;
comment|/* yes, essential.  :( */
name|inr
operator|=
name|CLAMP
argument_list|(
name|inr
argument_list|,
literal|0.0F
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
name|ing
operator|=
name|CLAMP
argument_list|(
name|ing
argument_list|,
literal|0.0F
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
name|inb
operator|=
name|CLAMP
argument_list|(
name|inb
argument_list|,
literal|0.0F
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SRGB
if|if
condition|(
name|inr
operator|<=
literal|0.0030402477F
condition|)
name|inr
operator|=
name|inr
operator|*
operator|(
literal|12.92F
operator|*
literal|255.0F
operator|)
expr_stmt|;
else|else
name|inr
operator|=
name|pow
argument_list|(
name|inr
argument_list|,
literal|1.0F
operator|/
literal|2.4F
argument_list|)
operator|*
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
operator|-
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
expr_stmt|;
if|if
condition|(
name|ing
operator|<=
literal|0.0030402477F
condition|)
name|ing
operator|=
name|ing
operator|*
operator|(
literal|12.92F
operator|*
literal|255.0F
operator|)
expr_stmt|;
else|else
name|ing
operator|=
name|pow
argument_list|(
name|ing
argument_list|,
literal|1.0F
operator|/
literal|2.4F
argument_list|)
operator|*
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
operator|-
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
expr_stmt|;
if|if
condition|(
name|inb
operator|<=
literal|0.0030402477F
condition|)
name|inb
operator|=
name|inb
operator|*
operator|(
literal|12.92F
operator|*
literal|255.0F
operator|)
expr_stmt|;
else|else
name|inb
operator|=
name|pow
argument_list|(
name|inb
argument_list|,
literal|1.0F
operator|/
literal|2.4F
argument_list|)
operator|*
operator|(
literal|1.055F
operator|*
literal|255.0F
operator|)
operator|-
operator|(
literal|0.055F
operator|*
literal|255.0F
operator|)
expr_stmt|;
else|#
directive|else
name|inr
operator|=
literal|255.0F
operator|*
name|pow
argument_list|(
name|inr
argument_list|,
name|REV_GAMMA
argument_list|)
expr_stmt|;
name|ing
operator|=
literal|255.0F
operator|*
name|pow
argument_list|(
name|ing
argument_list|,
name|REV_GAMMA
argument_list|)
expr_stmt|;
name|inb
operator|=
literal|255.0F
operator|*
name|pow
argument_list|(
name|inb
argument_list|,
name|REV_GAMMA
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|outr
operator|=
name|inr
expr_stmt|;
operator|*
name|outg
operator|=
name|ing
expr_stmt|;
operator|*
name|outb
operator|=
name|inb
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* EXPERIMENTAL SECTION */
end_comment

begin_if
unit|const double xscaler(const double start, const double end, 	const double me, const double him) {   return start + ((end-start) * him) / (me + him); }   void mix_colours (const double L1, const double a1, const double b1, 	     const double L2, const double a2, const double b2, 	     double *rtnL, double *rtna, double *rtnb, 	     double mass1, double mass2) {   double w1, w2;
if|#
directive|if
literal|0
end_if

begin_else
unit|*rtnL = xscaler (L1, L2, mass1, mass2);   *rtna = xscaler (a1, a2, mass1, mass2);   *rtnb = xscaler (b1, b2, mass1, mass2);
else|#
directive|else
end_else

begin_if
if|#
directive|if
literal|1
end_if

begin_else
unit|w1 = mass1 * L1;   w2 = mass2 * L2;
else|#
directive|else
end_else

begin_endif
unit|w1 = mass1 * (L1*L1*L1);   w2 = mass2 * (L2*L2*L2);
endif|#
directive|endif
end_endif

begin_ifdef
unit|*rtnL = xscaler (L1, L2, mass1, mass2);    if (w1<= 0.0&&       w2<= 0.0)     {       *rtna = 	*rtnb = 0.0;
ifdef|#
directive|ifdef
name|SANITY
end_ifdef

begin_comment
comment|/* g_printerr ("\007OUCH. "); */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|}   else     {       *rtna = xscaler(a1, a2, w1, w2);       *rtnb = xscaler(b1, b2, w1, w2);     }
endif|#
directive|endif
end_endif

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXPERIMENTAL SECTION */
end_comment

end_unit

