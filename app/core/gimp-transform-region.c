begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995-2003 Spencer Kimball, Peter Mattis, and others  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-surround.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/scale-funcs.h"
end_include

begin_include
include|#
directive|include
file|"gimp-transform-region.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpprogress.h"
end_include

begin_comment
comment|/*  forward function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gboolean
name|supersample_dtest
parameter_list|(
name|gdouble
name|u0
parameter_list|,
name|gdouble
name|v0
parameter_list|,
name|gdouble
name|u1
parameter_list|,
name|gdouble
name|v1
parameter_list|,
name|gdouble
name|u2
parameter_list|,
name|gdouble
name|v2
parameter_list|,
name|gdouble
name|u3
parameter_list|,
name|gdouble
name|v3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gdouble
name|uc
parameter_list|,
name|gdouble
name|vc
parameter_list|,
name|gdouble
name|u0
parameter_list|,
name|gdouble
name|v0
parameter_list|,
name|gdouble
name|u1
parameter_list|,
name|gdouble
name|v1
parameter_list|,
name|gdouble
name|u2
parameter_list|,
name|gdouble
name|v2
parameter_list|,
name|gdouble
name|u3
parameter_list|,
name|gdouble
name|v3
parameter_list|,
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|void
DECL|function|gimp_transform_region (GimpPickable * pickable,GimpContext * context,TileManager * orig_tiles,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,const GimpMatrix3 * matrix,GimpInterpolationType interpolation_type,gboolean supersample,gint recursion_level,GimpProgress * progress)
name|gimp_transform_region
parameter_list|(
name|GimpPickable
modifier|*
name|pickable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gboolean
name|supersample
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|PixelSurround
name|surround
decl_stmt|;
name|GimpImageType
name|pickable_type
decl_stmt|;
name|GimpMatrix3
name|m
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* target coordinates */
name|gint
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|u2
decl_stmt|,
name|v2
decl_stmt|;
comment|/* source bounding box */
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates                                         * per horizontal target coordinate                                         */
name|gdouble
name|u
index|[
literal|5
index|]
decl_stmt|,
name|v
index|[
literal|5
index|]
decl_stmt|;
comment|/* source coordinates,                                         *                                         *   2     0    is sample in the center                                         *  / \         of pixel                                         * 1 0 3   1..4 is offset 1 pixel in                                         *  \ /         each direction                                         *   4          (in target space)                                         */
name|gdouble
name|tu
index|[
literal|5
index|]
decl_stmt|,
name|tv
index|[
literal|5
index|]
decl_stmt|,
name|tw
index|[
literal|5
index|]
decl_stmt|;
comment|/* undivided source coordinates and                                         * divisor                                         */
name|gint
name|coords
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|u1
argument_list|,
operator|&
name|v1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|u1
operator|+
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|v2
operator|=
name|v1
operator|+
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|matrix
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|alpha
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|dest_x2
operator|-
name|dest_x1
expr_stmt|;
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
comment|/*  turn interpolation off for simple transformations (e.g. rot90)  */
if|if
condition|(
name|gimp_matrix3_is_simple
argument_list|(
name|matrix
argument_list|)
condition|)
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
name|pickable_type
operator|=
name|gimp_pickable_get_image_type
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  Get the background color  */
name|gimp_image_get_background
argument_list|(
name|gimp_pickable_get_image
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|context
argument_list|,
name|pickable_type
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|pickable_type
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|bg_color
index|[
name|ALPHA_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|bg_color
index|[
name|ALPHA_G_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_G_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|bg_color
index|[
name|ALPHA_I_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_I_PIX
expr_stmt|;
comment|/*  If the image is indexed color, ignore interpolation value  */
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|pickable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
comment|/*  setting alpha = 0 will cause the channel's value to be treated    *  as alpha and the color channel loops never to be entered    */
if|if
condition|(
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|alpha
operator|=
literal|0
expr_stmt|;
comment|/* initialise the pixel_surround and pixel_cache accessors */
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|orig_tiles
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|orig_tiles
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
break|break;
block|}
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/* these loops could be rearranged, depending on which bit of code    * you'd most like to write more than once.    */
if|if
condition|(
name|interpolation_type
operator|==
name|GIMP_INTERPOLATION_LANCZOS
condition|)
block|{
name|gfloat
modifier|*
name|lanczos
decl_stmt|;
comment|/* Lanczos lookup table         */
name|gdouble
name|x_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* 1-D kernels of window coeffs */
name|gdouble
name|y_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
name|gdouble
name|x_sum
decl_stmt|,
name|y_sum
decl_stmt|;
comment|/* sum of Lanczos weights       */
name|gdouble
name|uw
decl_stmt|;
name|gdouble
name|ww
decl_stmt|;
name|gdouble
name|vw
decl_stmt|;
name|gdouble
name|du
decl_stmt|;
name|gdouble
name|dv
decl_stmt|;
name|gint
name|pos
decl_stmt|;
name|gdouble
name|newval
decl_stmt|;
name|gdouble
name|arecip
decl_stmt|;
name|gdouble
name|aval
decl_stmt|;
name|guchar
name|lwin
index|[
name|LANCZOS_WIDTH2
operator|*
name|LANCZOS_WIDTH2
index|]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|pu
decl_stmt|,
name|pv
decl_stmt|,
name|su
decl_stmt|,
name|sv
decl_stmt|;
comment|/* allocate and fill lanczos lookup table */
name|lanczos
operator|=
name|create_lanczos_lookup
argument_list|()
expr_stmt|;
for|for
control|(
name|y
operator|=
name|dest_y1
init|;
name|y
operator|<
name|dest_y2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
call|(
name|gdouble
call|)
argument_list|(
name|y
operator|-
name|dest_y1
argument_list|)
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|dest_y2
operator|-
name|dest_y1
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
operator|(
name|y
operator|-
name|dest_y1
operator|)
argument_list|,
name|width
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dest_x1
init|;
name|x
operator|<
name|dest_x2
condition|;
name|x
operator|++
control|)
block|{
name|du
operator|=
name|uw
operator|=
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|dv
operator|=
name|vw
operator|=
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|ww
operator|=
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ww
operator|==
literal|1.0
condition|)
block|{
name|du
operator|=
name|uw
expr_stmt|;
name|dv
operator|=
name|vw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ww
operator|!=
literal|0.0
condition|)
block|{
name|du
operator|=
name|uw
operator|/
name|ww
expr_stmt|;
name|dv
operator|=
name|vw
operator|/
name|ww
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"homogeneous coordinate = 0...\n"
argument_list|)
expr_stmt|;
block|}
name|u
operator|=
operator|(
name|gint
operator|)
name|du
expr_stmt|;
name|v
operator|=
operator|(
name|gint
operator|)
name|dv
expr_stmt|;
comment|/* get weight for fractional error */
name|su
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|du
operator|-
name|u
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
name|sv
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|dv
operator|-
name|v
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|u1
operator|||
name|v
operator|<
name|v1
operator|||
name|u
operator|>=
name|u2
operator|||
name|v
operator|>=
name|v2
condition|)
block|{
comment|/* not in source range */
comment|/* increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
operator|,
name|pos
operator|++
control|)
block|{
name|pu
operator|=
name|CLAMP
argument_list|(
name|u
operator|+
name|i
operator|-
name|LANCZOS_WIDTH
argument_list|,
name|u1
argument_list|,
name|u2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pv
operator|=
name|CLAMP
argument_list|(
name|v
operator|+
name|j
operator|-
name|LANCZOS_WIDTH
argument_list|,
name|v1
argument_list|,
name|v2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|orig_tiles
argument_list|,
name|pu
operator|-
name|u1
argument_list|,
name|pv
operator|-
name|v1
argument_list|,
operator|&
name|lwin
index|[
name|pos
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* fill 1D kernels */
for|for
control|(
name|x_sum
operator|=
name|y_sum
operator|=
literal|0.0
operator|,
name|i
operator|=
name|LANCZOS_WIDTH
init|;
name|i
operator|>=
operator|-
name|LANCZOS_WIDTH
condition|;
name|i
operator|--
control|)
block|{
name|pos
operator|=
name|i
operator|*
name|LANCZOS_SPP
expr_stmt|;
name|x_sum
operator|+=
name|x_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|lanczos
index|[
name|ABS
argument_list|(
name|su
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
name|y_sum
operator|+=
name|y_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|lanczos
index|[
name|ABS
argument_list|(
name|sv
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* normalise the weighted arrays */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
block|{
name|x_kernel
index|[
name|i
index|]
operator|/=
name|x_sum
expr_stmt|;
name|y_kernel
index|[
name|i
index|]
operator|/=
name|y_sum
expr_stmt|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
name|aval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
operator|,
name|pos
operator|++
control|)
block|{
name|aval
operator|+=
name|y_kernel
index|[
name|j
index|]
operator|*
name|x_kernel
index|[
name|i
index|]
operator|*
name|lwin
index|[
name|pos
index|]
index|[
name|alpha
index|]
expr_stmt|;
block|}
if|if
condition|(
name|aval
operator|<=
literal|0.0
condition|)
block|{
name|arecip
operator|=
literal|0.0
expr_stmt|;
name|aval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aval
operator|>
literal|255.0
condition|)
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|aval
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|newval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
operator|,
name|pos
operator|++
control|)
block|{
name|newval
operator|+=
name|y_kernel
index|[
name|j
index|]
operator|*
name|x_kernel
index|[
name|i
index|]
operator|*
name|lwin
index|[
name|pos
index|]
index|[
name|b
index|]
operator|*
name|lwin
index|[
name|pos
index|]
index|[
name|alpha
index|]
expr_stmt|;
block|}
name|newval
operator|*=
name|arecip
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
name|RINT
argument_list|(
name|aval
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  set the pixel region row  */
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
operator|(
name|y
operator|-
name|dest_y1
operator|)
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lanczos
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|uinc
operator|=
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|coords
operator|=
operator|(
name|interpolation_type
operator|!=
name|GIMP_INTERPOLATION_NONE
operator|)
condition|?
literal|5
else|:
literal|1
expr_stmt|;
for|for
control|(
name|y
operator|=
name|dest_y1
init|;
name|y
operator|<
name|dest_y2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
call|(
name|gdouble
call|)
argument_list|(
name|y
operator|-
name|dest_y1
argument_list|)
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|dest_y2
operator|-
name|dest_y1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up inverse transform steps */
name|tu
index|[
literal|0
index|]
operator|=
name|uinc
operator|*
name|dest_x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|=
name|vinc
operator|*
name|dest_x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|0
index|]
operator|=
name|winc
operator|*
name|dest_x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|interpolation_type
operator|!=
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|gdouble
name|xx
init|=
name|dest_x1
decl_stmt|;
name|gdouble
name|yy
init|=
name|y
decl_stmt|;
name|tu
index|[
literal|1
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|1
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|2
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|2
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|2
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|3
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|3
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|3
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|4
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|4
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|4
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dest_x1
init|;
name|x
operator|<
name|dest_x2
condition|;
name|x
operator|++
control|)
block|{
name|gint
name|i
decl_stmt|;
comment|/*  normalize homogeneous coords  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tw
index|[
name|i
index|]
operator|==
literal|1.0
condition|)
block|{
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tw
index|[
name|i
index|]
operator|!=
literal|0.0
condition|)
block|{
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"homogeneous coordinate = 0...\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Set the destination pixels  */
if|if
condition|(
name|interpolation_type
operator|==
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|guchar
name|color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|iu
init|=
operator|(
name|gint
operator|)
name|u
index|[
literal|0
index|]
decl_stmt|;
name|gint
name|iv
init|=
operator|(
name|gint
operator|)
name|v
index|[
literal|0
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|;
if|if
condition|(
name|iu
operator|>=
name|u1
operator|&&
name|iu
operator|<
name|u2
operator|&&
name|iv
operator|>=
name|v1
operator|&&
name|iv
operator|<
name|v2
condition|)
block|{
comment|/*  u, v coordinates into source tiles  */
name|gint
name|u
init|=
name|iu
operator|-
name|u1
decl_stmt|;
name|gint
name|v
init|=
name|iv
operator|-
name|v1
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|orig_tiles
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|color
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|color
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
comment|/*  increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|gint
name|b
decl_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|<
name|u1
operator|||
name|v
index|[
literal|0
index|]
operator|<
name|v1
operator|||
name|u
index|[
literal|0
index|]
operator|>=
name|u2
operator|||
name|v
index|[
literal|0
index|]
operator|>=
name|v2
condition|)
block|{
comment|/* not in source range */
comment|/* increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
block|{
name|guchar
name|color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/* clamp texture coordinates */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|5
condition|;
name|b
operator|++
control|)
block|{
name|u
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|u
index|[
name|b
index|]
argument_list|,
name|u1
argument_list|,
name|u2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|v
index|[
name|b
index|]
argument_list|,
name|v1
argument_list|,
name|v2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|supersample
operator|&&
name|supersample_dtest
argument_list|(
name|u
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|u
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|u
index|[
literal|3
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|u
index|[
literal|4
index|]
argument_list|,
name|v
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|sample_adapt
argument_list|(
name|orig_tiles
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|1
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|1
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|2
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|2
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|3
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|3
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|4
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|4
index|]
operator|-
name|v1
argument_list|,
name|recursion_level
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|sample_linear
argument_list|(
operator|&
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
name|sample_cubic
argument_list|(
operator|&
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
break|break;
block|}
block|}
comment|/*  Set the destination pixel  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|color
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coords
condition|;
name|i
operator|++
control|)
block|{
name|tu
index|[
name|i
index|]
operator|+=
name|uinc
expr_stmt|;
name|tv
index|[
name|i
index|]
operator|+=
name|vinc
expr_stmt|;
name|tw
index|[
name|i
index|]
operator|+=
name|winc
expr_stmt|;
block|}
block|}
comment|/*  set the pixel region row  */
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
operator|(
name|y
operator|-
name|dest_y1
operator|)
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|pixel_surround_clear
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
break|break;
block|}
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_define
DECL|macro|BILINEAR (jk,j1k,jk1,j1k1,dx,dy)
define|#
directive|define
name|BILINEAR
parameter_list|(
name|jk
parameter_list|,
name|j1k
parameter_list|,
name|jk1
parameter_list|,
name|j1k1
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|((1 - dy) * (jk  + dx * (j1k  - jk)) + \                       dy  * (jk1 + dx * (j1k1 - jk1)))
end_define

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the two pixel coords around them:    *  iu to iu + 1, iv to iv + 1    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_linear (PixelSurround * surround,gdouble u,gdouble v,guchar * color,gint bytes,gint alpha)
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|guchar
modifier|*
name|alphachan
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha value of result pixel */
name|alphachan
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|a_val
operator|=
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
argument_list|,
name|alphachan
index|[
name|row
index|]
argument_list|,
name|alphachan
index|[
name|row
operator|+
name|bytes
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>=
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bilinear (c * alpha) / bilinear (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
operator|(
name|a_recip
operator|*
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
operator|*
name|data
index|[
name|i
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
operator|*
name|data
index|[
name|bytes
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|row
index|]
operator|*
name|data
index|[
name|row
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|row
operator|+
name|bytes
index|]
operator|*
name|data
index|[
name|row
operator|+
name|bytes
operator|+
name|i
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
operator|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_release
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* macros to handle conversion to/from fixed point, this fixed point code  * uses signed integers, by using 8 bits for the fractional part we have  *  *  1 bit  sign  * 21 bits integer part  *  8 bit  fractional part  *  * 1023 discrete subpixel sample positions should be enough for the needs  * of the supersampling algorithm, drawables where the dimensions have a need  * exceeding 2^21 ( 2097152px, will typically use terabytes of memory, when  * that is the common need, we can probably assume 64 bit integers and adjust  * FIXED_SHIFT accordingly.  */
end_comment

begin_define
DECL|macro|FIXED_SHIFT
define|#
directive|define
name|FIXED_SHIFT
value|10
end_define

begin_define
DECL|macro|FIXED_UNIT
define|#
directive|define
name|FIXED_UNIT
value|(1<< FIXED_SHIFT)
end_define

begin_define
DECL|macro|DOUBLE2FIXED (val)
define|#
directive|define
name|DOUBLE2FIXED
parameter_list|(
name|val
parameter_list|)
value|((val) * FIXED_UNIT)
end_define

begin_define
DECL|macro|FIXED2DOUBLE (val)
define|#
directive|define
name|FIXED2DOUBLE
parameter_list|(
name|val
parameter_list|)
value|((val) / FIXED_UNIT)
end_define

begin_comment
comment|/*     bilinear interpolation of a fixed point pixel */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_bi (TileManager * tm,gint x,gint y,guchar * color,guchar * bg_color,gint bpp,gint alpha)
name|sample_bi
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|guchar
name|C
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|xscale
init|=
operator|(
name|x
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|gint
name|yscale
init|=
operator|(
name|y
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|gint
name|x0
init|=
name|x
operator|>>
name|FIXED_SHIFT
decl_stmt|;
name|gint
name|y0
init|=
name|y
operator|>>
name|FIXED_SHIFT
decl_stmt|;
name|gint
name|x1
init|=
name|x0
operator|+
literal|1
decl_stmt|;
name|gint
name|y1
init|=
name|y0
operator|+
literal|1
decl_stmt|;
comment|/*  fill the color with default values, since read_pixel_data_1    *  does nothing, when accesses are out of bounds.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
operator|&
name|C
index|[
name|i
index|]
operator|)
operator|=
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
name|bg_color
operator|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
DECL|macro|lerp (v1,v2,r)
define|#
directive|define
name|lerp
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|r
parameter_list|)
define|\
value|(((guint)(v1) * (FIXED_UNIT - (guint)(r)) + \           (guint)(v2) * (guint)(r))>> FIXED_SHIFT)
name|color
index|[
name|alpha
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* to avoid problems, calculate with premultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
undef|#
directive|undef
name|lerp
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if one of the deltas of the  * quad edge is> 1.0 (16.16 fixed values).  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|supersample_test (gint x0,gint y0,gint x1,gint y1,gint x2,gint y2,gint x3,gint y3)
name|supersample_test
parameter_list|(
name|gint
name|x0
parameter_list|,
name|gint
name|y0
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|x3
parameter_list|,
name|gint
name|y3
parameter_list|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
name|FIXED_UNIT
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  *  Returns TRUE if one of the deltas of the  *  quad edge is> 1.0 (double values).  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|supersample_dtest (gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3)
name|supersample_dtest
parameter_list|(
name|gdouble
name|x0
parameter_list|,
name|gdouble
name|y0
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|gdouble
name|x3
parameter_list|,
name|gdouble
name|y3
parameter_list|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
literal|1.0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*     sample a grid that is spaced according to the quadraliteral's edges,     it subdivides a maximum of level times before sampling.     0..3 is a cycle around the quad */
end_comment

begin_function
specifier|static
name|void
DECL|function|get_sample (TileManager * tm,gint xc,gint yc,gint x0,gint y0,gint x1,gint y1,gint x2,gint y2,gint x3,gint y3,gint * cc,gint level,guint * color,guchar * bg_color,gint bpp,gint alpha)
name|get_sample
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xc
parameter_list|,
name|gint
name|yc
parameter_list|,
name|gint
name|x0
parameter_list|,
name|gint
name|y0
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|x3
parameter_list|,
name|gint
name|y3
parameter_list|,
name|gint
modifier|*
name|cc
parameter_list|,
name|gint
name|level
parameter_list|,
name|guint
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
if|if
condition|(
operator|!
name|level
operator|||
operator|!
name|supersample_test
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
condition|)
block|{
name|gint
name|i
decl_stmt|;
name|guchar
name|C
index|[
literal|4
index|]
decl_stmt|;
name|sample_bi
argument_list|(
name|tm
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|+=
name|C
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|cc
operator|)
operator|++
expr_stmt|;
comment|/* increase number of samples taken */
block|}
else|else
block|{
name|gint
name|tx
decl_stmt|,
name|lx
decl_stmt|,
name|rx
decl_stmt|,
name|bx
decl_stmt|,
name|tlx
decl_stmt|,
name|trx
decl_stmt|,
name|blx
decl_stmt|,
name|brx
decl_stmt|;
name|gint
name|ty
decl_stmt|,
name|ly
decl_stmt|,
name|ry
decl_stmt|,
name|by
decl_stmt|,
name|tly
decl_stmt|,
name|try
decl_stmt|,
name|bly
decl_stmt|,
name|bry
decl_stmt|;
comment|/* calculate subdivided corner coordinates (including centercoords          thus using a bilinear interpolation,. almost as good as          doing the perspective transform for each subpixel coordinate*/
name|tx
operator|=
operator|(
name|x0
operator|+
name|x1
operator|)
operator|/
literal|2
expr_stmt|;
name|tlx
operator|=
operator|(
name|x0
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|trx
operator|=
operator|(
name|x1
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|lx
operator|=
operator|(
name|x0
operator|+
name|x3
operator|)
operator|/
literal|2
expr_stmt|;
name|rx
operator|=
operator|(
name|x1
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|blx
operator|=
operator|(
name|x3
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|brx
operator|=
operator|(
name|x2
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|bx
operator|=
operator|(
name|x3
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|ty
operator|=
operator|(
name|y0
operator|+
name|y1
operator|)
operator|/
literal|2
expr_stmt|;
name|tly
operator|=
operator|(
name|y0
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|try
operator|=
operator|(
name|y1
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|ly
operator|=
operator|(
name|y0
operator|+
name|y3
operator|)
operator|/
literal|2
expr_stmt|;
name|ry
operator|=
operator|(
name|y1
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|bly
operator|=
operator|(
name|y3
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|bry
operator|=
operator|(
name|y2
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|by
operator|=
operator|(
name|y3
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|tlx
argument_list|,
name|tly
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|trx
argument_list|,
name|try
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|brx
argument_list|,
name|bry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|blx
argument_list|,
name|bly
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|sample_adapt (TileManager * tm,gdouble xc,gdouble yc,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3,gint level,guchar * color,guchar * bg_color,gint bpp,gint alpha)
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gdouble
name|xc
parameter_list|,
name|gdouble
name|yc
parameter_list|,
name|gdouble
name|x0
parameter_list|,
name|gdouble
name|y0
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|gdouble
name|x3
parameter_list|,
name|gdouble
name|y3
parameter_list|,
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gint
name|cc
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guint
name|C
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|C
index|[
literal|0
index|]
operator|=
name|C
index|[
literal|1
index|]
operator|=
name|C
index|[
literal|2
index|]
operator|=
name|C
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|xc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|yc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x3
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y3
argument_list|)
argument_list|,
operator|&
name|cc
argument_list|,
name|level
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc
condition|)
name|cc
operator|=
literal|1
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|C
index|[
name|alpha
index|]
operator|/
name|cc
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* go from premultiplied to postmultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|C
index|[
name|i
index|]
operator|/
name|cc
operator|)
operator|*
literal|255
operator|)
operator|/
name|color
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* access interleaved pixels */
end_comment

begin_define
DECL|macro|CUBIC_ROW (dx,row,step)
define|#
directive|define
name|CUBIC_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx,\             (row)[0], (row)[step], (row)[step+step], (row)[step+step+step])
end_define

begin_define
DECL|macro|CUBIC_SCALED_ROW (dx,row,arow,step)
define|#
directive|define
name|CUBIC_SCALED_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|arow
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx, \             (arow)[0]              * (row)[0], \             (arow)[step]           * (row)[step], \             (arow)[step+step]      * (row)[step+step], \             (arow)[step+step+step] * (row)[step+step+step])
end_define

begin_comment
comment|/*  Note: cubic function no longer clips result. */
end_comment

begin_comment
comment|/*  Inlining this function makes sample_cubic() run about 10% faster. (Sven) */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|gimp_drawable_transform_cubic (gdouble dx,gint jm1,gint j,gint jp1,gint jp2)
name|gimp_drawable_transform_cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
block|{
name|gdouble
name|result
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Equivalent to Gimp 1.1.1 and earlier - some ringing */
block|result = ((( ( - jm1 + j - jp1 + jp2 ) * dx +                ( jm1 + jm1 - j - j + jp1 - jp2 ) ) * dx +                ( - jm1 + jp1 ) ) * dx + j );
comment|/* Recommended by Mitchell and Netravali - too blurred? */
block|result = ((( ( - 7 * jm1 + 21 * j - 21 * jp1 + 7 * jp2 ) * dx +                ( 15 * jm1 - 36 * j + 27 * jp1 - 6 * jp2 ) ) * dx +                ( - 9 * jm1 + 9 * jp1 ) ) * dx + (jm1 + 16 * j + jp1) ) / 18.0;
endif|#
directive|endif
comment|/* Catmull-Rom - not bad */
name|result
operator|=
operator|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
operator|)
operator|/
literal|2.0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the four integer pixel coords around them:    *  iu to iu + 3, iv to iv + 3    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_cubic (PixelSurround * surround,gdouble u,gdouble v,guchar * color,gint bytes,gint alpha)
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
operator|-
literal|1
argument_list|,
name|iv
operator|-
literal|1
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha of result */
name|a_val
operator|=
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bicubic (c * alpha) / bicubic (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
operator|(
name|a_recip
operator|*
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|0
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|1
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|2
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|3
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_release
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

