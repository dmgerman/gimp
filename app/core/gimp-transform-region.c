begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995-2003 Spencer Kimball, Peter Mattis, and others  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-surround.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/scale-region.h"
end_include

begin_include
include|#
directive|include
file|"gimp-transform-region.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpprogress.h"
end_include

begin_comment
comment|/*  forward function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_transform_region_nearest
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_transform_region_linear
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_transform_region_cubic
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_transform_region_lanczos
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|untransform_coords
parameter_list|(
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
specifier|const
name|gint
name|x
parameter_list|,
specifier|const
name|gint
name|y
parameter_list|,
name|gdouble
modifier|*
name|tu
parameter_list|,
name|gdouble
modifier|*
name|tv
parameter_list|,
name|gdouble
modifier|*
name|tw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|normalize_coords
parameter_list|(
specifier|const
name|gint
name|coords
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tu
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tv
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tw
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gboolean
name|supersample_dtest
parameter_list|(
specifier|const
name|gdouble
name|u0
parameter_list|,
specifier|const
name|gdouble
name|v0
parameter_list|,
specifier|const
name|gdouble
name|u1
parameter_list|,
specifier|const
name|gdouble
name|v1
parameter_list|,
specifier|const
name|gdouble
name|u2
parameter_list|,
specifier|const
name|gdouble
name|v2
parameter_list|,
specifier|const
name|gdouble
name|u3
parameter_list|,
specifier|const
name|gdouble
name|v3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
specifier|const
name|gdouble
name|xc
parameter_list|,
specifier|const
name|gdouble
name|yc
parameter_list|,
specifier|const
name|gdouble
name|x0
parameter_list|,
specifier|const
name|gdouble
name|y0
parameter_list|,
specifier|const
name|gdouble
name|x1
parameter_list|,
specifier|const
name|gdouble
name|y1
parameter_list|,
specifier|const
name|gdouble
name|x2
parameter_list|,
specifier|const
name|gdouble
name|y2
parameter_list|,
specifier|const
name|gdouble
name|x3
parameter_list|,
specifier|const
name|gdouble
name|y3
parameter_list|,
specifier|const
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_lanczos
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|lanczos
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|void
DECL|function|gimp_transform_region (GimpPickable * pickable,GimpContext * context,TileManager * orig_tiles,gint orig_offset_x,gint orig_offset_y,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,const GimpMatrix3 * matrix,GimpInterpolationType interpolation_type,gint recursion_level,GimpProgress * progress)
name|gimp_transform_region
parameter_list|(
name|GimpPickable
modifier|*
name|pickable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|gint
name|orig_offset_x
parameter_list|,
name|gint
name|orig_offset_y
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GimpImageType
name|pickable_type
decl_stmt|;
name|GimpMatrix3
name|m
decl_stmt|;
name|gint
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|u2
decl_stmt|,
name|v2
decl_stmt|;
comment|/* source bounding box */
name|gint
name|alpha
decl_stmt|;
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_PICKABLE
argument_list|(
name|pickable
argument_list|)
argument_list|)
expr_stmt|;
name|u1
operator|=
name|orig_offset_x
expr_stmt|;
name|v1
operator|=
name|orig_offset_y
expr_stmt|;
name|u2
operator|=
name|u1
operator|+
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|v2
operator|=
name|v1
operator|+
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|matrix
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/*  turn interpolation off for simple transformations (e.g. rot90)  */
if|if
condition|(
name|gimp_matrix3_is_simple
argument_list|(
name|matrix
argument_list|)
condition|)
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
name|pickable_type
operator|=
name|gimp_pickable_get_image_type
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  Get the background color  */
name|gimp_image_get_background
argument_list|(
name|gimp_pickable_get_image
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|context
argument_list|,
name|pickable_type
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|pickable_type
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|bg_color
index|[
name|ALPHA
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|bg_color
index|[
name|ALPHA_G
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_G
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|bg_color
index|[
name|ALPHA_I
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_I
expr_stmt|;
comment|/*  If the image is indexed color, ignore interpolation value  */
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|pickable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
comment|/*  setting alpha = 0 will cause the channel's value to be treated    *  as alpha and the color channel loops never to be entered    */
if|if
condition|(
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|alpha
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|gimp_transform_region_nearest
argument_list|(
name|orig_tiles
argument_list|,
name|destPR
argument_list|,
name|dest_x1
argument_list|,
name|dest_y1
argument_list|,
name|dest_x2
argument_list|,
name|dest_y2
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|m
argument_list|,
name|alpha
argument_list|,
name|bg_color
argument_list|,
name|progress
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|gimp_transform_region_linear
argument_list|(
name|orig_tiles
argument_list|,
name|destPR
argument_list|,
name|dest_x1
argument_list|,
name|dest_y1
argument_list|,
name|dest_x2
argument_list|,
name|dest_y2
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|m
argument_list|,
name|alpha
argument_list|,
name|recursion_level
argument_list|,
name|bg_color
argument_list|,
name|progress
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
name|gimp_transform_region_cubic
argument_list|(
name|orig_tiles
argument_list|,
name|destPR
argument_list|,
name|dest_x1
argument_list|,
name|dest_y1
argument_list|,
name|dest_x2
argument_list|,
name|dest_y2
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|m
argument_list|,
name|alpha
argument_list|,
name|recursion_level
argument_list|,
name|bg_color
argument_list|,
name|progress
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|gimp_transform_region_lanczos
argument_list|(
name|orig_tiles
argument_list|,
name|destPR
argument_list|,
name|dest_x1
argument_list|,
name|dest_y1
argument_list|,
name|dest_x2
argument_list|,
name|dest_y2
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|m
argument_list|,
name|alpha
argument_list|,
name|recursion_level
argument_list|,
name|bg_color
argument_list|,
name|progress
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_transform_region_nearest (TileManager * orig_tiles,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,gint u1,gint v1,gint u2,gint v2,const GimpMatrix3 * m,gint alpha,const guchar * bg_color,GimpProgress * progress)
name|gimp_transform_region_nearest
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates  */
name|gint
name|pixels
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|n
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|uinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|total
operator|=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
name|destPR
argument_list|)
operator|,
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
name|guchar
modifier|*
name|dest
init|=
name|destPR
operator|->
name|data
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|destPR
operator|->
name|y
init|;
name|y
operator|<
name|destPR
operator|->
name|y
operator|+
name|destPR
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|gint
name|x
init|=
name|dest_x1
operator|+
name|destPR
operator|->
name|x
decl_stmt|;
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
name|gdouble
name|tu
decl_stmt|,
name|tv
decl_stmt|,
name|tw
decl_stmt|;
comment|/* undivided source coordinates and divisor */
comment|/* set up inverse transform steps */
name|tu
operator|=
name|uinc
operator|*
name|x
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|dest_y1
operator|+
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
operator|=
name|vinc
operator|*
name|x
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|dest_y1
operator|+
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
operator|=
name|winc
operator|*
name|x
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|dest_y1
operator|+
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
name|gdouble
name|u
decl_stmt|,
name|v
decl_stmt|;
comment|/* source coordinates */
name|gint
name|iu
decl_stmt|,
name|iv
decl_stmt|;
comment|/*  normalize homogeneous coords  */
name|normalize_coords
argument_list|(
literal|1
argument_list|,
operator|&
name|tu
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|tw
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|iu
operator|=
operator|(
name|gint
operator|)
name|u
expr_stmt|;
name|iv
operator|=
operator|(
name|gint
operator|)
name|v
expr_stmt|;
comment|/*  Set the destination pixels  */
if|if
condition|(
name|iu
operator|>=
name|u1
operator|&&
name|iu
operator|<
name|u2
operator|&&
name|iv
operator|>=
name|v1
operator|&&
name|iv
operator|<
name|v2
condition|)
block|{
name|tile_manager_read_pixel_data_1
argument_list|(
name|orig_tiles
argument_list|,
name|iu
operator|-
name|u1
argument_list|,
name|iv
operator|-
name|v1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|+=
name|destPR
operator|->
name|bytes
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
name|gint
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|destPR
operator|->
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
name|tu
operator|+=
name|uinc
expr_stmt|;
name|tv
operator|+=
name|vinc
expr_stmt|;
name|tw
operator|+=
name|winc
expr_stmt|;
block|}
name|dest
operator|+=
name|destPR
operator|->
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|pixels
operator|+=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_transform_region_linear (TileManager * orig_tiles,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,gint u1,gint v1,gint u2,gint v2,const GimpMatrix3 * m,gint alpha,gint recursion_level,const guchar * bg_color,GimpProgress * progress)
name|gimp_transform_region_linear
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|PixelSurround
modifier|*
name|surround
decl_stmt|;
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates  */
name|gint
name|pixels
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|n
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|surround
operator|=
name|pixel_surround_new
argument_list|(
name|orig_tiles
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|PIXEL_SURROUND_BACKGROUND
argument_list|)
expr_stmt|;
name|pixel_surround_set_bg
argument_list|(
name|surround
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
name|uinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|total
operator|=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
name|destPR
argument_list|)
operator|,
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
name|guchar
modifier|*
name|dest
init|=
name|destPR
operator|->
name|data
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|destPR
operator|->
name|y
init|;
name|y
operator|<
name|destPR
operator|->
name|y
operator|+
name|destPR
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
name|gdouble
name|tu
index|[
literal|5
index|]
decl_stmt|,
name|tv
index|[
literal|5
index|]
decl_stmt|;
comment|/* undivided source coordinates */
name|gdouble
name|tw
index|[
literal|5
index|]
decl_stmt|;
comment|/* divisor                      */
comment|/* set up inverse transform steps */
name|untransform_coords
argument_list|(
name|m
argument_list|,
name|dest_x1
operator|+
name|destPR
operator|->
name|x
argument_list|,
name|dest_y1
operator|+
name|y
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
name|gdouble
name|u
index|[
literal|5
index|]
decl_stmt|,
name|v
index|[
literal|5
index|]
decl_stmt|;
comment|/* source coordinates */
name|gint
name|i
decl_stmt|;
comment|/*  normalize homogeneous coords  */
name|normalize_coords
argument_list|(
literal|5
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/*  Set the destination pixels  */
if|if
condition|(
name|supersample_dtest
argument_list|(
name|u
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|u
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|u
index|[
literal|3
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|u
index|[
literal|4
index|]
argument_list|,
name|v
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|sample_adapt
argument_list|(
name|orig_tiles
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|1
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|1
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|2
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|2
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|3
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|3
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|4
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|4
index|]
operator|-
name|v1
argument_list|,
name|recursion_level
argument_list|,
name|d
argument_list|,
name|bg_color
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sample_linear
argument_list|(
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|d
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
name|d
operator|+=
name|destPR
operator|->
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|tu
index|[
name|i
index|]
operator|+=
name|uinc
expr_stmt|;
name|tv
index|[
name|i
index|]
operator|+=
name|vinc
expr_stmt|;
name|tw
index|[
name|i
index|]
operator|+=
name|winc
expr_stmt|;
block|}
block|}
name|dest
operator|+=
name|destPR
operator|->
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|pixels
operator|+=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
argument_list|)
expr_stmt|;
block|}
block|}
name|pixel_surround_destroy
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_transform_region_cubic (TileManager * orig_tiles,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,gint u1,gint v1,gint u2,gint v2,const GimpMatrix3 * m,gint alpha,gint recursion_level,const guchar * bg_color,GimpProgress * progress)
name|gimp_transform_region_cubic
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|PixelSurround
modifier|*
name|surround
decl_stmt|;
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates  */
name|gint
name|pixels
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|n
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|surround
operator|=
name|pixel_surround_new
argument_list|(
name|orig_tiles
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|PIXEL_SURROUND_BACKGROUND
argument_list|)
expr_stmt|;
name|pixel_surround_set_bg
argument_list|(
name|surround
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
name|uinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|total
operator|=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
name|destPR
argument_list|)
operator|,
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
name|guchar
modifier|*
name|dest
init|=
name|destPR
operator|->
name|data
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|destPR
operator|->
name|y
init|;
name|y
operator|<
name|destPR
operator|->
name|y
operator|+
name|destPR
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
name|gdouble
name|tu
index|[
literal|5
index|]
decl_stmt|,
name|tv
index|[
literal|5
index|]
decl_stmt|;
comment|/* undivided source coordinates */
name|gdouble
name|tw
index|[
literal|5
index|]
decl_stmt|;
comment|/* divisor                      */
comment|/* set up inverse transform steps */
name|untransform_coords
argument_list|(
name|m
argument_list|,
name|dest_x1
operator|+
name|destPR
operator|->
name|x
argument_list|,
name|dest_y1
operator|+
name|y
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
name|gdouble
name|u
index|[
literal|5
index|]
decl_stmt|,
name|v
index|[
literal|5
index|]
decl_stmt|;
comment|/* source coordinates */
name|gint
name|i
decl_stmt|;
comment|/*  normalize homogeneous coords  */
name|normalize_coords
argument_list|(
literal|5
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|supersample_dtest
argument_list|(
name|u
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|u
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|u
index|[
literal|3
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|u
index|[
literal|4
index|]
argument_list|,
name|v
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|sample_adapt
argument_list|(
name|orig_tiles
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|1
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|1
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|2
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|2
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|3
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|3
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|4
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|4
index|]
operator|-
name|v1
argument_list|,
name|recursion_level
argument_list|,
name|d
argument_list|,
name|bg_color
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sample_cubic
argument_list|(
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|d
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
name|d
operator|+=
name|destPR
operator|->
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|tu
index|[
name|i
index|]
operator|+=
name|uinc
expr_stmt|;
name|tv
index|[
name|i
index|]
operator|+=
name|vinc
expr_stmt|;
name|tw
index|[
name|i
index|]
operator|+=
name|winc
expr_stmt|;
block|}
block|}
name|dest
operator|+=
name|destPR
operator|->
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|pixels
operator|+=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
argument_list|)
expr_stmt|;
block|}
block|}
name|pixel_surround_destroy
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_transform_region_lanczos (TileManager * orig_tiles,PixelRegion * destPR,gint dest_x1,gint dest_y1,gint dest_x2,gint dest_y2,gint u1,gint v1,gint u2,gint v2,const GimpMatrix3 * m,gint alpha,gint recursion_level,const guchar * bg_color,GimpProgress * progress)
name|gimp_transform_region_lanczos
parameter_list|(
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|dest_x1
parameter_list|,
name|gint
name|dest_y1
parameter_list|,
name|gint
name|dest_x2
parameter_list|,
name|gint
name|dest_y2
parameter_list|,
name|gint
name|u1
parameter_list|,
name|gint
name|v1
parameter_list|,
name|gint
name|u2
parameter_list|,
name|gint
name|v2
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
name|gint
name|alpha
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|PixelSurround
modifier|*
name|surround
decl_stmt|;
name|gfloat
modifier|*
name|lanczos
decl_stmt|;
comment|/* Lanczos lookup table              */
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates  */
name|gint
name|pixels
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|n
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|surround
operator|=
name|pixel_surround_new
argument_list|(
name|orig_tiles
argument_list|,
name|LANCZOS_WIDTH2
argument_list|,
name|LANCZOS_WIDTH2
argument_list|,
name|PIXEL_SURROUND_BACKGROUND
argument_list|)
expr_stmt|;
name|pixel_surround_set_bg
argument_list|(
name|surround
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/* allocate and fill lanczos lookup table */
name|lanczos
operator|=
name|create_lanczos_lookup
argument_list|()
expr_stmt|;
name|uinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|total
operator|=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
name|destPR
argument_list|)
operator|,
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
name|guchar
modifier|*
name|dest
init|=
name|destPR
operator|->
name|data
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|destPR
operator|->
name|y
init|;
name|y
operator|<
name|destPR
operator|->
name|y
operator|+
name|destPR
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
name|gdouble
name|tu
index|[
literal|5
index|]
decl_stmt|,
name|tv
index|[
literal|5
index|]
decl_stmt|;
comment|/* undivided source coordinates */
name|gdouble
name|tw
index|[
literal|5
index|]
decl_stmt|;
comment|/* divisor                      */
comment|/* set up inverse transform steps */
name|untransform_coords
argument_list|(
name|m
argument_list|,
name|dest_x1
operator|+
name|destPR
operator|->
name|x
argument_list|,
name|dest_y1
operator|+
name|y
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
name|gdouble
name|u
index|[
literal|5
index|]
decl_stmt|,
name|v
index|[
literal|5
index|]
decl_stmt|;
comment|/* source coordinates */
name|gint
name|i
decl_stmt|;
comment|/*  normalize homogeneous coords  */
name|normalize_coords
argument_list|(
literal|5
argument_list|,
name|tu
argument_list|,
name|tv
argument_list|,
name|tw
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|supersample_dtest
argument_list|(
name|u
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|u
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|u
index|[
literal|3
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|u
index|[
literal|4
index|]
argument_list|,
name|v
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|sample_adapt
argument_list|(
name|orig_tiles
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|1
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|1
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|2
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|2
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|3
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|3
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|4
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|4
index|]
operator|-
name|v1
argument_list|,
name|recursion_level
argument_list|,
name|d
argument_list|,
name|bg_color
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sample_lanczos
argument_list|(
name|surround
argument_list|,
name|lanczos
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|d
argument_list|,
name|destPR
operator|->
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
name|d
operator|+=
name|destPR
operator|->
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|tu
index|[
name|i
index|]
operator|+=
name|uinc
expr_stmt|;
name|tv
index|[
name|i
index|]
operator|+=
name|vinc
expr_stmt|;
name|tw
index|[
name|i
index|]
operator|+=
name|winc
expr_stmt|;
block|}
block|}
name|dest
operator|+=
name|destPR
operator|->
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|pixels
operator|+=
name|destPR
operator|->
name|w
operator|*
name|destPR
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|lanczos
argument_list|)
expr_stmt|;
name|pixel_surround_destroy
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|untransform_coords (const GimpMatrix3 * m,const gint x,const gint y,gdouble * tu,gdouble * tv,gdouble * tw)
name|untransform_coords
parameter_list|(
specifier|const
name|GimpMatrix3
modifier|*
name|m
parameter_list|,
specifier|const
name|gint
name|x
parameter_list|,
specifier|const
name|gint
name|y
parameter_list|,
name|gdouble
modifier|*
name|tu
parameter_list|,
name|gdouble
modifier|*
name|tv
parameter_list|,
name|gdouble
modifier|*
name|tw
parameter_list|)
block|{
name|tu
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|2
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|2
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|2
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|-
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|3
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|3
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|3
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|4
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|4
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|4
index|]
operator|=
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|x
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|+
name|m
operator|->
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|normalize_coords (const gint coords,const gdouble * tu,const gdouble * tv,const gdouble * tw,gdouble * u,gdouble * v)
name|normalize_coords
parameter_list|(
specifier|const
name|gint
name|coords
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tu
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tv
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|tw
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|G_LIKELY
argument_list|(
name|tw
index|[
name|i
index|]
operator|!=
literal|0.0
argument_list|)
condition|)
block|{
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"homogeneous coordinate = 0...\n"
argument_list|)
expr_stmt|;
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
DECL|macro|BILINEAR (jk,j1k,jk1,j1k1,dx,dy)
define|#
directive|define
name|BILINEAR
parameter_list|(
name|jk
parameter_list|,
name|j1k
parameter_list|,
name|jk1
parameter_list|,
name|j1k1
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|((1 - dy) * (jk  + dx * (j1k  - jk)) + \                       dy  * (jk1 + dx * (j1k1 - jk1)))
end_define

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the two pixel coords around them:    *  iu to iu + 1, iv to iv + 1    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_linear (PixelSurround * surround,const gdouble u,const gdouble v,guchar * color,const gint bytes,const gint alpha)
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
specifier|const
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|rowstride
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|alphachan
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
argument_list|,
name|iv
argument_list|,
operator|&
name|rowstride
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha value of result pixel */
name|alphachan
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|a_val
operator|=
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
argument_list|,
name|alphachan
index|[
name|rowstride
index|]
argument_list|,
name|alphachan
index|[
name|rowstride
operator|+
name|bytes
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>=
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bilinear (c * alpha) / bilinear (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
name|ROUND
argument_list|(
operator|(
name|a_recip
operator|*
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
operator|*
name|data
index|[
name|i
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
operator|*
name|data
index|[
name|bytes
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|rowstride
index|]
operator|*
name|data
index|[
name|rowstride
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|rowstride
operator|+
name|bytes
index|]
operator|*
name|data
index|[
name|rowstride
operator|+
name|bytes
operator|+
name|i
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* macros to handle conversion to/from fixed point, this fixed point code  * uses signed integers, by using 8 bits for the fractional part we have  *  *  1 bit  sign  * 21 bits integer part  *  8 bit  fractional part  *  * 1023 discrete subpixel sample positions should be enough for the needs  * of the supersampling algorithm, drawables where the dimensions have a need  * exceeding 2^21 ( 2097152px, will typically use terabytes of memory, when  * that is the common need, we can probably assume 64 bit integers and adjust  * FIXED_SHIFT accordingly.  */
end_comment

begin_define
DECL|macro|FIXED_SHIFT
define|#
directive|define
name|FIXED_SHIFT
value|10
end_define

begin_define
DECL|macro|FIXED_UNIT
define|#
directive|define
name|FIXED_UNIT
value|(1<< FIXED_SHIFT)
end_define

begin_define
DECL|macro|DOUBLE2FIXED (val)
define|#
directive|define
name|DOUBLE2FIXED
parameter_list|(
name|val
parameter_list|)
value|((val) * FIXED_UNIT)
end_define

begin_define
DECL|macro|FIXED2DOUBLE (val)
define|#
directive|define
name|FIXED2DOUBLE
parameter_list|(
name|val
parameter_list|)
value|((val) / FIXED_UNIT)
end_define

begin_comment
comment|/*     bilinear interpolation of a fixed point pixel */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_bi (TileManager * tm,const gint x,const gint y,guchar * color,const guchar * bg_color,const gint bpp,const gint alpha)
name|sample_bi
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
specifier|const
name|gint
name|x
parameter_list|,
specifier|const
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
specifier|const
name|gint
name|bpp
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
specifier|const
name|gint
name|xscale
init|=
operator|(
name|x
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
specifier|const
name|gint
name|yscale
init|=
operator|(
name|y
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
specifier|const
name|gint
name|x0
init|=
name|x
operator|>>
name|FIXED_SHIFT
decl_stmt|;
specifier|const
name|gint
name|y0
init|=
name|y
operator|>>
name|FIXED_SHIFT
decl_stmt|;
specifier|const
name|gint
name|x1
init|=
name|x0
operator|+
literal|1
decl_stmt|;
specifier|const
name|gint
name|y1
init|=
name|y0
operator|+
literal|1
decl_stmt|;
name|guchar
name|C
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*  fill the color with default values, since    *  tile_manager_read_pixel_data_1 does nothing, when accesses are    *  out of bounds.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
operator|&
name|C
index|[
name|i
index|]
operator|)
operator|=
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
name|bg_color
operator|)
expr_stmt|;
name|tile_manager_read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tile_manager_read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tile_manager_read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tile_manager_read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
DECL|macro|lerp (v1,v2,r)
define|#
directive|define
name|lerp
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|r
parameter_list|)
define|\
value|(((guint)(v1) * (FIXED_UNIT - (guint)(r)) + \           (guint)(v2) * (guint)(r))>> FIXED_SHIFT)
name|color
index|[
name|alpha
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* to avoid problems, calculate with premultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
operator|/
literal|255
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
operator|/
literal|255
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
operator|/
literal|255
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
operator|/
literal|255
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
undef|#
directive|undef
name|lerp
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if one of the deltas of the quad edge is> 1.0 (16.16 fixed  * values). This is the condition used on whether additional recursive  * subdivision should be used.  */
end_comment

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|supersample_test (const gint x0,const gint y0,const gint x1,const gint y1,const gint x2,const gint y2,const gint x3,const gint y3)
name|supersample_test
parameter_list|(
specifier|const
name|gint
name|x0
parameter_list|,
specifier|const
name|gint
name|y0
parameter_list|,
specifier|const
name|gint
name|x1
parameter_list|,
specifier|const
name|gint
name|y1
parameter_list|,
specifier|const
name|gint
name|x2
parameter_list|,
specifier|const
name|gint
name|y2
parameter_list|,
specifier|const
name|gint
name|x3
parameter_list|,
specifier|const
name|gint
name|y3
parameter_list|)
block|{
return|return
operator|(
name|abs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
name|FIXED_UNIT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if one of the deltas of the quad edge is> sqrt(2) (double  * values). This is the condition used on whether supersampling should be used  * or not. By making this sqrt(2) supersampling will not be triggered by  * rotations.  */
end_comment

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|supersample_dtest (const gdouble x0,const gdouble y0,const gdouble x1,const gdouble y1,const gdouble x2,const gdouble y2,const gdouble x3,const gdouble y3)
name|supersample_dtest
parameter_list|(
specifier|const
name|gdouble
name|x0
parameter_list|,
specifier|const
name|gdouble
name|y0
parameter_list|,
specifier|const
name|gdouble
name|x1
parameter_list|,
specifier|const
name|gdouble
name|y1
parameter_list|,
specifier|const
name|gdouble
name|x2
parameter_list|,
specifier|const
name|gdouble
name|y2
parameter_list|,
specifier|const
name|gdouble
name|x3
parameter_list|,
specifier|const
name|gdouble
name|y3
parameter_list|)
block|{
return|return
operator|(
name|fabs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
name|G_SQRT2
operator|||
name|fabs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
name|G_SQRT2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     sample a grid that is spaced according to the quadraliteral's edges,     it subdivides a maximum of level times before sampling.     0..3 is a cycle around the quad */
end_comment

begin_function
specifier|static
name|void
DECL|function|get_sample (TileManager * tm,const gint xc,const gint yc,const gint x0,const gint y0,const gint x1,const gint y1,const gint x2,const gint y2,const gint x3,const gint y3,gint * cc,const gint level,guint * color,const guchar * bg_color,const gint bpp,const gint alpha)
name|get_sample
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
specifier|const
name|gint
name|xc
parameter_list|,
specifier|const
name|gint
name|yc
parameter_list|,
specifier|const
name|gint
name|x0
parameter_list|,
specifier|const
name|gint
name|y0
parameter_list|,
specifier|const
name|gint
name|x1
parameter_list|,
specifier|const
name|gint
name|y1
parameter_list|,
specifier|const
name|gint
name|x2
parameter_list|,
specifier|const
name|gint
name|y2
parameter_list|,
specifier|const
name|gint
name|x3
parameter_list|,
specifier|const
name|gint
name|y3
parameter_list|,
name|gint
modifier|*
name|cc
parameter_list|,
specifier|const
name|gint
name|level
parameter_list|,
name|guint
modifier|*
name|color
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
specifier|const
name|gint
name|bpp
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
if|if
condition|(
operator|!
name|level
operator|||
operator|!
name|supersample_test
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
condition|)
block|{
name|gint
name|i
decl_stmt|;
name|guchar
name|C
index|[
literal|4
index|]
decl_stmt|;
name|sample_bi
argument_list|(
name|tm
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|+=
name|C
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|cc
operator|)
operator|++
expr_stmt|;
comment|/* increase number of samples taken */
block|}
else|else
block|{
name|gint
name|tx
decl_stmt|,
name|lx
decl_stmt|,
name|rx
decl_stmt|,
name|bx
decl_stmt|,
name|tlx
decl_stmt|,
name|trx
decl_stmt|,
name|blx
decl_stmt|,
name|brx
decl_stmt|;
name|gint
name|ty
decl_stmt|,
name|ly
decl_stmt|,
name|ry
decl_stmt|,
name|by
decl_stmt|,
name|tly
decl_stmt|,
name|try
decl_stmt|,
name|bly
decl_stmt|,
name|bry
decl_stmt|;
comment|/* calculate subdivided corner coordinates (including centercoords          thus using a bilinear interpolation,. almost as good as          doing the perspective transform for each subpixel coordinate*/
name|tx
operator|=
operator|(
name|x0
operator|+
name|x1
operator|)
operator|/
literal|2
expr_stmt|;
name|tlx
operator|=
operator|(
name|x0
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|trx
operator|=
operator|(
name|x1
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|lx
operator|=
operator|(
name|x0
operator|+
name|x3
operator|)
operator|/
literal|2
expr_stmt|;
name|rx
operator|=
operator|(
name|x1
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|blx
operator|=
operator|(
name|x3
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|brx
operator|=
operator|(
name|x2
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|bx
operator|=
operator|(
name|x3
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|ty
operator|=
operator|(
name|y0
operator|+
name|y1
operator|)
operator|/
literal|2
expr_stmt|;
name|tly
operator|=
operator|(
name|y0
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|try
operator|=
operator|(
name|y1
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|ly
operator|=
operator|(
name|y0
operator|+
name|y3
operator|)
operator|/
literal|2
expr_stmt|;
name|ry
operator|=
operator|(
name|y1
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|bly
operator|=
operator|(
name|y3
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|bry
operator|=
operator|(
name|y2
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|by
operator|=
operator|(
name|y3
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|tlx
argument_list|,
name|tly
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|trx
argument_list|,
name|try
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|brx
argument_list|,
name|bry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|blx
argument_list|,
name|bly
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|sample_adapt (TileManager * tm,const gdouble xc,const gdouble yc,const gdouble x0,const gdouble y0,const gdouble x1,const gdouble y1,const gdouble x2,const gdouble y2,const gdouble x3,const gdouble y3,const gint level,guchar * color,const guchar * bg_color,const gint bpp,const gint alpha)
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
specifier|const
name|gdouble
name|xc
parameter_list|,
specifier|const
name|gdouble
name|yc
parameter_list|,
specifier|const
name|gdouble
name|x0
parameter_list|,
specifier|const
name|gdouble
name|y0
parameter_list|,
specifier|const
name|gdouble
name|x1
parameter_list|,
specifier|const
name|gdouble
name|y1
parameter_list|,
specifier|const
name|gdouble
name|x2
parameter_list|,
specifier|const
name|gdouble
name|y2
parameter_list|,
specifier|const
name|gdouble
name|x3
parameter_list|,
specifier|const
name|gdouble
name|y3
parameter_list|,
specifier|const
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg_color
parameter_list|,
specifier|const
name|gint
name|bpp
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
name|gint
name|cc
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guint
name|C
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|C
index|[
literal|0
index|]
operator|=
name|C
index|[
literal|1
index|]
operator|=
name|C
index|[
literal|2
index|]
operator|=
name|C
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|xc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|yc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x3
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y3
argument_list|)
argument_list|,
operator|&
name|cc
argument_list|,
name|level
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc
condition|)
name|cc
operator|=
literal|1
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|C
index|[
name|alpha
index|]
operator|/
name|cc
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* go from premultiplied to postmultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|C
index|[
name|i
index|]
operator|/
name|cc
operator|)
operator|*
literal|255
operator|)
operator|/
name|color
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* access interleaved pixels */
end_comment

begin_define
DECL|macro|CUBIC_ROW (dx,row,step)
define|#
directive|define
name|CUBIC_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx,\             (row)[0], (row)[step], (row)[step+step], (row)[step+step+step])
end_define

begin_define
DECL|macro|CUBIC_SCALED_ROW (dx,row,arow,step)
define|#
directive|define
name|CUBIC_SCALED_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|arow
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx, \             (arow)[0]              * (row)[0], \             (arow)[step]           * (row)[step], \             (arow)[step+step]      * (row)[step+step], \             (arow)[step+step+step] * (row)[step+step+step])
end_define

begin_comment
comment|/*  Note: cubic function no longer clips result. */
end_comment

begin_comment
comment|/*  Inlining this function makes sample_cubic() run about 10% faster. (Sven) */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|gimp_drawable_transform_cubic (const gdouble dx,const gint jm1,const gint j,const gint jp1,const gint jp2)
name|gimp_drawable_transform_cubic
parameter_list|(
specifier|const
name|gdouble
name|dx
parameter_list|,
specifier|const
name|gint
name|jm1
parameter_list|,
specifier|const
name|gint
name|j
parameter_list|,
specifier|const
name|gint
name|jp1
parameter_list|,
specifier|const
name|gint
name|jp2
parameter_list|)
block|{
name|gdouble
name|result
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Equivalent to Gimp 1.1.1 and earlier - some ringing */
block|result = ((( ( - jm1 + j - jp1 + jp2 ) * dx +                ( jm1 + jm1 - j - j + jp1 - jp2 ) ) * dx +                ( - jm1 + jp1 ) ) * dx + j );
comment|/* Recommended by Mitchell and Netravali - too blurred? */
block|result = ((( ( - 7 * jm1 + 21 * j - 21 * jp1 + 7 * jp2 ) * dx +                ( 15 * jm1 - 36 * j + 27 * jp1 - 6 * jp2 ) ) * dx +                ( - 9 * jm1 + 9 * jp1 ) ) * dx + (jm1 + 16 * j + jp1) ) / 18.0;
endif|#
directive|endif
comment|/* Catmull-Rom - not bad */
name|result
operator|=
operator|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
operator|)
operator|/
literal|2.0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the four integer pixel coords around them:    *  iu to iu + 3, iv to iv + 3    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_cubic (PixelSurround * surround,const gdouble u,const gdouble v,guchar * color,const gint bytes,const gint alpha)
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
specifier|const
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|rowstride
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
operator|-
literal|1
argument_list|,
name|iv
operator|-
literal|1
argument_list|,
operator|&
name|rowstride
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha of result */
name|a_val
operator|=
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bicubic (c * alpha) / bicubic (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
name|ROUND
argument_list|(
operator|(
name|a_recip
operator|*
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|rowstride
operator|*
literal|0
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|rowstride
operator|*
literal|1
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|rowstride
operator|*
literal|2
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|rowstride
operator|*
literal|3
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|rowstride
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|sample_lanczos (PixelSurround * surround,const gfloat * lanczos,const gdouble u,const gdouble v,guchar * color,const gint bytes,const gint alpha)
name|sample_lanczos
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|lanczos
parameter_list|,
specifier|const
name|gdouble
name|u
parameter_list|,
specifier|const
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
specifier|const
name|gint
name|bytes
parameter_list|,
specifier|const
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|x_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* 1-D kernels of window coeffs */
name|gdouble
name|y_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
name|gdouble
name|x_sum
decl_stmt|,
name|y_sum
decl_stmt|;
comment|/* sum of Lanczos weights       */
name|gdouble
name|arecip
decl_stmt|;
name|gdouble
name|aval
decl_stmt|;
name|gint
name|su
decl_stmt|,
name|sv
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|iu
decl_stmt|,
name|iv
decl_stmt|;
name|gint
name|rowstride
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src
decl_stmt|;
name|iu
operator|=
operator|(
name|gint
operator|)
name|u
expr_stmt|;
name|iv
operator|=
operator|(
name|gint
operator|)
name|v
expr_stmt|;
comment|/* get weight for fractional error */
name|su
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|u
operator|-
name|iu
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
name|sv
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|v
operator|-
name|iv
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
comment|/* fill 1D kernels */
for|for
control|(
name|x_sum
operator|=
name|y_sum
operator|=
literal|0.0
operator|,
name|i
operator|=
name|LANCZOS_WIDTH
init|;
name|i
operator|>=
operator|-
name|LANCZOS_WIDTH
condition|;
name|i
operator|--
control|)
block|{
name|gint
name|pos
init|=
name|i
operator|*
name|LANCZOS_SPP
decl_stmt|;
name|x_sum
operator|+=
name|x_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|lanczos
index|[
name|ABS
argument_list|(
name|su
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
name|y_sum
operator|+=
name|y_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|lanczos
index|[
name|ABS
argument_list|(
name|sv
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* normalise the weighted arrays */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
block|{
name|x_kernel
index|[
name|i
index|]
operator|/=
name|x_sum
expr_stmt|;
name|y_kernel
index|[
name|i
index|]
operator|/=
name|y_sum
expr_stmt|;
block|}
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
operator|-
name|LANCZOS_WIDTH
argument_list|,
name|iv
operator|-
name|LANCZOS_WIDTH
argument_list|,
operator|&
name|rowstride
argument_list|)
expr_stmt|;
name|src
operator|=
name|data
operator|+
name|alpha
expr_stmt|;
name|aval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|aval
operator|+=
name|y_kernel
index|[
name|j
index|]
operator|*
name|x_kernel
index|[
name|i
index|]
operator|*
operator|(
name|gdouble
operator|)
name|src
index|[
name|i
operator|*
name|bytes
index|]
expr_stmt|;
name|src
operator|+=
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|aval
operator|<=
literal|0.0
condition|)
block|{
name|arecip
operator|=
literal|0.0
expr_stmt|;
name|aval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aval
operator|>
literal|255.0
condition|)
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|aval
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|asrc
decl_stmt|;
name|gdouble
name|newval
init|=
literal|0.0
decl_stmt|;
name|src
operator|=
name|data
operator|+
name|b
expr_stmt|;
name|asrc
operator|=
name|data
operator|+
name|alpha
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|newval
operator|+=
operator|(
name|y_kernel
index|[
name|j
index|]
operator|*
name|x_kernel
index|[
name|i
index|]
operator|*
operator|(
name|gdouble
operator|)
name|src
index|[
name|i
operator|*
name|bytes
index|]
operator|*
operator|(
name|gdouble
operator|)
name|asrc
index|[
name|i
operator|*
name|bytes
index|]
operator|)
expr_stmt|;
name|src
operator|+=
name|rowstride
expr_stmt|;
name|asrc
operator|+=
name|rowstride
expr_stmt|;
block|}
name|newval
operator|*=
name|arecip
expr_stmt|;
name|color
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|ROUND
argument_list|(
name|newval
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|aval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

