begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2001 Spencer Kimball, Peter Mattis, and others  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/base-config.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-surround.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable-transform.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-mask.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_define
DECL|macro|BILINEAR (jk,j1k,jk1,j1k1,dx,dy)
define|#
directive|define
name|BILINEAR
parameter_list|(
name|jk
parameter_list|,
name|j1k
parameter_list|,
name|jk1
parameter_list|,
name|j1k1
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|((1-dy) * (jk + dx * (j1k - jk)) + \ 		    dy  * (jk1 + dx * (j1k1 - jk1)))
end_define

begin_comment
comment|/* access interleaved pixels */
end_comment

begin_define
DECL|macro|CUBIC_ROW (dx,row,step)
define|#
directive|define
name|CUBIC_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx, (row)[0], (row)[step], (row)[step+step], (row)[step+step+step])
end_define

begin_define
DECL|macro|CUBIC_SCALED_ROW (dx,row,step,i)
define|#
directive|define
name|CUBIC_SCALED_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|step
parameter_list|,
name|i
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx, (row)[0] * (row)[i], \             (row)[step] * (row)[step + i], \             (row)[step+step]* (row)[step+step + i], \             (row)[step+step+step] * (row)[step+step+step + i])
end_define

begin_define
DECL|macro|REF_TILE (i,x,y)
define|#
directive|define
name|REF_TILE
parameter_list|(
name|i
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|tile[i] = tile_manager_get_tile (float_tiles, x, y, TRUE, FALSE); \      src[i] = tile_data_pointer (tile[i], (x) % TILE_WIDTH, (y) % TILE_HEIGHT);
end_define

begin_comment
comment|/*  forward function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gdouble
name|gimp_drawable_transform_cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_affine (GimpDrawable * drawable,TileManager * float_tiles,gboolean interpolation,gboolean clip_result,GimpMatrix3 matrix,GimpTransformDirection direction,GimpProgressFunc progress_callback,gpointer progress_data)
name|gimp_drawable_transform_tiles_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|float_tiles
parameter_list|,
name|gboolean
name|interpolation
parameter_list|,
name|gboolean
name|clip_result
parameter_list|,
name|GimpMatrix3
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|PixelRegion
name|destPR
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|GimpMatrix3
name|m
decl_stmt|;
name|GimpMatrix3
name|im
decl_stmt|;
name|gint
name|itx
decl_stmt|,
name|ity
decl_stmt|;
name|gint
name|tx1
decl_stmt|,
name|ty1
decl_stmt|,
name|tx2
decl_stmt|,
name|ty2
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gdouble
name|xinc
decl_stmt|,
name|yinc
decl_stmt|,
name|winc
decl_stmt|;
name|gdouble
name|tx
decl_stmt|,
name|ty
decl_stmt|,
name|tw
decl_stmt|;
name|gdouble
name|ttx
init|=
literal|0.0
decl_stmt|,
name|tty
init|=
literal|0.0
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|src
index|[
literal|16
index|]
decl_stmt|;
name|Tile
modifier|*
name|tile
index|[
literal|16
index|]
decl_stmt|;
name|guchar
name|bg_col
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|newval
decl_stmt|;
name|PixelSurround
name|surround
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|float_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alpha
operator|=
literal|0
expr_stmt|;
comment|/*  turn interpolation off for simple transformations (e.g. rot90)  */
if|if
condition|(
name|gimp_matrix3_is_simple
argument_list|(
name|matrix
argument_list|)
operator|||
name|base_config
operator|->
name|interpolation_type
operator|==
name|GIMP_NEAREST_NEIGHBOR_INTERPOLATION
condition|)
name|interpolation
operator|=
name|FALSE
expr_stmt|;
comment|/*  Get the background color  */
name|gimp_image_get_background
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|bg_col
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|bg_col
index|[
name|ALPHA_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|bg_col
index|[
name|ALPHA_G_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_G_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|bg_col
index|[
name|ALPHA_I_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_I_PIX
expr_stmt|;
comment|/*  If the gimage is indexed color, ignore smoothing value  */
name|interpolation
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*  enable rotating un-floated non-layers  */
if|if
condition|(
name|tile_manager_bpp
argument_list|(
name|float_tiles
argument_list|)
operator|==
literal|1
condition|)
block|{
name|bg_col
index|[
literal|0
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
comment|/*  setting alpha = 0 will cause the channel's value to be treated        *  as alpha and the color channel loops never to be entered        */
name|alpha
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|direction
operator|==
name|GIMP_TRANSFORM_BACKWARD
condition|)
block|{
comment|/*  keep the original matrix here, so we dont need to recalculate        *  the inverse later        */
name|gimp_matrix3_duplicate
argument_list|(
name|matrix
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
name|matrix
argument_list|,
name|im
argument_list|)
expr_stmt|;
name|matrix
operator|=
name|im
expr_stmt|;
block|}
else|else
block|{
comment|/*  Find the inverse of the transformation matrix  */
name|gimp_matrix3_invert
argument_list|(
name|matrix
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GNUC__
warning|#
directive|warning
warning|FIXME: path_transform_current_path
endif|#
directive|endif
if|#
directive|if
literal|0
block|path_transform_current_path (gimage, matrix, FALSE);
endif|#
directive|endif
name|tile_manager_get_offsets
argument_list|(
name|float_tiles
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
name|tile_manager_width
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|tile_manager_height
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
comment|/*  Find the bounding coordinates  */
if|if
condition|(
name|alpha
operator|==
literal|0
operator|||
name|clip_result
condition|)
block|{
name|tx1
operator|=
name|x1
expr_stmt|;
name|ty1
operator|=
name|y1
expr_stmt|;
name|tx2
operator|=
name|x2
expr_stmt|;
name|ty2
operator|=
name|y2
expr_stmt|;
block|}
else|else
block|{
name|gdouble
name|dx1
decl_stmt|,
name|dy1
decl_stmt|;
name|gdouble
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
name|gdouble
name|dx3
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|dx4
decl_stmt|,
name|dy4
decl_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|dx1
argument_list|,
operator|&
name|dy1
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
operator|&
name|dx2
argument_list|,
operator|&
name|dy2
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
operator|&
name|dx3
argument_list|,
operator|&
name|dy3
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|dx4
argument_list|,
operator|&
name|dy4
argument_list|)
expr_stmt|;
name|tx1
operator|=
name|MIN
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|)
expr_stmt|;
name|tx1
operator|=
name|MIN
argument_list|(
name|tx1
argument_list|,
name|dx3
argument_list|)
expr_stmt|;
name|tx1
operator|=
name|MIN
argument_list|(
name|tx1
argument_list|,
name|dx4
argument_list|)
expr_stmt|;
name|ty1
operator|=
name|MIN
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|)
expr_stmt|;
name|ty1
operator|=
name|MIN
argument_list|(
name|ty1
argument_list|,
name|dy3
argument_list|)
expr_stmt|;
name|ty1
operator|=
name|MIN
argument_list|(
name|ty1
argument_list|,
name|dy4
argument_list|)
expr_stmt|;
name|tx2
operator|=
name|MAX
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|)
expr_stmt|;
name|tx2
operator|=
name|MAX
argument_list|(
name|tx2
argument_list|,
name|dx3
argument_list|)
expr_stmt|;
name|tx2
operator|=
name|MAX
argument_list|(
name|tx2
argument_list|,
name|dx4
argument_list|)
expr_stmt|;
name|ty2
operator|=
name|MAX
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|)
expr_stmt|;
name|ty2
operator|=
name|MAX
argument_list|(
name|ty2
argument_list|,
name|dy3
argument_list|)
expr_stmt|;
name|ty2
operator|=
name|MAX
argument_list|(
name|ty2
argument_list|,
name|dy4
argument_list|)
expr_stmt|;
block|}
comment|/*  Get the new temporary buffer for the transformed result  */
name|tiles
operator|=
name|tile_manager_new
argument_list|(
operator|(
name|tx2
operator|-
name|tx1
operator|)
argument_list|,
operator|(
name|ty2
operator|-
name|ty1
operator|)
argument_list|,
name|tile_manager_bpp
argument_list|(
name|float_tiles
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|tx2
operator|-
name|tx1
operator|)
argument_list|,
operator|(
name|ty2
operator|-
name|ty1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|tiles
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|)
expr_stmt|;
comment|/* initialise the pixel_surround accessor */
if|if
condition|(
name|interpolation
condition|)
block|{
if|if
condition|(
name|base_config
operator|->
name|interpolation_type
operator|==
name|GIMP_CUBIC_INTERPOLATION
condition|)
block|{
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|float_tiles
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|bg_col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|float_tiles
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|bg_col
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not actually useful, keeps the code cleaner */
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|float_tiles
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|bg_col
argument_list|)
expr_stmt|;
block|}
name|width
operator|=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|xinc
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|yinc
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* these loops could be rearranged, depending on which bit of code    * you'd most like to write more than once.    */
for|for
control|(
name|y
operator|=
name|ty1
init|;
name|y
operator|<
name|ty2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress_callback
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
name|ty1
argument_list|,
name|ty2
argument_list|,
name|y
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
comment|/* set up inverse transform steps */
name|tx
operator|=
name|xinc
operator|*
name|tx1
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|ty
operator|=
name|yinc
operator|*
name|tx1
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
operator|=
name|winc
operator|*
name|tx1
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|x
operator|=
name|tx1
init|;
name|x
operator|<
name|tx2
condition|;
name|x
operator|++
control|)
block|{
comment|/*  normalize homogeneous coords  */
if|if
condition|(
name|tw
operator|==
literal|0.0
condition|)
block|{
name|g_warning
argument_list|(
literal|"homogeneous coordinate = 0...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tw
operator|!=
literal|1.0
condition|)
block|{
name|ttx
operator|=
name|tx
operator|/
name|tw
expr_stmt|;
name|tty
operator|=
name|ty
operator|/
name|tw
expr_stmt|;
block|}
else|else
block|{
name|ttx
operator|=
name|tx
expr_stmt|;
name|tty
operator|=
name|ty
expr_stmt|;
block|}
comment|/*  Set the destination pixels  */
if|if
condition|(
name|interpolation
condition|)
block|{
if|if
condition|(
name|base_config
operator|->
name|interpolation_type
operator|==
name|GIMP_CUBIC_INTERPOLATION
condition|)
block|{
comment|/*  ttx& tty are the subpixel coordinates of the point in 		   *  the original selection's floating buffer. 		   *  We need the four integer pixel coords around them: 		   *  itx to itx + 3, ity to ity + 3                    */
name|itx
operator|=
name|floor
argument_list|(
name|ttx
argument_list|)
expr_stmt|;
name|ity
operator|=
name|floor
argument_list|(
name|tty
argument_list|)
expr_stmt|;
comment|/* check if any part of our region overlaps the buffer */
if|if
condition|(
operator|(
name|itx
operator|+
literal|2
operator|)
operator|>=
name|x1
operator|&&
operator|(
name|itx
operator|-
literal|1
operator|)
operator|<
name|x2
operator|&&
operator|(
name|ity
operator|+
literal|2
operator|)
operator|>=
name|y1
operator|&&
operator|(
name|ity
operator|-
literal|1
operator|)
operator|<
name|y2
condition|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gdouble
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|guchar
modifier|*
name|start
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
operator|&
name|surround
argument_list|,
name|itx
operator|-
literal|1
operator|-
name|x1
argument_list|,
name|ity
operator|-
literal|1
operator|-
name|y1
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|dx
operator|=
name|ttx
operator|-
name|itx
expr_stmt|;
name|dy
operator|=
name|tty
operator|-
name|ity
expr_stmt|;
comment|/* calculate alpha of result */
name|start
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|a_val
operator|=
name|gimp_drawable_transform_cubic
argument_list|(
name|dy
argument_list|,
name|CUBIC_ROW
argument_list|(
name|dx
argument_list|,
name|start
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
operator|+
name|row
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
operator|+
name|row
operator|+
name|row
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c, 		       *  result = bicubic (c * alpha) / bicubic (alpha) 		       * 		       *  never entered for alpha == 0 		       */
for|for
control|(
name|i
operator|=
operator|-
name|alpha
init|;
name|i
operator|<
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|start
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|newval
operator|=
name|RINT
argument_list|(
name|a_recip
operator|*
name|gimp_drawable_transform_cubic
argument_list|(
name|dy
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|dx
argument_list|,
name|start
argument_list|,
name|bytes
argument_list|,
name|i
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
argument_list|,
name|bytes
argument_list|,
name|i
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
operator|+
name|row
argument_list|,
name|bytes
argument_list|,
name|i
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|dx
argument_list|,
name|start
operator|+
name|row
operator|+
name|row
operator|+
name|row
argument_list|,
name|bytes
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|<=
literal|0
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newval
operator|>
literal|255
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
name|newval
expr_stmt|;
block|}
block|}
comment|/*  alpha already done  */
name|d
operator|++
expr_stmt|;
name|pixel_surround_release
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
comment|/*  increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_col
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
else|else
comment|/*  linear  */
block|{
name|itx
operator|=
name|floor
argument_list|(
name|ttx
argument_list|)
expr_stmt|;
name|ity
operator|=
name|floor
argument_list|(
name|tty
argument_list|)
expr_stmt|;
comment|/*  expand source area to cover interpolation region 		   *  (which runs from itx to itx + 1, same in y) 		   */
if|if
condition|(
operator|(
name|itx
operator|+
literal|1
operator|)
operator|>=
name|x1
operator|&&
name|itx
operator|<
name|x2
operator|&&
operator|(
name|ity
operator|+
literal|1
operator|)
operator|>=
name|y1
operator|&&
name|ity
operator|<
name|y2
condition|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|guchar
modifier|*
name|chan
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
operator|&
name|surround
argument_list|,
name|itx
operator|-
name|x1
argument_list|,
name|ity
operator|-
name|y1
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|dx
operator|=
name|ttx
operator|-
name|itx
expr_stmt|;
name|dy
operator|=
name|tty
operator|-
name|ity
expr_stmt|;
comment|/* calculate alpha value of result pixel */
name|chan
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|a_val
operator|=
name|BILINEAR
argument_list|(
name|chan
index|[
literal|0
index|]
argument_list|,
name|chan
index|[
name|bytes
index|]
argument_list|,
name|chan
index|[
name|row
index|]
argument_list|,
name|chan
index|[
name|row
operator|+
name|bytes
index|]
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>=
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c, 		       *  result = bilinear (c * alpha) / bilinear (alpha) 		       * 		       *  never entered for alpha == 0 		       */
for|for
control|(
name|i
operator|=
operator|-
name|alpha
init|;
name|i
operator|<
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|chan
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|newval
operator|=
name|RINT
argument_list|(
name|a_recip
operator|*
name|BILINEAR
argument_list|(
name|chan
index|[
literal|0
index|]
operator|*
name|chan
index|[
name|i
index|]
argument_list|,
name|chan
index|[
name|bytes
index|]
operator|*
name|chan
index|[
name|bytes
operator|+
name|i
index|]
argument_list|,
name|chan
index|[
name|row
index|]
operator|*
name|chan
index|[
name|row
operator|+
name|i
index|]
argument_list|,
name|chan
index|[
name|row
operator|+
name|bytes
index|]
operator|*
name|chan
index|[
name|row
operator|+
name|bytes
operator|+
name|i
index|]
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|<=
literal|0
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newval
operator|>
literal|255
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
name|newval
expr_stmt|;
block|}
block|}
comment|/*  alpha already done  */
name|d
operator|++
expr_stmt|;
name|pixel_surround_release
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
comment|/*  increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_col
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/*  no interpolation  */
block|{
name|itx
operator|=
name|floor
argument_list|(
name|ttx
argument_list|)
expr_stmt|;
name|ity
operator|=
name|floor
argument_list|(
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|itx
operator|>=
name|x1
operator|&&
name|itx
operator|<
name|x2
operator|&&
name|ity
operator|>=
name|y1
operator|&&
name|ity
operator|<
name|y2
condition|)
block|{
comment|/*  x, y coordinates into source tiles  */
name|sx
operator|=
name|itx
operator|-
name|x1
expr_stmt|;
name|sy
operator|=
name|ity
operator|-
name|y1
expr_stmt|;
name|REF_TILE
argument_list|(
literal|0
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|src
index|[
literal|0
index|]
index|[
name|b
index|]
expr_stmt|;
name|tile_release
argument_list|(
name|tile
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
comment|/*  increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_col
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
comment|/*  increment the transformed coordinates  */
name|tx
operator|+=
name|xinc
expr_stmt|;
name|ty
operator|+=
name|yinc
expr_stmt|;
name|tw
operator|+=
name|winc
expr_stmt|;
block|}
comment|/*  set the pixel region row  */
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
literal|0
argument_list|,
operator|(
name|y
operator|-
name|ty1
operator|)
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_clear
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|tiles
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_flip (GimpDrawable * drawable,TileManager * orig,InternalOrientationType flip_type)
name|gimp_drawable_transform_tiles_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|orig
parameter_list|,
name|InternalOrientationType
name|flip_type
parameter_list|)
block|{
name|TileManager
modifier|*
name|new
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gint
name|orig_width
decl_stmt|;
name|gint
name|orig_height
decl_stmt|;
name|gint
name|orig_bpp
decl_stmt|;
name|gint
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|orig_width
operator|=
name|tile_manager_width
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|orig_height
operator|=
name|tile_manager_height
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|orig_bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|new
operator|=
name|tile_manager_new
argument_list|(
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip_type
operator|==
name|ORIENTATION_HORIZONTAL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|orig_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new
argument_list|,
operator|(
name|orig_width
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|orig_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|orig_width
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new
argument_list|,
literal|0
argument_list|,
operator|(
name|orig_height
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|,
name|orig_width
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__GNUC__
warning|#
directive|warning
warning|FIXME: path_transform_flip_horz/vert
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* flip locked paths */
comment|/* Note that the undo structures etc are setup before we enter this    * function.    */
block|if (flip_type == ORIENTATION_HORIZONTAL)     path_transform_flip_horz (gimage);   else     path_transform_flip_vert (gimage);
endif|#
directive|endif
return|return
name|new
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_affine (GimpDrawable * drawable,gboolean interpolation,gboolean clip_result,GimpMatrix3 matrix,GimpTransformDirection direction)
name|gimp_drawable_transform_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
name|interpolation
parameter_list|,
name|gboolean
name|clip_result
parameter_list|,
name|GimpMatrix3
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_affine
argument_list|(
name|drawable
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|FALSE
argument_list|,
name|matrix
argument_list|,
name|GIMP_TRANSFORM_FORWARD
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
name|success
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
block|}
comment|/*  push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_flip (GimpDrawable * drawable,InternalOrientationType flip_type)
name|gimp_drawable_transform_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|InternalOrientationType
name|flip_type
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_flip
argument_list|(
name|drawable
argument_list|,
name|float_tiles
argument_list|,
name|flip_type
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
name|success
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
block|}
comment|/*  push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_cut (GimpDrawable * drawable,gboolean * new_layer)
name|gimp_drawable_transform_cut
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
modifier|*
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|new_layer
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  extract the selected mask if there is a selection  */
if|if
condition|(
operator|!
name|gimp_image_mask_is_empty
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
comment|/* set the keep_indexed flag to FALSE here, since we use        * gimp_layer_new_from_tiles() later which assumes that the tiles        * are either RGB or GRAY.  Eeek!!!              (Sven)        */
name|tiles
operator|=
name|gimp_image_mask_extract
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*  otherwise, just copy the layer  */
else|else
block|{
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
name|tiles
operator|=
name|gimp_image_mask_extract
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|tiles
operator|=
name|gimp_image_mask_extract
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|tiles
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_paste (GimpDrawable * drawable,TileManager * tiles,gboolean new_layer)
name|gimp_drawable_transform_paste
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|gboolean
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tiles
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_layer
condition|)
block|{
name|layer
operator|=
name|gimp_layer_new_from_tiles
argument_list|(
name|gimage
argument_list|,
name|tiles
argument_list|,
name|_
argument_list|(
literal|"Transformation"
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: gimp_layer_new_frome_tiles() failed"
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|tile_manager_get_offsets
argument_list|(
name|tiles
argument_list|,
operator|&
operator|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
operator|)
argument_list|,
operator|&
operator|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
operator|)
argument_list|)
expr_stmt|;
comment|/*  Start a group undo  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|EDIT_PASTE_UNDO
argument_list|)
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|layer
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
comment|/*  End the group undo  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Free the tiles  */
name|tile_manager_destroy
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
name|layer
operator|=
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|channel
operator|=
name|GIMP_CHANNEL
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|layer
condition|)
name|gimp_layer_add_alpha
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
name|drawable
operator|->
name|offset_x
argument_list|,
name|drawable
operator|->
name|offset_y
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/*  Push an undo  */
if|if
condition|(
name|layer
condition|)
name|undo_push_layer_mod
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|channel
condition|)
name|undo_push_channel_mod
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  set the current layer's data  */
name|drawable
operator|->
name|tiles
operator|=
name|tiles
expr_stmt|;
comment|/*  Fill in the new layer's attributes  */
name|drawable
operator|->
name|width
operator|=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|drawable
operator|->
name|height
operator|=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|drawable
operator|->
name|bytes
operator|=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|tiles
argument_list|,
operator|&
name|drawable
operator|->
name|offset_x
argument_list|,
operator|&
name|drawable
operator|->
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  if we were operating on the floating selection, then it's boundary         *  and previews need invalidating        */
if|if
condition|(
name|drawable
operator|==
operator|(
name|GimpDrawable
operator|*
operator|)
name|floating_layer
condition|)
name|floating_sel_invalidate
argument_list|(
name|floating_layer
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Note: cubic function no longer clips result */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|gimp_drawable_transform_cubic (gdouble dx,gint jm1,gint j,gint jp1,gint jp2)
name|gimp_drawable_transform_cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
block|{
name|gdouble
name|result
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Equivalent to Gimp 1.1.1 and earlier - some ringing */
block|result = ((( ( - jm1 + j - jp1 + jp2 ) * dx +                ( jm1 + jm1 - j - j + jp1 - jp2 ) ) * dx +                ( - jm1 + jp1 ) ) * dx + j );
comment|/* Recommended by Mitchell and Netravali - too blurred? */
block|result = ((( ( - 7 * jm1 + 21 * j - 21 * jp1 + 7 * jp2 ) * dx +                ( 15 * jm1 - 36 * j + 27 * jp1 - 6 * jp2 ) ) * dx +                ( - 9 * jm1 + 9 * jp1 ) ) * dx + (jm1 + 16 * j + jp1) ) / 18.0;
endif|#
directive|endif
comment|/* Catmull-Rom - not bad */
name|result
operator|=
operator|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
operator|)
operator|/
literal|2.0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

