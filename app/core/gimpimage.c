begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/temp-buf.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpcoreconfig.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimp-parasites.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-colorhash.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-guides.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-preview.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-projection.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplist.h"
end_include

begin_include
include|#
directive|include
file|"gimpmarshal.h"
end_include

begin_include
include|#
directive|include
file|"gimpparasitelist.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimpundostack.h"
end_include

begin_include
include|#
directive|include
file|"file/file-utils.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
DECL|enum|__anon2acc501d0103
block|{
DECL|enumerator|MODE_CHANGED
name|MODE_CHANGED
block|,
DECL|enumerator|ALPHA_CHANGED
name|ALPHA_CHANGED
block|,
DECL|enumerator|FLOATING_SELECTION_CHANGED
name|FLOATING_SELECTION_CHANGED
block|,
DECL|enumerator|ACTIVE_LAYER_CHANGED
name|ACTIVE_LAYER_CHANGED
block|,
DECL|enumerator|ACTIVE_CHANNEL_CHANGED
name|ACTIVE_CHANNEL_CHANGED
block|,
DECL|enumerator|ACTIVE_VECTORS_CHANGED
name|ACTIVE_VECTORS_CHANGED
block|,
DECL|enumerator|COMPONENT_VISIBILITY_CHANGED
name|COMPONENT_VISIBILITY_CHANGED
block|,
DECL|enumerator|COMPONENT_ACTIVE_CHANGED
name|COMPONENT_ACTIVE_CHANGED
block|,
DECL|enumerator|GRID_CHANGED
name|GRID_CHANGED
block|,
DECL|enumerator|MASK_CHANGED
name|MASK_CHANGED
block|,
DECL|enumerator|RESOLUTION_CHANGED
name|RESOLUTION_CHANGED
block|,
DECL|enumerator|UNIT_CHANGED
name|UNIT_CHANGED
block|,
DECL|enumerator|QMASK_CHANGED
name|QMASK_CHANGED
block|,
DECL|enumerator|SELECTION_CONTROL
name|SELECTION_CONTROL
block|,
DECL|enumerator|CLEAN
name|CLEAN
block|,
DECL|enumerator|DIRTY
name|DIRTY
block|,
DECL|enumerator|UPDATE
name|UPDATE
block|,
DECL|enumerator|UPDATE_GUIDE
name|UPDATE_GUIDE
block|,
DECL|enumerator|COLORMAP_CHANGED
name|COLORMAP_CHANGED
block|,
DECL|enumerator|UNDO_START
name|UNDO_START
block|,
DECL|enumerator|UNDO_EVENT
name|UNDO_EVENT
block|,
DECL|enumerator|FLUSH
name|FLUSH
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_dispose
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gsize
name|gimp_image_get_memsize
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|,
name|gsize
modifier|*
name|gui_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_size_changed
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_image_get_description
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gchar
modifier|*
modifier|*
name|tooltip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_real_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|ncol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_visibility
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_get_active_components
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
modifier|*
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|valid_combinations
specifier|static
name|gint
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* GIMP_RGB_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* GIMP_RGBA_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GIMP_GRAY_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_GRAYA_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_INDEXED_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_INDEXEDA_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimp_image_signals
specifier|static
name|guint
name|gimp_image_signals
index|[
name|LAST_SIGNAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|parent_class
specifier|static
name|GimpViewableClass
modifier|*
name|parent_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|GType
DECL|function|gimp_image_get_type (void)
name|gimp_image_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GType
name|image_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|image_type
condition|)
block|{
specifier|static
specifier|const
name|GTypeInfo
name|image_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|GimpImageClass
argument_list|)
block|,
name|NULL
block|,
comment|/* base_init */
name|NULL
block|,
comment|/* base_finalize */
operator|(
name|GClassInitFunc
operator|)
name|gimp_image_class_init
block|,
name|NULL
block|,
comment|/* class_finalize */
name|NULL
block|,
comment|/* class_data */
sizeof|sizeof
argument_list|(
name|GimpImage
argument_list|)
block|,
literal|0
block|,
comment|/* n_preallocs */
operator|(
name|GInstanceInitFunc
operator|)
name|gimp_image_init
block|,       }
decl_stmt|;
name|image_type
operator|=
name|g_type_register_static
argument_list|(
name|GIMP_TYPE_VIEWABLE
argument_list|,
literal|"GimpImage"
argument_list|,
operator|&
name|image_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|image_type
return|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_class_init (GimpImageClass * klass)
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
block|{
name|GObjectClass
modifier|*
name|object_class
decl_stmt|;
name|GimpObjectClass
modifier|*
name|gimp_object_class
decl_stmt|;
name|GimpViewableClass
modifier|*
name|viewable_class
decl_stmt|;
name|object_class
operator|=
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|gimp_object_class
operator|=
name|GIMP_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|viewable_class
operator|=
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|parent_class
operator|=
name|g_type_class_peek_parent
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|MODE_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"mode_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|mode_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ALPHA_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"alpha_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|alpha_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|FLOATING_SELECTION_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"floating_selection_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|floating_selection_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active_layer_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_layer_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active_channel_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_channel_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active_vectors_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_vectors_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COMPONENT_VISIBILITY_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"component_visibility_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|component_visibility_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_CHANNEL_TYPE
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COMPONENT_ACTIVE_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"component_active_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|component_active_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_CHANNEL_TYPE
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|GRID_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"grid_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|grid_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|MASK_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"mask_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|mask_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESOLUTION_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"resolution_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|resolution_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNIT_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"unit_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|unit_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|QMASK_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"qmask_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|qmask_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|SELECTION_CONTROL
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"selection_control"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|selection_control
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_SELECTION_CONTROL
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|CLEAN
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"clean"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|clean
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|DIRTY
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"dirty"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|dirty
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UPDATE
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"update"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|update
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__INT_INT_INT_INT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|4
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UPDATE_GUIDE
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"update_guide"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|update_guide
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__POINTER
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_POINTER
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"colormap_changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|colormap_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__INT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNDO_START
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"undo_start"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|undo_start
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"undo_event"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|undo_event
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM_OBJECT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|2
argument_list|,
name|GIMP_TYPE_UNDO_EVENT
argument_list|,
name|GIMP_TYPE_UNDO
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|FLUSH
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"flush"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|flush
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|object_class
operator|->
name|dispose
operator|=
name|gimp_image_dispose
expr_stmt|;
name|object_class
operator|->
name|finalize
operator|=
name|gimp_image_finalize
expr_stmt|;
name|gimp_object_class
operator|->
name|name_changed
operator|=
name|gimp_image_name_changed
expr_stmt|;
name|gimp_object_class
operator|->
name|get_memsize
operator|=
name|gimp_image_get_memsize
expr_stmt|;
name|viewable_class
operator|->
name|default_stock_id
operator|=
literal|"gimp-image"
expr_stmt|;
name|viewable_class
operator|->
name|invalidate_preview
operator|=
name|gimp_image_invalidate_preview
expr_stmt|;
name|viewable_class
operator|->
name|size_changed
operator|=
name|gimp_image_size_changed
expr_stmt|;
name|viewable_class
operator|->
name|get_preview_size
operator|=
name|gimp_image_get_preview_size
expr_stmt|;
name|viewable_class
operator|->
name|get_popup_size
operator|=
name|gimp_image_get_popup_size
expr_stmt|;
name|viewable_class
operator|->
name|get_preview
operator|=
name|gimp_image_get_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_new_preview
operator|=
name|gimp_image_get_new_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_description
operator|=
name|gimp_image_get_description
expr_stmt|;
name|klass
operator|->
name|grid_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|mode_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|alpha_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|floating_selection_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_layer_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_channel_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_vectors_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|component_visibility_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|component_active_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|mask_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|clean
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|dirty
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|update
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|update_guide
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|colormap_changed
operator|=
name|gimp_image_real_colormap_changed
expr_stmt|;
name|klass
operator|->
name|undo_start
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|undo_event
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|flush
operator|=
name|NULL
expr_stmt|;
name|gimp_image_color_hash_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_init (GimpImage * gimage)
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|ID
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|save_proc
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
literal|1.0
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
literal|1.0
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|disp_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|tattoo_state
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|GIMP_RGBA_IMAGE
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|grid
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_LAYER
argument_list|,
name|GIMP_CONTAINER_POLICY_STRONG
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_CHANNEL
argument_list|,
name|GIMP_CONTAINER_POLICY_STRONG
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|vectors
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_VECTORS
argument_list|,
name|GIMP_CONTAINER_POLICY_STRONG
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layer_update_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|"update"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_update
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channel_update_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|"update"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_update
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_visible_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|"visibility_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_visibility
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channel_visible_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|"visibility_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_visibility
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|"add"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_add
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|"add"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_add
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|"remove"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_remove
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|"remove"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_remove
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_vectors
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|selection_mask
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|parasites
operator|=
name|gimp_parasite_list_new
argument_list|()
expr_stmt|;
name|gimage
operator|->
name|qmask_state
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|qmask_inverted
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|r
operator|=
literal|1.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|g
operator|=
literal|0.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|b
operator|=
literal|0.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|a
operator|=
literal|0.5
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|gimp_undo_stack_new
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|gimp_undo_stack_new
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|group_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|pushing_undo_group
operator|=
name|GIMP_UNDO_GROUP_NONE
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_dispose (GObject * object)
name|gimp_image_dispose
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_image_undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|gimage
operator|->
name|layer_update_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|gimage
operator|->
name|channel_update_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|gimage
operator|->
name|layer_visible_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|gimage
operator|->
name|channel_visible_handler
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|gimp_image_drawable_add
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|gimp_image_drawable_add
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|gimp_image_drawable_remove
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|gimp_image_drawable_remove
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|dispose
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_finalize (GObject * object)
name|gimp_image_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimage
operator|->
name|gimp
operator|&&
name|gimage
operator|->
name|gimp
operator|->
name|image_table
condition|)
block|{
name|g_hash_table_remove
argument_list|(
name|gimage
operator|->
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|gimp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|gimp_image_projection_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
block|{
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|layers
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|channels
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|vectors
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|vectors
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|layer_stack
condition|)
block|{
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|selection_mask
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|selection_mask
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
block|{
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|parasites
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|parasites
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|guides
condition|)
block|{
name|g_list_foreach
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_image_guide_unref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|gimage
operator|->
name|guides
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|grid
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|grid
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|grid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|undo_stack
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|undo_stack
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|redo_stack
condition|)
block|{
name|g_object_unref
argument_list|(
name|gimage
operator|->
name|redo_stack
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
block|}
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|finalize
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_name_changed (GimpObject * object)
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
condition|)
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|name
operator|=
name|gimp_object_get_name
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|g_free
argument_list|(
name|object
operator|->
name|name
argument_list|)
expr_stmt|;
name|object
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gsize
DECL|function|gimp_image_get_memsize (GimpObject * object,gsize * gui_size)
name|gimp_image_get_memsize
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|,
name|gsize
modifier|*
name|gui_size
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gsize
name|memsize
init|=
literal|0
decl_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|memsize
operator|+=
name|GIMP_IMAGE_COLORMAP_SIZE
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|memsize
operator|+=
name|tile_manager_get_memsize
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|memsize
operator|+=
name|tile_manager_get_memsize
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
expr_stmt|;
name|memsize
operator|+=
operator|(
name|g_list_length
argument_list|(
name|gimage
operator|->
name|guides
argument_list|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|GList
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|GimpGuide
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|grid
condition|)
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|grid
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|GSList
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|selection_mask
condition|)
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|undo_stack
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|redo_stack
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
operator|*
name|gui_size
operator|+=
name|temp_buf_get_memsize
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
return|return
name|memsize
operator|+
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|get_memsize
argument_list|(
name|object
argument_list|,
name|gui_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_invalidate_preview (GimpViewable * viewable)
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
if|if
condition|(
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_preview
condition|)
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_preview
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
block|{
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_size_changed (GimpViewable * viewable)
name|gimp_image_size_changed
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|size_changed
condition|)
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|size_changed
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_image_get_description (GimpViewable * viewable,gchar ** tooltip)
name|gimp_image_get_description
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gchar
modifier|*
modifier|*
name|tooltip
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|gchar
modifier|*
name|basename
decl_stmt|;
name|gchar
modifier|*
name|retval
decl_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|uri
operator|=
name|gimp_image_get_uri
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|basename
operator|=
name|file_utils_uri_to_utf8_basename
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|tooltip
condition|)
operator|*
name|tooltip
operator|=
name|file_utils_uri_to_utf8_filename
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|retval
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s-%d"
argument_list|,
name|basename
argument_list|,
name|gimp_image_get_ID
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_real_colormap_changed (GimpImage * gimage,gint ncol)
name|gimp_image_real_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|ncol
parameter_list|)
block|{
if|if
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GIMP_INDEXED
condition|)
block|{
comment|/* A colormap alteration affects the whole image */
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_color_hash_invalidate
argument_list|(
name|gimage
argument_list|,
name|ncol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_update (GimpDrawable * drawable,gint x,gint y,gint width,gint height,GimpImage * gimage)
name|gimp_image_drawable_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|x
operator|+=
name|offset_x
expr_stmt|;
name|y
operator|+=
name|offset_y
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_visibility (GimpItem * item,GimpImage * gimage)
name|gimp_image_drawable_visibility
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_add (GimpContainer * container,GimpItem * item,GimpImage * gimage)
name|gimp_image_drawable_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_remove (GimpContainer * container,GimpItem * item,GimpImage * gimage)
name|gimp_image_drawable_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_get_active_components (const GimpImage * gimage,const GimpDrawable * drawable,gboolean * active)
name|gimp_image_get_active_components
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
modifier|*
name|active
parameter_list|)
block|{
comment|/* If the drawable is a channel make sure that the alpha channel is    * not valid.    */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|active
index|[
name|GRAY_PIX
index|]
operator|=
name|TRUE
expr_stmt|;
name|active
index|[
name|ALPHA_G_PIX
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  otherwise, check whether preserve transparency is    *  enabled in the layer and if the layer has alpha    */
elseif|else
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*  first copy the gimage active channels  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|active
index|[
name|i
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
operator|&&
name|layer
operator|->
name|preserve_trans
condition|)
name|active
index|[
name|gimp_drawable_bytes
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_new (Gimp * gimp,gint width,gint height,GimpImageBaseType base_type)
name|gimp_image_new
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImageBaseType
name|base_type
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_GIMP
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_IMAGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|gimp
operator|=
name|gimp
expr_stmt|;
name|gimage
operator|->
name|ID
operator|=
name|gimp
operator|->
name|next_image_ID
operator|++
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|gimp
operator|->
name|config
operator|->
name|default_xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|gimp
operator|->
name|config
operator|->
name|default_yresolution
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|gimp
operator|->
name|config
operator|->
name|default_unit
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
case|case
name|GIMP_GRAY
case|:
break|break;
case|case
name|GIMP_INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|GIMP_IMAGE_COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  set all color channels visible and active  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|visible
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|active
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* create the selection mask */
name|gimage
operator|->
name|selection_mask
operator|=
name|gimp_selection_new
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|gimp
operator|->
name|config
argument_list|,
literal|"notify::transparency-type"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_invalidate_layer_previews
argument_list|)
argument_list|,
name|gimage
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|gimp
operator|->
name|config
argument_list|,
literal|"notify::transparency-size"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_invalidate_layer_previews
argument_list|)
argument_list|,
name|gimage
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|gimp
operator|->
name|config
argument_list|,
literal|"notify::layer-previews"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_viewable_size_changed
argument_list|)
argument_list|,
name|gimage
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
name|GimpImageBaseType
DECL|function|gimp_image_base_type (const GimpImage * gimage)
name|gimp_image_base_type
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_base_type_with_alpha (const GimpImage * gimage)
name|gimp_image_base_type_with_alpha
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimage
operator|->
name|base_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
name|GIMP_RGBA_IMAGE
return|;
case|case
name|GIMP_GRAY
case|:
return|return
name|GIMP_GRAYA_IMAGE
return|;
case|case
name|GIMP_INDEXED
case|:
return|return
name|GIMP_INDEXEDA_IMAGE
return|;
block|}
return|return
name|GIMP_RGB_IMAGE
return|;
block|}
end_function

begin_function
name|CombinationMode
DECL|function|gimp_image_get_combination_mode (GimpImageType dest_type,gint src_bytes)
name|gimp_image_get_combination_mode
parameter_list|(
name|GimpImageType
name|dest_type
parameter_list|,
name|gint
name|src_bytes
parameter_list|)
block|{
return|return
name|valid_combinations
index|[
name|dest_type
index|]
index|[
name|src_bytes
index|]
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_ID (const GimpImage * gimage)
name|gimp_image_get_ID
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|ID
return|;
block|}
end_function

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_get_by_ID (Gimp * gimp,gint image_id)
name|gimp_image_get_by_ID
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gint
name|image_id
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_GIMP
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp
operator|->
name|image_table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|GimpImage
operator|*
operator|)
name|g_hash_table_lookup
argument_list|(
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|image_id
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_uri (GimpImage * gimage,const gchar * uri)
name|gimp_image_set_uri
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_image_get_uri (const GimpImage * gimage)
name|gimp_image_get_uri
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uri
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|uri
condition|?
name|uri
else|:
name|_
argument_list|(
literal|"Untitled"
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_filename (GimpImage * gimage,const gchar * filename)
name|gimp_image_set_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|strlen
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|uri
decl_stmt|;
name|uri
operator|=
name|file_utils_filename_to_uri
argument_list|(
name|gimage
operator|->
name|gimp
operator|->
name|load_procs
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_image_set_uri
argument_list|(
name|gimage
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_set_uri
argument_list|(
name|gimage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|gimp_image_get_filename (const GimpImage * gimage)
name|gimp_image_get_filename
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uri
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uri
condition|)
return|return
name|NULL
return|;
return|return
name|g_filename_from_uri
argument_list|(
name|uri
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_save_proc (GimpImage * gimage,PlugInProcDef * proc)
name|gimp_image_set_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PlugInProcDef
modifier|*
name|proc
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|save_proc
operator|=
name|proc
expr_stmt|;
block|}
end_function

begin_function
name|PlugInProcDef
modifier|*
DECL|function|gimp_image_get_save_proc (const GimpImage * gimage)
name|gimp_image_get_save_proc
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|save_proc
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_resolution (GimpImage * gimage,gdouble xresolution,gdouble yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
name|xresolution
parameter_list|,
name|gdouble
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't allow to set the resolution out of bounds */
if|if
condition|(
name|xresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xresolution
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
name|yresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yresolution
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
return|return;
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|xresolution
operator|-
name|xresolution
argument_list|)
operator|>=
literal|1e-5
operator|)
operator|||
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|yresolution
operator|-
name|yresolution
argument_list|)
operator|>=
literal|1e-5
operator|)
condition|)
block|{
name|gimp_image_undo_push_image_resolution
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Change Image Resolution"
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|yresolution
expr_stmt|;
name|gimp_image_resolution_changed
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_resolution (const GimpImage * gimage,gdouble * xresolution,gdouble * yresolution)
name|gimp_image_get_resolution
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
modifier|*
name|xresolution
parameter_list|,
name|gdouble
modifier|*
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|xresolution
operator|&&
name|yresolution
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
operator|*
name|yresolution
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_resolution_changed (GimpImage * gimage)
name|gimp_image_resolution_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|RESOLUTION_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_unit (GimpImage * gimage,GimpUnit unit)
name|gimp_image_set_unit
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|unit
operator|!=
name|unit
condition|)
block|{
name|gimp_image_undo_push_image_resolution
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Change Image Unit"
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|gimp_image_unit_changed
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GimpUnit
DECL|function|gimp_image_get_unit (const GimpImage * gimage)
name|gimp_image_get_unit
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|GIMP_UNIT_INCH
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|unit
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_unit_changed (GimpImage * gimage)
name|gimp_image_unit_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|UNIT_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_width (const GimpImage * gimage)
name|gimp_image_get_width
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|width
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_height (const GimpImage * gimage)
name|gimp_image_get_height
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|height
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_has_alpha (const GimpImage * gimage)
name|gimp_image_has_alpha
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|layer
operator|&&
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_is_empty (const GimpImage * gimage)
name|gimp_image_is_empty
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_floating_sel (const GimpImage * gimage)
name|gimp_image_floating_sel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|gimage
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_floating_selection_changed (GimpImage * gimage)
name|gimp_image_floating_selection_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|FLOATING_SELECTION_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_mask (const GimpImage * gimage)
name|gimp_image_get_mask
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_mask_changed (GimpImage * gimage)
name|gimp_image_mask_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|MASK_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_component_index (const GimpImage * gimage,GimpChannelType channel)
name|gimp_image_get_component_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|channel
condition|)
block|{
case|case
name|GIMP_RED_CHANNEL
case|:
return|return
name|RED_PIX
return|;
case|case
name|GIMP_GREEN_CHANNEL
case|:
return|return
name|GREEN_PIX
return|;
case|case
name|GIMP_BLUE_CHANNEL
case|:
return|return
name|BLUE_PIX
return|;
case|case
name|GIMP_GRAY_CHANNEL
case|:
return|return
name|GRAY_PIX
return|;
case|case
name|GIMP_INDEXED_CHANNEL
case|:
return|return
name|INDEXED_PIX
return|;
case|case
name|GIMP_ALPHA_CHANNEL
case|:
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
name|ALPHA_PIX
return|;
case|case
name|GIMP_GRAY
case|:
return|return
name|ALPHA_G_PIX
return|;
case|case
name|GIMP_INDEXED
case|:
return|return
name|ALPHA_I_PIX
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_active (GimpImage * gimage,GimpChannelType channel,gboolean active)
name|gimp_image_set_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|,
name|gboolean
name|active
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
operator|&&
name|active
operator|!=
name|gimage
operator|->
name|active
index|[
name|index
index|]
condition|)
block|{
name|gimage
operator|->
name|active
index|[
name|index
index|]
operator|=
name|active
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/*  If there is an active channel and we mess with the components,        *  the active channel gets unset...        */
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|COMPONENT_ACTIVE_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_active (const GimpImage * gimage,GimpChannelType channel)
name|gimp_image_get_component_active
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
return|return
name|gimage
operator|->
name|active
index|[
name|index
index|]
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_visible (GimpImage * gimage,GimpChannelType channel,gboolean visible)
name|gimp_image_set_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|,
name|gboolean
name|visible
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
operator|&&
name|visible
operator|!=
name|gimage
operator|->
name|visible
index|[
name|index
index|]
condition|)
block|{
name|gimage
operator|->
name|visible
index|[
name|index
index|]
operator|=
name|visible
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|COMPONENT_VISIBILITY_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_visible (const GimpImage * gimage,GimpChannelType channel)
name|gimp_image_get_component_visible
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
return|return
name|gimage
operator|->
name|visible
index|[
name|index
index|]
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_grid_changed (GimpImage * gimage)
name|gimp_image_grid_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|GRID_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_mode_changed (GimpImage * gimage)
name|gimp_image_mode_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|MODE_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_alpha_changed (GimpImage * gimage)
name|gimp_image_alpha_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ALPHA_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_update (GimpImage * gimage,gint x,gint y,gint width,gint height)
name|gimp_image_update
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|UPDATE
index|]
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_update_guide (GimpImage * gimage,GimpGuide * guide)
name|gimp_image_update_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpGuide
modifier|*
name|guide
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|guide
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|UPDATE_GUIDE
index|]
argument_list|,
literal|0
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_colormap_changed (GimpImage * gimage,gint col)
name|gimp_image_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|col
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|col
operator|>=
operator|-
literal|1
operator|&&
name|col
operator|<
name|gimage
operator|->
name|num_cols
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_selection_control (GimpImage * gimage,GimpSelectionControl control)
name|gimp_image_selection_control
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpSelectionControl
name|control
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|SELECTION_CONTROL
index|]
argument_list|,
literal|0
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_qmask_changed (GimpImage * gimage)
name|gimp_image_qmask_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|QMASK_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  undo  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_is_enabled (const GimpImage * gimage)
name|gimp_image_undo_is_enabled
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|undo_on
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_enable (GimpImage * gimage)
name|gimp_image_undo_enable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Free all undo steps as they are now invalidated  */
name|gimp_image_undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_thaw
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_disable (GimpImage * gimage)
name|gimp_image_undo_disable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_freeze
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_freeze (GimpImage * gimage)
name|gimp_image_undo_freeze
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_thaw (GimpImage * gimage)
name|gimp_image_undo_thaw
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_undo_start (GimpImage * gimage)
name|gimp_image_undo_start
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|UNDO_START
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_undo_event (GimpImage * gimage,GimpUndoEvent event,GimpUndo * undo)
name|gimp_image_undo_event
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpUndoEvent
name|event
parameter_list|,
name|GimpUndo
modifier|*
name|undo
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|event
operator|==
name|GIMP_UNDO_EVENT_UNDO_FREE
operator|||
name|GIMP_IS_UNDO
argument_list|(
name|undo
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
argument_list|,
literal|0
argument_list|,
name|event
argument_list|,
name|undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE about the gimage->dirty counter:  *   If 0, then the image is clean (ie, copy on disk is the same as the one  *      in memory).  *   If positive, then that's the number of dirtying operations done  *       on the image since the last save.  *   If negative, then user has hit undo and gone back in time prior  *       to the saved copy.  Hitting redo will eventually come back to  *       the saved copy.  *  *   The image is dirty (ie, needs saving) if counter is non-zero.  *  *   If the counter is around 10000, this is due to undo-ing back  *   before a saved version, then mutating the image (thus destroying  *   the redo stack).  Once this has happened, it's impossible to get  *   the image back to the state on disk, since the redo info has been  *   freed.  See undo.c for the gorey details.  */
end_comment

begin_comment
comment|/*  * NEVER CALL gimp_image_dirty() directly!  *  * If your code has just dirtied the image, push an undo instead.  * Failing that, push the trivial undo which tells the user the  * command is not undoable: undo_push_cantundo() (But really, it would  * be best to push a proper undo).  If you just dirty the image  * without pushing an undo then the dirty count is increased, but  * popping that many undo actions won't lead to a clean image.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_dirty (GimpImage * gimage)
name|gimp_image_dirty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|++
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|DIRTY
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"dirty %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|-
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_clean (GimpImage * gimage)
name|gimp_image_clean
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|--
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"clean %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|+
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_clean_all (GimpImage * gimage)
name|gimp_image_clean_all
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  flush this image's displays  */
end_comment

begin_function
name|void
DECL|function|gimp_image_flush (GimpImage * gimage)
name|gimp_image_flush
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|FLUSH
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  color transforms / utilities  */
end_comment

begin_comment
comment|/* Get rid of these! A "foreground" is an UI concept.. */
end_comment

begin_function
name|void
DECL|function|gimp_image_get_foreground (const GimpImage * gimage,const GimpDrawable * drawable,guchar * fg)
name|gimp_image_get_foreground
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|fg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pfg
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|!
name|drawable
operator|||
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|fg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|gimp_get_current_context
argument_list|(
name|gimage
operator|->
name|gimp
argument_list|)
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|fg
argument_list|,
name|GIMP_RGB
argument_list|,
name|pfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_background (const GimpImage * gimage,const GimpDrawable * drawable,guchar * bg)
name|gimp_image_get_background
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pbg
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|!
name|drawable
operator|||
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|bg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
name|gimp_get_current_context
argument_list|(
name|gimage
operator|->
name|gimp
argument_list|)
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|bg
argument_list|,
name|GIMP_RGB
argument_list|,
name|pbg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_color (const GimpImage * src_gimage,GimpImageType src_type,const guchar * src,guchar * rgb)
name|gimp_image_get_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|src_gimage
parameter_list|,
name|GimpImageType
name|src_type
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|rgb
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|src_gimage
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
case|case
name|GIMP_RGBA_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|rgb
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|rgb
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|rgb
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_GRAYA_IMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|rgb
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|rgb
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|rgb
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
comment|/*  Indexed palette lookup  */
block|{
name|gint
name|index
init|=
operator|*
name|src
operator|*
literal|3
decl_stmt|;
operator|*
name|rgb
operator|++
operator|=
name|src_gimage
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
operator|*
name|rgb
operator|++
operator|=
name|src_gimage
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
operator|*
name|rgb
operator|=
name|src_gimage
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_color (const GimpImage * dest_gimage,const GimpDrawable * dest_drawable,guchar * dest,GimpImageBaseType src_type,const guchar * src)
name|gimp_image_transform_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|dest_gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|dest_drawable
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|GimpImageBaseType
name|src_type
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src
parameter_list|)
block|{
name|GimpImageType
name|dest_type
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|dest_gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|src_type
operator|!=
name|GIMP_INDEXED
argument_list|)
expr_stmt|;
name|dest_type
operator|=
operator|(
name|dest_drawable
condition|?
name|gimp_drawable_type
argument_list|(
name|dest_drawable
argument_list|)
else|:
name|gimp_image_base_type_with_alpha
argument_list|(
name|dest_gimage
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|src_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
case|case
name|GIMP_RGBA_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_GRAYA_IMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|INTENSITY
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|gimp_image_color_hash_rgb_to_indexed
argument_list|(
name|dest_gimage
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GIMP_GRAY
case|:
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
case|case
name|GIMP_RGBA_IMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_GRAYA_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|gimp_image_color_hash_rgb_to_indexed
argument_list|(
name|dest_gimage
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  shadow tiles  */
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_shadow (GimpImage * gimage,gint width,gint height,gint bpp)
name|gimp_image_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tile_manager_bpp
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
condition|)
block|{
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
block|}
name|gimage
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_free_shadow (GimpImage * gimage)
name|gimp_image_free_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
block|{
name|tile_manager_unref
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  combine functions  */
end_comment

begin_function
name|void
DECL|function|gimp_image_apply_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gboolean push_undo,const gchar * undo_desc,gdouble opacity,GimpLayerModeEffects mode,TileManager * src1_tiles,gint x,gint y)
name|gimp_image_apply_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gdouble
name|opacity
parameter_list|,
name|GimpLayerModeEffects
name|mode
parameter_list|,
comment|/*  alternative to using drawable tiles as src1: */
name|TileManager
modifier|*
name|src1_tiles
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|CombinationMode
name|operation
decl_stmt|;
name|gboolean
name|active_components
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_channel_is_empty
argument_list|(
name|mask
argument_list|)
condition|)
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_components
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active_components
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|gimp_image_get_combination_mode
argument_list|(
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|src2PR
operator|->
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: illegal parameters."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|push_undo
condition|)
name|gimp_drawable_push_undo
argument_list|(
name|drawable
argument_list|,
name|undo_desc
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
if|if
condition|(
name|src1_tiles
condition|)
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src1_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|gint
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
operator|*
literal|255.999
argument_list|,
name|mode
argument_list|,
name|active_components
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opacity
operator|*
literal|255.999
argument_list|,
name|mode
argument_list|,
name|active_components
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to gimp_image_apply_image but works in "replace" mode (i.e.    transparent pixels in src2 make the result transparent rather    than opaque.     Takes an additional mask pixel region as well. */
end_comment

begin_function
name|void
DECL|function|gimp_image_replace_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gboolean push_undo,const gchar * undo_desc,gdouble opacity,PixelRegion * maskPR,gint x,gint y)
name|gimp_image_replace_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gdouble
name|opacity
parameter_list|,
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|;
name|CombinationMode
name|operation
decl_stmt|;
name|gboolean
name|active_components
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_channel_is_empty
argument_list|(
name|mask
argument_list|)
condition|)
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_components
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active_components
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|gimp_image_get_combination_mode
argument_list|(
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|src2PR
operator|->
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: illegal parameters."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|push_undo
condition|)
name|gimp_drawable_push_undo
argument_list|(
name|drawable
argument_list|,
name|undo_desc
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|PixelRegion
name|mask2PR
decl_stmt|,
name|tempPR
decl_stmt|;
name|guchar
modifier|*
name|temp_data
decl_stmt|;
name|gint
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mask2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|rowstride
operator|=
name|tempPR
operator|.
name|w
operator|*
name|tempPR
operator|.
name|bytes
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
operator|=
name|g_malloc
argument_list|(
name|tempPR
operator|.
name|h
operator|*
name|tempPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|mask2PR
argument_list|,
operator|&
name|tempPR
argument_list|)
expr_stmt|;
comment|/* apparently, region operations can mutate some PR data. */
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|apply_mask_to_region
argument_list|(
operator|&
name|tempPR
argument_list|,
name|maskPR
argument_list|,
name|OPAQUE_OPACITY
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|tempPR
argument_list|,
name|NULL
argument_list|,
name|opacity
operator|*
literal|255.999
argument_list|,
name|active_components
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
operator|*
literal|255.999
argument_list|,
name|active_components
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  parasites  */
end_comment

begin_function
name|GimpParasite
modifier|*
DECL|function|gimp_image_parasite_find (const GimpImage * gimage,const gchar * name)
name|gimp_image_parasite_find
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimp_parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|list_func (gchar * key,GimpParasite * p,gchar *** cur)
name|list_func
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|GimpParasite
modifier|*
name|p
parameter_list|,
name|gchar
modifier|*
modifier|*
modifier|*
name|cur
parameter_list|)
block|{
operator|*
operator|(
operator|*
name|cur
operator|)
operator|++
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gchar
modifier|*
modifier|*
DECL|function|gimp_image_parasite_list (const GimpImage * gimage,gint * count)
name|gimp_image_parasite_list
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
modifier|*
name|count
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|list
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|cur
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|gimp_parasite_list_length
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|cur
operator|=
name|list
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
name|gimp_parasite_list_foreach
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
operator|(
name|GHFunc
operator|)
name|list_func
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_attach (GimpImage * gimage,GimpParasite * parasite)
name|gimp_image_parasite_attach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
operator|&&
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* only set the dirty bit manually if we can be saved and the new      parasite differs from the current one and we aren't undoable */
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|parasite
argument_list|)
condition|)
name|gimp_image_undo_push_image_parasite
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Attach Paraite to Image"
argument_list|)
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
comment|/*  We used to push an cantundo on te stack here. This made the undo stack       unusable (NULL on the stack) and prevented people from undoing after a       save (since most save plug-ins attach an undoable comment parasite).       Now we simply attach the parasite without pushing an undo. That way it's       undoable but does not block the undo system.   --Sven    */
name|gimp_parasite_list_add
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_parasite_has_flag
argument_list|(
name|parasite
argument_list|,
name|GIMP_PARASITE_ATTACH_PARENT
argument_list|)
condition|)
block|{
name|gimp_parasite_shift_parent
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_attach
argument_list|(
name|gimage
operator|->
name|gimp
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_detach (GimpImage * gimage,const gchar * parasite)
name|gimp_image_parasite_detach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|parasite
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|p
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|gimp_parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|p
argument_list|)
condition|)
name|gimp_image_undo_push_image_parasite_remove
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Remove Parasite from Image"
argument_list|)
argument_list|,
name|gimp_parasite_name
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_list_remove
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  tattoos  */
end_comment

begin_function
name|GimpTattoo
DECL|function|gimp_image_get_new_tattoo (GimpImage * gimage)
name|gimp_image_get_new_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|tattoo_state
operator|++
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|tattoo_state
operator|<=
literal|0
condition|)
name|g_warning
argument_list|(
literal|"%s: Tattoo state corrupted "
literal|"(integer overflow)."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|tattoo_state
return|;
block|}
end_function

begin_function
name|GimpTattoo
DECL|function|gimp_image_get_tattoo_state (GimpImage * gimage)
name|gimp_image_get_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|tattoo_state
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_set_tattoo_state (GimpImage * gimage,GimpTattoo val)
name|gimp_image_set_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpTattoo
name|val
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|gboolean
name|retval
init|=
name|TRUE
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GimpTattoo
name|maxval
init|=
literal|0
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Check that the layer tatoos don't overlap with channel or vector ones */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|ltattoo
decl_stmt|;
name|ltattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ltattoo
expr_stmt|;
if|if
condition|(
name|gimp_image_get_channel_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ltattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in channel */
if|if
condition|(
name|gimp_image_get_vectors_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ltattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in vectors */
block|}
comment|/* Now check that the channel and vectors tattoos don't overlap */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|ctattoo
decl_stmt|;
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|ctattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ctattoo
expr_stmt|;
if|if
condition|(
name|gimp_image_get_vectors_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ctattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in vectors */
block|}
comment|/* Find the max tatto value in the vectors */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|vtattoo
decl_stmt|;
name|vtattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|vtattoo
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|maxval
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Must check if the state is valid */
if|if
condition|(
name|retval
operator|==
name|TRUE
condition|)
name|gimage
operator|->
name|tattoo_state
operator|=
name|val
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  layers / channels / vectors  */
end_comment

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_layers (const GimpImage * gimage)
name|gimp_image_get_layers
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|layers
return|;
block|}
end_function

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_channels (const GimpImage * gimage)
name|gimp_image_get_channels
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|channels
return|;
block|}
end_function

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_vectors (const GimpImage * gimage)
name|gimp_image_get_vectors
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|vectors
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_image_active_drawable (const GimpImage * gimage)
name|gimp_image_active_drawable
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|gimage
operator|->
name|active_channel
condition|)
block|{
return|return
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_channel
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|mask
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_active_layer (const GimpImage * gimage)
name|gimp_image_get_active_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_active_channel (const GimpImage * gimage)
name|gimp_image_get_active_channel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_active_vectors (const GimpImage * gimage)
name|gimp_image_get_active_vectors
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|active_vectors
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_set_active_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_set_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  First, find the layer in the gimage    *  If it isn't valid, find the first layer that is    */
if|if
condition|(
operator|!
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|!=
name|gimage
operator|->
name|active_layer
condition|)
block|{
if|if
condition|(
name|layer
condition|)
block|{
comment|/*  Configure the layer stack to reflect this change  */
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  Don't cache selection info for the previous active layer  */
name|gimp_drawable_invalidate_boundary
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_channel
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  return the layer  */
return|return
name|layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_set_active_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_set_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*  First, find the channel    *  If it doesn't exist, find the first channel that does    */
if|if
condition|(
operator|!
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|!=
name|gimage
operator|->
name|active_channel
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_layer
condition|)
block|{
comment|/*  Don't cache selection info for the previous active layer  */
name|gimp_drawable_invalidate_boundary
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  return the channel  */
return|return
name|channel
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_unset_active_channel (GimpImage * gimage)
name|gimp_image_unset_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|layer_stack
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimage
operator|->
name|layer_stack
operator|->
name|data
expr_stmt|;
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|channel
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_set_active_vectors (GimpImage * gimage,GimpVectors * vectors)
name|gimp_image_set_active_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  First, find the vectors    *  If it doesn't exist, find the first vectors that does    */
if|if
condition|(
operator|!
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
condition|)
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
operator|!=
name|gimage
operator|->
name|active_vectors
condition|)
block|{
name|gimage
operator|->
name|active_vectors
operator|=
name|vectors
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|vectors
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_layer_changed (GimpImage * gimage)
name|gimp_image_active_layer_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_channel_changed (GimpImage * gimage)
name|gimp_image_active_channel_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_vectors_changed (GimpImage * gimage)
name|gimp_image_active_vectors_changed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_layer_index (const GimpImage * gimage,const GimpLayer * layer)
name|gimp_image_get_layer_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_channel_index (const GimpImage * gimage,const GimpChannel * channel)
name|gimp_image_get_channel_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_vectors_index (const GimpImage * gimage,const GimpVectors * vectors)
name|gimp_image_get_vectors_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_layer_by_tattoo (const GimpImage * gimage,GimpTattoo tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|layer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_tattoo (const GimpImage * gimage,GimpTattoo tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|channel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_vectors_by_tattoo (const GimpImage * gimage,GimpTattoo tattoo)
name|gimp_image_get_vectors_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|vectors
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_layer_by_name (const GimpImage * gimage,const gchar * name)
name|gimp_image_get_layer_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_name (const GimpImage * gimage,const gchar * name)
name|gimp_image_get_channel_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_vectors_by_name (const GimpImage * gimage,const gchar * name)
name|gimp_image_get_vectors_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_layer (GimpImage * gimage,GimpLayer * layer,gint position)
name|gimp_image_add_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|gboolean
name|alpha_changed
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add layer to wrong image."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add layer to image twice."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_image_undo_push_layer_add
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Add Layer"
argument_list|)
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|gimage
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
comment|/*  let the layer know about the gimage  */
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer has a mask, set the mask's gimage  */
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
name|GimpLayer
modifier|*
name|active_layer
decl_stmt|;
name|active_layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_layer
condition|)
block|{
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|position
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  If there is a floating selection (and this isn't it!),    *  make sure the insert position is greater than 0    */
if|if
condition|(
name|position
operator|==
literal|0
operator|&&
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|&&
operator|(
name|gimage
operator|->
name|floating_sel
operator|!=
name|layer
operator|)
condition|)
block|{
name|position
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
operator|->
name|data
argument_list|)
condition|)
block|{
name|alpha_changed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_changed
condition|)
name|gimp_image_alpha_changed
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_remove_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_layer_remove
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Remove Layer"
argument_list|)
argument_list|,
name|layer
argument_list|,
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Make sure we're not caching any old selection info  */
name|gimp_drawable_invalidate_boundary
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  If this was the floating selection, reset the fs pointer  */
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_reset
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|layer_stack
condition|)
block|{
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|layer_stack
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Send out REMOVED signal from layer */
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
operator|->
name|data
argument_list|)
condition|)
block|{
name|gimp_image_alpha_changed
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_raise_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is this the top layer already? */
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|curpos
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Layer"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_lower_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is this the bottom layer already? */
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|>=
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|curpos
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Layer"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer_to_top (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on top."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot raise a layer without alpha."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Layer to Top"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer_to_bottom (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|>=
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on the bottom."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Layer to Bottom"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_layer (GimpImage * gimage,GimpLayer * layer,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_layers
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_layers
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|<
literal|0
condition|)
name|new_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_index
operator|>=
name|num_layers
condition|)
name|new_index
operator|=
name|num_layers
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
comment|/* check if we want to move it below a bottom layer without alpha */
if|if
condition|(
name|new_index
operator|==
name|num_layers
operator|-
literal|1
condition|)
block|{
name|GimpLayer
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|num_layers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|num_layers
operator|-
literal|1
operator|&&
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer \"%s\" has no alpha.\nLayer was placed above it."
argument_list|)
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|tmp
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|new_index
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_layer_reposition
argument_list|(
name|gimage
argument_list|,
name|undo_desc
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_channel (GimpImage * gimage,GimpChannel * channel,gint position)
name|gimp_image_add_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add channel to wrong image."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add channel to image twice."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_image_undo_push_channel_add
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Add Channel"
argument_list|)
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
name|GimpChannel
modifier|*
name|active_channel
decl_stmt|;
name|active_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_channel
condition|)
block|{
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|position
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active channel  */
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_remove_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_channel_remove
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Remove Channel"
argument_list|)
argument_list|,
name|channel
argument_list|,
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out REMOVED signal from channel */
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|>
literal|0
condition|)
block|{
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
block|}
name|g_object_unref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_raise_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|index
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Channel"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_lower_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Channel"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_channel (GimpImage * gimage,GimpChannel * channel,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_channels
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_channels
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|CLAMP
argument_list|(
name|new_index
argument_list|,
literal|0
argument_list|,
name|num_channels
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_channel_reposition
argument_list|(
name|gimage
argument_list|,
name|undo_desc
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|gimage
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_vectors (GimpImage * gimage,GimpVectors * vectors,gint position)
name|gimp_image_add_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add vectors to wrong image."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add vectors to image twice."
argument_list|,
name|G_GNUC_PRETTY_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_image_undo_push_vectors_add
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Add Path"
argument_list|)
argument_list|,
name|vectors
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|active_vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vectors
condition|)
block|{
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_vectors
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|position
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active vectors  */
name|gimp_image_set_active_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_vectors (GimpImage * gimage,GimpVectors * vectors)
name|gimp_image_remove_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_vectors_remove
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"Remove Path"
argument_list|)
argument_list|,
name|vectors
argument_list|,
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|,
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Send out REMOVED signal from vectors */
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
name|gimp_image_get_active_vectors
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|>
literal|0
condition|)
block|{
name|gimp_image_set_active_vectors
argument_list|(
name|gimage
argument_list|,
name|GIMP_VECTORS
argument_list|(
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|active_vectors
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|gimage
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|g_object_unref
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_vectors (GimpImage * gimage,GimpVectors * vectors)
name|gimp_image_raise_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|,
name|index
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Path"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_vectors (GimpImage * gimage,GimpVectors * vectors)
name|gimp_image_lower_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|gimage
argument_list|,
name|vectors
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Path"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_vectors (GimpImage * gimage,GimpVectors * vectors,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_vectors
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_vectors
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_vectors
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|CLAMP
argument_list|(
name|new_index
argument_list|,
literal|0
argument_list|,
name|num_vectors
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_vectors_reposition
argument_list|(
name|gimage
argument_list|,
name|undo_desc
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|gimage
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_layer_boundary (const GimpImage * gimage,BoundSeg ** segs,gint * n_segs)
name|gimp_image_layer_boundary
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|gint
modifier|*
name|n_segs
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
operator|*
name|segs
operator|=
name|gimp_layer_boundary
argument_list|(
name|layer
argument_list|,
name|n_segs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|n_segs
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_pick_correlate_layer (const GimpImage * gimage,gint x,gint y)
name|gimp_image_pick_correlate_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_layer_pick_correlate
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|layer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_layer_previews (GimpImage * gimage)
name|gimp_image_invalidate_layer_previews
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_channel_previews (GimpImage * gimage)
name|gimp_image_invalidate_channel_previews
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

