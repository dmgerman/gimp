begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gimpimageP.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/parasite.h"
end_include

begin_include
include|#
directive|include
file|"parasitelist.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpsignal.h"
end_include

begin_include
include|#
directive|include
file|"gimpparasite.h"
end_include

begin_include
include|#
directive|include
file|"pathsP.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_include
include|#
directive|include
file|"drawable_pvt.h"
end_include

begin_comment
comment|/* ick ick. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Local function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_free_layers
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_free_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|gint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  projection functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Channel
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Global variables  */
end_comment

begin_decl_stmt
DECL|variable|valid_combinations
name|int
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* RGB GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* RGBA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GRAY GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GRAYA GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXED GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXEDA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|next_guide_id
name|guint32
name|next_guide_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|next_guide_id
comment|/* For generating guide_ID handles for PDB stuff */
end_comment

begin_comment
comment|/*  *  Static variables  */
end_comment

begin_enum
DECL|enum|__anon2b2e5e2c0103
enum|enum
block|{
DECL|enumerator|CLEAN
name|CLEAN
block|,
DECL|enumerator|DIRTY
name|DIRTY
block|,
DECL|enumerator|REPAINT
name|REPAINT
block|,
DECL|enumerator|RENAME
name|RENAME
block|,
DECL|enumerator|RESIZE
name|RESIZE
block|,
DECL|enumerator|RESTRUCTURE
name|RESTRUCTURE
block|,
DECL|enumerator|COLORMAP_CHANGED
name|COLORMAP_CHANGED
block|,
DECL|enumerator|UNDO_EVENT
name|UNDO_EVENT
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|gimp_image_signals
specifier|static
name|guint
name|gimp_image_signals
index|[
name|LAST_SIGNAL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|parent_class
specifier|static
name|GimpObjectClass
modifier|*
name|parent_class
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|gimp_image_class_init (GimpImageClass * klass)
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
block|{
name|GtkObjectClass
modifier|*
name|object_class
decl_stmt|;
name|GtkType
name|type
decl_stmt|;
name|object_class
operator|=
name|GTK_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|parent_class
operator|=
name|gtk_type_class
argument_list|(
name|gimp_object_get_type
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|=
name|object_class
operator|->
name|type
expr_stmt|;
name|object_class
operator|->
name|destroy
operator|=
name|gimp_image_destroy
expr_stmt|;
name|gimp_image_signals
index|[
name|CLEAN
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"clean"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|DIRTY
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"dirty"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|REPAINT
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"repaint"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_int_int_int_int
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RENAME
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"rename"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESIZE
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"resize"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"restructure"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"colormap_changed"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_int
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"undo_event"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_int
argument_list|)
expr_stmt|;
name|gtk_object_class_add_signals
argument_list|(
name|object_class
argument_list|,
name|gimp_image_signals
argument_list|,
name|LAST_SIGNAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static functions */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_init (GimpImage * gimage)
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|has_filename
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
comment|/* ID and ref_count handled in gimage.c */
name|gimage
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
operator|-
literal|1
expr_stmt|;
name|gimage
operator|->
name|tattoo_state
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_bytes
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|undo_levels
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|group_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|pushing_undo_group
operator|=
name|UNDO_NULL
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|parasites
operator|=
name|parasite_list_new
argument_list|()
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|default_xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|default_yresolution
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|default_units
expr_stmt|;
name|gimage
operator|->
name|save_proc
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|paths
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|GtkType
DECL|function|gimp_image_get_type (void)
name|gimp_image_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GtkType
name|type
decl_stmt|;
name|GIMP_TYPE_INIT
argument_list|(
name|type
argument_list|,
name|GimpImage
argument_list|,
name|GimpImageClass
argument_list|,
name|gimp_image_init
argument_list|,
name|gimp_image_class_init
argument_list|,
name|GIMP_TYPE_OBJECT
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_projection (GimpImage * gimage)
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Find the number of bytes required for the projection.    *  This includes the intensity channels and an alpha channel    *  if one doesn't exist.    */
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|4
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|2
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|GRAYA_GIMAGE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|projection
operator|=
name|tile_manager_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|gimage
operator|->
name|proj_bytes
argument_list|)
expr_stmt|;
name|tile_manager_set_user_data
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
name|gimp_image_validate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_projection (GimpImage * gimage)
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_shadow (GimpImage * gimage,gint width,gint height,gint bpp)
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function definitions */
end_comment

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_new (gint width,gint height,GimpImageBaseType base_type)
name|gimp_image_new
parameter_list|(
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImageBaseType
name|base_type
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|gtk_type_new
argument_list|(
name|gimp_image_get_type
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|GRAY
case|:
break|break;
case|case
name|INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc0
argument_list|(
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  configure the active pointers  */
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/* no default active channel */
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
comment|/*  set all color channels visible and active  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|visible
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|active
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* create the selection mask */
name|gimage
operator|->
name|selection_mask
operator|=
name|channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* set the qmask properties */
name|gimage
operator|->
name|qmask_state
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|qmask_opacity
operator|=
literal|50
expr_stmt|;
name|gimage
operator|->
name|qmask_color
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
name|gimage
operator|->
name|qmask_color
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_filename (GimpImage * gimage,gchar * filename)
name|gimp_image_set_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|gchar
modifier|*
name|new_filename
decl_stmt|,
modifier|*
name|old_filename
decl_stmt|;
name|gboolean
name|free_old
decl_stmt|;
comment|/*     * WARNING: this function will free the current filename even if you are     * setting it to itself so any pointer you hold to the filename will be    * invalid after this call.  So please use with care.    */
name|new_filename
operator|=
name|g_strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|old_filename
operator|=
name|gimage
operator|->
name|filename
expr_stmt|;
name|free_old
operator|=
name|gimage
operator|->
name|has_filename
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|gimage
operator|->
name|filename
operator|=
name|new_filename
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|free_old
condition|)
name|g_free
argument_list|(
name|old_filename
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RENAME
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_resolution (GimpImage * gimage,gdouble xresolution,gdouble yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
name|xresolution
parameter_list|,
name|gdouble
name|yresolution
parameter_list|)
block|{
comment|/* nothing to do if setting res to the same as before */
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|xresolution
operator|-
name|xresolution
argument_list|)
operator|<
literal|1e-5
operator|)
operator|&&
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|yresolution
operator|-
name|yresolution
argument_list|)
operator|<
literal|1e-5
operator|)
condition|)
return|return;
name|undo_push_resolution
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|yresolution
expr_stmt|;
comment|/* really just want to recalc size and repaint */
name|gdisplays_shrink_wrap
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_resolution (GimpImage * gimage,gdouble * xresolution,gdouble * yresolution)
name|gimp_image_get_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
modifier|*
name|xresolution
parameter_list|,
name|gdouble
modifier|*
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|xresolution
operator|&&
name|yresolution
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
operator|*
name|yresolution
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_unit (GimpImage * gimage,GUnit unit)
name|gimp_image_set_unit
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GUnit
name|unit
parameter_list|)
block|{
name|undo_push_resolution
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
block|}
end_function

begin_function
name|GUnit
DECL|function|gimp_image_get_unit (GimpImage * gimage)
name|gimp_image_get_unit
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|unit
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_save_proc (GimpImage * gimage,PlugInProcDef * proc)
name|gimp_image_set_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PlugInProcDef
modifier|*
name|proc
parameter_list|)
block|{
name|gimage
operator|->
name|save_proc
operator|=
name|proc
expr_stmt|;
block|}
end_function

begin_function
name|PlugInProcDef
modifier|*
DECL|function|gimp_image_get_save_proc (GimpImage * gimage)
name|gimp_image_get_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|save_proc
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_resize (GimpImage * gimage,gint new_width,gint new_height,gint offset_x,gint offset_y)
name|gimp_image_resize
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|guide_list
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|g_assert
argument_list|(
name|new_width
operator|>
literal|0
operator|&&
name|new_height
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|IMAGE_RESIZE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Resize all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_resize
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Reposition or remove any guides  */
name|guide_list
operator|=
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|guide_list
condition|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
operator|(
name|Guide
operator|*
operator|)
name|guide_list
operator|->
name|data
expr_stmt|;
name|guide_list
operator|=
name|g_list_next
argument_list|(
name|guide_list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|+=
name|offset_y
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
operator|||
name|guide
operator|->
name|position
operator|>
name|new_height
condition|)
name|gimp_image_delete_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|+=
name|offset_x
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
operator|||
name|guide
operator|->
name|position
operator|>
name|new_width
condition|)
name|gimp_image_delete_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"Unknown guide orientation I.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_resize
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Reposition all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_width (const GimpImage * gimage)
name|gimp_image_get_width
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|width
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_height (const GimpImage * gimage)
name|gimp_image_get_height
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|height
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_scale (GimpImage * gimage,gint new_width,gint new_height)
name|gimp_image_scale
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|glist
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint
name|old_width
decl_stmt|,
name|old_height
decl_stmt|;
name|gint
name|layer_width
decl_stmt|,
name|layer_height
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|IMAGE_SCALE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|old_width
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|old_height
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Scale all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_scale
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_scale
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Scale all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_width
operator|=
operator|(
name|new_width
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_width
expr_stmt|;
name|layer_height
operator|=
operator|(
name|new_height
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_height
expr_stmt|;
name|layer_scale
argument_list|(
name|layer
argument_list|,
name|layer_width
argument_list|,
name|layer_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Scale any Guides  */
name|glist
operator|=
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|glist
condition|)
block|{
name|guide
operator|=
operator|(
name|Guide
operator|*
operator|)
name|glist
operator|->
name|data
expr_stmt|;
name|glist
operator|=
name|g_list_next
argument_list|(
name|glist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|(
name|guide
operator|->
name|position
operator|*
name|new_height
operator|)
operator|/
name|old_height
expr_stmt|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|(
name|guide
operator|->
name|position
operator|*
name|new_width
operator|)
operator|/
name|old_width
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"Unknown guide orientation II.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_shadow (GimpImage * gimage,gint width,gint height,gint bpp)
name|gimp_image_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|shadow
operator|&&
operator|(
operator|(
name|width
operator|!=
name|tile_manager_level_width
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|!=
name|tile_manager_level_height
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tile_manager_level_bpp
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|)
condition|)
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
return|return
name|gimage
operator|->
name|shadow
return|;
name|gimp_image_allocate_shadow
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_free_shadow (GimpImage * gimage)
name|gimp_image_free_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free the shadow buffer from the specified gimage if it exists  */
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_destroy (GtkObject * object)
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gimp_image_free_layers
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_free_channels
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|channel_delete
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|parasites
condition|)
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_apply_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gint undo,gint opacity,LayerModeEffects mode,TileManager * src1_tiles,gint x,gint y)
name|gimp_image_apply_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gint
name|undo
parameter_list|,
name|gint
name|opacity
parameter_list|,
name|LayerModeEffects
name|mode
parameter_list|,
comment|/*  alternative to using drawable tiles as src1: */
name|TileManager
modifier|*
name|src1_tiles
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_apply_image sent illegal parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|undo_push_image
argument_list|(
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
if|if
condition|(
name|src1_tiles
condition|)
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src1_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to gimp_image_apply_image but works in "replace" mode (i.e.    transparent pixels in src2 make the result transparent rather    than opaque.     Takes an additional mask pixel region as well. */
end_comment

begin_function
name|void
DECL|function|gimp_image_replace_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gint undo,gint opacity,PixelRegion * maskPR,gint x,gint y)
name|gimp_image_replace_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gint
name|undo
parameter_list|,
name|gint
name|opacity
parameter_list|,
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|;
name|PixelRegion
name|mask2PR
decl_stmt|,
name|tempPR
decl_stmt|;
name|guchar
modifier|*
name|temp_data
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_apply_image sent illegal parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|drawable_apply_image
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mask2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|rowstride
operator|=
name|mask2PR
operator|.
name|rowstride
expr_stmt|;
name|temp_data
operator|=
name|g_malloc
argument_list|(
name|tempPR
operator|.
name|h
operator|*
name|tempPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|mask2PR
argument_list|,
operator|&
name|tempPR
argument_list|)
expr_stmt|;
comment|/* apparently, region operations can mutate some PR data. */
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|apply_mask_to_region
argument_list|(
operator|&
name|tempPR
argument_list|,
name|maskPR
argument_list|,
name|OPAQUE_OPACITY
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|tempPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_data
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get rid of these! A "foreground" is an UI concept.. */
end_comment

begin_function
name|void
DECL|function|gimp_image_get_foreground (GimpImage * gimage,GimpDrawable * drawable,guchar * fg)
name|gimp_image_get_foreground
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|fg
parameter_list|)
block|{
name|guchar
name|pfg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|gimp_context_get_foreground
argument_list|(
name|NULL
argument_list|,
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pfg
argument_list|,
name|fg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_background (GimpImage * gimage,GimpDrawable * drawable,guchar * bg)
name|gimp_image_get_background
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|guchar
name|pbg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|gimp_context_get_background
argument_list|(
name|NULL
argument_list|,
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pbg
argument_list|,
name|bg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|guchar
modifier|*
DECL|function|gimp_image_get_color_at (GimpImage * gimage,gint x,gint y)
name|gimp_image_get_color_at
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|y
operator|<
literal|0
operator|||
name|x
operator|>=
name|gimage
operator|->
name|width
operator|||
name|y
operator|>=
name|gimage
operator|->
name|height
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|dest
operator|=
name|g_new
argument_list|(
argument|unsigned char
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|gimp_image_composite
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|src
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|gimp_image_get_color
argument_list|(
name|gimage
argument_list|,
name|gimp_image_composite_type
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ALPHA
argument_list|(
name|gimp_image_composite_type
argument_list|(
name|gimage
argument_list|)
argument_list|)
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src
index|[
name|gimp_image_composite_bytes
argument_list|(
name|gimage
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dest
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
name|dest
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_color (GimpImage * gimage,GimpImageType d_type,guchar * rgb,guchar * src)
name|gimp_image_get_color
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpImageType
name|d_type
parameter_list|,
name|guchar
modifier|*
name|rgb
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|)
block|{
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|2
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_color (GimpImage * gimage,GimpDrawable * drawable,guchar * src,guchar * dest,GimpImageBaseType type)
name|gimp_image_transform_color
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|GimpImageBaseType
name|type
parameter_list|)
block|{
DECL|macro|INTENSITY (r,g,b)
define|#
directive|define
name|INTENSITY
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|(r * 0.30 + g * 0.59 + b * 0.11 + 0.001)
name|GimpImageType
name|d_type
decl_stmt|;
name|d_type
operator|=
operator|(
name|drawable
operator|!=
name|NULL
operator|)
condition|?
name|drawable_type
argument_list|(
name|drawable
argument_list|)
else|:
name|gimp_image_base_type_with_alpha
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RGB
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|INTENSITY
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GRAY
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_hguide (GimpImage * gimage)
name|gimp_image_add_hguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|ORIENTATION_HORIZONTAL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_vguide (GimpImage * gimage)
name|gimp_image_add_vguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|ORIENTATION_VERTICAL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_add_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_add_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_remove_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_delete_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_delete_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|ref_count
operator|<=
literal|0
condition|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|guide
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Parasite
modifier|*
DECL|function|gimp_image_parasite_find (const GimpImage * gimage,const gchar * name)
name|gimp_image_parasite_find
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
return|return
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|list_func (gchar * key,Parasite * p,gchar *** cur)
name|list_func
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|Parasite
modifier|*
name|p
parameter_list|,
name|gchar
modifier|*
modifier|*
modifier|*
name|cur
parameter_list|)
block|{
operator|*
operator|(
operator|*
name|cur
operator|)
operator|++
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gchar
modifier|*
modifier|*
DECL|function|gimp_image_parasite_list (GimpImage * image,gint * count)
name|gimp_image_parasite_list
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
modifier|*
name|count
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|cur
decl_stmt|;
operator|*
name|count
operator|=
name|parasite_list_length
argument_list|(
name|image
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|cur
operator|=
name|list
operator|=
operator|(
name|gchar
operator|*
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gchar
operator|*
argument_list|)
operator|*
operator|*
name|count
argument_list|)
expr_stmt|;
name|parasite_list_foreach
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
operator|(
name|GHFunc
operator|)
name|list_func
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_attach (GimpImage * gimage,Parasite * parasite)
name|gimp_image_parasite_attach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Parasite
modifier|*
name|parasite
parameter_list|)
block|{
comment|/* only set the dirty bit manually if we can be saved and the new      parasite differs from the current one and we aren't undoable */
if|if
condition|(
name|parasite_is_undoable
argument_list|(
name|parasite
argument_list|)
condition|)
name|undo_push_image_parasite
argument_list|(
name|gimage
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_is_persistent
argument_list|(
name|parasite
argument_list|)
operator|&&
operator|!
name|parasite_compare
argument_list|(
name|parasite
argument_list|,
name|gimp_image_parasite_find
argument_list|(
name|gimage
argument_list|,
name|parasite_name
argument_list|(
name|parasite
argument_list|)
argument_list|)
argument_list|)
condition|)
name|undo_push_cantundo
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"attach parasite to image"
argument_list|)
argument_list|)
expr_stmt|;
name|parasite_list_add
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_has_flag
argument_list|(
name|parasite
argument_list|,
name|PARASITE_ATTACH_PARENT
argument_list|)
condition|)
block|{
name|parasite_shift_parent
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_attach
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_detach (GimpImage * gimage,const gchar * parasite)
name|gimp_image_parasite_detach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|parasite
parameter_list|)
block|{
name|Parasite
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|parasite_is_undoable
argument_list|(
name|p
argument_list|)
condition|)
name|undo_push_image_parasite_remove
argument_list|(
name|gimage
argument_list|,
name|parasite_name
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parasite_is_persistent
argument_list|(
name|p
argument_list|)
condition|)
name|undo_push_cantundo
argument_list|(
name|gimage
argument_list|,
name|_
argument_list|(
literal|"detach parasite from image"
argument_list|)
argument_list|)
expr_stmt|;
name|parasite_list_remove
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Tattoo
DECL|function|gimp_image_get_new_tattoo (GimpImage * image)
name|gimp_image_get_new_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|image
operator|->
name|tattoo_state
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|tattoo_state
operator|<=
literal|0
condition|)
name|g_warning
argument_list|(
literal|"Tattoo state has become corrupt (2.1 billion operation limit exceded)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|image
operator|->
name|tattoo_state
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_colormap_changed (GimpImage * image,gint col)
name|gimp_image_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|col
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|col
operator|<
name|image
operator|->
name|num_cols
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_paths (GimpImage * gimage,PathsList * paths)
name|gimp_image_set_paths
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PathsList
modifier|*
name|paths
parameter_list|)
block|{
name|gimage
operator|->
name|paths
operator|=
name|paths
expr_stmt|;
block|}
end_function

begin_function
name|PathsList
modifier|*
DECL|function|gimp_image_get_paths (GimpImage * gimage)
name|gimp_image_get_paths
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|paths
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection functions                                    */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|project_intensity (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_intensity_alpha (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest)
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED
argument_list|)
expr_stmt|;
else|else
name|g_message
argument_list|(
literal|"Unable to project indexed image."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed_alpha (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_indexed_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INDEXED_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_channel (GimpImage * gimage,Channel * channel,PixelRegion * src,PixelRegion * src2)
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|)
block|{
name|gint
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|INITIAL_CHANNEL_MASK
else|:
name|INITIAL_CHANNEL_SELECTION
expr_stmt|;
name|initial_region
argument_list|(
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL_MODE
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|COMBINE_INTEN_A_CHANNEL_MASK
else|:
name|COMBINE_INTEN_A_CHANNEL_SELECTION
expr_stmt|;
name|combine_regions
argument_list|(
name|src
argument_list|,
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL_MODE
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Layer/Channel functions                                 */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_layers (GimpImage * gimage)
name|gimp_image_free_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_delete
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_channels (GimpImage * gimage)
name|gimp_image_free_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_delete
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_layers (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  composite the floating selection if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_composite
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
comment|/*      g_warning("g_i_c_l on layerless image."); */
block|}
comment|/* Note added by Raph Levien, 27 Jan 1998       This looks it was intended as an optimization, but it seems to      have correctness problems. In particular, if all channels are      turned off, the screen simply does not update the projected      image. It should be black. Turning off this optimization seems to      restore correct behavior. At some future point, it may be      desirable to turn the optimization back on.       */
if|#
directive|if
literal|0
comment|/*  If all channels are not visible, simply return  */
block|switch (gimp_image_base_type (gimage))     {     case RGB:       if (! gimp_image_get_component_visible (gimage, RED_CHANNEL)&& 	  ! gimp_image_get_component_visible (gimage, GREEN_CHANNEL)&& 	  ! gimp_image_get_component_visible (gimage, BLUE_CHANNEL)) 	return;       break;     case GRAY:       if (! gimp_image_get_component_visible (gimage, GRAY_CHANNEL)) 	return;       break;     case INDEXED:       if (! gimp_image_get_component_visible (gimage, INDEXED_CHANNEL)) 	return;       break;     }
endif|#
directive|endif
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections to the list  */
if|if
condition|(
operator|!
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  If we're showing the layer mask instead of the layer...  */
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|show_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|copy_gray_to_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
block|}
comment|/*  Otherwise, normal  */
else|else
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the 	   *  projection image... 	   */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
comment|/* no mask possible */
name|project_intensity
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|project_intensity_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
comment|/* no mask possible */
name|project_indexed
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXEDA_GIMAGE
case|:
name|project_indexed_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
comment|/*  something was projected  */
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_channels (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
comment|/*      g_warning("g_i_c_c on channelless image."); */
block|}
comment|/*  reverse the channel list  */
while|while
condition|(
name|list
condition|)
block|{
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|project_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
block|}
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_initialize_projection (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|gint
name|coverage
init|=
literal|0
decl_stmt|;
name|PixelRegion
name|PR
decl_stmt|;
name|guchar
name|clear
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*  this function determines whether a visible layer    *  provides complete coverage over the image.  If not,    *  the projection is initialized to transparent    */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
operator|(
name|off_x
operator|<=
name|x
operator|)
operator|&&
operator|(
name|off_y
operator|<=
name|y
operator|)
operator|&&
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|x
operator|+
name|w
operator|)
operator|&&
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|y
operator|+
name|h
operator|)
condition|)
block|{
name|coverage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coverage
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|PR
argument_list|,
name|clear
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_get_active_channels (GimpImage * gimage,GimpDrawable * drawable,gint * active)
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
modifier|*
name|active
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*  first, blindly copy the gimage active channels  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|active
index|[
name|i
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|i
index|]
expr_stmt|;
comment|/*  If the drawable is a channel (a saved selection, etc.)    *  make sure that the alpha channel is not valid    */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|active
index|[
name|ALPHA_G_PIX
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  no alpha values in channels  */
else|else
block|{
comment|/*  otherwise, check whether preserve transparency is        *  enabled in the layer and if the layer has alpha        */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|layer
operator|=
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer
operator|->
name|preserve_trans
condition|)
name|active
index|[
name|drawable_bytes
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_construct (GimpImage * gimage,gint x,gint y,gint w,gint h,gboolean can_use_cowproject)
name|gimp_image_construct
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|,
name|gboolean
name|can_use_cowproject
parameter_list|)
block|{
if|#
directive|if
literal|0
block|gint xoff, yoff;
comment|/*  set the construct flag, used to determine if anything    *  has been written to the gimage raw image yet.    */
block|gimage->construct_flag = 0;    if (gimage->layers)     {       gimp_drawable_offsets (GIMP_DRAWABLE((Layer*)(gimage->layers->data)),&xoff,&yoff);     }    if (
comment|/*can_use_cowproject&&*/
block|(gimage->layers)&&
comment|/* There's a layer.      */
block|(!g_slist_next(gimage->layers))&&
comment|/* It's the only layer.  */
block|(layer_has_alpha((Layer*)(gimage->layers->data)))&&
comment|/* It's !flat.  */
comment|/* It's visible.         */
block|(drawable_visible (GIMP_DRAWABLE((Layer*)(gimage->layers->data))))&&       (drawable_width (GIMP_DRAWABLE((Layer*)(gimage->layers->data))) ==        gimage->width)&&       (drawable_height (GIMP_DRAWABLE((Layer*)(gimage->layers->data))) ==        gimage->height)&&
comment|/* Covers all.           */
comment|/* Not indexed.          */
block|(!drawable_indexed (GIMP_DRAWABLE((Layer*)(gimage->layers->data))))&&       (((Layer*)(gimage->layers->data))->opacity == OPAQUE_OPACITY)
comment|/*opaq */
block|)     {       int xoff, yoff;              gimp_drawable_offsets (GIMP_DRAWABLE((Layer*)(gimage->layers->data)),&xoff,&yoff);         if ((xoff==0)&& (yoff==0))
comment|/* Starts at 0,0         */
block|{ 	  PixelRegion srcPR, destPR; 	  void * pr; 	 	  g_warning("Can use cow-projection hack.  Yay!");  	  pixel_region_init (&srcPR, gimp_drawable_data 			     (GIMP_DRAWABLE 			      ((Layer*)(gimage->layers->data))), 			     x, y, w,h, FALSE); 	  pixel_region_init (&destPR, 			     gimp_image_projection (gimage), 			     x, y, w,h, TRUE);  	  for (pr = pixel_regions_register (2,&srcPR,&destPR); 	       pr != NULL; 	       pr = pixel_regions_process (pr)) 	    { 	      tile_manager_map_over_tile (destPR.tiles, 					  destPR.curtile, srcPR.curtile); 	    }  	  gimage->construct_flag = 1; 	  gimp_image_construct_channels (gimage, x, y, w, h); 	  return; 	}     }
else|#
directive|else
name|gimage
operator|->
name|construct_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*  First, determine if the projection image needs to be    *  initialized--this is the case when there are no visible    *  layers that cover the entire canvas--either because layers    *  are offset or only a floating selection is visible    */
name|gimp_image_initialize_projection
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/*  call functions which process the list of layers and    *  the list of channels    */
name|gimp_image_construct_layers
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|gimp_image_construct_channels
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_without_render (GimpImage * gimage,gint x,gint y,gint w,gint h,gint x1,gint y1,gint x2,gint y2)
name|gimp_image_invalidate_without_render
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tm
operator|=
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate (GimpImage * gimage,gint x,gint y,gint w,gint h,gint x1,gint y1,gint x2,gint y2)
name|gimp_image_invalidate
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|startx
decl_stmt|,
name|starty
decl_stmt|;
name|gint
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|gint
name|tilex
decl_stmt|,
name|tiley
decl_stmt|;
name|tm
operator|=
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|startx
operator|=
name|x
expr_stmt|;
name|starty
operator|=
name|y
expr_stmt|;
name|endx
operator|=
name|x
operator|+
name|w
expr_stmt|;
name|endy
operator|=
name|y
operator|+
name|h
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  invalidate all lower level tiles  */
comment|/*tile_manager_invalidate_tiles (gimp_image_projection (gimage), tile);*/
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|x1
condition|)
name|startx
operator|=
name|MAX
argument_list|(
name|startx
argument_list|,
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endx
operator|=
name|MIN
argument_list|(
name|endx
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|y1
condition|)
name|starty
operator|=
name|MAX
argument_list|(
name|starty
argument_list|,
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endy
operator|=
name|MIN
argument_list|(
name|endy
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tile is not valid, make sure we get the entire tile              *   in the construction extents              */
if|if
condition|(
name|tile_is_valid
argument_list|(
name|tile
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|tilex
operator|=
name|j
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
expr_stmt|;
name|tiley
operator|=
name|i
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
expr_stmt|;
name|startx
operator|=
name|MIN
argument_list|(
name|startx
argument_list|,
name|tilex
argument_list|)
expr_stmt|;
name|endx
operator|=
name|MAX
argument_list|(
name|endx
argument_list|,
name|tilex
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|starty
operator|=
name|MIN
argument_list|(
name|starty
argument_list|,
name|tiley
argument_list|)
expr_stmt|;
name|endy
operator|=
name|MAX
argument_list|(
name|endy
argument_list|,
name|tiley
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_mark_valid
argument_list|(
name|tile
argument_list|)
expr_stmt|;
comment|/* hmmmmmmm..... */
block|}
block|}
block|}
if|if
condition|(
operator|(
name|endx
operator|-
name|startx
operator|)
operator|>
literal|0
operator|&&
operator|(
name|endy
operator|-
name|starty
operator|)
operator|>
literal|0
condition|)
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
operator|(
name|endx
operator|-
name|startx
operator|)
argument_list|,
operator|(
name|endy
operator|-
name|starty
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_validate (TileManager * tm,Tile * tile)
name|gimp_image_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|w
decl_stmt|,
name|h
decl_stmt|;
name|gimp_add_busy_cursors_until_idle
argument_list|()
expr_stmt|;
comment|/*  Get the gimage from the tilemanager  */
name|gimage
operator|=
operator|(
name|GimpImage
operator|*
operator|)
name|tile_manager_get_user_data
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|/*  Find the coordinates of this tile  */
name|tile_manager_get_tile_coordinates
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|w
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|h
operator|=
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_layer_index (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_get_layer_index
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|layers
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|gint
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|layers
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layers
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|layers
operator|=
name|g_slist_next
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_channel_index (GimpImage * gimage,Channel * channel_ID)
name|gimp_image_get_channel_index
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_ID
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|gint
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_ID
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|channels
operator|=
name|g_slist_next
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_get_active_layer (GimpImage * gimage)
name|gimp_image_get_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_active_channel (GimpImage * gimage)
name|gimp_image_get_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_get_layer_by_tattoo (GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|layers
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
while|while
condition|(
name|layers
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layers
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_get_tattoo
argument_list|(
name|layer
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|layer
return|;
name|layers
operator|=
name|g_slist_next
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_channel_by_tattoo (GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel_get_tattoo
argument_list|(
name|channel
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|channel
return|;
name|channels
operator|=
name|g_slist_next
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_channel_by_name (GimpImage * gimage,char * name)
name|gimp_image_get_channel_by_name
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|channel_get_name
argument_list|(
name|channel
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|channel
return|;
name|channels
operator|=
name|g_slist_next
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_component_active (GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
break|break;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_component_visible (GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
break|break;
block|}
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_mask (GimpImage * gimage)
name|gimp_image_get_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_layer_boundary (GimpImage * gimage,BoundSeg ** segs,int * num_segs)
name|gimp_image_layer_boundary
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|num_segs
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage
operator|->
name|active_layer
operator|)
condition|)
block|{
operator|*
name|segs
operator|=
name|layer_boundary
argument_list|(
name|layer
argument_list|,
name|num_segs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_segs
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_set_active_layer (GimpImage * gimage,Layer * layer)
name|gimp_image_set_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
comment|/*  First, find the layer in the gimage    *  If it isn't valid, find the first layer that is    */
if|if
condition|(
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|layers
condition|)
return|return
name|NULL
return|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layers
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|layer
condition|)
return|return
name|NULL
return|;
comment|/*  Configure the layer stack to reflect this change  */
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
comment|/*  invalidate the selection boundary because of a layer modification  */
name|layer_invalidate_boundary
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Set the active layer  */
name|gimage
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/*  return the layer  */
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_set_active_channel (GimpImage * gimage,Channel * channel)
name|gimp_image_set_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*  First, find the channel    *  If it doesn't exist, find the first channel that does    */
if|if
condition|(
operator|!
name|channel
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|channels
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
expr_stmt|;
block|}
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
comment|/*  return the channel  */
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_unset_active_channel (GimpImage * gimage)
name|gimp_image_unset_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
comment|/*  make sure there is an active channel  */
if|if
condition|(
operator|!
operator|(
name|channel
operator|=
name|gimage
operator|->
name|active_channel
operator|)
condition|)
return|return
name|NULL
return|;
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_active (GimpImage * gimage,ChannelType type,gint value)
name|gimp_image_set_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|gint
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|AUXILLARY_CHANNEL
case|:
break|break;
block|}
comment|/*  If there is an active channel and we mess with the components,    *  the active channel gets unset...    */
if|if
condition|(
name|type
operator|!=
name|AUXILLARY_CHANNEL
condition|)
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_visible (GimpImage * gimage,ChannelType type,gint value)
name|gimp_image_set_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|gint
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_pick_correlate_layer (GimpImage * gimage,gint x,gint y)
name|gimp_image_pick_correlate_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_pick_correlate
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|layer
return|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_raise_layer (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_raise_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|gint
name|curpos
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|curpos
operator|=
name|g_slist_index
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* invalid "layer_arg" */
comment|/* is this the top layer already? */
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be raised any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer_arg
argument_list|,
name|curpos
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_lower_layer (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_lower_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|gint
name|curpos
decl_stmt|;
name|guint
name|length
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|curpos
operator|=
name|g_slist_index
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* invalid "layer_arg" */
comment|/* is this the bottom layer already? */
name|length
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be lowered any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer_arg
argument_list|,
name|curpos
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_raise_layer_to_top (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|gint
name|curpos
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|curpos
operator|=
name|g_slist_index
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on top"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|layer_has_alpha
argument_list|(
name|layer_arg
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Can't raise Layer without alpha"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer_arg
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_lower_layer_to_bottom (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|gint
name|curpos
decl_stmt|;
name|guint
name|length
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|curpos
operator|=
name|g_slist_index
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|length
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on bottom"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer_arg
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_position_layer (GimpImage * gimage,Layer * layer_arg,gint new_index,gboolean push_undo)
name|gimp_image_position_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|gint
name|x_min
decl_stmt|,
name|y_min
decl_stmt|,
name|x_max
decl_stmt|,
name|y_max
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|list_length
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|list_length
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* find layer_arg */
name|index
operator|=
name|g_slist_index
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|/* The requested layer was not found in the layerstack        * Return without changing anything        */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|new_index
operator|<
literal|0
condition|)
name|new_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_index
operator|>=
name|list_length
condition|)
name|new_index
operator|=
name|list_length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|NULL
return|;
comment|/* check if we want to move it below a bottom layer without alpha */
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|g_slist_last
argument_list|(
name|list
argument_list|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|list_length
operator|-
literal|1
operator|&&
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"BG has no alpha, layer was placed above"
argument_list|)
argument_list|)
expr_stmt|;
name|new_index
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|push_undo
condition|)
name|undo_push_layer_reposition
argument_list|(
name|gimage
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_insert
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
comment|/* update the affected area (== area of layer_arg) */
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x_min
operator|=
name|off_x
expr_stmt|;
name|y_min
operator|=
name|off_y
expr_stmt|;
name|x_max
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|y_max
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x_min
argument_list|,
name|y_min
argument_list|,
name|x_max
argument_list|,
name|y_max
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|layer_arg
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_visible_layers (GimpImage * gimage,MergeType merge_type)
name|gimp_image_merge_visible_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|gboolean
name|had_floating_sel
init|=
name|FALSE
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/* if there's a floating selection, anchor it */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|floating_sel_anchor
argument_list|(
name|gimage
operator|->
name|floating_sel
argument_list|)
expr_stmt|;
name|had_floating_sel
operator|=
name|TRUE
expr_stmt|;
block|}
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
comment|/* If there was a floating selection, we have done something. 	 No need to warn the user. Return the active layer instead */
if|if
condition|(
name|had_floating_sel
condition|)
return|return
name|layer
return|;
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge.\nThere must be at least two."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_flatten (GimpImage * gimage)
name|gimp_image_flatten
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
comment|/* if there's a floating selection, anchor it */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
name|floating_sel_anchor
argument_list|(
name|gimage
operator|->
name|floating_sel
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|FLATTEN_IMAGE
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_down (GimpImage * gimage,Layer * current_layer,MergeType merge_type)
name|gimp_image_merge_down
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|current_layer
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|current_layer
condition|)
block|{
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|merge_list
operator|=
name|g_slist_prepend
argument_list|(
name|merge_list
argument_list|,
name|current_layer
argument_list|)
expr_stmt|;
block|}
else|else
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge down."
argument_list|)
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_layers (GimpImage * gimage,GSList * merge_list,MergeType merge_type)
name|gimp_image_merge_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GSList
modifier|*
name|merge_list
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|Layer
modifier|*
name|merge_layer
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|bottom
decl_stmt|;
name|gint
name|bottom_mode
decl_stmt|;
name|guchar
name|bg
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|GimpImageType
name|type
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|position
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
name|NULL
expr_stmt|;
name|bottom_mode
operator|=
literal|0
expr_stmt|;
comment|/*  Get the layer extents  */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|merge_type
condition|)
block|{
case|case
name|EXPAND_AS_NECESSARY
case|:
case|case
name|CLIP_TO_IMAGE
case|:
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off_x
operator|<
name|x1
condition|)
name|x1
operator|=
name|off_x
expr_stmt|;
if|if
condition|(
name|off_y
operator|<
name|y1
condition|)
name|y1
operator|=
name|off_y
expr_stmt|;
if|if
condition|(
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|x2
condition|)
name|x2
operator|=
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|y2
condition|)
name|y2
operator|=
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_type
operator|==
name|CLIP_TO_IMAGE
condition|)
block|{
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLIP_TO_BOTTOM_LAYER
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLATTEN_IMAGE
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
literal|0
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|y2
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|g_slist_next
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
operator|||
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*  Start a merge undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_MERGE_UNDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_type
operator|==
name|FLATTEN_IMAGE
operator|||
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|INDEXED_GIMAGE
condition|)
block|{
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
name|type
operator|=
name|RGB_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|type
operator|=
name|GRAY_GIMAGE
expr_stmt|;
break|break;
case|case
name|INDEXED
case|:
name|type
operator|=
name|INDEXED_GIMAGE
expr_stmt|;
break|break;
block|}
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|type
argument_list|,
name|drawable_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  get the background for compositing  */
name|gimp_image_get_background
argument_list|(
name|gimage
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  init the pixel region  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to the background color  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*  The final merged layer inherits the name of the bottom most layer        *  and the resulting layer has an alpha channel        *  whether or not the original did        *  Opacity is set to 100% and the MODE is set to normal        */
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|drawable_type_with_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  Set the layer to transparent  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to 0's  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  Find the index in the layer list of the bottom layer--we need this        *  in order to add the final, merged layer to the layer list correctly        */
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|position
operator|=
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* set the mode of the bottom layer to normal so that the contents        *  aren't lost when merging with the all-alpha merge_layer        *  Keep a pointer to it so that we can set the mode right after it's been        *  merged so that undo works correctly.        */
name|bottom
operator|=
name|layer
expr_stmt|;
name|bottom_mode
operator|=
name|bottom
operator|->
name|mode
expr_stmt|;
name|bottom
operator|->
name|mode
operator|=
name|NORMAL_MODE
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and        *  if it's actually legal...        */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
index|]
index|[
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers attempting to merge incompatible layers\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x3
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y3
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x4
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y4
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|y1
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
comment|/* Save old mode in undo */
if|if
condition|(
name|bottom
condition|)
name|bottom
operator|->
name|mode
operator|=
name|bottom_mode
expr_stmt|;
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
comment|/*  if the type is flatten, remove all the remaining layers  */
if|if
condition|(
name|merge_type
operator|==
name|FLATTEN_IMAGE
condition|)
block|{
name|merge_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|merge_list
operator|=
name|g_slist_next
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Add the layer to the gimage  */
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
operator|(
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|position
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  End the merge undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Update the gimage  */
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*reinit_layer_idlerender (gimage, merge_layer);*/
return|return
name|merge_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_add_layer (GimpImage * gimage,Layer * float_layer,gint position)
name|gimp_image_add_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|float_layer
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|GSList
modifier|*
name|ll
decl_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_layer: attempt to add layer to wrong image"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|ll
operator|=
name|gimage
operator|->
name|layers
init|;
name|ll
condition|;
name|ll
operator|=
name|g_slist_next
argument_list|(
name|ll
argument_list|)
control|)
if|if
condition|(
name|ll
operator|->
name|data
operator|==
name|float_layer
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_layer: trying to add layer to image twice"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Prepare a layer undo and push it  */
name|lu
operator|=
name|g_new
argument_list|(
name|LayerUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|float_layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|LAYER_ADD_UNDO
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|float_layer
argument_list|)
condition|)
name|gimage
operator|->
name|floating_sel
operator|=
name|float_layer
expr_stmt|;
comment|/*  let the layer know about the gimage  */
name|gimp_drawable_set_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer has a mask, set the mask's gimage and layer */
if|if
condition|(
name|float_layer
operator|->
name|mask
condition|)
block|{
name|gimp_drawable_set_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
operator|->
name|mask
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
block|}
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
name|position
operator|=
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*  If there is a floating selection (and this isn't it!),        *  make sure the insert position is greater than 0        */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|&&
operator|(
name|gimage
operator|->
name|floating_sel
operator|!=
name|float_layer
operator|)
operator|&&
name|position
operator|==
literal|0
condition|)
name|position
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_insert
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_ref
argument_list|(
name|float_layer
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|layers
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_ref
argument_list|(
name|float_layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  update the new layer's area  */
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|float_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_remove_layer (GimpImage * gimage,Layer * layer)
name|gimp_image_remove_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
comment|/*  Prepare a layer undo--push it at the end  */
name|lu
operator|=
name|g_new
argument_list|(
name|LayerUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|layer
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  If this was the floating selection, reset the fs pointer  */
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_reset
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|==
name|layer
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|layers
condition|)
name|gimage
operator|->
name|active_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layer_stack
operator|->
name|data
expr_stmt|;
else|else
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out REMOVED signal from layer */
name|layer_removed
argument_list|(
name|layer
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Push the layer undo--It is important it goes here since layer might        *   be immediately destroyed if the undo push fails        */
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|LAYER_REMOVE_UNDO
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|LayerMask
modifier|*
DECL|function|gimp_image_add_layer_mask (GimpImage * gimage,Layer * layer,LayerMask * mask)
name|gimp_image_add_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|LayerMask
modifier|*
name|mask
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|!=
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask since\nthe layer already has one."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawable_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask to a\nlayer in an indexed image."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask to a layer\nwith no alpha channel."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask of different dimensions than specified layer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer undo and push it  */
name|lmu
operator|=
name|g_new
argument_list|(
name|LayerMaskUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|LAYER_MASK_ADD_UNDO
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_remove_layer_mask (GimpImage * gimage,Layer * layer,MaskApplyMode mode)
name|gimp_image_remove_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|MaskApplyMode
name|mode
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
operator|!
name|layer
operator|||
operator|!
name|layer
operator|->
name|mask
condition|)
return|return
name|NULL
return|;
comment|/*  Start an undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_APPLY_MASK_UNDO
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer mask undo--push it below  */
name|lmu
operator|=
name|g_new
argument_list|(
name|LayerMaskUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|layer
operator|->
name|mask
expr_stmt|;
name|lmu
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|layer_apply_mask
argument_list|(
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*  Push the undo--Important to do it here, AFTER the call    *   to layer_apply_mask, in case the undo push fails and the    *   mask is delete : NULL)d    */
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|LAYER_MASK_REMOVE_UNDO
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
comment|/*  end the undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer mode is discard, update the layer--invalidate gimage also  */
if|if
condition|(
name|mode
operator|==
name|DISCARD
condition|)
block|{
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdisplays_flush
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_raise_channel (GimpImage * gimage,Channel * channel_arg)
name|gimp_image_raise_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|prev_channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|prev
decl_stmt|;
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|prev_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|prev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|prev_channel
expr_stmt|;
name|prev
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|prev_channel
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be raised any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_lower_channel (GimpImage * gimage,Channel * channel_arg)
name|gimp_image_lower_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|next_channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|gint
name|index
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|next_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|next_channel
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|next_channel
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be lowered any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_position_channel (GimpImage * gimage,Channel * channel_arg,gint new_index)
name|gimp_image_position_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|,
name|gint
name|new_index
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|list_length
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|list_length
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|channel
operator|=
name|NULL
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* find channel_arg */
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
break|break;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|channel
operator|!=
name|channel_arg
condition|)
block|{
comment|/* The requested channel was not found in the channel stack        * Return without changing anything        */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|new_index
operator|<
literal|0
condition|)
name|new_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_index
operator|>=
name|list_length
condition|)
name|new_index
operator|=
name|list_length
operator|-
literal|1
expr_stmt|;
name|list
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|g_slist_insert
argument_list|(
name|list
argument_list|,
name|channel
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_add_channel (GimpImage * gimage,Channel * channel,gint position)
name|gimp_image_add_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
name|GSList
modifier|*
name|cc
decl_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_channel: attempt to add channel to wrong image"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|cc
operator|=
name|gimage
operator|->
name|channels
init|;
name|cc
condition|;
name|cc
operator|=
name|g_slist_next
argument_list|(
name|cc
argument_list|)
control|)
if|if
condition|(
name|cc
operator|->
name|data
operator|==
name|channel
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_channel: trying to add channel to image twice"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Prepare a channel undo and push it  */
name|cu
operator|=
name|g_new
argument_list|(
name|ChannelUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|CHANNEL_ADD_UNDO
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/*  add the channel to the list  */
name|gimage
operator|->
name|channels
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel_ref
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active channel  */
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  if channel is visible, update the image  */
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_remove_channel (GimpImage * gimage,Channel * channel)
name|gimp_image_remove_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
comment|/*  Prepare a channel undo--push it below  */
name|cu
operator|=
name|g_new
argument_list|(
name|ChannelUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
name|gimp_image_get_channel_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|==
name|channel
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|channels
condition|)
name|gimage
operator|->
name|active_channel
operator|=
operator|(
operator|(
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
operator|)
operator|)
expr_stmt|;
else|else
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Important to push the undo here in case the push fails  */
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|CHANNEL_REMOVE_UNDO
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Access functions                                        */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_is_empty (GimpImage * gimage)
name|gimp_image_is_empty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
operator|(
operator|!
name|gimage
operator|->
name|layers
operator|)
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_image_active_drawable (GimpImage * gimage)
name|gimp_image_active_drawable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|!=
name|NULL
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_channel
argument_list|)
return|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|!=
name|NULL
condition|)
block|{
name|layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpImageBaseType
DECL|function|gimp_image_base_type (GimpImage * gimage)
name|gimp_image_base_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_base_type_with_alpha (GimpImage * gimage)
name|gimp_image_base_type_with_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
switch|switch
condition|(
name|gimage
operator|->
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
return|return
name|RGBA_GIMAGE
return|;
case|case
name|GRAY
case|:
return|return
name|GRAYA_GIMAGE
return|;
case|case
name|INDEXED
case|:
return|return
name|INDEXEDA_GIMAGE
return|;
block|}
return|return
name|RGB_GIMAGE
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|gimp_image_filename (GimpImage * gimage)
name|gimp_image_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
return|return
name|gimage
operator|->
name|filename
return|;
else|else
return|return
name|_
argument_list|(
literal|"Untitled"
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_is_enabled (GimpImage * gimage)
name|gimp_image_undo_is_enabled
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|undo_on
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_freeze (GimpImage * gimage)
name|gimp_image_undo_freeze
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|undo_on
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_thaw (GimpImage * gimage)
name|gimp_image_undo_thaw
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_disable (GimpImage * gimage)
name|gimp_image_undo_disable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_undo_freeze
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_enable (GimpImage * gimage)
name|gimp_image_undo_enable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free all undo steps as they are now invalidated  */
name|undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_thaw
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_undo_event (GimpImage * gimage,int event)
name|gimp_image_undo_event
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE about the gimage->dirty counter:  *   If 0, then the image is clean (ie, copy on disk is the same as the one   *      in memory).  *   If positive, then that's the number of dirtying operations done  *       on the image since the last save.  *   If negative, then user has hit undo and gone back in time prior  *       to the saved copy.  Hitting redo will eventually come back to  *       the saved copy.  *  *   The image is dirty (ie, needs saving) if counter is non-zero.  *  *   If the counter is around 10000, this is due to undo-ing back  *   before a saved version, then mutating the image (thus destroying  *   the redo stack).  Once this has happened, it's impossible to get  *   the image back to the state on disk, since the redo info has been  *   freed.  See undo.c for the gorey details.  */
end_comment

begin_comment
comment|/*  * NEVER CALL gimp_image_dirty() directly!  *  * If your code has just dirtied the image, push an undo instead.  * Failing that, push the trivial undo which tells the user the  * command is not undoable: undo_push_cantundo() (But really, it would  * be best to push a proper undo).  If you just dirty the image  * without pushing an undo then the dirty count is increased, but  * popping that many undo actions won't lead to a clean image.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_dirty (GimpImage * gimage)
name|gimp_image_dirty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|dirty
operator|++
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|DIRTY
index|]
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"dirty %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|-
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_clean (GimpImage * gimage)
name|gimp_image_clean
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|dirty
operator|--
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"clean %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|+
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_clean_all (GimpImage * gimage)
name|gimp_image_clean_all
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_floating_sel (GimpImage * gimage)
name|gimp_image_floating_sel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|gimage
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
DECL|function|gimp_image_cmap (GimpImage * gimage)
name|gimp_image_cmap
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|drawable_cmap
argument_list|(
name|gimp_image_active_drawable
argument_list|(
name|gimage
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection access functions                             */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_projection (GimpImage * gimage)
name|gimp_image_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
operator|(
name|gimage
operator|->
name|projection
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tile_manager_level_width
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|width
operator|)
operator|||
operator|(
name|tile_manager_level_height
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|height
operator|)
condition|)
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|projection
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_projection_type (GimpImage * gimage)
name|gimp_image_projection_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|proj_type
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_projection_bytes (GimpImage * gimage)
name|gimp_image_projection_bytes
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|proj_bytes
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_projection_opacity (GimpImage * gimage)
name|gimp_image_projection_opacity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|OPAQUE_OPACITY
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_projection_realloc (GimpImage * gimage)
name|gimp_image_projection_realloc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Composition access functions                            */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_composite (GimpImage * gimage)
name|gimp_image_composite
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_composite_type (GimpImage * gimage)
name|gimp_image_composite_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_type
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_composite_bytes (GimpImage * gimage)
name|gimp_image_composite_bytes
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_bytes
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimp_image_construct_composite_preview (GimpImage * gimage,gint width,gint height)
name|gimp_image_construct_composite_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|TempBuf
modifier|*
name|comp
decl_stmt|;
name|TempBuf
modifier|*
name|layer_buf
decl_stmt|;
name|TempBuf
modifier|*
name|mask_buf
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|gdouble
name|ratio
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gint
name|construct_flag
decl_stmt|;
name|gint
name|visible
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|ratio
operator|=
operator|(
name|double
operator|)
name|width
operator|/
operator|(
name|double
operator|)
name|gimage
operator|->
name|width
expr_stmt|;
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|bytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|bytes
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*  The construction buffer  */
name|comp
operator|=
name|temp_buf_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|comp
operator|->
name|width
operator|*
name|comp
operator|->
name|height
operator|*
name|comp
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|floating_sel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible to the list  */
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
comment|/* floating selections are added right above the layer they are attached to */
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|floating_sel
operator|=
name|layer
expr_stmt|;
else|else
block|{
if|if
condition|(
name|floating_sel
operator|&&
name|floating_sel
operator|->
name|fs
operator|.
name|drawable
operator|==
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|floating_sel
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|construct_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|w
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|h
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src1PR
operator|.
name|bytes
operator|=
name|comp
operator|->
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|src1PR
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|src1PR
operator|.
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|rowstride
operator|=
name|comp
operator|->
name|width
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
operator|+
name|y1
operator|*
name|src1PR
operator|.
name|rowstride
operator|+
name|x1
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|layer_buf
operator|=
name|layer_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|src2PR
operator|.
name|bytes
operator|=
name|layer_buf
operator|->
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|w
operator|=
name|src1PR
operator|.
name|w
expr_stmt|;
name|src2PR
operator|.
name|h
operator|=
name|src1PR
operator|.
name|h
expr_stmt|;
name|src2PR
operator|.
name|x
operator|=
name|src1PR
operator|.
name|x
expr_stmt|;
name|src2PR
operator|.
name|y
operator|=
name|src1PR
operator|.
name|y
expr_stmt|;
name|src2PR
operator|.
name|rowstride
operator|=
name|layer_buf
operator|->
name|width
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|layer_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|src2PR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|mask_buf
operator|=
name|layer_mask_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|maskPR
operator|.
name|bytes
operator|=
name|mask_buf
operator|->
name|bytes
expr_stmt|;
name|maskPR
operator|.
name|rowstride
operator|=
name|mask_buf
operator|->
name|width
expr_stmt|;
name|maskPR
operator|.
name|data
operator|=
name|mask_buf_data
argument_list|(
name|mask_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|maskPR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|maskPR
operator|.
name|bytes
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the        *   composite preview...        *  Indexed images are actually already converted to RGB and RGBA,        *   so just project them as if they were type "intensity"        *  Send in all TRUE for visible since that info doesn't matter        *   for previews        */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
case|case
name|INDEXED_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|construct_flag
operator|=
literal|1
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
return|return
name|comp
return|;
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimp_image_composite_preview (GimpImage * gimage,ChannelType type,gint width,gint height)
name|gimp_image_composite_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gint
name|channel
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
name|channel
operator|=
name|RED_PIX
expr_stmt|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
name|channel
operator|=
name|GREEN_PIX
expr_stmt|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
name|channel
operator|=
name|BLUE_PIX
expr_stmt|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
name|channel
operator|=
name|GRAY_PIX
expr_stmt|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
name|channel
operator|=
name|INDEXED_PIX
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
comment|/*  The easy way  */
if|if
condition|(
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|width
operator|==
name|width
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|height
operator|==
name|height
condition|)
return|return
name|gimage
operator|->
name|comp_preview
return|;
comment|/*  The hard way  */
else|else
block|{
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
comment|/*  Actually construct the composite preview from the layer previews!        *  This might seem ridiculous, but it's actually the best way, given        *  a number of unsavory alternatives.        */
name|gimage
operator|->
name|comp_preview
operator|=
name|gimp_image_construct_composite_preview
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
name|gimage
operator|->
name|comp_preview
return|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_preview_valid (GimpImage * gimage,ChannelType type)
name|gimp_image_preview_valid
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_preview (GimpImage * gimage)
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  Invalidate the floating sel if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_invalidate
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

end_unit

