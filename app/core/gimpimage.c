begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpconfig/gimpconfig.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/temp-buf.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpcoreconfig.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimp-parasites.h"
end_include

begin_include
include|#
directive|include
file|"gimp-utils.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpgrid.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-colorhash.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-guides.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-sample-points.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-preview.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-quick-mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplist.h"
end_include

begin_include
include|#
directive|include
file|"gimpmarshal.h"
end_include

begin_include
include|#
directive|include
file|"gimpparasitelist.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpprojection.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimptemplate.h"
end_include

begin_include
include|#
directive|include
file|"gimpundostack.h"
end_include

begin_include
include|#
directive|include
file|"plug-in/gimppluginmanager.h"
end_include

begin_include
include|#
directive|include
file|"file/file-utils.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
DECL|enum|__anon27f169520103
block|{
DECL|enumerator|MODE_CHANGED
name|MODE_CHANGED
block|,
DECL|enumerator|ALPHA_CHANGED
name|ALPHA_CHANGED
block|,
DECL|enumerator|FLOATING_SELECTION_CHANGED
name|FLOATING_SELECTION_CHANGED
block|,
DECL|enumerator|ACTIVE_LAYER_CHANGED
name|ACTIVE_LAYER_CHANGED
block|,
DECL|enumerator|ACTIVE_CHANNEL_CHANGED
name|ACTIVE_CHANNEL_CHANGED
block|,
DECL|enumerator|ACTIVE_VECTORS_CHANGED
name|ACTIVE_VECTORS_CHANGED
block|,
DECL|enumerator|COMPONENT_VISIBILITY_CHANGED
name|COMPONENT_VISIBILITY_CHANGED
block|,
DECL|enumerator|COMPONENT_ACTIVE_CHANGED
name|COMPONENT_ACTIVE_CHANGED
block|,
DECL|enumerator|MASK_CHANGED
name|MASK_CHANGED
block|,
DECL|enumerator|RESOLUTION_CHANGED
name|RESOLUTION_CHANGED
block|,
DECL|enumerator|UNIT_CHANGED
name|UNIT_CHANGED
block|,
DECL|enumerator|QUICK_MASK_CHANGED
name|QUICK_MASK_CHANGED
block|,
DECL|enumerator|SELECTION_CONTROL
name|SELECTION_CONTROL
block|,
DECL|enumerator|CLEAN
name|CLEAN
block|,
DECL|enumerator|DIRTY
name|DIRTY
block|,
DECL|enumerator|UPDATE
name|UPDATE
block|,
DECL|enumerator|UPDATE_GUIDE
name|UPDATE_GUIDE
block|,
DECL|enumerator|UPDATE_SAMPLE_POINT
name|UPDATE_SAMPLE_POINT
block|,
DECL|enumerator|SAMPLE_POINT_ADDED
name|SAMPLE_POINT_ADDED
block|,
DECL|enumerator|SAMPLE_POINT_REMOVED
name|SAMPLE_POINT_REMOVED
block|,
DECL|enumerator|COLORMAP_CHANGED
name|COLORMAP_CHANGED
block|,
DECL|enumerator|UNDO_EVENT
name|UNDO_EVENT
block|,
DECL|enumerator|FLUSH
name|FLUSH
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_enum
enum|enum
DECL|enum|__anon27f169520203
block|{
DECL|enumerator|PROP_0
name|PROP_0
block|,
DECL|enumerator|PROP_GIMP
name|PROP_GIMP
block|,
DECL|enumerator|PROP_ID
name|PROP_ID
block|,
DECL|enumerator|PROP_WIDTH
name|PROP_WIDTH
block|,
DECL|enumerator|PROP_HEIGHT
name|PROP_HEIGHT
block|,
DECL|enumerator|PROP_BASE_TYPE
name|PROP_BASE_TYPE
block|}
enum|;
end_enum

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|GObject
modifier|*
name|gimp_image_constructor
parameter_list|(
name|GType
name|type
parameter_list|,
name|guint
name|n_params
parameter_list|,
name|GObjectConstructParam
modifier|*
name|params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_dispose
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint64
name|gimp_image_get_memsize
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|,
name|gint64
modifier|*
name|gui_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_image_get_size
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_size_changed
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_image_get_description
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gchar
modifier|*
modifier|*
name|tooltip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_real_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|color_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_real_flush
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_mask_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_drawable_visibility
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_layer_alpha_changed
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_layer_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_layer_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_channel_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_channel_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_channel_name_changed
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_channel_color_changed
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|valid_combinations
specifier|static
specifier|const
name|gint
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* GIMP_RGB_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* GIMP_RGBA_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GIMP_GRAY_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_GRAYA_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_INDEXED_IMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GIMP_INDEXEDA_IMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|G_DEFINE_TYPE
argument_list|(
name|GimpImage
argument_list|,
name|gimp_image
argument_list|,
name|GIMP_TYPE_VIEWABLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_image_parent_class
end_define

begin_decl_stmt
DECL|variable|gimp_image_signals
specifier|static
name|guint
name|gimp_image_signals
index|[
name|LAST_SIGNAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|gimp_image_class_init (GimpImageClass * klass)
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
block|{
name|GObjectClass
modifier|*
name|object_class
init|=
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpObjectClass
modifier|*
name|gimp_object_class
init|=
name|GIMP_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpViewableClass
modifier|*
name|viewable_class
init|=
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|gimp_image_signals
index|[
name|MODE_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"mode-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|mode_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ALPHA_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"alpha-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|alpha_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|FLOATING_SELECTION_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"floating-selection-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|floating_selection_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active-layer-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_layer_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active-channel-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_channel_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"active-vectors-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|active_vectors_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COMPONENT_VISIBILITY_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"component-visibility-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|component_visibility_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_CHANNEL_TYPE
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COMPONENT_ACTIVE_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"component-active-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|component_active_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_CHANNEL_TYPE
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|MASK_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"mask-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|mask_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESOLUTION_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"resolution-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|resolution_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNIT_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"unit-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|unit_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|QUICK_MASK_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"quick-mask-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|quick_mask_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|SELECTION_CONTROL
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"selection-control"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|selection_control
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_SELECTION_CONTROL
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|CLEAN
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"clean"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|clean
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__FLAGS
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_DIRTY_MASK
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|DIRTY
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"dirty"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|dirty
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__FLAGS
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GIMP_TYPE_DIRTY_MASK
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UPDATE
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"update"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|update
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__INT_INT_INT_INT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|4
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|,
name|G_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UPDATE_GUIDE
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"update-guide"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|update_guide
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__POINTER
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_POINTER
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UPDATE_SAMPLE_POINT
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"update-sample-point"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|update_sample_point
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__POINTER
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_POINTER
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|SAMPLE_POINT_ADDED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"sample-point-added"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|sample_point_added
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__POINTER
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_POINTER
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|SAMPLE_POINT_REMOVED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"sample-point-removed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|sample_point_removed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__POINTER
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_POINTER
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"colormap-changed"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|colormap_changed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__INT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|G_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"undo-event"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|undo_event
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__ENUM_OBJECT
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|2
argument_list|,
name|GIMP_TYPE_UNDO_EVENT
argument_list|,
name|GIMP_TYPE_UNDO
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|FLUSH
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"flush"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|flush
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|object_class
operator|->
name|constructor
operator|=
name|gimp_image_constructor
expr_stmt|;
name|object_class
operator|->
name|set_property
operator|=
name|gimp_image_set_property
expr_stmt|;
name|object_class
operator|->
name|get_property
operator|=
name|gimp_image_get_property
expr_stmt|;
name|object_class
operator|->
name|dispose
operator|=
name|gimp_image_dispose
expr_stmt|;
name|object_class
operator|->
name|finalize
operator|=
name|gimp_image_finalize
expr_stmt|;
name|gimp_object_class
operator|->
name|name_changed
operator|=
name|gimp_image_name_changed
expr_stmt|;
name|gimp_object_class
operator|->
name|get_memsize
operator|=
name|gimp_image_get_memsize
expr_stmt|;
name|viewable_class
operator|->
name|default_stock_id
operator|=
literal|"gimp-image"
expr_stmt|;
name|viewable_class
operator|->
name|get_size
operator|=
name|gimp_image_get_size
expr_stmt|;
name|viewable_class
operator|->
name|invalidate_preview
operator|=
name|gimp_image_invalidate_preview
expr_stmt|;
name|viewable_class
operator|->
name|size_changed
operator|=
name|gimp_image_size_changed
expr_stmt|;
name|viewable_class
operator|->
name|get_preview_size
operator|=
name|gimp_image_get_preview_size
expr_stmt|;
name|viewable_class
operator|->
name|get_popup_size
operator|=
name|gimp_image_get_popup_size
expr_stmt|;
name|viewable_class
operator|->
name|get_preview
operator|=
name|gimp_image_get_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_new_preview
operator|=
name|gimp_image_get_new_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_description
operator|=
name|gimp_image_get_description
expr_stmt|;
name|klass
operator|->
name|mode_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|alpha_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|floating_selection_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_layer_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_channel_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|active_vectors_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|component_visibility_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|component_active_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|mask_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|clean
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|dirty
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|update
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|update_guide
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|update_sample_point
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|sample_point_added
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|sample_point_removed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|colormap_changed
operator|=
name|gimp_image_real_colormap_changed
expr_stmt|;
name|klass
operator|->
name|undo_event
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|flush
operator|=
name|gimp_image_real_flush
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_GIMP
argument_list|,
name|g_param_spec_object
argument_list|(
literal|"gimp"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_TYPE_GIMP
argument_list|,
name|GIMP_PARAM_READWRITE
operator||
name|G_PARAM_CONSTRUCT_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_ID
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"id"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|G_MAXINT
argument_list|,
literal|0
argument_list|,
name|GIMP_PARAM_READABLE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_WIDTH
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"width"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
operator||
name|G_PARAM_CONSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_HEIGHT
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"height"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|GIMP_PARAM_READWRITE
operator||
name|G_PARAM_CONSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_BASE_TYPE
argument_list|,
name|g_param_spec_enum
argument_list|(
literal|"base-type"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_TYPE_IMAGE_BASE_TYPE
argument_list|,
name|GIMP_RGB
argument_list|,
name|GIMP_PARAM_READWRITE
operator||
name|G_PARAM_CONSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_color_hash_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_init (GimpImage * image)
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|image
operator|->
name|ID
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|save_proc
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|xresolution
operator|=
literal|1.0
expr_stmt|;
name|image
operator|->
name|yresolution
operator|=
literal|1.0
expr_stmt|;
name|image
operator|->
name|resolution_unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
name|image
operator|->
name|base_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|image
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|image
operator|->
name|dirty_time
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|undo_freeze_count
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|disp_count
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|tattoo_state
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|projection
operator|=
name|gimp_projection_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|grid
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|sample_points
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|layers
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_LAYER
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|image
operator|->
name|channels
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_CHANNEL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|image
operator|->
name|vectors
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_VECTORS
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|layer_update_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|"update"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_update
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_visible_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|"visibility-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_visibility
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_alpha_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|"alpha-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_layer_alpha_changed
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|channel_update_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"update"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_update
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|channel_visible_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"visibility-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_drawable_visibility
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|channel_name_changed_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"name-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_channel_name_changed
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|channel_color_changed_handler
operator|=
name|gimp_container_add_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"color-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_channel_color_changed
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|"add"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_layer_add
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|"remove"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_layer_remove
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"add"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_channel_add
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|image
operator|->
name|channels
argument_list|,
literal|"remove"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_channel_remove
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|active_vectors
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|selection_mask
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|parasites
operator|=
name|gimp_parasite_list_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|image
operator|->
name|visible
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|image
operator|->
name|active
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|image
operator|->
name|quick_mask_state
operator|=
name|FALSE
expr_stmt|;
name|image
operator|->
name|quick_mask_inverted
operator|=
name|FALSE
expr_stmt|;
name|gimp_rgba_set
argument_list|(
operator|&
name|image
operator|->
name|quick_mask_color
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|image
operator|->
name|undo_stack
operator|=
name|gimp_undo_stack_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|redo_stack
operator|=
name|gimp_undo_stack_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|group_count
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|pushing_undo_group
operator|=
name|GIMP_UNDO_GROUP_NONE
expr_stmt|;
name|image
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
name|image
operator|->
name|flush_accum
operator|.
name|alpha_changed
operator|=
name|FALSE
expr_stmt|;
name|image
operator|->
name|flush_accum
operator|.
name|mask_changed
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GObject
modifier|*
DECL|function|gimp_image_constructor (GType type,guint n_params,GObjectConstructParam * params)
name|gimp_image_constructor
parameter_list|(
name|GType
name|type
parameter_list|,
name|guint
name|n_params
parameter_list|,
name|GObjectConstructParam
modifier|*
name|params
parameter_list|)
block|{
name|GObject
modifier|*
name|object
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpCoreConfig
modifier|*
name|config
decl_stmt|;
name|object
operator|=
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|constructor
argument_list|(
name|type
argument_list|,
name|n_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|image
operator|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|GIMP_IS_GIMP
argument_list|(
name|image
operator|->
name|gimp
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|=
name|image
operator|->
name|gimp
operator|->
name|config
expr_stmt|;
do|do
block|{
name|image
operator|->
name|ID
operator|=
name|image
operator|->
name|gimp
operator|->
name|next_image_ID
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|gimp
operator|->
name|next_image_ID
operator|==
name|G_MAXINT
condition|)
name|image
operator|->
name|gimp
operator|->
name|next_image_ID
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|g_hash_table_lookup
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|image
operator|->
name|ID
argument_list|)
argument_list|)
condition|)
do|;
name|g_hash_table_insert
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|image
operator|->
name|ID
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|xresolution
operator|=
name|config
operator|->
name|default_image
operator|->
name|xresolution
expr_stmt|;
name|image
operator|->
name|yresolution
operator|=
name|config
operator|->
name|default_image
operator|->
name|yresolution
expr_stmt|;
name|image
operator|->
name|resolution_unit
operator|=
name|config
operator|->
name|default_image
operator|->
name|resolution_unit
expr_stmt|;
name|image
operator|->
name|grid
operator|=
name|gimp_config_duplicate
argument_list|(
name|GIMP_CONFIG
argument_list|(
name|config
operator|->
name|default_grid
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|image
operator|->
name|base_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
case|case
name|GIMP_GRAY
case|:
break|break;
case|case
name|GIMP_INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|image
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|cmap
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|GIMP_IMAGE_COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* create the selection mask */
name|image
operator|->
name|selection_mask
operator|=
name|gimp_selection_new
argument_list|(
name|image
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|image
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
name|gimp_item_sink
argument_list|(
name|GIMP_ITEM
argument_list|(
name|image
operator|->
name|selection_mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|image
operator|->
name|selection_mask
argument_list|,
literal|"update"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_mask_update
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|config
argument_list|,
literal|"notify::transparency-type"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_invalidate_layer_previews
argument_list|)
argument_list|,
name|image
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|config
argument_list|,
literal|"notify::transparency-size"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_image_invalidate_layer_previews
argument_list|)
argument_list|,
name|image
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
name|g_signal_connect_object
argument_list|(
name|config
argument_list|,
literal|"notify::layer-previews"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_viewable_size_changed
argument_list|)
argument_list|,
name|image
argument_list|,
name|G_CONNECT_SWAPPED
argument_list|)
expr_stmt|;
name|gimp_container_add
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|images
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_set_property (GObject * object,guint property_id,const GValue * value,GParamSpec * pspec)
name|gimp_image_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_GIMP
case|:
name|image
operator|->
name|gimp
operator|=
name|g_value_get_object
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_ID
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROP_WIDTH
case|:
name|image
operator|->
name|width
operator|=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_HEIGHT
case|:
name|image
operator|->
name|height
operator|=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_BASE_TYPE
case|:
name|image
operator|->
name|base_type
operator|=
name|g_value_get_enum
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_get_property (GObject * object,guint property_id,GValue * value,GParamSpec * pspec)
name|gimp_image_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_GIMP
case|:
name|g_value_set_object
argument_list|(
name|value
argument_list|,
name|image
operator|->
name|gimp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_ID
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|image
operator|->
name|ID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_WIDTH
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|image
operator|->
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_HEIGHT
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|image
operator|->
name|height
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_BASE_TYPE
case|:
name|g_value_set_enum
argument_list|(
name|value
argument_list|,
name|image
operator|->
name|base_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_dispose (GObject * object)
name|gimp_image_dispose
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_image_undo_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|image
operator|->
name|layer_update_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|image
operator|->
name|layer_visible_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|image
operator|->
name|layer_alpha_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|image
operator|->
name|channel_update_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|image
operator|->
name|channel_visible_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|image
operator|->
name|channel_name_changed_handler
argument_list|)
expr_stmt|;
name|gimp_container_remove_handler
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|image
operator|->
name|channel_color_changed_handler
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|gimp_image_layer_add
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|gimp_image_layer_remove
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|gimp_image_channel_add
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|g_signal_handlers_disconnect_by_func
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|gimp_image_channel_remove
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_item_removed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_item_removed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_item_removed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|dispose
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_finalize (GObject * object)
name|gimp_image_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|projection
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|projection
argument_list|)
expr_stmt|;
name|image
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|shadow
condition|)
name|gimp_image_free_shadow_tiles
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|cmap
condition|)
block|{
name|g_free
argument_list|(
name|image
operator|->
name|cmap
argument_list|)
expr_stmt|;
name|image
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|layers
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|layers
argument_list|)
expr_stmt|;
name|image
operator|->
name|layers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|channels
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|channels
argument_list|)
expr_stmt|;
name|image
operator|->
name|channels
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|vectors
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|image
operator|->
name|vectors
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|layer_stack
condition|)
block|{
name|g_slist_free
argument_list|(
name|image
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|selection_mask
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
name|image
operator|->
name|selection_mask
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|comp_preview
condition|)
block|{
name|temp_buf_free
argument_list|(
name|image
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
name|image
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|parasites
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|image
operator|->
name|parasites
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|guides
condition|)
block|{
name|g_list_foreach
argument_list|(
name|image
operator|->
name|guides
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_image_guide_unref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|image
operator|->
name|guides
argument_list|)
expr_stmt|;
name|image
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|grid
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|grid
argument_list|)
expr_stmt|;
name|image
operator|->
name|grid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|sample_points
condition|)
block|{
name|g_list_foreach
argument_list|(
name|image
operator|->
name|sample_points
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_image_sample_point_unref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|image
operator|->
name|sample_points
argument_list|)
expr_stmt|;
name|image
operator|->
name|sample_points
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|undo_stack
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|undo_stack
argument_list|)
expr_stmt|;
name|image
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|redo_stack
condition|)
block|{
name|g_object_unref
argument_list|(
name|image
operator|->
name|redo_stack
argument_list|)
expr_stmt|;
name|image
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|gimp
operator|&&
name|image
operator|->
name|gimp
operator|->
name|image_table
condition|)
block|{
name|g_hash_table_remove
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|image
operator|->
name|ID
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|gimp
operator|=
name|NULL
expr_stmt|;
block|}
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|finalize
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_name_changed (GimpObject * object)
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
condition|)
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|name
operator|=
name|gimp_object_get_name
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|g_free
argument_list|(
name|object
operator|->
name|name
argument_list|)
expr_stmt|;
name|object
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gint64
DECL|function|gimp_image_get_memsize (GimpObject * object,gint64 * gui_size)
name|gimp_image_get_memsize
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|,
name|gint64
modifier|*
name|gui_size
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gint64
name|memsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|cmap
condition|)
name|memsize
operator|+=
name|GIMP_IMAGE_COLORMAP_SIZE
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|shadow
condition|)
name|memsize
operator|+=
name|tile_manager_get_memsize
argument_list|(
name|image
operator|->
name|shadow
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|projection
condition|)
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|projection
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_g_list_get_memsize
argument_list|(
name|image
operator|->
name|guides
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpGuide
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|grid
condition|)
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|grid
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_g_list_get_memsize
argument_list|(
name|image
operator|->
name|sample_points
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpSamplePoint
argument_list|)
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|layers
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|channels
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_g_slist_get_memsize
argument_list|(
name|image
operator|->
name|layer_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|selection_mask
condition|)
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|selection_mask
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|parasites
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|undo_stack
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
name|memsize
operator|+=
name|gimp_object_get_memsize
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
operator|->
name|redo_stack
argument_list|)
argument_list|,
name|gui_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|comp_preview
condition|)
operator|*
name|gui_size
operator|+=
name|temp_buf_get_memsize
argument_list|(
name|image
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
return|return
name|memsize
operator|+
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|get_memsize
argument_list|(
name|object
argument_list|,
name|gui_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_image_get_size (GimpViewable * viewable,gint * width,gint * height)
name|gimp_image_get_size
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
decl_stmt|;
operator|*
name|width
operator|=
name|image
operator|->
name|width
expr_stmt|;
operator|*
name|height
operator|=
name|image
operator|->
name|height
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_invalidate_preview (GimpViewable * viewable)
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
decl_stmt|;
if|if
condition|(
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_preview
condition|)
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_preview
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|image
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|comp_preview
condition|)
block|{
name|temp_buf_free
argument_list|(
name|image
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
name|image
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_size_changed (GimpViewable * viewable)
name|gimp_image_size_changed
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|size_changed
condition|)
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|size_changed
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_size_changed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_image_get_description (GimpViewable * viewable,gchar ** tooltip)
name|gimp_image_get_description
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gchar
modifier|*
modifier|*
name|tooltip
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|gchar
modifier|*
name|basename
decl_stmt|;
name|gchar
modifier|*
name|retval
decl_stmt|;
name|uri
operator|=
name|gimp_image_get_uri
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|basename
operator|=
name|file_utils_uri_display_basename
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|tooltip
condition|)
operator|*
name|tooltip
operator|=
name|file_utils_uri_display_name
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|retval
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s-%d"
argument_list|,
name|basename
argument_list|,
name|gimp_image_get_ID
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_real_colormap_changed (GimpImage * image,gint color_index)
name|gimp_image_real_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|color_index
parameter_list|)
block|{
if|if
condition|(
name|gimp_image_base_type
argument_list|(
name|image
argument_list|)
operator|==
name|GIMP_INDEXED
condition|)
block|{
name|gimp_image_color_hash_invalidate
argument_list|(
name|image
argument_list|,
name|color_index
argument_list|)
expr_stmt|;
comment|/* A colormap alteration affects the whole image */
name|gimp_image_update
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_image_invalidate_layer_previews
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_real_flush (GimpImage * image)
name|gimp_image_real_flush
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|->
name|flush_accum
operator|.
name|alpha_changed
condition|)
block|{
name|gimp_image_alpha_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|flush_accum
operator|.
name|alpha_changed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|image
operator|->
name|flush_accum
operator|.
name|mask_changed
condition|)
block|{
name|gimp_image_mask_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|flush_accum
operator|.
name|mask_changed
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_mask_update (GimpDrawable * drawable,gint x,gint y,gint width,gint height,GimpImage * image)
name|gimp_image_mask_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|image
operator|->
name|flush_accum
operator|.
name|mask_changed
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_update (GimpDrawable * drawable,gint x,gint y,gint width,gint height,GimpImage * image)
name|gimp_image_drawable_update
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|x
operator|+=
name|offset_x
expr_stmt|;
name|y
operator|+=
name|offset_y
expr_stmt|;
name|gimp_image_update
argument_list|(
name|image
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_drawable_visibility (GimpItem * item,GimpImage * image)
name|gimp_image_drawable_visibility
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|image
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|gimp_item_width
argument_list|(
name|item
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_layer_alpha_changed (GimpDrawable * drawable,GimpImage * image)
name|gimp_image_layer_alpha_changed
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|==
literal|1
condition|)
name|image
operator|->
name|flush_accum
operator|.
name|alpha_changed
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_layer_add (GimpContainer * container,GimpLayer * layer,GimpImage * image)
name|gimp_image_layer_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_layer_remove (GimpContainer * container,GimpLayer * layer,GimpImage * image)
name|gimp_image_layer_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_channel_add (GimpContainer * container,GimpChannel * channel,GimpImage * image)
name|gimp_image_channel_add
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GIMP_IMAGE_QUICK_MASK_NAME
argument_list|,
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|gimp_image_set_quick_mask_state
argument_list|(
name|image
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_channel_remove (GimpContainer * container,GimpChannel * channel,GimpImage * image)
name|gimp_image_channel_remove
parameter_list|(
name|GimpContainer
modifier|*
name|container
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|item
argument_list|)
condition|)
name|gimp_image_drawable_visibility
argument_list|(
name|item
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GIMP_IMAGE_QUICK_MASK_NAME
argument_list|,
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|gimp_image_set_quick_mask_state
argument_list|(
name|image
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_channel_name_changed (GimpChannel * channel,GimpImage * image)
name|gimp_image_channel_name_changed
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GIMP_IMAGE_QUICK_MASK_NAME
argument_list|,
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|gimp_image_set_quick_mask_state
argument_list|(
name|image
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimp_image_get_quick_mask_state
argument_list|(
name|image
argument_list|)
operator|&&
operator|!
name|gimp_image_get_quick_mask
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|gimp_image_set_quick_mask_state
argument_list|(
name|image
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_channel_color_changed (GimpChannel * channel,GimpImage * image)
name|gimp_image_channel_color_changed
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GIMP_IMAGE_QUICK_MASK_NAME
argument_list|,
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|image
operator|->
name|quick_mask_color
operator|=
name|channel
operator|->
name|color
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_new (Gimp * gimp,gint width,gint height,GimpImageBaseType base_type)
name|gimp_image_new
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImageBaseType
name|base_type
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_GIMP
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|g_object_new
argument_list|(
name|GIMP_TYPE_IMAGE
argument_list|,
literal|"gimp"
argument_list|,
name|gimp
argument_list|,
literal|"width"
argument_list|,
name|width
argument_list|,
literal|"height"
argument_list|,
name|height
argument_list|,
literal|"base-type"
argument_list|,
name|base_type
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpImageBaseType
DECL|function|gimp_image_base_type (const GimpImage * image)
name|gimp_image_base_type
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_base_type_with_alpha (const GimpImage * image)
name|gimp_image_base_type_with_alpha
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|image
operator|->
name|base_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
name|GIMP_RGBA_IMAGE
return|;
case|case
name|GIMP_GRAY
case|:
return|return
name|GIMP_GRAYA_IMAGE
return|;
case|case
name|GIMP_INDEXED
case|:
return|return
name|GIMP_INDEXEDA_IMAGE
return|;
block|}
return|return
name|GIMP_RGB_IMAGE
return|;
block|}
end_function

begin_function
name|CombinationMode
DECL|function|gimp_image_get_combination_mode (GimpImageType dest_type,gint src_bytes)
name|gimp_image_get_combination_mode
parameter_list|(
name|GimpImageType
name|dest_type
parameter_list|,
name|gint
name|src_bytes
parameter_list|)
block|{
return|return
name|valid_combinations
index|[
name|dest_type
index|]
index|[
name|src_bytes
index|]
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_ID (const GimpImage * image)
name|gimp_image_get_ID
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|ID
return|;
block|}
end_function

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_get_by_ID (Gimp * gimp,gint image_id)
name|gimp_image_get_by_ID
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gint
name|image_id
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_GIMP
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp
operator|->
name|image_table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|GimpImage
operator|*
operator|)
name|g_hash_table_lookup
argument_list|(
name|gimp
operator|->
name|image_table
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|image_id
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_uri (GimpImage * image,const gchar * uri)
name|gimp_image_set_uri
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_image_get_uri (const GimpImage * image)
name|gimp_image_get_uri
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uri
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|uri
condition|?
name|uri
else|:
name|_
argument_list|(
literal|"Untitled"
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_filename (GimpImage * image,const gchar * filename)
name|gimp_image_set_filename
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|strlen
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|uri
decl_stmt|;
name|uri
operator|=
name|file_utils_filename_to_uri
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|plug_in_manager
operator|->
name|load_procs
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_image_set_uri
argument_list|(
name|image
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_set_uri
argument_list|(
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|gimp_image_get_filename (const GimpImage * image)
name|gimp_image_get_filename
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|uri
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uri
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uri
condition|)
return|return
name|NULL
return|;
return|return
name|g_filename_from_uri
argument_list|(
name|uri
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_save_proc (GimpImage * image,GimpPlugInProcedure * proc)
name|gimp_image_set_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpPlugInProcedure
modifier|*
name|proc
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|save_proc
operator|=
name|proc
expr_stmt|;
block|}
end_function

begin_function
name|GimpPlugInProcedure
modifier|*
DECL|function|gimp_image_get_save_proc (const GimpImage * image)
name|gimp_image_get_save_proc
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|save_proc
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_resolution (GimpImage * image,gdouble xresolution,gdouble yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gdouble
name|xresolution
parameter_list|,
name|gdouble
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't allow to set the resolution out of bounds */
if|if
condition|(
name|xresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xresolution
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
name|yresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yresolution
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
return|return;
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|image
operator|->
name|xresolution
operator|-
name|xresolution
argument_list|)
operator|>=
literal|1e-5
operator|)
operator|||
operator|(
name|ABS
argument_list|(
name|image
operator|->
name|yresolution
operator|-
name|yresolution
argument_list|)
operator|>=
literal|1e-5
operator|)
condition|)
block|{
name|gimp_image_undo_push_image_resolution
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Change Image Resolution"
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|xresolution
operator|=
name|xresolution
expr_stmt|;
name|image
operator|->
name|yresolution
operator|=
name|yresolution
expr_stmt|;
name|gimp_image_resolution_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_viewable_size_changed
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_resolution (const GimpImage * image,gdouble * xresolution,gdouble * yresolution)
name|gimp_image_get_resolution
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gdouble
modifier|*
name|xresolution
parameter_list|,
name|gdouble
modifier|*
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|xresolution
operator|&&
name|yresolution
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
name|image
operator|->
name|xresolution
expr_stmt|;
operator|*
name|yresolution
operator|=
name|image
operator|->
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_resolution_changed (GimpImage * image)
name|gimp_image_resolution_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|RESOLUTION_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_unit (GimpImage * image,GimpUnit unit)
name|gimp_image_set_unit
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|unit
operator|>
name|GIMP_UNIT_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|resolution_unit
operator|!=
name|unit
condition|)
block|{
name|gimp_image_undo_push_image_resolution
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Change Image Unit"
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|resolution_unit
operator|=
name|unit
expr_stmt|;
name|gimp_image_unit_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GimpUnit
DECL|function|gimp_image_get_unit (const GimpImage * image)
name|gimp_image_get_unit
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|GIMP_UNIT_INCH
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|resolution_unit
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_unit_changed (GimpImage * image)
name|gimp_image_unit_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|UNIT_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_width (const GimpImage * image)
name|gimp_image_get_width
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|width
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_height (const GimpImage * image)
name|gimp_image_get_height
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|height
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_has_alpha (const GimpImage * image)
name|gimp_image_has_alpha
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|layer
operator|&&
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_is_empty (const GimpImage * image)
name|gimp_image_is_empty
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|gimp_container_is_empty
argument_list|(
name|image
operator|->
name|layers
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_floating_sel (const GimpImage * image)
name|gimp_image_floating_sel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_floating_selection_changed (GimpImage * image)
name|gimp_image_floating_selection_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|FLOATING_SELECTION_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_mask (const GimpImage * image)
name|gimp_image_get_mask
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_mask_changed (GimpImage * image)
name|gimp_image_mask_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|MASK_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_component_index (const GimpImage * image,GimpChannelType channel)
name|gimp_image_get_component_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|channel
condition|)
block|{
case|case
name|GIMP_RED_CHANNEL
case|:
return|return
name|RED_PIX
return|;
case|case
name|GIMP_GREEN_CHANNEL
case|:
return|return
name|GREEN_PIX
return|;
case|case
name|GIMP_BLUE_CHANNEL
case|:
return|return
name|BLUE_PIX
return|;
case|case
name|GIMP_GRAY_CHANNEL
case|:
return|return
name|GRAY_PIX
return|;
case|case
name|GIMP_INDEXED_CHANNEL
case|:
return|return
name|INDEXED_PIX
return|;
case|case
name|GIMP_ALPHA_CHANNEL
case|:
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|image
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
name|ALPHA_PIX
return|;
case|case
name|GIMP_GRAY
case|:
return|return
name|ALPHA_G_PIX
return|;
case|case
name|GIMP_INDEXED
case|:
return|return
name|ALPHA_I_PIX
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_active (GimpImage * image,GimpChannelType channel,gboolean active)
name|gimp_image_set_component_active
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|,
name|gboolean
name|active
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|image
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
operator|&&
name|active
operator|!=
name|image
operator|->
name|active
index|[
name|index
index|]
condition|)
block|{
name|image
operator|->
name|active
index|[
name|index
index|]
operator|=
name|active
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/*  If there is an active channel and we mess with the components,        *  the active channel gets unset...        */
name|gimp_image_unset_active_channel
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|COMPONENT_ACTIVE_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_active (const GimpImage * image,GimpChannelType channel)
name|gimp_image_get_component_active
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|image
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
return|return
name|image
operator|->
name|active
index|[
name|index
index|]
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_visible (GimpImage * image,GimpChannelType channel,gboolean visible)
name|gimp_image_set_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|,
name|gboolean
name|visible
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|image
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
operator|&&
name|visible
operator|!=
name|image
operator|->
name|visible
index|[
name|index
index|]
condition|)
block|{
name|image
operator|->
name|visible
index|[
name|index
index|]
operator|=
name|visible
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|COMPONENT_VISIBILITY_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_visible (const GimpImage * image,GimpChannelType channel)
name|gimp_image_get_component_visible
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannelType
name|channel
parameter_list|)
block|{
name|gint
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_image_get_component_index
argument_list|(
name|image
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
return|return
name|image
operator|->
name|visible
index|[
name|index
index|]
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_mode_changed (GimpImage * image)
name|gimp_image_mode_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|MODE_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_alpha_changed (GimpImage * image)
name|gimp_image_alpha_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ALPHA_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_update (GimpImage * image,gint x,gint y,gint width,gint height)
name|gimp_image_update
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|UPDATE
index|]
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_update_guide (GimpImage * image,GimpGuide * guide)
name|gimp_image_update_guide
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpGuide
modifier|*
name|guide
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|guide
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|UPDATE_GUIDE
index|]
argument_list|,
literal|0
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_update_sample_point (GimpImage * image,GimpSamplePoint * sample_point)
name|gimp_image_update_sample_point
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpSamplePoint
modifier|*
name|sample_point
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|sample_point
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|UPDATE_SAMPLE_POINT
index|]
argument_list|,
literal|0
argument_list|,
name|sample_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_sample_point_added (GimpImage * image,GimpSamplePoint * sample_point)
name|gimp_image_sample_point_added
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpSamplePoint
modifier|*
name|sample_point
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|sample_point
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|SAMPLE_POINT_ADDED
index|]
argument_list|,
literal|0
argument_list|,
name|sample_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_sample_point_removed (GimpImage * image,GimpSamplePoint * sample_point)
name|gimp_image_sample_point_removed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpSamplePoint
modifier|*
name|sample_point
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|sample_point
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|SAMPLE_POINT_REMOVED
index|]
argument_list|,
literal|0
argument_list|,
name|sample_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_colormap_changed (GimpImage * image,gint color_index)
name|gimp_image_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|color_index
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|color_index
operator|>=
operator|-
literal|1
operator|&&
name|color_index
operator|<
name|image
operator|->
name|num_cols
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
argument_list|,
literal|0
argument_list|,
name|color_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_selection_control (GimpImage * image,GimpSelectionControl control)
name|gimp_image_selection_control
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpSelectionControl
name|control
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|SELECTION_CONTROL
index|]
argument_list|,
literal|0
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_quick_mask_changed (GimpImage * image)
name|gimp_image_quick_mask_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|QUICK_MASK_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  undo  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_is_enabled (const GimpImage * image)
name|gimp_image_undo_is_enabled
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|image
operator|->
name|undo_freeze_count
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_enable (GimpImage * image)
name|gimp_image_undo_enable
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Free all undo steps as they are now invalidated  */
name|gimp_image_undo_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_thaw
argument_list|(
name|image
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_disable (GimpImage * image)
name|gimp_image_undo_disable
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_freeze
argument_list|(
name|image
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_freeze (GimpImage * image)
name|gimp_image_undo_freeze
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|->
name|undo_freeze_count
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|undo_freeze_count
operator|==
literal|1
condition|)
name|gimp_image_undo_event
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_EVENT_UNDO_FREEZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_thaw (GimpImage * image)
name|gimp_image_undo_thaw
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image
operator|->
name|undo_freeze_count
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|->
name|undo_freeze_count
operator|--
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|undo_freeze_count
operator|==
literal|0
condition|)
name|gimp_image_undo_event
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_EVENT_UNDO_THAW
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_undo_event (GimpImage * image,GimpUndoEvent event,GimpUndo * undo)
name|gimp_image_undo_event
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpUndoEvent
name|event
parameter_list|,
name|GimpUndo
modifier|*
name|undo
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
operator|(
name|event
operator|==
name|GIMP_UNDO_EVENT_UNDO_FREE
operator|||
name|event
operator|==
name|GIMP_UNDO_EVENT_UNDO_FREEZE
operator|||
name|event
operator|==
name|GIMP_UNDO_EVENT_UNDO_THAW
operator|)
operator|&&
name|undo
operator|==
name|NULL
operator|)
operator|||
name|GIMP_IS_UNDO
argument_list|(
name|undo
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
argument_list|,
literal|0
argument_list|,
name|event
argument_list|,
name|undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE about the image->dirty counter:  *   If 0, then the image is clean (ie, copy on disk is the same as the one  *      in memory).  *   If positive, then that's the number of dirtying operations done  *       on the image since the last save.  *   If negative, then user has hit undo and gone back in time prior  *       to the saved copy.  Hitting redo will eventually come back to  *       the saved copy.  *  *   The image is dirty (ie, needs saving) if counter is non-zero.  *  *   If the counter is around 10000, this is due to undo-ing back  *   before a saved version, then mutating the image (thus destroying  *   the redo stack).  Once this has happened, it's impossible to get  *   the image back to the state on disk, since the redo info has been  *   freed.  See undo.c for the gorey details.  */
end_comment

begin_comment
comment|/*  * NEVER CALL gimp_image_dirty() directly!  *  * If your code has just dirtied the image, push an undo instead.  * Failing that, push the trivial undo which tells the user the  * command is not undoable: undo_push_cantundo() (But really, it would  * be best to push a proper undo).  If you just dirty the image  * without pushing an undo then the dirty count is increased, but  * popping that many undo actions won't lead to a clean image.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_dirty (GimpImage * image,GimpDirtyMask dirty_mask)
name|gimp_image_dirty
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDirtyMask
name|dirty_mask
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|->
name|dirty
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|->
name|dirty_time
condition|)
name|image
operator|->
name|dirty_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|DIRTY
index|]
argument_list|,
literal|0
argument_list|,
name|dirty_mask
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"dirty %d -> %d\n"
operator|,
name|image
operator|->
name|dirty
operator|-
literal|1
operator|,
name|image
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_clean (GimpImage * image,GimpDirtyMask dirty_mask)
name|gimp_image_clean
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDirtyMask
name|dirty_mask
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|->
name|dirty
operator|--
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|,
literal|0
argument_list|,
name|dirty_mask
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"clean %d -> %d\n"
operator|,
name|image
operator|->
name|dirty
operator|+
literal|1
operator|,
name|image
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_clean_all (GimpImage * image)
name|gimp_image_clean_all
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|dirty_time
operator|=
literal|0
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  flush this image's displays  */
end_comment

begin_function
name|void
DECL|function|gimp_image_flush (GimpImage * image)
name|gimp_image_flush
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|FLUSH
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  color transforms / utilities  */
end_comment

begin_function
name|void
DECL|function|gimp_image_get_foreground (const GimpImage * image,const GimpDrawable * drawable,GimpContext * context,guchar * fg)
name|gimp_image_get_foreground
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|guchar
modifier|*
name|fg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pfg
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|!
name|drawable
operator|||
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|fg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|image
argument_list|,
name|drawable
argument_list|,
name|fg
argument_list|,
name|GIMP_RGB
argument_list|,
name|pfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_background (const GimpImage * image,const GimpDrawable * drawable,GimpContext * context,guchar * bg)
name|gimp_image_get_background
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pbg
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|!
name|drawable
operator|||
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|bg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
name|context
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|image
argument_list|,
name|drawable
argument_list|,
name|bg
argument_list|,
name|GIMP_RGB
argument_list|,
name|pbg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_color (const GimpImage * src_image,GimpImageType src_type,const guchar * src,guchar * rgba)
name|gimp_image_get_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|src_image
parameter_list|,
name|GimpImageType
name|src_type
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|rgba
parameter_list|)
block|{
name|gboolean
name|has_alpha
init|=
name|FALSE
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|src_image
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_type
condition|)
block|{
case|case
name|GIMP_RGBA_IMAGE
case|:
name|has_alpha
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_RGB_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|has_alpha
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_GRAY_IMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|has_alpha
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_INDEXED_IMAGE
case|:
comment|/*  Indexed palette lookup  */
block|{
name|gint
name|index
init|=
operator|*
name|src
operator|++
operator|*
literal|3
decl_stmt|;
operator|*
name|rgba
operator|++
operator|=
name|src_image
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
name|src_image
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
operator|*
name|rgba
operator|++
operator|=
name|src_image
operator|->
name|cmap
index|[
name|index
operator|++
index|]
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|has_alpha
condition|)
operator|*
name|rgba
operator|=
operator|*
name|src
expr_stmt|;
else|else
operator|*
name|rgba
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_rgb (const GimpImage * dest_image,const GimpDrawable * dest_drawable,const GimpRGB * rgb,guchar * color)
name|gimp_image_transform_rgb
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|dest_image
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|dest_drawable
parameter_list|,
specifier|const
name|GimpRGB
modifier|*
name|rgb
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|)
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|dest_image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|!
name|dest_drawable
operator|||
name|GIMP_IS_DRAWABLE
argument_list|(
name|dest_drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|rgb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|color
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
name|rgb
argument_list|,
operator|&
name|col
index|[
literal|0
index|]
argument_list|,
operator|&
name|col
index|[
literal|1
index|]
argument_list|,
operator|&
name|col
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|dest_image
argument_list|,
name|dest_drawable
argument_list|,
name|color
argument_list|,
name|GIMP_RGB
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_color (const GimpImage * dest_image,const GimpDrawable * dest_drawable,guchar * dest,GimpImageBaseType src_type,const guchar * src)
name|gimp_image_transform_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|dest_image
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|dest_drawable
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|GimpImageBaseType
name|src_type
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src
parameter_list|)
block|{
name|GimpImageType
name|dest_type
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|dest_image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|src_type
operator|!=
name|GIMP_INDEXED
argument_list|)
expr_stmt|;
name|dest_type
operator|=
operator|(
name|dest_drawable
condition|?
name|gimp_drawable_type
argument_list|(
name|dest_drawable
argument_list|)
else|:
name|gimp_image_base_type_with_alpha
argument_list|(
name|dest_image
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|src_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
case|case
name|GIMP_RGBA_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_GRAYA_IMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|GIMP_RGB_LUMINANCE
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
operator|+
literal|0.5
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|gimp_image_color_hash_rgb_to_indexed
argument_list|(
name|dest_image
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GIMP_GRAY
case|:
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
case|case
name|GIMP_RGBA_IMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_GRAYA_IMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|gimp_image_color_hash_rgb_to_indexed
argument_list|(
name|dest_image
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimp_image_transform_temp_buf (const GimpImage * dest_image,const GimpDrawable * dest_drawable,TempBuf * temp_buf,gboolean * new_buf)
name|gimp_image_transform_temp_buf
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|dest_image
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|dest_drawable
parameter_list|,
name|TempBuf
modifier|*
name|temp_buf
parameter_list|,
name|gboolean
modifier|*
name|new_buf
parameter_list|)
block|{
name|TempBuf
modifier|*
name|ret_buf
decl_stmt|;
name|GimpImageType
name|ret_buf_type
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gboolean
name|is_rgb
decl_stmt|;
name|gint
name|in_bytes
decl_stmt|;
name|gint
name|out_bytes
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|dest_image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|dest_drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|temp_buf
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|new_buf
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|in_bytes
operator|=
name|temp_buf
operator|->
name|bytes
expr_stmt|;
name|has_alpha
operator|=
operator|(
name|in_bytes
operator|==
literal|2
operator|||
name|in_bytes
operator|==
literal|4
operator|)
expr_stmt|;
name|is_rgb
operator|=
operator|(
name|in_bytes
operator|==
literal|3
operator|||
name|in_bytes
operator|==
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
name|ret_buf_type
operator|=
name|gimp_drawable_type_with_alpha
argument_list|(
name|dest_drawable
argument_list|)
expr_stmt|;
else|else
name|ret_buf_type
operator|=
name|gimp_drawable_type_without_alpha
argument_list|(
name|dest_drawable
argument_list|)
expr_stmt|;
name|out_bytes
operator|=
name|GIMP_IMAGE_TYPE_BYTES
argument_list|(
name|ret_buf_type
argument_list|)
expr_stmt|;
comment|/*  If the pattern doesn't match the image in terms of color type,    *  transform it.  (ie  pattern is RGB, image is indexed)    */
if|if
condition|(
name|in_bytes
operator|!=
name|out_bytes
operator|||
name|gimp_drawable_is_indexed
argument_list|(
name|dest_drawable
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|ret_buf
operator|=
name|temp_buf_new
argument_list|(
name|temp_buf
operator|->
name|width
argument_list|,
name|temp_buf
operator|->
name|height
argument_list|,
name|out_bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|src
operator|=
name|temp_buf_data
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
name|dest
operator|=
name|temp_buf_data
argument_list|(
name|ret_buf
argument_list|)
expr_stmt|;
name|size
operator|=
name|temp_buf
operator|->
name|width
operator|*
name|temp_buf
operator|->
name|height
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|gimp_image_transform_color
argument_list|(
name|dest_image
argument_list|,
name|dest_drawable
argument_list|,
name|dest
argument_list|,
name|is_rgb
condition|?
name|GIMP_RGB
else|:
name|GIMP_GRAY
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Handle alpha */
if|if
condition|(
name|has_alpha
condition|)
name|dest
index|[
name|out_bytes
operator|-
literal|1
index|]
operator|=
name|src
index|[
name|in_bytes
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|+=
name|in_bytes
expr_stmt|;
name|dest
operator|+=
name|out_bytes
expr_stmt|;
block|}
operator|*
name|new_buf
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ret_buf
operator|=
name|temp_buf
expr_stmt|;
operator|*
name|new_buf
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|ret_buf
return|;
block|}
end_function

begin_comment
comment|/*  shadow tiles  */
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_get_shadow_tiles (GimpImage * image,gint width,gint height,gint bpp)
name|gimp_image_get_shadow_tiles
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|shadow
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|image
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|image
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tile_manager_bpp
argument_list|(
name|image
operator|->
name|shadow
argument_list|)
operator|)
condition|)
block|{
name|gimp_image_free_shadow_tiles
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|image
operator|->
name|shadow
return|;
block|}
block|}
name|image
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_free_shadow_tiles (GimpImage * image)
name|gimp_image_free_shadow_tiles
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|shadow
condition|)
block|{
name|tile_manager_unref
argument_list|(
name|image
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|image
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  parasites  */
end_comment

begin_function
specifier|const
name|GimpParasite
modifier|*
DECL|function|gimp_image_parasite_find (const GimpImage * image,const gchar * name)
name|gimp_image_parasite_find
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimp_parasite_list_find
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|list_func (gchar * key,GimpParasite * p,gchar *** cur)
name|list_func
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|GimpParasite
modifier|*
name|p
parameter_list|,
name|gchar
modifier|*
modifier|*
modifier|*
name|cur
parameter_list|)
block|{
operator|*
operator|(
operator|*
name|cur
operator|)
operator|++
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gchar
modifier|*
modifier|*
DECL|function|gimp_image_parasite_list (const GimpImage * image,gint * count)
name|gimp_image_parasite_list
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
modifier|*
name|count
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|list
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|cur
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|gimp_parasite_list_length
argument_list|(
name|image
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|cur
operator|=
name|list
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
name|gimp_parasite_list_foreach
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
operator|(
name|GHFunc
operator|)
name|list_func
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_attach (GimpImage * image,const GimpParasite * parasite)
name|gimp_image_parasite_attach
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpParasite
modifier|*
name|parasite
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|copy
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  make a temp copy of the struct because    *  gimp_parasite_shift_parent() changes it    */
name|copy
operator|=
name|g_memdup
argument_list|(
name|parasite
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpParasite
argument_list|)
argument_list|)
expr_stmt|;
comment|/* only set the dirty bit manually if we can be saved and the new      parasite differs from the current one and we aren't undoable */
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|copy
argument_list|)
condition|)
name|gimp_image_undo_push_image_parasite
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Attach Parasite to Image"
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
comment|/*  We used to push an cantundo on te stack here. This made the undo stack       unusable (NULL on the stack) and prevented people from undoing after a       save (since most save plug-ins attach an undoable comment parasite).       Now we simply attach the parasite without pushing an undo. That way it's       undoable but does not block the undo system.   --Sven    */
name|gimp_parasite_list_add
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_parasite_has_flag
argument_list|(
name|copy
argument_list|,
name|GIMP_PARASITE_ATTACH_PARENT
argument_list|)
condition|)
block|{
name|gimp_parasite_shift_parent
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|gimp_parasite_attach
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_detach (GimpImage * image,const gchar * name)
name|gimp_image_parasite_detach
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parasite
operator|=
name|gimp_parasite_list_find
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|parasite
argument_list|)
condition|)
name|gimp_image_undo_push_image_parasite_remove
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Remove Parasite from Image"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_parasite_list_remove
argument_list|(
name|image
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  tattoos  */
end_comment

begin_function
name|GimpTattoo
DECL|function|gimp_image_get_new_tattoo (GimpImage * image)
name|gimp_image_get_new_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|image
operator|->
name|tattoo_state
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|tattoo_state
operator|<=
literal|0
condition|)
name|g_warning
argument_list|(
literal|"%s: Tattoo state corrupted (integer overflow)."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|tattoo_state
return|;
block|}
end_function

begin_function
name|GimpTattoo
DECL|function|gimp_image_get_tattoo_state (GimpImage * image)
name|gimp_image_get_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|tattoo_state
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_set_tattoo_state (GimpImage * image,GimpTattoo val)
name|gimp_image_set_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpTattoo
name|val
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|gboolean
name|retval
init|=
name|TRUE
decl_stmt|;
name|GimpTattoo
name|maxval
init|=
literal|0
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Check that the layer tatoos don't overlap with channel or vector ones */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|ltattoo
decl_stmt|;
name|ltattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ltattoo
expr_stmt|;
if|if
condition|(
name|gimp_image_get_channel_by_tattoo
argument_list|(
name|image
argument_list|,
name|ltattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in channel */
if|if
condition|(
name|gimp_image_get_vectors_by_tattoo
argument_list|(
name|image
argument_list|,
name|ltattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in vectors */
block|}
comment|/* Now check that the channel and vectors tattoos don't overlap */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|ctattoo
decl_stmt|;
name|ctattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ctattoo
expr_stmt|;
if|if
condition|(
name|gimp_image_get_vectors_by_tattoo
argument_list|(
name|image
argument_list|,
name|ctattoo
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in vectors */
block|}
comment|/* Find the max tattoo value in the vectors */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpTattoo
name|vtattoo
decl_stmt|;
name|vtattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|vtattoo
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|maxval
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Must check if the state is valid */
if|if
condition|(
name|retval
operator|==
name|TRUE
condition|)
name|image
operator|->
name|tattoo_state
operator|=
name|val
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  layers / channels / vectors  */
end_comment

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_layers (const GimpImage * image)
name|gimp_image_get_layers
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|layers
return|;
block|}
end_function

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_channels (const GimpImage * image)
name|gimp_image_get_channels
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|channels
return|;
block|}
end_function

begin_function
name|GimpContainer
modifier|*
DECL|function|gimp_image_get_vectors (const GimpImage * image)
name|gimp_image_get_vectors
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|vectors
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_image_active_drawable (const GimpImage * image)
name|gimp_image_active_drawable
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|image
operator|->
name|active_channel
condition|)
block|{
return|return
name|GIMP_DRAWABLE
argument_list|(
name|image
operator|->
name|active_channel
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|->
name|active_layer
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|image
operator|->
name|active_layer
decl_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|mask
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_active_layer (const GimpImage * image)
name|gimp_image_get_active_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_active_channel (const GimpImage * image)
name|gimp_image_get_active_channel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_active_vectors (const GimpImage * image)
name|gimp_image_get_active_vectors
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|active_vectors
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_set_active_layer (GimpImage * image,GimpLayer * layer)
name|gimp_image_set_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|==
name|NULL
operator|||
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|==
name|NULL
operator|||
name|gimp_container_have
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|floating_sel
operator|=
name|gimp_image_floating_sel
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*  Make sure the floating_sel always is the active layer  */
if|if
condition|(
name|floating_sel
operator|&&
name|layer
operator|!=
name|floating_sel
condition|)
return|return
name|floating_sel
return|;
if|if
condition|(
name|layer
operator|!=
name|image
operator|->
name|active_layer
condition|)
block|{
if|if
condition|(
name|layer
condition|)
block|{
comment|/*  Configure the layer stack to reflect this change  */
name|image
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|image
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|image
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't cache selection info for the previous active layer  */
if|if
condition|(
name|image
operator|->
name|active_layer
condition|)
name|gimp_drawable_invalidate_boundary
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|image
operator|->
name|active_layer
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&&
name|image
operator|->
name|active_channel
condition|)
name|gimp_image_set_active_channel
argument_list|(
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|image
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_set_active_channel (GimpImage * image,GimpChannel * channel)
name|gimp_image_set_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|==
name|NULL
operator|||
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|==
name|NULL
operator|||
name|gimp_container_have
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|channel
operator|&&
name|gimp_image_floating_sel
argument_list|(
name|image
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|channel
operator|!=
name|image
operator|->
name|active_channel
condition|)
block|{
name|image
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|&&
name|image
operator|->
name|active_layer
condition|)
name|gimp_image_set_active_layer
argument_list|(
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|image
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_unset_active_channel (GimpImage * image)
name|gimp_image_unset_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|gimp_image_set_active_channel
argument_list|(
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|layer_stack
condition|)
name|gimp_image_set_active_layer
argument_list|(
name|image
argument_list|,
name|image
operator|->
name|layer_stack
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|channel
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_set_active_vectors (GimpImage * image,GimpVectors * vectors)
name|gimp_image_set_active_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|vectors
operator|==
name|NULL
operator|||
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|vectors
operator|==
name|NULL
operator|||
name|gimp_container_have
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
operator|!=
name|image
operator|->
name|active_vectors
condition|)
block|{
name|image
operator|->
name|active_vectors
operator|=
name|vectors
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|image
operator|->
name|active_vectors
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_layer_changed (GimpImage * image)
name|gimp_image_active_layer_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_LAYER_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_channel_changed (GimpImage * image)
name|gimp_image_active_channel_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_CHANNEL_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_active_vectors_changed (GimpImage * image)
name|gimp_image_active_vectors_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|image
argument_list|,
name|gimp_image_signals
index|[
name|ACTIVE_VECTORS_CHANGED
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_layer_index (const GimpImage * image,const GimpLayer * layer)
name|gimp_image_get_layer_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_channel_index (const GimpImage * image,const GimpChannel * channel)
name|gimp_image_get_channel_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_vectors_index (const GimpImage * image,const GimpVectors * vectors)
name|gimp_image_get_vectors_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_layer_by_tattoo (const GimpImage * image,GimpTattoo tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|layer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_tattoo (const GimpImage * image,GimpTattoo tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpChannel
modifier|*
name|channel
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|channel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_vectors_by_tattoo (const GimpImage * image,GimpTattoo tattoo)
name|gimp_image_get_vectors_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpTattoo
name|tattoo
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpVectors
modifier|*
name|vectors
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|vectors
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_layer_by_name (const GimpImage * image,const gchar * name)
name|gimp_image_get_layer_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_name (const GimpImage * image,const gchar * name)
name|gimp_image_get_channel_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpVectors
modifier|*
DECL|function|gimp_image_get_vectors_by_name (const GimpImage * image,const gchar * name)
name|gimp_image_get_vectors_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_name
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_layer (GimpImage * image,GimpLayer * layer,gint position)
name|gimp_image_add_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|active_layer
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|gboolean
name|old_has_alpha
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|image
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|image
operator|!=
name|image
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add layer to wrong image."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add layer to image twice."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|floating_sel
operator|=
name|gimp_image_floating_sel
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_sel
operator|&&
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add floating layer to image which alyready "
literal|"has a floating selection."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|active_layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|old_has_alpha
operator|=
name|gimp_image_has_alpha
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_layer_add
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Add Layer"
argument_list|)
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|,
name|active_layer
argument_list|)
expr_stmt|;
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|image
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|active_layer
condition|)
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_layer
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  If there is a floating selection (and this isn't it!),    *  make sure the insert position is greater than 0    */
if|if
condition|(
name|position
operator|==
literal|0
operator|&&
name|floating_sel
condition|)
name|position
operator|=
literal|1
expr_stmt|;
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_item_sink
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimp_image_set_active_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_has_alpha
operator|!=
name|gimp_image_has_alpha
argument_list|(
name|image
argument_list|)
condition|)
name|gimp_image_alpha_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|gimp_image_floating_selection_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_layer (GimpImage * image,GimpLayer * layer)
name|gimp_image_remove_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|active_layer
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gboolean
name|old_has_alpha
decl_stmt|;
name|gboolean
name|undo_group
init|=
name|FALSE
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_floating_sel
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_IMAGE_ITEM_REMOVE
argument_list|,
name|_
argument_list|(
literal|"Remove Layer"
argument_list|)
argument_list|)
expr_stmt|;
name|undo_group
operator|=
name|TRUE
expr_stmt|;
name|floating_sel_remove
argument_list|(
name|gimp_image_floating_sel
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|active_layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|old_has_alpha
operator|=
name|gimp_image_has_alpha
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_layer_remove
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Remove Layer"
argument_list|)
argument_list|,
name|layer
argument_list|,
name|index
argument_list|,
name|active_layer
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Make sure we're not caching any old selection info  */
if|if
condition|(
name|layer
operator|==
name|active_layer
condition|)
name|gimp_drawable_invalidate_boundary
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|image
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
comment|/*  If this was the floating selection, reset the fs pointer        *  and activate the underlying drawable        */
name|image
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_activate_drawable
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimp_image_floating_selection_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|layer
operator|==
name|active_layer
condition|)
block|{
if|if
condition|(
name|image
operator|->
name|layer_stack
condition|)
block|{
name|active_layer
operator|=
name|image
operator|->
name|layer_stack
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|gint
name|n_children
init|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_children
operator|>
literal|0
condition|)
block|{
name|index
operator|=
name|CLAMP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|n_children
operator|-
literal|1
argument_list|)
expr_stmt|;
name|active_layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|active_layer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|gimp_image_set_active_layer
argument_list|(
name|image
argument_list|,
name|active_layer
argument_list|)
expr_stmt|;
block|}
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_has_alpha
operator|!=
name|gimp_image_has_alpha
argument_list|(
name|image
argument_list|)
condition|)
name|gimp_image_alpha_changed
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|undo_group
condition|)
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer (GimpImage * image,GimpLayer * layer)
name|gimp_image_raise_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|index
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Layer"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer (GimpImage * image,GimpLayer * layer)
name|gimp_image_lower_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Layer"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer_to_top (GimpImage * image,GimpLayer * layer)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimp_image_position_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Layer to Top"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer_to_bottom (GimpImage * image,GimpLayer * layer)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
expr_stmt|;
return|return
name|gimp_image_position_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Layer to Bottom"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_layer (GimpImage * image,GimpLayer * layer,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_layer
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_layers
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_layers
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|layers
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|CLAMP
argument_list|(
name|new_index
argument_list|,
literal|0
argument_list|,
name|num_layers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_layer_reposition
argument_list|(
name|image
argument_list|,
name|undo_desc
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|image
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|image
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_channel (GimpImage * image,GimpChannel * channel,gint position)
name|gimp_image_add_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|active_channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|image
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|image
operator|!=
name|image
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add channel to wrong image."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add channel to image twice."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|active_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_channel_add
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Add Channel"
argument_list|)
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|,
name|active_channel
argument_list|)
expr_stmt|;
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|active_channel
condition|)
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_channel
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_item_sink
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify this image of the currently active channel  */
name|gimp_image_set_active_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_channel (GimpImage * image,GimpChannel * channel)
name|gimp_image_remove_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|active_channel
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gboolean
name|undo_group
init|=
name|FALSE
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_floating_sel
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_IMAGE_ITEM_REMOVE
argument_list|,
name|_
argument_list|(
literal|"Remove Channel"
argument_list|)
argument_list|)
expr_stmt|;
name|undo_group
operator|=
name|TRUE
expr_stmt|;
name|floating_sel_remove
argument_list|(
name|gimp_image_floating_sel
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|active_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_channel_remove
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Remove Channel"
argument_list|)
argument_list|,
name|channel
argument_list|,
name|index
argument_list|,
name|active_channel
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|active_channel
condition|)
block|{
name|gint
name|n_children
init|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_children
operator|>
literal|0
condition|)
block|{
name|index
operator|=
name|CLAMP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|n_children
operator|-
literal|1
argument_list|)
expr_stmt|;
name|active_channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|gimp_image_set_active_channel
argument_list|(
name|image
argument_list|,
name|active_channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_unset_active_channel
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
name|g_object_unref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|undo_group
condition|)
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_channel (GimpImage * image,GimpChannel * channel)
name|gimp_image_raise_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
name|index
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Channel"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_channel_to_top (GimpImage * image,GimpChannel * channel)
name|gimp_image_raise_channel_to_top
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel is already on top."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Channel to Top"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_channel (GimpImage * image,GimpChannel * channel)
name|gimp_image_lower_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Channel"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_channel_to_bottom (GimpImage * image,GimpChannel * channel)
name|gimp_image_lower_channel_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel is already on the bottom."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Channel to Bottom"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_channel (GimpImage * image,GimpChannel * channel,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_channel
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_channels
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_channels
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|channels
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|CLAMP
argument_list|(
name|new_index
argument_list|,
literal|0
argument_list|,
name|num_channels
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_channel_reposition
argument_list|(
name|image
argument_list|,
name|undo_desc
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|image
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gimp_image_update
argument_list|(
name|image
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|gimp_item_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_vectors (GimpImage * image,GimpVectors * vectors,gint position)
name|gimp_image_add_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
operator|->
name|image
operator|!=
name|NULL
operator|&&
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
operator|->
name|image
operator|!=
name|image
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: attempting to add vectors to wrong image."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: trying to add vectors to image twice."
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|active_vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_vectors_add
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Add Path"
argument_list|)
argument_list|,
name|vectors
argument_list|,
literal|0
argument_list|,
name|active_vectors
argument_list|)
expr_stmt|;
name|gimp_item_set_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|active_vectors
condition|)
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_vectors
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  Don't add at a non-existing index  */
if|if
condition|(
name|position
operator|>
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
condition|)
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_insert
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_item_sink
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify this image of the currently active vectors  */
name|gimp_image_set_active_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_vectors (GimpImage * image,GimpVectors * vectors)
name|gimp_image_remove_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|active_vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_push_vectors_remove
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Remove Path"
argument_list|)
argument_list|,
name|vectors
argument_list|,
name|index
argument_list|,
name|active_vectors
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_removed
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
name|active_vectors
condition|)
block|{
name|gint
name|n_children
init|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_children
operator|>
literal|0
condition|)
block|{
name|index
operator|=
name|CLAMP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|n_children
operator|-
literal|1
argument_list|)
expr_stmt|;
name|active_vectors
operator|=
operator|(
name|GimpVectors
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|active_vectors
operator|=
name|NULL
expr_stmt|;
block|}
name|gimp_image_set_active_vectors
argument_list|(
name|image
argument_list|,
name|active_vectors
argument_list|)
expr_stmt|;
block|}
name|g_object_unref
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_vectors (GimpImage * image,GimpVectors * vectors)
name|gimp_image_raise_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path cannot be raised higher."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|index
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Path"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_vectors_to_top (GimpImage * image,GimpVectors * vectors)
name|gimp_image_raise_vectors_to_top
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path is already on top."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Raise Path to Top"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_vectors (GimpImage * image,GimpVectors * vectors)
name|gimp_image_lower_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path cannot be lowered more."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Path"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_vectors_to_bottom (GimpImage * image,GimpVectors * vectors)
name|gimp_image_lower_vectors_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Path is already on the bottom."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Lower Path to Bottom"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_vectors (GimpImage * image,GimpVectors * vectors,gint new_index,gboolean push_undo,const gchar * undo_desc)
name|gimp_image_position_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpVectors
modifier|*
name|vectors
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_vectors
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_VECTORS
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_vectors
operator|=
name|gimp_container_num_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|CLAMP
argument_list|(
name|new_index
argument_list|,
literal|0
argument_list|,
name|num_vectors
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|push_undo
condition|)
name|gimp_image_undo_push_vectors_reposition
argument_list|(
name|image
argument_list|,
name|undo_desc
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_layer_boundary (const GimpImage * image,BoundSeg ** segs,gint * n_segs)
name|gimp_image_layer_boundary
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|gint
modifier|*
name|n_segs
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
operator|*
name|segs
operator|=
name|gimp_layer_boundary
argument_list|(
name|layer
argument_list|,
name|n_segs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|n_segs
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_pick_correlate_layer (const GimpImage * image,gint x,gint y)
name|gimp_image_pick_correlate_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|image
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|list
operator|->
name|data
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_pickable_get_opacity_at
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|x
operator|-
name|off_x
argument_list|,
name|y
operator|-
name|off_y
argument_list|)
operator|>
literal|63
condition|)
block|{
return|return
name|layer
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_coords_in_active_drawable (GimpImage * image,const GimpCoords * coords)
name|gimp_image_coords_in_active_drawable
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|)
block|{
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
condition|)
block|{
name|GimpItem
modifier|*
name|item
init|=
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|item
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|ROUND
argument_list|(
name|coords
operator|->
name|x
argument_list|)
operator|-
name|x
expr_stmt|;
name|y
operator|=
name|ROUND
argument_list|(
name|coords
operator|->
name|y
argument_list|)
operator|-
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
name|gimp_item_width
argument_list|(
name|item
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>
name|gimp_item_height
argument_list|(
name|item
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_layer_previews (GimpImage * image)
name|gimp_image_invalidate_layer_previews
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_channel_previews (GimpImage * image)
name|gimp_image_invalidate_channel_previews
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|image
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

