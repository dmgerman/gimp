begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * gimpbrush-transform.c  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gdk-pixbuf/gdk-pixbuf.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-gegl-loops.h"
end_include

begin_include
include|#
directive|include
file|"gimpbrush.h"
end_include

begin_include
include|#
directive|include
file|"gimpbrush-transform.h"
end_include

begin_include
include|#
directive|include
file|"gimptempbuf.h"
end_include

begin_define
DECL|macro|MAX_BLUR_KERNEL
define|#
directive|define
name|MAX_BLUR_KERNEL
value|50
end_define

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_brush_transform_bounding_box
parameter_list|(
name|GimpBrush
modifier|*
name|brush
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_brush_transform_blur
parameter_list|(
name|GimpTempBuf
modifier|*
name|buf
parameter_list|,
name|gint
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|gimp_brush_transform_blur_kernel_size
parameter_list|(
name|gint
name|height
parameter_list|,
name|gint
name|width
parameter_list|,
name|gdouble
name|hardness
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_brush_transform_adjust_hardness_matrix
parameter_list|(
name|gdouble
name|width
parameter_list|,
name|gdouble
name|height
parameter_list|,
name|gdouble
name|kernel_size
parameter_list|,
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|void
DECL|function|gimp_brush_real_transform_size (GimpBrush * brush,gdouble scale,gdouble aspect_ratio,gdouble angle,gint * width,gint * height)
name|gimp_brush_real_transform_size
parameter_list|(
name|GimpBrush
modifier|*
name|brush
parameter_list|,
name|gdouble
name|scale
parameter_list|,
name|gdouble
name|aspect_ratio
parameter_list|,
name|gdouble
name|angle
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
block|{
name|GimpMatrix3
name|matrix
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gimp_brush_transform_matrix
argument_list|(
name|gimp_brush_get_width
argument_list|(
name|brush
argument_list|)
argument_list|,
name|gimp_brush_get_height
argument_list|(
name|brush
argument_list|)
argument_list|,
name|scale
argument_list|,
name|aspect_ratio
argument_list|,
name|angle
argument_list|,
operator|&
name|matrix
argument_list|)
expr_stmt|;
name|gimp_brush_transform_bounding_box
argument_list|(
name|brush
argument_list|,
operator|&
name|matrix
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transforms the brush mask with bilinear interpolation.  *  * Rather than calculating the inverse transform for each point in the  * transformed image, this algorithm uses the inverse transformed  * corner points of the destination image to work out the starting  * position in the source image and the U and V deltas in the source  * image space.  It then uses a scan-line approach, looping through  * rows and colummns in the transformed (destination) image while  * walking along the corresponding rows and columns (named U and V) in  * the source image.  *  * The horizontal in destination space (transform result) is reverse  * transformed into source image space to get U.  The vertical in  * destination space (transform result) is reverse transformed into  * source image space to get V.  *  * The strength of this particular algorithm is that calculation work  * should depend more upon the final transformed brush size rather  * than the input brush size.  *  * There are no floating point calculations in the inner loop for speed.  *  * Some variables end with the suffix _i to indicate they have been  * premultiplied by int_multiple  */
end_comment

begin_function
name|GimpTempBuf
modifier|*
DECL|function|gimp_brush_real_transform_mask (GimpBrush * brush,gdouble scale,gdouble aspect_ratio,gdouble angle,gdouble hardness)
name|gimp_brush_real_transform_mask
parameter_list|(
name|GimpBrush
modifier|*
name|brush
parameter_list|,
name|gdouble
name|scale
parameter_list|,
name|gdouble
name|aspect_ratio
parameter_list|,
name|gdouble
name|angle
parameter_list|,
name|gdouble
name|hardness
parameter_list|)
block|{
name|GimpTempBuf
modifier|*
name|result
decl_stmt|;
name|GimpTempBuf
modifier|*
name|source
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src
decl_stmt|;
name|GimpMatrix3
name|matrix
decl_stmt|;
name|gint
name|src_width
decl_stmt|;
name|gint
name|src_height
decl_stmt|;
name|gint
name|src_width_minus_one
decl_stmt|;
name|gint
name|src_height_minus_one
decl_stmt|;
name|gint
name|dest_width
decl_stmt|;
name|gint
name|dest_height
decl_stmt|;
name|gint
name|kernel_size
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdouble
name|blx
decl_stmt|,
name|brx
decl_stmt|,
name|tlx
decl_stmt|,
name|trx
decl_stmt|;
name|gdouble
name|bly
decl_stmt|,
name|bry
decl_stmt|,
name|tly
decl_stmt|,
name|try
decl_stmt|;
name|gdouble
name|src_tl_to_tr_delta_x
decl_stmt|;
name|gdouble
name|src_tl_to_tr_delta_y
decl_stmt|;
name|gdouble
name|src_tl_to_bl_delta_x
decl_stmt|;
name|gdouble
name|src_tl_to_bl_delta_y
decl_stmt|;
name|gint
name|src_walk_ux_i
decl_stmt|;
name|gint
name|src_walk_uy_i
decl_stmt|;
name|gint
name|src_walk_vx_i
decl_stmt|;
name|gint
name|src_walk_vy_i
decl_stmt|;
name|gint
name|src_space_cur_pos_x
decl_stmt|;
name|gint
name|src_space_cur_pos_y
decl_stmt|;
name|gint
name|src_space_cur_pos_x_i
decl_stmt|;
name|gint
name|src_space_cur_pos_y_i
decl_stmt|;
name|gint
name|src_space_row_start_x_i
decl_stmt|;
name|gint
name|src_space_row_start_y_i
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src_walker
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_next
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_below
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_below_next
decl_stmt|;
name|gint
name|opposite_x
decl_stmt|,
name|distance_from_true_x
decl_stmt|;
name|gint
name|opposite_y
decl_stmt|,
name|distance_from_true_y
decl_stmt|;
comment|/*    * tl, tr etc are used because it is easier to visualize top left,    * top right etc corners of the forward transformed source image    * rectangle.    */
specifier|const
name|gint
name|fraction_bits
init|=
literal|12
decl_stmt|;
specifier|const
name|gint
name|int_multiple
init|=
name|pow
argument_list|(
literal|2
argument_list|,
name|fraction_bits
argument_list|)
decl_stmt|;
comment|/* In inner loop's bilinear calculation, two numbers that were each    * previously multiplied by int_multiple are multiplied together.    * To get back the right result, the multiplication result must be    * divided *twice* by 2^fraction_bits, equivalent to bit shift right    * by 2 * fraction_bits    */
specifier|const
name|gint
name|recovery_bits
init|=
literal|2
operator|*
name|fraction_bits
decl_stmt|;
comment|/*    * example: suppose fraction_bits = 9    * a 9-bit mask looks like this: 0001 1111 1111    * and is given by:  2^fraction_bits - 1    * demonstration:    * 2^0     = 0000 0000 0001    * 2^1     = 0000 0000 0010    * :    * 2^8     = 0001 0000 0000    * 2^9     = 0010 0000 0000    * 2^9 - 1 = 0001 1111 1111    */
specifier|const
name|guint
name|fraction_bitmask
init|=
name|pow
argument_list|(
literal|2
argument_list|,
name|fraction_bits
argument_list|)
operator|-
literal|1
decl_stmt|;
name|source
operator|=
name|gimp_brush_get_mask
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|src_width
operator|=
name|gimp_brush_get_width
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|src_height
operator|=
name|gimp_brush_get_height
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|gimp_brush_transform_matrix
argument_list|(
name|src_width
argument_list|,
name|src_height
argument_list|,
name|scale
argument_list|,
name|aspect_ratio
argument_list|,
name|angle
argument_list|,
operator|&
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_matrix3_is_identity
argument_list|(
operator|&
name|matrix
argument_list|)
operator|&&
name|hardness
operator|==
literal|1.0
condition|)
return|return
name|gimp_temp_buf_copy
argument_list|(
name|source
argument_list|)
return|;
name|src_width_minus_one
operator|=
name|src_width
operator|-
literal|1
expr_stmt|;
name|src_height_minus_one
operator|=
name|src_height
operator|-
literal|1
expr_stmt|;
name|gimp_brush_transform_bounding_box
argument_list|(
name|brush
argument_list|,
operator|&
name|matrix
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|dest_width
argument_list|,
operator|&
name|dest_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|hardness
operator|<
literal|1.0
condition|)
block|{
name|kernel_size
operator|=
name|gimp_brush_transform_blur_kernel_size
argument_list|(
name|dest_width
argument_list|,
name|dest_height
argument_list|,
name|hardness
argument_list|)
expr_stmt|;
name|gimp_brush_transform_adjust_hardness_matrix
argument_list|(
name|dest_width
argument_list|,
name|dest_height
argument_list|,
name|kernel_size
argument_list|,
operator|&
name|matrix
argument_list|)
expr_stmt|;
block|}
name|gimp_matrix3_translate
argument_list|(
operator|&
name|matrix
argument_list|,
operator|-
name|x
argument_list|,
operator|-
name|y
argument_list|)
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
operator|&
name|matrix
argument_list|)
expr_stmt|;
name|result
operator|=
name|gimp_temp_buf_new
argument_list|(
name|dest_width
argument_list|,
name|dest_height
argument_list|,
name|gimp_temp_buf_get_format
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gimp_temp_buf_get_data
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|src
operator|=
name|gimp_temp_buf_get_data
argument_list|(
name|source
argument_list|)
expr_stmt|;
comment|/* prevent disappearance of 1x1 pixel brush at some rotations when      scaling< 1 */
comment|/*   if (src_width == 1&& src_height == 1&& scale_x< 1&& scale_y< 1 )     {       *dest = src[0];       return result;     }*/
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tlx
argument_list|,
operator|&
name|tly
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
name|dest_width
argument_list|,
literal|0
argument_list|,
operator|&
name|trx
argument_list|,
operator|&
name|try
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
literal|0
argument_list|,
name|dest_height
argument_list|,
operator|&
name|blx
argument_list|,
operator|&
name|bly
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
name|dest_width
argument_list|,
name|dest_height
argument_list|,
operator|&
name|brx
argument_list|,
operator|&
name|bry
argument_list|)
expr_stmt|;
comment|/* in image space, calc U (what was horizontal originally)    * note: double precision    */
name|src_tl_to_tr_delta_x
operator|=
name|trx
operator|-
name|tlx
expr_stmt|;
name|src_tl_to_tr_delta_y
operator|=
name|try
operator|-
name|tly
expr_stmt|;
comment|/* in image space, calc V (what was vertical originally)    * note: double precision    */
name|src_tl_to_bl_delta_x
operator|=
name|blx
operator|-
name|tlx
expr_stmt|;
name|src_tl_to_bl_delta_y
operator|=
name|bly
operator|-
name|tly
expr_stmt|;
comment|/* speed optimized, note conversion to int precision */
name|src_walk_ux_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_tr_delta_x
operator|/
name|dest_width
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_uy_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_tr_delta_y
operator|/
name|dest_width
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_vx_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_bl_delta_x
operator|/
name|dest_height
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_vy_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_bl_delta_y
operator|/
name|dest_height
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
comment|/* initialize current position in source space to the start position (tl)    * speed optimized, note conversion to int precision    */
name|src_space_cur_pos_x_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tlx
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_cur_pos_y_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tly
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_cur_pos_x
operator|=
call|(
name|gint
call|)
argument_list|(
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
argument_list|)
expr_stmt|;
name|src_space_cur_pos_y
operator|=
call|(
name|gint
call|)
argument_list|(
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
argument_list|)
expr_stmt|;
name|src_space_row_start_x_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tlx
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_row_start_y_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tly
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dest_height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dest_width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|src_space_cur_pos_x
operator|>
name|src_width_minus_one
operator|||
name|src_space_cur_pos_x
operator|<
literal|0
operator|||
name|src_space_cur_pos_y
operator|>
name|src_height_minus_one
operator|||
name|src_space_cur_pos_y
operator|<
literal|0
condition|)
comment|/* no corresponding pixel in source space */
block|{
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* reverse transformed point hits source pixel */
block|{
name|src_walker
operator|=
name|src
operator|+
name|src_space_cur_pos_y
operator|*
name|src_width
operator|+
name|src_space_cur_pos_x
expr_stmt|;
comment|/* bottom right corner                * no pixel below, reuse current pixel instead                * no next pixel to the right so reuse current pixel instead                */
if|if
condition|(
name|src_space_cur_pos_y
operator|==
name|src_height_minus_one
operator|&&
name|src_space_cur_pos_x
operator|==
name|src_width_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
expr_stmt|;
name|pixel_below_next
operator|=
name|src_walker
expr_stmt|;
block|}
comment|/* bottom edge pixel row, except rightmost corner                * no pixel below, reuse current pixel instead  */
elseif|else
if|if
condition|(
name|src_space_cur_pos_y
operator|==
name|src_height_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
operator|+
literal|1
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
expr_stmt|;
name|pixel_below_next
operator|=
name|src_walker
operator|+
literal|1
expr_stmt|;
block|}
comment|/* right edge pixel column, except bottom corner                * no next pixel to the right so reuse current pixel instead */
elseif|else
if|if
condition|(
name|src_space_cur_pos_x
operator|==
name|src_width_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
operator|+
name|src_width
expr_stmt|;
name|pixel_below_next
operator|=
name|pixel_below
expr_stmt|;
block|}
comment|/* neither on bottom edge nor on right edge */
else|else
block|{
name|pixel_next
operator|=
name|src_walker
operator|+
literal|1
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
operator|+
name|src_width
expr_stmt|;
name|pixel_below_next
operator|=
name|pixel_below
operator|+
literal|1
expr_stmt|;
block|}
name|distance_from_true_x
operator|=
name|src_space_cur_pos_x_i
operator|&
name|fraction_bitmask
expr_stmt|;
name|distance_from_true_y
operator|=
name|src_space_cur_pos_y_i
operator|&
name|fraction_bitmask
expr_stmt|;
name|opposite_x
operator|=
name|int_multiple
operator|-
name|distance_from_true_x
expr_stmt|;
name|opposite_y
operator|=
name|int_multiple
operator|-
name|distance_from_true_y
expr_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|(
name|src_walker
index|[
literal|0
index|]
operator|*
name|opposite_x
operator|+
name|pixel_next
index|[
literal|0
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|opposite_y
operator|+
operator|(
name|pixel_below
index|[
literal|0
index|]
operator|*
name|opposite_x
operator|+
name|pixel_below_next
index|[
literal|0
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|distance_from_true_y
operator|)
operator|>>
name|recovery_bits
expr_stmt|;
block|}
name|src_space_cur_pos_x_i
operator|+=
name|src_walk_ux_i
expr_stmt|;
name|src_space_cur_pos_y_i
operator|+=
name|src_walk_uy_i
expr_stmt|;
name|src_space_cur_pos_x
operator|=
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
expr_stmt|;
name|src_space_cur_pos_y
operator|=
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
expr_stmt|;
name|dest
operator|++
expr_stmt|;
block|}
comment|/* end for x */
name|src_space_row_start_x_i
operator|+=
name|src_walk_vx_i
expr_stmt|;
name|src_space_row_start_y_i
operator|+=
name|src_walk_vy_i
expr_stmt|;
name|src_space_cur_pos_x_i
operator|=
name|src_space_row_start_x_i
expr_stmt|;
name|src_space_cur_pos_y_i
operator|=
name|src_space_row_start_y_i
expr_stmt|;
name|src_space_cur_pos_x
operator|=
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
expr_stmt|;
name|src_space_cur_pos_y
operator|=
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
expr_stmt|;
block|}
comment|/* end for y */
if|if
condition|(
name|hardness
operator|<
literal|1.0
condition|)
block|{
name|gimp_brush_transform_blur
argument_list|(
name|result
argument_list|,
name|kernel_size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Transforms the brush pixmap with bilinear interpolation.  *  * The algorithm used is exactly the same as for the brush mask  * (gimp_brush_real_transform_mask) except it accounts for 3 color channels  *  instead of 1 grayscale channel.  *  * Rather than calculating the inverse transform for each point in the  * transformed image, this algorithm uses the inverse transformed  * corner points of the destination image to work out the starting  * position in the source image and the U and V deltas in the source  * image space.  It then uses a scan-line approach, looping through  * rows and colummns in the transformed (destination) image while  * walking along the corresponding rows and columns (named U and V) in  * the source image.  *  * The horizontal in destination space (transform result) is reverse  * transformed into source image space to get U.  The vertical in  * destination space (transform result) is reverse transformed into  * source image space to get V.  *  * The strength of this particular algorithm is that calculation work  * should depend more upon the final transformed brush size rather  * than the input brush size.  *  * There are no floating point calculations in the inner loop for speed.  *  * Some variables end with the suffix _i to indicate they have been  * premultiplied by int_multiple  */
end_comment

begin_function
name|GimpTempBuf
modifier|*
DECL|function|gimp_brush_real_transform_pixmap (GimpBrush * brush,gdouble scale,gdouble aspect_ratio,gdouble angle,gdouble hardness)
name|gimp_brush_real_transform_pixmap
parameter_list|(
name|GimpBrush
modifier|*
name|brush
parameter_list|,
name|gdouble
name|scale
parameter_list|,
name|gdouble
name|aspect_ratio
parameter_list|,
name|gdouble
name|angle
parameter_list|,
name|gdouble
name|hardness
parameter_list|)
block|{
name|GimpTempBuf
modifier|*
name|result
decl_stmt|;
name|GimpTempBuf
modifier|*
name|source
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src
decl_stmt|;
name|GimpMatrix3
name|matrix
decl_stmt|;
name|gint
name|src_width
decl_stmt|;
name|gint
name|src_height
decl_stmt|;
name|gint
name|src_width_minus_one
decl_stmt|;
name|gint
name|src_height_minus_one
decl_stmt|;
name|gint
name|dest_width
decl_stmt|;
name|gint
name|dest_height
decl_stmt|;
name|gint
name|kernel_size
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdouble
name|blx
decl_stmt|,
name|brx
decl_stmt|,
name|tlx
decl_stmt|,
name|trx
decl_stmt|;
name|gdouble
name|bly
decl_stmt|,
name|bry
decl_stmt|,
name|tly
decl_stmt|,
name|try
decl_stmt|;
name|gdouble
name|src_tl_to_tr_delta_x
decl_stmt|;
name|gdouble
name|src_tl_to_tr_delta_y
decl_stmt|;
name|gdouble
name|src_tl_to_bl_delta_x
decl_stmt|;
name|gdouble
name|src_tl_to_bl_delta_y
decl_stmt|;
name|gint
name|src_walk_ux_i
decl_stmt|;
name|gint
name|src_walk_uy_i
decl_stmt|;
name|gint
name|src_walk_vx_i
decl_stmt|;
name|gint
name|src_walk_vy_i
decl_stmt|;
name|gint
name|src_space_cur_pos_x
decl_stmt|;
name|gint
name|src_space_cur_pos_y
decl_stmt|;
name|gint
name|src_space_cur_pos_x_i
decl_stmt|;
name|gint
name|src_space_cur_pos_y_i
decl_stmt|;
name|gint
name|src_space_row_start_x_i
decl_stmt|;
name|gint
name|src_space_row_start_y_i
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src_walker
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_next
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_below
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|pixel_below_next
decl_stmt|;
name|gint
name|opposite_x
decl_stmt|,
name|distance_from_true_x
decl_stmt|;
name|gint
name|opposite_y
decl_stmt|,
name|distance_from_true_y
decl_stmt|;
comment|/*    * tl, tr etc are used because it is easier to visualize top left,    * top right etc corners of the forward transformed source image    * rectangle.    */
specifier|const
name|gint
name|fraction_bits
init|=
literal|12
decl_stmt|;
specifier|const
name|gint
name|int_multiple
init|=
name|pow
argument_list|(
literal|2
argument_list|,
name|fraction_bits
argument_list|)
decl_stmt|;
comment|/* In inner loop's bilinear calculation, two numbers that were each    * previously multiplied by int_multiple are multiplied together.    * To get back the right result, the multiplication result must be    * divided *twice* by 2^fraction_bits, equivalent to bit shift right    * by 2 * fraction_bits    */
specifier|const
name|gint
name|recovery_bits
init|=
literal|2
operator|*
name|fraction_bits
decl_stmt|;
comment|/*    * example: suppose fraction_bits = 9    * a 9-bit mask looks like this: 0001 1111 1111    * and is given by:  2^fraction_bits - 1    * demonstration:    * 2^0     = 0000 0000 0001    * 2^1     = 0000 0000 0010    * :    * 2^8     = 0001 0000 0000    * 2^9     = 0010 0000 0000    * 2^9 - 1 = 0001 1111 1111    */
specifier|const
name|guint
name|fraction_bitmask
init|=
name|pow
argument_list|(
literal|2
argument_list|,
name|fraction_bits
argument_list|)
operator|-
literal|1
decl_stmt|;
name|source
operator|=
name|gimp_brush_get_pixmap
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|src_width
operator|=
name|gimp_brush_get_width
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|src_height
operator|=
name|gimp_brush_get_height
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|gimp_brush_transform_matrix
argument_list|(
name|src_width
argument_list|,
name|src_height
argument_list|,
name|scale
argument_list|,
name|aspect_ratio
argument_list|,
name|angle
argument_list|,
operator|&
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_matrix3_is_identity
argument_list|(
operator|&
name|matrix
argument_list|)
operator|&&
name|hardness
operator|==
literal|1.0
condition|)
return|return
name|gimp_temp_buf_copy
argument_list|(
name|source
argument_list|)
return|;
name|src_width_minus_one
operator|=
name|src_width
operator|-
literal|1
expr_stmt|;
name|src_height_minus_one
operator|=
name|src_height
operator|-
literal|1
expr_stmt|;
name|gimp_brush_transform_bounding_box
argument_list|(
name|brush
argument_list|,
operator|&
name|matrix
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|dest_width
argument_list|,
operator|&
name|dest_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|hardness
operator|<
literal|1.0
condition|)
block|{
name|kernel_size
operator|=
name|gimp_brush_transform_blur_kernel_size
argument_list|(
name|dest_width
argument_list|,
name|dest_height
argument_list|,
name|hardness
argument_list|)
expr_stmt|;
block|}
name|gimp_matrix3_translate
argument_list|(
operator|&
name|matrix
argument_list|,
operator|-
name|x
argument_list|,
operator|-
name|y
argument_list|)
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
operator|&
name|matrix
argument_list|)
expr_stmt|;
name|result
operator|=
name|gimp_temp_buf_new
argument_list|(
name|dest_width
argument_list|,
name|dest_height
argument_list|,
name|gimp_temp_buf_get_format
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gimp_temp_buf_get_data
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|src
operator|=
name|gimp_temp_buf_get_data
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tlx
argument_list|,
operator|&
name|tly
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
name|dest_width
argument_list|,
literal|0
argument_list|,
operator|&
name|trx
argument_list|,
operator|&
name|try
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
literal|0
argument_list|,
name|dest_height
argument_list|,
operator|&
name|blx
argument_list|,
operator|&
name|bly
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|matrix
argument_list|,
name|dest_width
argument_list|,
name|dest_height
argument_list|,
operator|&
name|brx
argument_list|,
operator|&
name|bry
argument_list|)
expr_stmt|;
comment|/* in image space, calc U (what was horizontal originally)    * note: double precision    */
name|src_tl_to_tr_delta_x
operator|=
name|trx
operator|-
name|tlx
expr_stmt|;
name|src_tl_to_tr_delta_y
operator|=
name|try
operator|-
name|tly
expr_stmt|;
comment|/* in image space, calc V (what was vertical originally)    * note: double precision    */
name|src_tl_to_bl_delta_x
operator|=
name|blx
operator|-
name|tlx
expr_stmt|;
name|src_tl_to_bl_delta_y
operator|=
name|bly
operator|-
name|tly
expr_stmt|;
comment|/* speed optimized, note conversion to int precision */
name|src_walk_ux_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_tr_delta_x
operator|/
name|dest_width
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_uy_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_tr_delta_y
operator|/
name|dest_width
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_vx_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_bl_delta_x
operator|/
name|dest_height
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_walk_vy_i
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|src_tl_to_bl_delta_y
operator|/
name|dest_height
operator|)
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
comment|/* initialize current position in source space to the start position (tl)    * speed optimized, note conversion to int precision    */
name|src_space_cur_pos_x_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tlx
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_cur_pos_y_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tly
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_cur_pos_x
operator|=
call|(
name|gint
call|)
argument_list|(
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
argument_list|)
expr_stmt|;
name|src_space_cur_pos_y
operator|=
call|(
name|gint
call|)
argument_list|(
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
argument_list|)
expr_stmt|;
name|src_space_row_start_x_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tlx
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
name|src_space_row_start_y_i
operator|=
call|(
name|gint
call|)
argument_list|(
name|tly
operator|*
name|int_multiple
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dest_height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dest_width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|src_space_cur_pos_x
operator|>
name|src_width_minus_one
operator|||
name|src_space_cur_pos_x
operator|<
literal|0
operator|||
name|src_space_cur_pos_y
operator|>
name|src_height_minus_one
operator|||
name|src_space_cur_pos_y
operator|<
literal|0
condition|)
comment|/* no corresponding pixel in source space */
block|{
name|dest
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* reverse transformed point hits source pixel */
block|{
name|src_walker
operator|=
name|src
operator|+
literal|3
operator|*
operator|(
name|src_space_cur_pos_y
operator|*
name|src_width
operator|+
name|src_space_cur_pos_x
operator|)
expr_stmt|;
comment|/* bottom right corner                * no pixel below, reuse current pixel instead                * no next pixel to the right so reuse current pixel instead                */
if|if
condition|(
name|src_space_cur_pos_y
operator|==
name|src_height_minus_one
operator|&&
name|src_space_cur_pos_x
operator|==
name|src_width_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
expr_stmt|;
name|pixel_below_next
operator|=
name|src_walker
expr_stmt|;
block|}
comment|/* bottom edge pixel row, except rightmost corner                * no pixel below, reuse current pixel instead  */
elseif|else
if|if
condition|(
name|src_space_cur_pos_y
operator|==
name|src_height_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
operator|+
literal|3
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
expr_stmt|;
name|pixel_below_next
operator|=
name|src_walker
operator|+
literal|3
expr_stmt|;
block|}
comment|/* right edge pixel column, except bottom corner                * no next pixel to the right so reuse current pixel instead */
elseif|else
if|if
condition|(
name|src_space_cur_pos_x
operator|==
name|src_width_minus_one
condition|)
block|{
name|pixel_next
operator|=
name|src_walker
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
operator|+
name|src_width
operator|*
literal|3
expr_stmt|;
name|pixel_below_next
operator|=
name|pixel_below
expr_stmt|;
block|}
comment|/* neither on bottom edge nor on right edge */
else|else
block|{
name|pixel_next
operator|=
name|src_walker
operator|+
literal|3
expr_stmt|;
name|pixel_below
operator|=
name|src_walker
operator|+
name|src_width
operator|*
literal|3
expr_stmt|;
name|pixel_below_next
operator|=
name|pixel_below
operator|+
literal|3
expr_stmt|;
block|}
name|distance_from_true_x
operator|=
name|src_space_cur_pos_x_i
operator|&
name|fraction_bitmask
expr_stmt|;
name|distance_from_true_y
operator|=
name|src_space_cur_pos_y_i
operator|&
name|fraction_bitmask
expr_stmt|;
name|opposite_x
operator|=
name|int_multiple
operator|-
name|distance_from_true_x
expr_stmt|;
name|opposite_y
operator|=
name|int_multiple
operator|-
name|distance_from_true_y
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|src_walker
index|[
literal|0
index|]
operator|*
name|opposite_x
operator|+
name|pixel_next
index|[
literal|0
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|opposite_y
operator|+
operator|(
name|pixel_below
index|[
literal|0
index|]
operator|*
name|opposite_x
operator|+
name|pixel_below_next
index|[
literal|0
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|distance_from_true_y
operator|)
operator|>>
name|recovery_bits
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|src_walker
index|[
literal|1
index|]
operator|*
name|opposite_x
operator|+
name|pixel_next
index|[
literal|1
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|opposite_y
operator|+
operator|(
name|pixel_below
index|[
literal|1
index|]
operator|*
name|opposite_x
operator|+
name|pixel_below_next
index|[
literal|1
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|distance_from_true_y
operator|)
operator|>>
name|recovery_bits
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|src_walker
index|[
literal|2
index|]
operator|*
name|opposite_x
operator|+
name|pixel_next
index|[
literal|2
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|opposite_y
operator|+
operator|(
name|pixel_below
index|[
literal|2
index|]
operator|*
name|opposite_x
operator|+
name|pixel_below_next
index|[
literal|2
index|]
operator|*
name|distance_from_true_x
operator|)
operator|*
name|distance_from_true_y
operator|)
operator|>>
name|recovery_bits
expr_stmt|;
block|}
name|src_space_cur_pos_x_i
operator|+=
name|src_walk_ux_i
expr_stmt|;
name|src_space_cur_pos_y_i
operator|+=
name|src_walk_uy_i
expr_stmt|;
name|src_space_cur_pos_x
operator|=
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
expr_stmt|;
name|src_space_cur_pos_y
operator|=
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
expr_stmt|;
name|dest
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* end for x */
name|src_space_row_start_x_i
operator|+=
name|src_walk_vx_i
expr_stmt|;
name|src_space_row_start_y_i
operator|+=
name|src_walk_vy_i
expr_stmt|;
name|src_space_cur_pos_x_i
operator|=
name|src_space_row_start_x_i
expr_stmt|;
name|src_space_cur_pos_y_i
operator|=
name|src_space_row_start_y_i
expr_stmt|;
name|src_space_cur_pos_x
operator|=
name|src_space_cur_pos_x_i
operator|>>
name|fraction_bits
expr_stmt|;
name|src_space_cur_pos_y
operator|=
name|src_space_cur_pos_y_i
operator|>>
name|fraction_bits
expr_stmt|;
block|}
comment|/* end for y */
if|if
condition|(
name|hardness
operator|<
literal|1.0
condition|)
block|{
name|gimp_brush_transform_blur
argument_list|(
name|result
argument_list|,
name|kernel_size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_brush_transform_matrix (gdouble width,gdouble height,gdouble scale,gdouble aspect_ratio,gdouble angle,GimpMatrix3 * matrix)
name|gimp_brush_transform_matrix
parameter_list|(
name|gdouble
name|width
parameter_list|,
name|gdouble
name|height
parameter_list|,
name|gdouble
name|scale
parameter_list|,
name|gdouble
name|aspect_ratio
parameter_list|,
name|gdouble
name|angle
parameter_list|,
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|)
block|{
specifier|const
name|gdouble
name|center_x
init|=
name|width
operator|/
literal|2
decl_stmt|;
specifier|const
name|gdouble
name|center_y
init|=
name|height
operator|/
literal|2
decl_stmt|;
name|gdouble
name|scale_x
init|=
name|scale
decl_stmt|;
name|gdouble
name|scale_y
init|=
name|scale
decl_stmt|;
if|if
condition|(
name|aspect_ratio
operator|<
literal|0.0
condition|)
block|{
name|scale_x
operator|=
name|scale
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|fabs
argument_list|(
name|aspect_ratio
argument_list|)
operator|/
literal|20.0
operator|)
operator|)
expr_stmt|;
name|scale_y
operator|=
name|scale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aspect_ratio
operator|>
literal|0.0
condition|)
block|{
name|scale_x
operator|=
name|scale
expr_stmt|;
name|scale_y
operator|=
name|scale
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|aspect_ratio
operator|/
literal|20.0
operator|)
operator|)
expr_stmt|;
block|}
name|gimp_matrix3_identity
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|gimp_matrix3_scale
argument_list|(
name|matrix
argument_list|,
name|scale_x
argument_list|,
name|scale_y
argument_list|)
expr_stmt|;
name|gimp_matrix3_translate
argument_list|(
name|matrix
argument_list|,
operator|-
name|center_x
operator|*
name|scale_x
argument_list|,
operator|-
name|center_y
operator|*
name|scale_y
argument_list|)
expr_stmt|;
name|gimp_matrix3_rotate
argument_list|(
name|matrix
argument_list|,
operator|-
literal|2
operator|*
name|G_PI
operator|*
name|angle
argument_list|)
expr_stmt|;
name|gimp_matrix3_translate
argument_list|(
name|matrix
argument_list|,
name|center_x
operator|*
name|scale_x
argument_list|,
name|center_y
operator|*
name|scale_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_brush_transform_adjust_hardness_matrix (gdouble width,gdouble height,gdouble kernel_size,GimpMatrix3 * matrix)
name|gimp_brush_transform_adjust_hardness_matrix
parameter_list|(
name|gdouble
name|width
parameter_list|,
name|gdouble
name|height
parameter_list|,
name|gdouble
name|kernel_size
parameter_list|,
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|)
block|{
name|gdouble
name|scale_x
init|=
operator|(
name|width
operator|-
literal|2
operator|*
name|kernel_size
operator|)
operator|/
name|width
decl_stmt|;
name|gdouble
name|scale_y
init|=
operator|(
name|height
operator|-
literal|2
operator|*
name|kernel_size
operator|)
operator|/
name|height
decl_stmt|;
name|gimp_matrix3_scale
argument_list|(
name|matrix
argument_list|,
name|scale_x
argument_list|,
name|scale_y
argument_list|)
expr_stmt|;
name|gimp_matrix3_translate
argument_list|(
name|matrix
argument_list|,
name|kernel_size
argument_list|,
name|kernel_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_brush_transform_bounding_box (GimpBrush * brush,const GimpMatrix3 * matrix,gint * x,gint * y,gint * width,gint * height)
name|gimp_brush_transform_bounding_box
parameter_list|(
name|GimpBrush
modifier|*
name|brush
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
block|{
specifier|const
name|gdouble
name|w
init|=
name|gimp_brush_get_width
argument_list|(
name|brush
argument_list|)
decl_stmt|;
specifier|const
name|gdouble
name|h
init|=
name|gimp_brush_get_height
argument_list|(
name|brush
argument_list|)
decl_stmt|;
name|gdouble
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|x3
decl_stmt|,
name|x4
decl_stmt|;
name|gdouble
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|y4
decl_stmt|;
name|gdouble
name|temp_x
decl_stmt|;
name|gdouble
name|temp_y
decl_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
literal|0
argument_list|,
name|h
argument_list|,
operator|&
name|x3
argument_list|,
operator|&
name|y3
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
name|matrix
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
operator|&
name|x4
argument_list|,
operator|&
name|y4
argument_list|)
expr_stmt|;
name|temp_x
operator|=
name|MIN
argument_list|(
name|MIN
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|x3
argument_list|,
name|x4
argument_list|)
argument_list|)
expr_stmt|;
name|temp_y
operator|=
name|MIN
argument_list|(
name|MIN
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|y3
argument_list|,
name|y4
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX
argument_list|(
name|MAX
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|x3
argument_list|,
name|x4
argument_list|)
argument_list|)
operator|-
name|temp_x
argument_list|)
expr_stmt|;
operator|*
name|height
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX
argument_list|(
name|MAX
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|y3
argument_list|,
name|y4
argument_list|)
argument_list|)
operator|-
name|temp_y
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|floor
argument_list|(
name|temp_x
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|floor
argument_list|(
name|temp_y
argument_list|)
expr_stmt|;
comment|/* Transform size can not be less than 1 px */
operator|*
name|width
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|*
name|width
argument_list|)
expr_stmt|;
operator|*
name|height
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|*
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Blurs the brush mask/pixmap using a convolution of the form:  *  *   12  11  10   9   8  *    7   6   5   4   3  *    2   1   0   1   2  *    3   4   5   6   7  *    8   9  10  11  12  *  * (i.e., an array, wrapped into a matrix, whose i-th element is  * `abs (i - a / 2)`, where `a` is the length of the array.)  `r` specifies the  * convolution kernel's radius.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_brush_transform_blur (GimpTempBuf * buf,gint r)
name|gimp_brush_transform_blur
parameter_list|(
name|GimpTempBuf
modifier|*
name|buf
parameter_list|,
name|gint
name|r
parameter_list|)
block|{
typedef|typedef
struct|struct
DECL|struct|__anon290a029e0108
block|{
DECL|member|sum
name|gint
name|sum
decl_stmt|;
DECL|member|weighted_sum
name|gint
name|weighted_sum
decl_stmt|;
DECL|member|middle_sum
name|gint
name|middle_sum
decl_stmt|;
DECL|typedef|Sums
block|}
name|Sums
typedef|;
specifier|const
name|Babl
modifier|*
name|format
init|=
name|gimp_temp_buf_get_format
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|gint
name|components
init|=
name|babl_format_get_n_components
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|gint
name|width
init|=
name|gimp_temp_buf_get_width
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gimp_temp_buf_get_height
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|gint
name|stride
init|=
name|components
operator|*
name|width
decl_stmt|;
name|guchar
modifier|*
name|data
init|=
name|gimp_temp_buf_get_data
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|gint
name|rw
init|=
name|MIN
argument_list|(
name|r
argument_list|,
name|width
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gint
name|rh
init|=
name|MIN
argument_list|(
name|r
argument_list|,
name|height
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gint
name|n
init|=
literal|2
operator|*
name|r
operator|+
literal|1
decl_stmt|;
name|gint
name|weight
init|=
operator|(
name|n
operator|*
name|n
operator|/
literal|2
operator|)
operator|*
operator|(
name|n
operator|*
name|n
operator|/
literal|2
operator|+
literal|1
operator|)
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
name|gint
name|c
decl_stmt|;
name|Sums
modifier|*
name|sums
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|Sums
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|rw
operator|<=
literal|0
operator|||
name|rh
operator|<=
literal|0
condition|)
return|return;
name|sums
operator|=
name|g_new
argument_list|(
name|Sums
argument_list|,
name|width
operator|*
name|height
operator|*
name|components
argument_list|)
expr_stmt|;
name|d
operator|=
name|data
expr_stmt|;
name|s
operator|=
name|sums
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
struct|struct
DECL|struct|__anon290a029e0208
block|{
DECL|member|sum
name|gint
name|sum
decl_stmt|;
DECL|member|weighted_sum
name|gint
name|weighted_sum
decl_stmt|;
DECL|member|leading_sum
name|gint
name|leading_sum
decl_stmt|;
DECL|member|leading_weighted_sum
name|gint
name|leading_weighted_sum
decl_stmt|;
block|}
name|acc
index|[
name|components
index|]
struct|;
name|memset
argument_list|(
name|acc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|acc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|rw
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|sum
operator|+=
name|d
index|[
name|components
operator|*
name|x
operator|+
name|c
index|]
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
operator|-
name|x
operator|*
name|d
index|[
name|components
operator|*
name|x
operator|+
name|c
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
name|acc
index|[
name|c
index|]
operator|.
name|sum
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|leading_weighted_sum
operator|+=
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|width
operator|-
name|r
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|sum
operator|+=
name|d
index|[
name|components
operator|*
name|r
index|]
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
operator|-
name|r
operator|*
name|d
index|[
name|components
operator|*
name|r
index|]
expr_stmt|;
block|}
block|}
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
operator|+=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|->
name|sum
operator|=
name|acc
index|[
name|c
index|]
operator|.
name|sum
expr_stmt|;
name|s
operator|->
name|weighted_sum
operator|=
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
expr_stmt|;
name|s
operator|->
name|middle_sum
operator|=
literal|2
operator|*
name|acc
index|[
name|c
index|]
operator|.
name|leading_weighted_sum
operator|-
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|r
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|sum
operator|-=
name|d
index|[
name|components
operator|*
operator|-
name|r
index|]
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|-=
name|r
operator|*
name|d
index|[
name|components
operator|*
operator|-
name|r
index|]
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
operator|-=
name|d
index|[
name|components
operator|*
operator|-
name|r
index|]
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|leading_weighted_sum
operator|-=
name|r
operator|*
name|d
index|[
name|components
operator|*
operator|-
name|r
index|]
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
struct|struct
DECL|struct|__anon290a029e0308
block|{
DECL|member|weighted_sum
name|gint
name|weighted_sum
decl_stmt|;
DECL|member|leading_sum
name|gint
name|leading_sum
decl_stmt|;
DECL|member|trailing_sum
name|gint
name|trailing_sum
decl_stmt|;
block|}
name|acc
index|[
name|components
index|]
struct|;
name|memset
argument_list|(
name|acc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|acc
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|data
operator|+
name|components
operator|*
name|x
expr_stmt|;
name|s
operator|=
name|sums
operator|+
name|components
operator|*
name|x
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<=
name|rh
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
name|n
operator|*
name|y
operator|*
name|s
index|[
name|stride
operator|*
name|y
operator|+
name|c
index|]
operator|.
name|sum
operator|-
name|s
index|[
name|stride
operator|*
name|y
operator|+
name|c
index|]
operator|.
name|weighted_sum
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|trailing_sum
operator|+=
name|s
index|[
name|stride
operator|*
name|y
operator|+
name|c
index|]
operator|.
name|sum
expr_stmt|;
block|}
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
name|s
operator|->
name|weighted_sum
operator|+
name|n
operator|*
operator|(
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
operator|-
name|acc
index|[
name|c
index|]
operator|.
name|trailing_sum
operator|)
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|trailing_sum
operator|-=
name|s
operator|->
name|sum
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|height
operator|-
name|r
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
name|n
operator|*
name|r
operator|*
name|s
index|[
name|stride
operator|*
name|r
index|]
operator|.
name|sum
operator|-
name|s
index|[
name|stride
operator|*
name|r
index|]
operator|.
name|weighted_sum
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|trailing_sum
operator|+=
name|s
index|[
name|stride
operator|*
name|r
index|]
operator|.
name|sum
expr_stmt|;
block|}
block|}
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
operator|+=
name|s
operator|->
name|sum
expr_stmt|;
operator|*
name|d
operator|=
operator|(
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+
name|s
operator|->
name|middle_sum
operator|+
name|weight
operator|/
literal|2
operator|)
operator|/
name|weight
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|+=
name|s
operator|->
name|weighted_sum
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|r
condition|)
block|{
name|acc
index|[
name|c
index|]
operator|.
name|weighted_sum
operator|-=
name|n
operator|*
name|r
operator|*
name|s
index|[
name|stride
operator|*
operator|-
name|r
index|]
operator|.
name|sum
operator|+
name|s
index|[
name|stride
operator|*
operator|-
name|r
index|]
operator|.
name|weighted_sum
expr_stmt|;
name|acc
index|[
name|c
index|]
operator|.
name|leading_sum
operator|-=
name|s
index|[
name|stride
operator|*
operator|-
name|r
index|]
operator|.
name|sum
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|d
operator|+=
name|stride
operator|-
name|components
expr_stmt|;
name|s
operator|+=
name|stride
operator|-
name|components
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|sums
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimp_brush_transform_blur_kernel_size (gint height,gint width,gdouble hardness)
name|gimp_brush_transform_blur_kernel_size
parameter_list|(
name|gint
name|height
parameter_list|,
name|gint
name|width
parameter_list|,
name|gdouble
name|hardness
parameter_list|)
block|{
name|gint
name|kernel_size
init|=
operator|(
name|MIN
argument_list|(
name|MAX_BLUR_KERNEL
argument_list|,
name|MIN
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|*
operator|(
operator|(
name|MIN
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|*
operator|(
literal|1.0
operator|-
name|hardness
operator|)
operator|)
operator|/
name|MIN
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|/* Kernel size must be odd */
if|if
condition|(
name|kernel_size
operator|%
literal|2
operator|==
literal|0
condition|)
name|kernel_size
operator|++
expr_stmt|;
return|return
name|kernel_size
return|;
block|}
end_function

end_unit

