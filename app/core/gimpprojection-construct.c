begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"apptypes.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplist.h"
end_include

begin_include
include|#
directive|include
file|"gimpmarshal.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"gimpparasite.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"parasitelist.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"pixel_region.h"
end_include

begin_include
include|#
directive|include
file|"temp_buf.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimplimits.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpparasite.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Local function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TempBuf
modifier|*
name|gimp_image_get_preview
parameter_list|(
name|GimpViewable
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TempBuf
modifier|*
name|gimp_image_get_new_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
modifier|*
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  projection functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_indexed_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Global variables  */
end_comment

begin_decl_stmt
DECL|variable|valid_combinations
name|gint
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* RGB GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* RGBA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GRAY GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GRAYA GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXED GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXEDA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|next_guide_id
name|guint32
name|next_guide_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|next_guide_id
comment|/* For generating guide_ID handles for PDB stuff */
end_comment

begin_comment
comment|/*  *  Static variables  */
end_comment

begin_enum
enum|enum
DECL|enum|__anon28ca16f90103
block|{
DECL|enumerator|CLEAN
name|CLEAN
block|,
DECL|enumerator|DIRTY
name|DIRTY
block|,
DECL|enumerator|REPAINT
name|REPAINT
block|,
DECL|enumerator|RESIZE
name|RESIZE
block|,
DECL|enumerator|RESTRUCTURE
name|RESTRUCTURE
block|,
DECL|enumerator|COLORMAP_CHANGED
name|COLORMAP_CHANGED
block|,
DECL|enumerator|UNDO_EVENT
name|UNDO_EVENT
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_decl_stmt
DECL|variable|gimp_image_signals
specifier|static
name|guint
name|gimp_image_signals
index|[
name|LAST_SIGNAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|parent_class
specifier|static
name|GimpViewableClass
modifier|*
name|parent_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|GtkType
DECL|function|gimp_image_get_type (void)
name|gimp_image_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GtkType
name|image_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|image_type
condition|)
block|{
name|GtkTypeInfo
name|image_info
init|=
block|{
literal|"GimpImage"
block|,
sizeof|sizeof
argument_list|(
name|GimpImage
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|GimpImageClass
argument_list|)
block|,
operator|(
name|GtkClassInitFunc
operator|)
name|gimp_image_class_init
block|,
operator|(
name|GtkObjectInitFunc
operator|)
name|gimp_image_init
block|,
comment|/* reserved_1 */
name|NULL
block|,
comment|/* reserved_2 */
name|NULL
block|,
operator|(
name|GtkClassInitFunc
operator|)
name|NULL
block|,       }
decl_stmt|;
name|image_type
operator|=
name|gtk_type_unique
argument_list|(
name|GIMP_TYPE_VIEWABLE
argument_list|,
operator|&
name|image_info
argument_list|)
expr_stmt|;
block|}
return|return
name|image_type
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_class_init (GimpImageClass * klass)
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
block|{
name|GtkObjectClass
modifier|*
name|object_class
decl_stmt|;
name|GimpObjectClass
modifier|*
name|gimp_object_class
decl_stmt|;
name|GimpViewableClass
modifier|*
name|viewable_class
decl_stmt|;
name|object_class
operator|=
operator|(
name|GtkObjectClass
operator|*
operator|)
name|klass
expr_stmt|;
name|gimp_object_class
operator|=
operator|(
name|GimpObjectClass
operator|*
operator|)
name|klass
expr_stmt|;
name|viewable_class
operator|=
operator|(
name|GimpViewableClass
operator|*
operator|)
name|klass
expr_stmt|;
name|parent_class
operator|=
name|gtk_type_class
argument_list|(
name|GIMP_TYPE_VIEWABLE
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|CLEAN
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"clean"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|clean
argument_list|)
argument_list|,
name|gtk_signal_default_marshaller
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|DIRTY
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"dirty"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|dirty
argument_list|)
argument_list|,
name|gtk_signal_default_marshaller
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|REPAINT
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"repaint"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|repaint
argument_list|)
argument_list|,
name|gimp_marshal_NONE__INT_INT_INT_INT
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|4
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESIZE
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"resize"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|resize
argument_list|)
argument_list|,
name|gtk_signal_default_marshaller
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"restructure"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|restructure
argument_list|)
argument_list|,
name|gtk_signal_default_marshaller
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"colormap_changed"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|colormap_changed
argument_list|)
argument_list|,
name|gtk_marshal_NONE__INT
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GTK_TYPE_INT
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"undo_event"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpImageClass
argument_list|,
name|undo_event
argument_list|)
argument_list|,
name|gtk_marshal_NONE__INT
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|1
argument_list|,
name|GTK_TYPE_INT
argument_list|)
expr_stmt|;
name|gtk_object_class_add_signals
argument_list|(
name|object_class
argument_list|,
name|gimp_image_signals
argument_list|,
name|LAST_SIGNAL
argument_list|)
expr_stmt|;
name|object_class
operator|->
name|destroy
operator|=
name|gimp_image_destroy
expr_stmt|;
name|gimp_object_class
operator|->
name|name_changed
operator|=
name|gimp_image_name_changed
expr_stmt|;
name|viewable_class
operator|->
name|invalidate_preview
operator|=
name|gimp_image_invalidate_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_preview
operator|=
name|gimp_image_get_preview
expr_stmt|;
name|viewable_class
operator|->
name|get_new_preview
operator|=
name|gimp_image_get_new_preview
expr_stmt|;
name|klass
operator|->
name|clean
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|dirty
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|repaint
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|resize
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|restructure
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|colormap_changed
operator|=
name|NULL
expr_stmt|;
name|klass
operator|->
name|undo_event
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static functions */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_init (GimpImage * gimage)
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|save_proc
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|default_xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|default_yresolution
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|default_units
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|RGB
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|disp_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|tattoo_state
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
operator|-
literal|1
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_LAYER
argument_list|,
name|GIMP_CONTAINER_POLICY_STRONG
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|gimp_list_new
argument_list|(
name|GIMP_TYPE_CHANNEL
argument_list|,
name|GIMP_CONTAINER_POLICY_STRONG
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|selection_mask
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|parasites
operator|=
name|parasite_list_new
argument_list|()
expr_stmt|;
name|gimage
operator|->
name|paths
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|by_color_select
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|qmask_state
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|r
operator|=
literal|1.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|g
operator|=
literal|0.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|b
operator|=
literal|0.0
expr_stmt|;
name|gimage
operator|->
name|qmask_color
operator|.
name|a
operator|=
literal|0.5
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_bytes
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|undo_levels
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|group_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|pushing_undo_group
operator|=
name|UNDO_NULL
expr_stmt|;
name|gimage
operator|->
name|undo_history
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_destroy (GtkObject * object)
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|parasites
condition|)
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_name_changed (GimpObject * object)
name|gimp_image_name_changed
parameter_list|(
name|GimpObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
condition|)
name|GIMP_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|name_changed
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|name
operator|=
name|gimp_object_get_name
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|g_free
argument_list|(
name|object
operator|->
name|name
argument_list|)
expr_stmt|;
name|object
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_invalidate_preview (GimpViewable * viewable)
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
comment|/*  Invalidate the floating sel if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_invalidate
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_projection (GimpImage * gimage)
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Find the number of bytes required for the projection.    *  This includes the intensity channels and an alpha channel    *  if one doesn't exist.    */
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|4
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|2
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|GRAYA_GIMAGE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|projection
operator|=
name|tile_manager_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|gimage
operator|->
name|proj_bytes
argument_list|)
expr_stmt|;
name|tile_manager_set_user_data
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
name|gimp_image_validate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_projection (GimpImage * gimage)
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_shadow (GimpImage * gimage,gint width,gint height,gint bpp)
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function definitions */
end_comment

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_new (gint width,gint height,GimpImageBaseType base_type)
name|gimp_image_new
parameter_list|(
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImageBaseType
name|base_type
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|gtk_type_new
argument_list|(
name|GIMP_TYPE_IMAGE
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimage
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|GRAY
case|:
break|break;
case|case
name|INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc0
argument_list|(
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  set all color channels visible and active  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|visible
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|active
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* create the selection mask */
name|gimage
operator|->
name|selection_mask
operator|=
name|gimp_channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_filename (GimpImage * gimage,const gchar * filename)
name|gimp_image_set_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_resolution (GimpImage * gimage,gdouble xresolution,gdouble yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
name|xresolution
parameter_list|,
name|gdouble
name|yresolution
parameter_list|)
block|{
comment|/* nothing to do if setting res to the same as before */
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|xresolution
operator|-
name|xresolution
argument_list|)
operator|<
literal|1e-5
operator|)
operator|&&
operator|(
name|ABS
argument_list|(
name|gimage
operator|->
name|yresolution
operator|-
name|yresolution
argument_list|)
operator|<
literal|1e-5
operator|)
condition|)
return|return;
comment|/* don't allow to set the resolution out of bounds */
if|if
condition|(
name|xresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xresolution
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
name|yresolution
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yresolution
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
return|return;
name|undo_push_resolution
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|yresolution
expr_stmt|;
comment|/* really just want to recalc size and repaint */
name|gdisplays_shrink_wrap
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_resolution (const GimpImage * gimage,gdouble * xresolution,gdouble * yresolution)
name|gimp_image_get_resolution
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gdouble
modifier|*
name|xresolution
parameter_list|,
name|gdouble
modifier|*
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|xresolution
operator|&&
name|yresolution
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
operator|*
name|yresolution
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_unit (GimpImage * gimage,GimpUnit unit)
name|gimp_image_set_unit
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|undo_push_resolution
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
block|}
end_function

begin_function
name|GimpUnit
DECL|function|gimp_image_get_unit (const GimpImage * gimage)
name|gimp_image_get_unit
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|unit
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_save_proc (GimpImage * gimage,PlugInProcDef * proc)
name|gimp_image_set_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PlugInProcDef
modifier|*
name|proc
parameter_list|)
block|{
name|gimage
operator|->
name|save_proc
operator|=
name|proc
expr_stmt|;
block|}
end_function

begin_function
name|PlugInProcDef
modifier|*
DECL|function|gimp_image_get_save_proc (const GimpImage * gimage)
name|gimp_image_get_save_proc
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|save_proc
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_width (const GimpImage * gimage)
name|gimp_image_get_width
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|width
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_height (const GimpImage * gimage)
name|gimp_image_get_height
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|height
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_resize (GimpImage * gimage,gint new_width,gint new_height,gint offset_x,gint offset_y)
name|gimp_image_resize
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|guide_list
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|g_assert
argument_list|(
name|new_width
operator|>
literal|0
operator|&&
name|new_height
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|IMAGE_RESIZE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Resize all channels  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gimp_channel_resize
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  Reposition or remove any guides  */
name|guide_list
operator|=
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|guide_list
condition|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
operator|(
name|Guide
operator|*
operator|)
name|guide_list
operator|->
name|data
expr_stmt|;
name|guide_list
operator|=
name|g_list_next
argument_list|(
name|guide_list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|+=
name|offset_y
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
operator|||
name|guide
operator|->
name|position
operator|>
name|new_height
condition|)
name|gimp_image_delete_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|+=
name|offset_x
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
operator|||
name|guide
operator|->
name|position
operator|>
name|new_width
condition|)
name|gimp_image_delete_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"Unknown guide orientation\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Don't forget the selection mask!  */
name|gimp_channel_resize
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Reposition all layers  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gimp_layer_translate
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_scale (GimpImage * gimage,gint new_width,gint new_height)
name|gimp_image_scale
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|remove
init|=
name|NULL
decl_stmt|;
name|GSList
modifier|*
name|slist
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint
name|old_width
decl_stmt|;
name|gint
name|old_height
decl_stmt|;
name|gdouble
name|img_scale_w
init|=
literal|1.0
decl_stmt|;
name|gdouble
name|img_scale_h
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
operator|(
name|new_width
operator|==
literal|0
operator|)
operator|||
operator|(
name|new_height
operator|==
literal|0
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"%s(): Scaling to zero width or height has been rejected."
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return;
block|}
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|IMAGE_SCALE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|old_width
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|old_height
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
name|img_scale_w
operator|=
operator|(
name|gdouble
operator|)
name|new_width
operator|/
operator|(
name|gdouble
operator|)
name|old_width
expr_stmt|;
name|img_scale_h
operator|=
operator|(
name|gdouble
operator|)
name|new_height
operator|/
operator|(
name|gdouble
operator|)
name|old_height
expr_stmt|;
comment|/*  Scale all channels  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gimp_channel_scale
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
comment|/*  if (channel_is_empty(gimage->selection_mask))         gimp_channel_resize(gimage->selection_mask, new_width, new_height, 0, 0)       else   */
name|gimp_channel_scale
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Scale all layers  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_layer_scale_by_factors
argument_list|(
name|layer
argument_list|,
name|img_scale_w
argument_list|,
name|img_scale_h
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* Since 0< img_scale_w, img_scale_h, failure due to one or more 	   * vanishing scaled layer dimensions. Implicit delete implemented 	   * here. Upstream warning implemented in resize_check_layer_scaling() 	   * [resize.c line 1295], which offers the user the chance to bail out. 	   */
name|remove
operator|=
name|g_slist_append
argument_list|(
name|remove
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We defer removing layers lost to scaling until now            */
comment|/* so as not to mix the operations of iterating over and removal */
comment|/* from gimage->layers.                                          */
for|for
control|(
name|slist
operator|=
name|remove
init|;
name|slist
condition|;
name|slist
operator|=
name|g_slist_next
argument_list|(
name|slist
argument_list|)
control|)
block|{
name|layer
operator|=
name|slist
operator|->
name|data
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|remove
argument_list|)
expr_stmt|;
comment|/*  Scale any Guides  */
for|for
control|(
name|list
operator|=
name|gimage
operator|->
name|guides
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|guide
operator|=
operator|(
name|Guide
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|(
name|guide
operator|->
name|position
operator|*
name|new_height
operator|)
operator|/
name|old_height
expr_stmt|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|undo_push_guide
argument_list|(
name|gimage
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|(
name|guide
operator|->
name|position
operator|*
name|new_width
operator|)
operator|/
name|old_width
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"Unknown guide orientation II.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_shadow (GimpImage * gimage,gint width,gint height,gint bpp)
name|gimp_image_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|shadow
operator|&&
operator|(
operator|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tile_manager_bpp
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|)
condition|)
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
return|return
name|gimage
operator|->
name|shadow
return|;
name|gimp_image_allocate_shadow
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_free_shadow (GimpImage * gimage)
name|gimp_image_free_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free the shadow buffer from the specified gimage if it exists  */
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_apply_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gint undo,gint opacity,LayerModeEffects mode,TileManager * src1_tiles,gint x,gint y)
name|gimp_image_apply_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gint
name|undo
parameter_list|,
name|gint
name|opacity
parameter_list|,
name|LayerModeEffects
name|mode
parameter_list|,
comment|/*  alternative to using drawable tiles as src1: */
name|TileManager
modifier|*
name|src1_tiles
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"%s(): illegal parameters"
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|undo_push_image
argument_list|(
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
if|if
condition|(
name|src1_tiles
condition|)
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src1_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|gint
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to gimp_image_apply_image but works in "replace" mode (i.e.    transparent pixels in src2 make the result transparent rather    than opaque.     Takes an additional mask pixel region as well. */
end_comment

begin_function
name|void
DECL|function|gimp_image_replace_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,gint undo,gint opacity,PixelRegion * maskPR,gint x,gint y)
name|gimp_image_replace_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|gint
name|undo
parameter_list|,
name|gint
name|opacity
parameter_list|,
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|;
name|PixelRegion
name|mask2PR
decl_stmt|,
name|tempPR
decl_stmt|;
name|guchar
modifier|*
name|temp_data
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"%s(): got illegal parameters"
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|drawable_apply_image
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mask2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|rowstride
operator|=
name|tempPR
operator|.
name|w
operator|*
name|tempPR
operator|.
name|bytes
expr_stmt|;
name|temp_data
operator|=
name|g_malloc
argument_list|(
name|tempPR
operator|.
name|h
operator|*
name|tempPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|mask2PR
argument_list|,
operator|&
name|tempPR
argument_list|)
expr_stmt|;
comment|/* apparently, region operations can mutate some PR data. */
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|apply_mask_to_region
argument_list|(
operator|&
name|tempPR
argument_list|,
name|maskPR
argument_list|,
name|OPAQUE_OPACITY
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|tempPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get rid of these! A "foreground" is an UI concept.. */
end_comment

begin_function
name|void
DECL|function|gimp_image_get_foreground (const GimpImage * gimage,const GimpDrawable * drawable,guchar * fg)
name|gimp_image_get_foreground
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|fg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pfg
index|[
literal|3
index|]
decl_stmt|;
name|gimp_context_get_foreground
argument_list|(
name|NULL
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pfg
argument_list|,
name|fg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_background (const GimpImage * gimage,const GimpDrawable * drawable,guchar * bg)
name|gimp_image_get_background
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|pbg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|gimp_context_get_background
argument_list|(
name|NULL
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pbg
argument_list|,
name|bg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|guchar
modifier|*
DECL|function|gimp_image_get_color_at (GimpImage * gimage,gint x,gint y)
name|gimp_image_get_color_at
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|y
operator|<
literal|0
operator|||
name|x
operator|>=
name|gimage
operator|->
name|width
operator|||
name|y
operator|>=
name|gimage
operator|->
name|height
condition|)
return|return
name|NULL
return|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|gimp_image_composite
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|src
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|gimp_image_get_color
argument_list|(
name|gimage
argument_list|,
name|gimp_image_composite_type
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IMAGE_TYPE_HAS_ALPHA
argument_list|(
name|gimp_image_composite_type
argument_list|(
name|gimage
argument_list|)
argument_list|)
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src
index|[
name|gimp_image_composite_bytes
argument_list|(
name|gimage
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dest
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
name|dest
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_color (const GimpImage * gimage,GimpImageType d_type,guchar * rgb,guchar * src)
name|gimp_image_get_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpImageType
name|d_type
parameter_list|,
name|guchar
modifier|*
name|rgb
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|2
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_color (const GimpImage * gimage,const GimpDrawable * drawable,guchar * src,guchar * dest,GimpImageBaseType type)
name|gimp_image_transform_color
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|GimpImageBaseType
name|type
parameter_list|)
block|{
name|GimpImageType
name|d_type
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|d_type
operator|=
operator|(
name|drawable
operator|!=
name|NULL
operator|)
condition|?
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
else|:
name|gimp_image_base_type_with_alpha
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RGB
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|INTENSITY
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GRAY
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_hguide (GimpImage * gimage)
name|gimp_image_add_hguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|ORIENTATION_HORIZONTAL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_vguide (GimpImage * gimage)
name|gimp_image_add_vguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|ORIENTATION_VERTICAL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_add_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_add_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_remove_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_delete_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_delete_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|ref_count
operator|<=
literal|0
condition|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|guide
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GimpParasite
modifier|*
DECL|function|gimp_image_parasite_find (const GimpImage * gimage,const gchar * name)
name|gimp_image_parasite_find
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|list_func (gchar * key,GimpParasite * p,gchar *** cur)
name|list_func
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|GimpParasite
modifier|*
name|p
parameter_list|,
name|gchar
modifier|*
modifier|*
modifier|*
name|cur
parameter_list|)
block|{
operator|*
operator|(
operator|*
name|cur
operator|)
operator|++
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gchar
modifier|*
modifier|*
DECL|function|gimp_image_parasite_list (const GimpImage * gimage,gint * count)
name|gimp_image_parasite_list
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
modifier|*
name|count
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|list
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|cur
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|parasite_list_length
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|cur
operator|=
name|list
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
name|parasite_list_foreach
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
operator|(
name|GHFunc
operator|)
name|list_func
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_attach (GimpImage * gimage,GimpParasite * parasite)
name|gimp_image_parasite_attach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
operator|&&
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* only set the dirty bit manually if we can be saved and the new      parasite differs from the current one and we aren't undoable */
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|parasite
argument_list|)
condition|)
name|undo_push_image_parasite
argument_list|(
name|gimage
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
comment|/*  We used to push an cantundo on te stack here. This made the undo stack       unusable (NULL on the stack) and prevented people from undoing after a        save (since most save plug-ins attach an undoable comment parasite).       Now we simply attach the parasite without pushing an undo. That way it's       undoable but does not block the undo system.   --Sven    */
name|parasite_list_add
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_parasite_has_flag
argument_list|(
name|parasite
argument_list|,
name|GIMP_PARASITE_ATTACH_PARENT
argument_list|)
condition|)
block|{
name|parasite_shift_parent
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_attach
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_parasite_detach (GimpImage * gimage,const gchar * parasite)
name|gimp_image_parasite_detach
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|parasite
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|p
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
operator|&&
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|gimp_parasite_is_undoable
argument_list|(
name|p
argument_list|)
condition|)
name|undo_push_image_parasite_remove
argument_list|(
name|gimage
argument_list|,
name|gimp_parasite_name
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|parasite_list_remove
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Tattoo
DECL|function|gimp_image_get_new_tattoo (GimpImage * image)
name|gimp_image_get_new_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|image
operator|->
name|tattoo_state
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|tattoo_state
operator|<=
literal|0
condition|)
name|g_warning
argument_list|(
literal|"Tattoo state has become corrupt (2.1 billion operation limit exceded)"
argument_list|)
expr_stmt|;
return|return
name|image
operator|->
name|tattoo_state
return|;
block|}
end_function

begin_function
name|Tattoo
DECL|function|gimp_image_get_tattoo_state (GimpImage * image)
name|gimp_image_get_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
return|return
operator|(
name|image
operator|->
name|tattoo_state
operator|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_set_tattoo_state (GimpImage * gimage,Tattoo val)
name|gimp_image_set_tattoo_state
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|val
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|gboolean
name|retval
init|=
name|TRUE
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|Tattoo
name|maxval
init|=
literal|0
decl_stmt|;
name|Path
modifier|*
name|pptr
init|=
name|NULL
decl_stmt|;
name|PathList
modifier|*
name|plist
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|Tattoo
name|ltattoo
decl_stmt|;
name|ltattoo
operator|=
name|gimp_drawable_get_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ltattoo
expr_stmt|;
if|if
condition|(
name|gimp_image_get_channel_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ltattoo
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in channel */
block|}
comment|/* Now check path an't got this tattoo */
if|if
condition|(
name|path_get_path_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ltattoo
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in layer */
block|}
block|}
comment|/* Now check that the paths channel tattoos don't overlap */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|Tattoo
name|ctattoo
decl_stmt|;
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|ctattoo
operator|=
name|gimp_drawable_get_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ctattoo
expr_stmt|;
comment|/* Now check path an't got this tattoo */
if|if
condition|(
name|path_get_path_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|ctattoo
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Oopps duplicated tattoo in layer */
block|}
block|}
comment|/* Find the max tatto value in the paths */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|Tattoo
name|ptattoo
decl_stmt|;
name|GSList
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
name|plist
operator|->
name|bz_paths
init|;
name|pl
condition|;
name|pl
operator|=
name|g_slist_next
argument_list|(
name|pl
argument_list|)
control|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
name|ptattoo
operator|=
name|path_get_tattoo
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptattoo
operator|>
name|maxval
condition|)
name|maxval
operator|=
name|ptattoo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|<
name|maxval
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
comment|/* Must check the state is valid */
if|if
condition|(
name|retval
operator|==
name|TRUE
condition|)
name|gimage
operator|->
name|tattoo_state
operator|=
name|val
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_paths (GimpImage * gimage,PathList * paths)
name|gimp_image_set_paths
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PathList
modifier|*
name|paths
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|paths
operator|=
name|paths
expr_stmt|;
block|}
end_function

begin_function
name|PathList
modifier|*
DECL|function|gimp_image_get_paths (const GimpImage * gimage)
name|gimp_image_get_paths
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|paths
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_colormap_changed (const GimpImage * gimage,gint col)
name|gimp_image_colormap_changed
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|col
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|col
operator|<
name|gimage
operator|->
name|num_cols
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection functions                                    */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|project_intensity (GimpImage * gimage,GimpLayer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_intensity_alpha (GimpImage * gimage,GimpLayer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed (GimpImage * gimage,GimpLayer * layer,PixelRegion * src,PixelRegion * dest)
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED
argument_list|)
expr_stmt|;
else|else
name|g_message
argument_list|(
literal|"%s(): unable to project indexed image."
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed_alpha (GimpImage * gimage,GimpLayer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_indexed_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INDEXED_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_channel (GimpImage * gimage,GimpChannel * channel,PixelRegion * src,PixelRegion * src2)
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|)
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
name|guchar
name|opacity
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gimp_rgba_get_uchar
argument_list|(
operator|&
name|channel
operator|->
name|color
argument_list|,
operator|&
name|col
index|[
literal|0
index|]
argument_list|,
operator|&
name|col
index|[
literal|1
index|]
argument_list|,
operator|&
name|col
index|[
literal|2
index|]
argument_list|,
operator|&
name|opacity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|INITIAL_CHANNEL_MASK
else|:
name|INITIAL_CHANNEL_SELECTION
expr_stmt|;
name|initial_region
argument_list|(
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|col
argument_list|,
name|opacity
argument_list|,
name|NORMAL_MODE
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|COMBINE_INTEN_A_CHANNEL_MASK
else|:
name|COMBINE_INTEN_A_CHANNEL_SELECTION
expr_stmt|;
name|combine_regions
argument_list|(
name|src
argument_list|,
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|col
argument_list|,
name|opacity
argument_list|,
name|NORMAL_MODE
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Layer/Channel functions                                 */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_layers (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|gint
name|off_x
decl_stmt|;
name|gint
name|off_y
decl_stmt|;
comment|/*  composite the floating selection if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_composite
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Note added by Raph Levien, 27 Jan 1998       This looks it was intended as an optimization, but it seems to      have correctness problems. In particular, if all channels are      turned off, the screen simply does not update the projected      image. It should be black. Turning off this optimization seems to      restore correct behavior. At some future point, it may be      desirable to turn the optimization back on.       */
if|#
directive|if
literal|0
comment|/*  If all channels are not visible, simply return  */
block|switch (gimp_image_base_type (gimage))     {     case RGB:       if (! gimp_image_get_component_visible (gimage, RED_CHANNEL)&& 	  ! gimp_image_get_component_visible (gimage, GREEN_CHANNEL)&& 	  ! gimp_image_get_component_visible (gimage, BLUE_CHANNEL)) 	return;       break;     case GRAY:       if (! gimp_image_get_component_visible (gimage, GRAY_CHANNEL)) 	return;       break;     case INDEXED:       if (! gimp_image_get_component_visible (gimage, INDEXED_CHANNEL)) 	return;       break;     }
endif|#
directive|endif
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections  	  to the list  */
if|if
condition|(
operator|!
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  If we're showing the layer mask instead of the layer...  */
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|show_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|copy_gray_to_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
block|}
comment|/*  Otherwise, normal  */
else|else
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the 	   *  projection image... 	   */
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
comment|/* no mask possible */
name|project_intensity
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|project_intensity_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
comment|/* no mask possible */
name|project_indexed
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXEDA_GIMAGE
case|:
name|project_indexed_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
comment|/*  something was projected  */
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_channels (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|;
name|PixelRegion
name|src2PR
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
comment|/*  reverse the channel list  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|project_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
block|}
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_initialize_projection (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint
name|coverage
init|=
literal|0
decl_stmt|;
name|PixelRegion
name|PR
decl_stmt|;
name|guchar
name|clear
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*  this function determines whether a visible layer    *  provides complete coverage over the image.  If not,    *  the projection is initialized to transparent    */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
operator|!
name|gimp_layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
operator|(
name|off_x
operator|<=
name|x
operator|)
operator|&&
operator|(
name|off_y
operator|<=
name|y
operator|)
operator|&&
operator|(
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|x
operator|+
name|w
operator|)
operator|&&
operator|(
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|y
operator|+
name|h
operator|)
condition|)
block|{
name|coverage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|coverage
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|PR
argument_list|,
name|clear
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_get_active_channels (GimpImage * gimage,GimpDrawable * drawable,gint * active)
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
modifier|*
name|active
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*  first, blindly copy the gimage active channels  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|active
index|[
name|i
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|i
index|]
expr_stmt|;
comment|/*  If the drawable is a channel (a saved selection, etc.)    *  make sure that the alpha channel is not valid    */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|active
index|[
name|ALPHA_G_PIX
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  no alpha values in channels  */
else|else
block|{
comment|/*  otherwise, check whether preserve transparency is        *  enabled in the layer and if the layer has alpha        */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|layer
operator|=
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer
operator|->
name|preserve_trans
condition|)
name|active
index|[
name|gimp_drawable_bytes
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_construct (GimpImage * gimage,gint x,gint y,gint w,gint h)
name|gimp_image_construct
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|gint xoff;   gint yoff;
comment|/*  set the construct flag, used to determine if anything    *  has been written to the gimage raw image yet.    */
block|gimage->construct_flag = 0;    if (gimage->layers)     {       gimp_drawable_offsets (GIMP_DRAWABLE ((GimpLayer*) gimage->layers->data),&xoff,&yoff);     }    if ((gimage->layers)&&
comment|/* There's a layer.      */
block|(! g_slist_next (gimage->layers))&&
comment|/* It's the only layer.  */
block|(gimp_layer_has_alpha ((GimpLayer *) (gimage->layers->data)))&&
comment|/* It's !flat.  */
comment|/* It's visible.         */
block|(gimp_drawable_visible (GIMP_DRAWABLE (gimage->layers->data)))&&       (gimp_drawable_width (GIMP_DRAWABLE (gimage->layers->data)) ==        gimage->width)&&       (gimp_drawable_height (GIMP_DRAWABLE (gimage->layers->data)) ==        gimage->height)&&
comment|/* Covers all.           */
comment|/* Not indexed.          */
block|(!gimp_drawable_is_indexed (GIMP_DRAWABLE (gimage->layers->data)))&&       (((GimpLayer *)(gimage->layers->data))->opacity == OPAQUE_OPACITY)
comment|/*opaq */
block|)     {       gint xoff;       gint yoff;              gimp_drawable_offsets (GIMP_DRAWABLE (gimage->layers->data),&xoff,&yoff);        if ((xoff==0)&& (yoff==0))
comment|/* Starts at 0,0         */
block|{ 	  PixelRegion srcPR, destPR; 	  gpointer    pr; 	 	  g_warning("Can use cow-projection hack.  Yay!");  	  pixel_region_init (&srcPR, gimp_drawable_data 			     (GIMP_DRAWABLE (gimage->layers->data)), 			     x, y, w,h, FALSE); 	  pixel_region_init (&destPR, 			     gimp_image_projection (gimage), 			     x, y, w,h, TRUE);  	  for (pr = pixel_regions_register (2,&srcPR,&destPR); 	       pr != NULL; 	       pr = pixel_regions_process (pr)) 	    { 	      tile_manager_map_over_tile (destPR.tiles, 					  destPR.curtile, srcPR.curtile); 	    }  	  gimage->construct_flag = 1; 	  gimp_image_construct_channels (gimage, x, y, w, h);  	  return; 	}     }
else|#
directive|else
name|gimage
operator|->
name|construct_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*  First, determine if the projection image needs to be    *  initialized--this is the case when there are no visible    *  layers that cover the entire canvas--either because layers    *  are offset or only a floating selection is visible    */
name|gimp_image_initialize_projection
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/*  call functions which process the list of layers and    *  the list of channels    */
name|gimp_image_construct_layers
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|gimp_image_construct_channels
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_without_render (GimpImage * gimage,gint x,gint y,gint w,gint h,gint x1,gint y1,gint x2,gint y2)
name|gimp_image_invalidate_without_render
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate (GimpImage * gimage,gint x,gint y,gint w,gint h,gint x1,gint y1,gint x2,gint y2)
name|gimp_image_invalidate
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|startx
decl_stmt|,
name|starty
decl_stmt|;
name|gint
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|gint
name|tilex
decl_stmt|,
name|tiley
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|startx
operator|=
name|x
expr_stmt|;
name|starty
operator|=
name|y
expr_stmt|;
name|endx
operator|=
name|x
operator|+
name|w
expr_stmt|;
name|endy
operator|=
name|y
operator|+
name|h
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|x1
condition|)
name|startx
operator|=
name|MAX
argument_list|(
name|startx
argument_list|,
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endx
operator|=
name|MIN
argument_list|(
name|endx
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|y1
condition|)
name|starty
operator|=
name|MAX
argument_list|(
name|starty
argument_list|,
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endy
operator|=
name|MIN
argument_list|(
name|endy
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tile is not valid, make sure we get the entire tile              *   in the construction extents              */
if|if
condition|(
name|tile_is_valid
argument_list|(
name|tile
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|tilex
operator|=
name|j
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
expr_stmt|;
name|tiley
operator|=
name|i
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
expr_stmt|;
name|startx
operator|=
name|MIN
argument_list|(
name|startx
argument_list|,
name|tilex
argument_list|)
expr_stmt|;
name|endx
operator|=
name|MAX
argument_list|(
name|endx
argument_list|,
name|tilex
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|starty
operator|=
name|MIN
argument_list|(
name|starty
argument_list|,
name|tiley
argument_list|)
expr_stmt|;
name|endy
operator|=
name|MAX
argument_list|(
name|endy
argument_list|,
name|tiley
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_mark_valid
argument_list|(
name|tile
argument_list|)
expr_stmt|;
comment|/* hmmmmmmm..... */
block|}
block|}
block|}
if|if
condition|(
operator|(
name|endx
operator|-
name|startx
operator|)
operator|>
literal|0
operator|&&
operator|(
name|endy
operator|-
name|starty
operator|)
operator|>
literal|0
condition|)
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
operator|(
name|endx
operator|-
name|startx
operator|)
argument_list|,
operator|(
name|endy
operator|-
name|starty
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_validate (TileManager * tm,Tile * tile)
name|gimp_image_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|w
decl_stmt|,
name|h
decl_stmt|;
name|gimp_add_busy_cursors_until_idle
argument_list|()
expr_stmt|;
comment|/*  Get the gimage from the tilemanager  */
name|gimage
operator|=
operator|(
name|GimpImage
operator|*
operator|)
name|tile_manager_get_user_data
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|/*  Find the coordinates of this tile  */
name|tile_manager_get_tile_coordinates
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|w
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|h
operator|=
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_layer_previews (GimpImage * gimage)
name|gimp_image_invalidate_layer_previews
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_channel_previews (GimpImage * gimage)
name|gimp_image_invalidate_channel_previews
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_foreach
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
operator|(
name|GFunc
operator|)
name|gimp_viewable_invalidate_preview
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_layer_index (const GimpImage * gimage,const GimpLayer * layer)
name|gimp_image_get_layer_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_get_channel_index (const GimpImage * gimage,const GimpChannel * channel)
name|gimp_image_get_channel_index
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_active_layer (const GimpImage * gimage)
name|gimp_image_get_active_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_active_channel (const GimpImage * gimage)
name|gimp_image_get_active_channel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_get_layer_by_tattoo (const GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_get_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|layer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_tattoo (const GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_get_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|channel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_channel_by_name (const GimpImage * gimage,const gchar * name)
name|gimp_image_get_channel_by_name
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|channel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_get_mask (const GimpImage * gimage)
name|gimp_image_get_mask
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_active (const GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_active
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
case|case
name|ALPHA_CHANNEL
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|ALPHA_PIX
index|]
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
break|break;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_get_component_visible (const GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_visible
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
case|case
name|ALPHA_CHANNEL
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|ALPHA_PIX
index|]
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
break|break;
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_layer_boundary (const GimpImage * gimage,BoundSeg ** segs,gint * n_segs)
name|gimp_image_layer_boundary
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|gint
modifier|*
name|n_segs
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_segs
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
operator|*
name|segs
operator|=
name|gimp_layer_boundary
argument_list|(
name|layer
argument_list|,
name|n_segs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|n_segs
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_set_active_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_set_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  First, find the layer in the gimage    *  If it isn't valid, find the first layer that is    */
if|if
condition|(
operator|!
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
block|{
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Configure the layer stack to reflect this change  */
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  invalidate the selection boundary because of a layer modification  */
name|gimp_layer_invalidate_boundary
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Set the active layer  */
name|gimage
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/*  return the layer  */
return|return
name|layer
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_set_active_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_set_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*  First, find the channel    *  If it doesn't exist, find the first channel that does    */
if|if
condition|(
operator|!
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
comment|/*  return the channel  */
return|return
name|channel
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_unset_active_channel (GimpImage * gimage)
name|gimp_image_unset_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  make sure there is an active channel  */
if|if
condition|(
operator|!
operator|(
name|channel
operator|=
name|gimage
operator|->
name|active_channel
operator|)
condition|)
return|return
name|NULL
return|;
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_active (GimpImage * gimage,ChannelType type,gboolean active)
name|gimp_image_set_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|gboolean
name|active
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|ALPHA_CHANNEL
case|:
name|gimage
operator|->
name|active
index|[
name|ALPHA_PIX
index|]
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|AUXILLARY_CHANNEL
case|:
break|break;
block|}
comment|/*  If there is an active channel and we mess with the components,    *  the active channel gets unset...    */
if|if
condition|(
name|type
operator|!=
name|AUXILLARY_CHANNEL
condition|)
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_visible (GimpImage * gimage,ChannelType type,gboolean visible)
name|gimp_image_set_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|gboolean
name|visible
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RED_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|GREEN_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|BLUE_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|GRAY_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|INDEXED_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|ALPHA_CHANNEL
case|:
name|gimage
operator|->
name|visible
index|[
name|ALPHA_PIX
index|]
operator|=
name|visible
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_pick_correlate_layer (const GimpImage * gimage,gint x,gint y)
name|gimp_image_pick_correlate_layer
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_layer_pick_correlate
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|layer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_raise_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is this the top layer already? */
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"%s(): layer cannot be raised any further"
argument_list|)
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|curpos
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_lower_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is this the bottom layer already? */
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|>=
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"%s(): layer cannot be lowered any further"
argument_list|)
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|curpos
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer_to_top (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"%s(): layer is already on top"
argument_list|)
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gimp_layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"%s(): can't raise Layer without alpha"
argument_list|)
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer_to_bottom (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|gint
name|curpos
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|curpos
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpos
operator|>=
name|length
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"%s(): layer is already on bottom"
argument_list|)
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_layer (GimpImage * gimage,GimpLayer * layer,gint new_index,gboolean push_undo)
name|gimp_image_position_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|new_index
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|gint
name|x_min
decl_stmt|,
name|y_min
decl_stmt|,
name|x_max
decl_stmt|,
name|y_max
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|num_layers
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_layers
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|<
literal|0
condition|)
name|new_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_index
operator|>=
name|num_layers
condition|)
name|new_index
operator|=
name|num_layers
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
comment|/* check if we want to move it below a bottom layer without alpha */
if|if
condition|(
name|new_index
operator|==
name|num_layers
operator|-
literal|1
condition|)
block|{
name|GimpLayer
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|num_layers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|num_layers
operator|-
literal|1
operator|&&
operator|!
name|gimp_layer_has_alpha
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"BG has no alpha, layer was placed above"
argument_list|)
argument_list|)
expr_stmt|;
name|new_index
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push_undo
condition|)
name|undo_push_layer_reposition
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimp_container_reorder
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x_min
operator|=
name|off_x
expr_stmt|;
name|y_min
operator|=
name|off_y
expr_stmt|;
name|x_max
operator|=
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y_max
operator|=
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x_min
argument_list|,
name|y_min
argument_list|,
name|x_max
argument_list|,
name|y_max
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_merge_visible_layers (GimpImage * gimage,MergeType merge_type)
name|gimp_image_merge_visible_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|gboolean
name|had_floating_sel
init|=
name|FALSE
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if there's a floating selection, anchor it */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|floating_sel_anchor
argument_list|(
name|gimage
operator|->
name|floating_sel
argument_list|)
expr_stmt|;
name|had_floating_sel
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
comment|/* If there was a floating selection, we have done something. 	 No need to warn the user. Return the active layer instead */
if|if
condition|(
name|had_floating_sel
condition|)
return|return
name|layer
return|;
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge.\nThere must be at least two."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_flatten (GimpImage * gimage)
name|gimp_image_flatten
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
comment|/* if there's a floating selection, anchor it */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
name|floating_sel_anchor
argument_list|(
name|gimage
operator|->
name|floating_sel
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|FLATTEN_IMAGE
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_merge_down (GimpImage * gimage,GimpLayer * current_layer,MergeType merge_type)
name|gimp_image_merge_down
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|current_layer
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
operator|,
name|layer_list
operator|=
name|NULL
init|;
name|list
operator|&&
operator|!
name|layer_list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|current_layer
condition|)
break|break;
block|}
for|for
control|(
name|layer_list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
operator|,
name|merge_list
operator|=
name|NULL
init|;
name|layer_list
operator|&&
operator|!
name|merge_list
condition|;
name|layer_list
operator|=
name|g_list_next
argument_list|(
name|layer_list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|NULL
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
condition|)
block|{
name|merge_list
operator|=
name|g_slist_prepend
argument_list|(
name|merge_list
argument_list|,
name|current_layer
argument_list|)
expr_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge down."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_merge_layers (GimpImage * gimage,GSList * merge_list,MergeType merge_type)
name|gimp_image_merge_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GSList
modifier|*
name|merge_list
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|GimpLayer
modifier|*
name|merge_layer
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayer
modifier|*
name|bottom
decl_stmt|;
name|LayerModeEffects
name|bottom_mode
decl_stmt|;
name|guchar
name|bg
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|GimpImageType
name|type
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|gint
name|operation
decl_stmt|;
name|gint
name|position
decl_stmt|;
name|gint
name|active
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
name|NULL
expr_stmt|;
name|bottom_mode
operator|=
name|NORMAL_MODE
expr_stmt|;
comment|/*  Get the layer extents  */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|merge_type
condition|)
block|{
case|case
name|EXPAND_AS_NECESSARY
case|:
case|case
name|CLIP_TO_IMAGE
case|:
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off_x
operator|<
name|x1
condition|)
name|x1
operator|=
name|off_x
expr_stmt|;
if|if
condition|(
name|off_y
operator|<
name|y1
condition|)
name|y1
operator|=
name|off_y
expr_stmt|;
if|if
condition|(
operator|(
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|x2
condition|)
name|x2
operator|=
operator|(
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|y2
condition|)
name|y2
operator|=
operator|(
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_type
operator|==
name|CLIP_TO_IMAGE
condition|)
block|{
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLIP_TO_BOTTOM_LAYER
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLATTEN_IMAGE
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
literal|0
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|y2
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|g_slist_next
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
operator|||
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*  Start a merge undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_MERGE_UNDO
argument_list|)
expr_stmt|;
name|name
operator|=
name|g_strdup
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_type
operator|==
name|FLATTEN_IMAGE
operator|||
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|INDEXED_GIMAGE
condition|)
block|{
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
name|type
operator|=
name|RGB_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|type
operator|=
name|GRAY_GIMAGE
expr_stmt|;
break|break;
case|case
name|INDEXED
case|:
name|type
operator|=
name|INDEXED_GIMAGE
expr_stmt|;
break|break;
block|}
name|merge_layer
operator|=
name|gimp_layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|type
argument_list|,
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  get the background for compositing  */
name|gimp_image_get_background
argument_list|(
name|gimage
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  init the pixel region  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to the background color  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*  The final merged layer inherits the name of the bottom most layer        *  and the resulting layer has an alpha channel        *  whether or not the original did        *  Opacity is set to 100% and the MODE is set to normal        */
name|merge_layer
operator|=
name|gimp_layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|gimp_drawable_type_with_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
literal|"merged layer"
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  Set the layer to transparent  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to 0's  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  Find the index in the layer list of the bottom layer--we need this        *  in order to add the final, merged layer to the layer list correctly        */
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|position
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the mode of the bottom layer to normal so that the contents        *  aren't lost when merging with the all-alpha merge_layer        *  Keep a pointer to it so that we can set the mode right after it's        *  been merged so that undo works correctly.        */
name|bottom
operator|=
name|layer
expr_stmt|;
name|bottom_mode
operator|=
name|bottom
operator|->
name|mode
expr_stmt|;
comment|/* DISSOLVE_MODE is special since it is the only mode that does not        *  work on the projection with the lower layer, but only locally on        *  the layers alpha channel.         */
if|if
condition|(
name|bottom
operator|->
name|mode
operator|!=
name|DISSOLVE_MODE
condition|)
name|bottom
operator|->
name|mode
operator|=
name|NORMAL_MODE
expr_stmt|;
block|}
comment|/* Copy the tattoo and parasites of the bottom layer to the new layer */
name|gimp_drawable_set_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|gimp_drawable_get_tattoo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|parasites
operator|=
name|parasite_list_copy
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and        *  if it's actually legal...        */
name|operation
operator|=
name|valid_combinations
index|[
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
index|]
index|[
name|gimp_drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_merge_layers attempting to merge incompatible layers\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x3
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y3
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x4
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y4
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|y1
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
comment|/* Save old mode in undo */
if|if
condition|(
name|bottom
condition|)
name|bottom
operator|->
name|mode
operator|=
name|bottom_mode
expr_stmt|;
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
comment|/*  if the type is flatten, remove all the remaining layers  */
if|if
condition|(
name|merge_type
operator|==
name|FLATTEN_IMAGE
condition|)
block|{
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Add the layer to the gimage  */
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|position
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set the name after the original layers have been removed so we    * don't end up with #2 appended to the name    */
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*  End the merge undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Update the gimage  */
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*reinit_layer_idlerender (gimage, merge_layer);*/
return|return
name|merge_layer
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_layer (GimpImage * gimage,GimpLayer * layer,gint position)
name|gimp_image_add_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_layer: attempt to add layer to wrong image"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"gimp_image_add_layer: trying to add layer to image twice"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*  Prepare a layer undo and push it  */
name|lu
operator|=
name|g_new
argument_list|(
name|LayerUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|LAYER_ADD_UNDO
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|gimage
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
comment|/*  let the layer know about the gimage  */
name|gimp_drawable_set_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer has a mask, set the mask's gimage and layer */
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|gimp_drawable_set_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
block|}
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
name|position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|gimage
operator|->
name|active_layer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*  If there is a floating selection (and this isn't it!),        *  make sure the insert position is greater than 0        */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|&&
operator|(
name|gimage
operator|->
name|floating_sel
operator|!=
name|layer
operator|)
operator|&&
name|position
operator|==
literal|0
condition|)
name|position
operator|=
literal|1
expr_stmt|;
block|}
name|gimp_container_insert
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  update the new layer's area  */
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_layer (GimpImage * gimage,GimpLayer * layer)
name|gimp_image_remove_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|layer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Push a layer undo  */
name|lu
operator|=
name|g_new
argument_list|(
name|LayerUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|layer
expr_stmt|;
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|LAYER_REMOVE_UNDO
argument_list|,
name|lu
argument_list|)
expr_stmt|;
name|gtk_object_ref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  If this was the floating selection, reset the fs pointer  */
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_reset
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|layer_stack
condition|)
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|layer_stack
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Send out REMOVED signal from layer */
name|gimp_drawable_removed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gdisplays_update_full
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpLayerMask
modifier|*
DECL|function|gimp_image_add_layer_mask (GimpImage * gimage,GimpLayer * layer,GimpLayerMask * mask)
name|gimp_image_add_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GimpLayerMask
modifier|*
name|mask
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER_MASK
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|!=
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask since\nthe layer already has one."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|gimp_drawable_is_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask to a\nlayer in an indexed image."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|gimp_layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask to a layer\nwith no alpha channel."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask of different dimensions than specified layer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gimp_layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer undo and push it  */
name|lmu
operator|=
name|g_new
argument_list|(
name|LayerMaskUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|LAYER_MASK_ADD_UNDO
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_image_remove_layer_mask (GimpImage * gimage,GimpLayer * layer,MaskApplyMode mode)
name|gimp_image_remove_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|MaskApplyMode
name|mode
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|gint
name|off_x
decl_stmt|;
name|gint
name|off_y
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
operator|||
operator|!
name|layer
operator|->
name|mask
condition|)
return|return
name|NULL
return|;
comment|/*  Start an undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_APPLY_MASK_UNDO
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer mask undo--push it below  */
name|lmu
operator|=
name|g_new
argument_list|(
name|LayerMaskUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|layer
operator|->
name|mask
expr_stmt|;
name|lmu
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|gimp_layer_apply_mask
argument_list|(
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*  Push the undo--Important to do it here, AFTER the call    *   to layer_apply_mask, in case the undo push fails and the    *   mask is deleted    */
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|LAYER_MASK_REMOVE_UNDO
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
comment|/*  end the undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If applying actually changed the view  */
if|if
condition|(
operator|(
name|mode
operator|==
name|APPLY
operator|&&
operator|(
operator|!
name|lmu
operator|->
name|apply_mask
operator|||
name|lmu
operator|->
name|show_mask
operator|)
operator|)
operator|||
operator|(
name|mode
operator|==
name|DISCARD
operator|&&
operator|(
name|lmu
operator|->
name|apply_mask
operator|||
name|lmu
operator|->
name|show_mask
operator|)
operator|)
condition|)
block|{
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_raise_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_raise_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be raiseed any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|index
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_lower_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_lower_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be lowered any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|gimp_image_position_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|index
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_position_channel (GimpImage * gimage,GimpChannel * channel,gint new_index)
name|gimp_image_position_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|new_index
parameter_list|)
block|{
name|gint
name|index
decl_stmt|;
name|gint
name|num_channels
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|num_channels
operator|=
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_index
operator|<
literal|0
condition|)
name|new_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_index
operator|>=
name|num_channels
condition|)
name|new_index
operator|=
name|num_channels
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|index
condition|)
return|return
name|TRUE
return|;
name|gimp_container_reorder
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|new_index
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_add_channel (GimpImage * gimage,GimpChannel * channel,gint position)
name|gimp_image_add_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
literal|"%s(): attempt to add channel to wrong image"
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"%s(): trying to add channel to image twice"
argument_list|,
name|G_GNUC_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*  Push a channel undo  */
name|cu
operator|=
name|g_new
argument_list|(
name|ChannelUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|CHANNEL_ADD_UNDO
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/*  add the channel to the list  */
name|gimp_container_add
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active channel  */
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  if channel is visible, update the image  */
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_channel (GimpImage * gimage,GimpChannel * channel)
name|gimp_image_remove_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|gimp_container_have
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Prepare a channel undo--push it below  */
name|cu
operator|=
name|g_new
argument_list|(
name|ChannelUndo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
name|gimp_container_get_child_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|CHANNEL_REMOVE_UNDO
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|gtk_object_ref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_container_remove
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out REMOVED signal from channel */
name|gimp_drawable_removed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|gimp_container_get_child_by_index
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_viewable_invalidate_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gdisplays_update_full
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Access functions                                        */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_is_empty (const GimpImage * gimage)
name|gimp_image_is_empty
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_image_active_drawable (const GimpImage * gimage)
name|gimp_image_active_drawable
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|gimage
operator|->
name|active_channel
condition|)
block|{
return|return
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_channel
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
condition|)
block|{
name|layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpImageBaseType
DECL|function|gimp_image_base_type (const GimpImage * gimage)
name|gimp_image_base_type
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_base_type_with_alpha (const GimpImage * gimage)
name|gimp_image_base_type_with_alpha
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimage
operator|->
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
return|return
name|RGBA_GIMAGE
return|;
case|case
name|GRAY
case|:
return|return
name|GRAYA_GIMAGE
return|;
case|case
name|INDEXED
case|:
return|return
name|INDEXEDA_GIMAGE
return|;
block|}
return|return
name|RGB_GIMAGE
return|;
block|}
end_function

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_image_filename (const GimpImage * gimage)
name|gimp_image_filename
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|filename
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimage
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filename
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|filename
condition|?
name|filename
else|:
name|_
argument_list|(
literal|"Untitled"
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_is_enabled (const GimpImage * gimage)
name|gimp_image_undo_is_enabled
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|undo_on
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_freeze (GimpImage * gimage)
name|gimp_image_undo_freeze
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_thaw (GimpImage * gimage)
name|gimp_image_undo_thaw
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_disable (GimpImage * gimage)
name|gimp_image_undo_disable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_freeze
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_undo_enable (GimpImage * gimage)
name|gimp_image_undo_enable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Free all undo steps as they are now invalidated  */
name|undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimp_image_undo_thaw
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_undo_event (GimpImage * gimage,gint event)
name|gimp_image_undo_event
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|gint
name|event
parameter_list|)
block|{
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|UNDO_EVENT
index|]
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE about the gimage->dirty counter:  *   If 0, then the image is clean (ie, copy on disk is the same as the one   *      in memory).  *   If positive, then that's the number of dirtying operations done  *       on the image since the last save.  *   If negative, then user has hit undo and gone back in time prior  *       to the saved copy.  Hitting redo will eventually come back to  *       the saved copy.  *  *   The image is dirty (ie, needs saving) if counter is non-zero.  *  *   If the counter is around 10000, this is due to undo-ing back  *   before a saved version, then mutating the image (thus destroying  *   the redo stack).  Once this has happened, it's impossible to get  *   the image back to the state on disk, since the redo info has been  *   freed.  See undo.c for the gorey details.  */
end_comment

begin_comment
comment|/*  * NEVER CALL gimp_image_dirty() directly!  *  * If your code has just dirtied the image, push an undo instead.  * Failing that, push the trivial undo which tells the user the  * command is not undoable: undo_push_cantundo() (But really, it would  * be best to push a proper undo).  If you just dirty the image  * without pushing an undo then the dirty count is increased, but  * popping that many undo actions won't lead to a clean image.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_dirty (GimpImage * gimage)
name|gimp_image_dirty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|++
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|DIRTY
index|]
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"dirty %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|-
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_clean (GimpImage * gimage)
name|gimp_image_clean
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|--
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"clean %d -> %d\n"
operator|,
name|gimage
operator|->
name|dirty
operator|+
literal|1
operator|,
name|gimage
operator|->
name|dirty
operator|)
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_clean_all (GimpImage * gimage)
name|gimp_image_clean_all
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|CLEAN
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_image_floating_sel (const GimpImage * gimage)
name|gimp_image_floating_sel
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|gimage
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|guchar
modifier|*
DECL|function|gimp_image_cmap (const GimpImage * gimage)
name|gimp_image_cmap
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_drawable_cmap
argument_list|(
name|gimp_image_active_drawable
argument_list|(
name|gimage
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection access functions                             */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_projection (GimpImage * gimage)
name|gimp_image_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|->
name|projection
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tile_manager_width
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|width
operator|)
operator|||
operator|(
name|tile_manager_height
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|height
operator|)
condition|)
block|{
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
return|return
name|gimage
operator|->
name|projection
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_projection_type (const GimpImage * gimage)
name|gimp_image_projection_type
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|proj_type
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_projection_bytes (const GimpImage * gimage)
name|gimp_image_projection_bytes
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|proj_bytes
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_projection_opacity (const GimpImage * gimage)
name|gimp_image_projection_opacity
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|OPAQUE_OPACITY
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_projection_realloc (GimpImage * gimage)
name|gimp_image_projection_realloc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Composition access functions                            */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_composite (GimpImage * gimage)
name|gimp_image_composite
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpImageType
DECL|function|gimp_image_composite_type (const GimpImage * gimage)
name|gimp_image_composite_type
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_type
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_image_composite_bytes (const GimpImage * gimage)
name|gimp_image_composite_bytes
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_bytes
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_image_preview_valid (const GimpImage * gimage)
name|gimp_image_preview_valid
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|comp_preview_valid
return|;
block|}
end_function

begin_function
specifier|static
name|TempBuf
modifier|*
DECL|function|gimp_image_get_preview (GimpViewable * viewable,gint width,gint height)
name|gimp_image_get_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|comp_preview_valid
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|width
operator|==
name|width
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|height
operator|==
name|height
condition|)
block|{
comment|/*  The easy way  */
return|return
name|gimage
operator|->
name|comp_preview
return|;
block|}
else|else
block|{
comment|/*  The hard way  */
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
comment|/*  Actually construct the composite preview from the layer previews!        *  This might seem ridiculous, but it's actually the best way, given        *  a number of unsavory alternatives.        */
name|gimage
operator|->
name|comp_preview
operator|=
name|gimp_image_get_new_preview
argument_list|(
name|viewable
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|gimage
operator|->
name|comp_preview
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|TempBuf
modifier|*
DECL|function|gimp_image_get_new_preview (GimpViewable * viewable,gint width,gint height)
name|gimp_image_get_new_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|TempBuf
modifier|*
name|comp
decl_stmt|;
name|TempBuf
modifier|*
name|layer_buf
decl_stmt|;
name|TempBuf
modifier|*
name|mask_buf
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|gdouble
name|ratio
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gboolean
name|construct_flag
decl_stmt|;
name|gint
name|visible
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gimage
operator|=
name|GIMP_IMAGE
argument_list|(
name|viewable
argument_list|)
expr_stmt|;
name|ratio
operator|=
operator|(
name|gdouble
operator|)
name|width
operator|/
operator|(
name|gdouble
operator|)
name|gimage
operator|->
name|width
expr_stmt|;
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|bytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|bytes
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*  The construction buffer  */
name|comp
operator|=
name|temp_buf_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|temp_buf_data_clear
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|floating_sel
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible to the list  */
if|if
condition|(
name|gimp_drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
comment|/*  floating selections are added right above the layer  	      they are attached to  */
if|if
condition|(
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|floating_sel
operator|=
name|layer
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|floating_sel
operator|&&
name|floating_sel
operator|->
name|fs
operator|.
name|drawable
operator|==
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|floating_sel
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|construct_flag
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|ratio
operator|*
name|off_x
argument_list|)
expr_stmt|;
name|y
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|ratio
operator|*
name|off_y
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|ratio
operator|*
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|ratio
operator|*
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|h
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src1PR
operator|.
name|bytes
operator|=
name|comp
operator|->
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|src1PR
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|src1PR
operator|.
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|rowstride
operator|=
name|comp
operator|->
name|width
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
operator|+
name|y1
operator|*
name|src1PR
operator|.
name|rowstride
operator|+
name|x1
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|layer_buf
operator|=
name|gimp_viewable_get_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|src2PR
operator|.
name|bytes
operator|=
name|layer_buf
operator|->
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|w
operator|=
name|src1PR
operator|.
name|w
expr_stmt|;
name|src2PR
operator|.
name|h
operator|=
name|src1PR
operator|.
name|h
expr_stmt|;
name|src2PR
operator|.
name|x
operator|=
name|src1PR
operator|.
name|x
expr_stmt|;
name|src2PR
operator|.
name|y
operator|=
name|src1PR
operator|.
name|y
expr_stmt|;
name|src2PR
operator|.
name|rowstride
operator|=
name|layer_buf
operator|->
name|width
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|layer_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|src2PR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|mask_buf
operator|=
name|gimp_viewable_get_preview
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|maskPR
operator|.
name|bytes
operator|=
name|mask_buf
operator|->
name|bytes
expr_stmt|;
name|maskPR
operator|.
name|rowstride
operator|=
name|mask_buf
operator|->
name|width
expr_stmt|;
name|maskPR
operator|.
name|data
operator|=
name|mask_buf_data
argument_list|(
name|mask_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|maskPR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|maskPR
operator|.
name|bytes
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  Based on the type of the layer, project the layer onto the        *   composite preview...        *  Indexed images are actually already converted to RGB and RGBA,        *   so just project them as if they were type "intensity"        *  Send in all TRUE for visible since that info doesn't matter        *   for previews        */
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
case|case
name|INDEXED_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|construct_flag
operator|=
name|TRUE
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
return|return
name|comp
return|;
block|}
end_function

end_unit

