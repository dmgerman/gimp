begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-2003 Spencer Kimball, Peter Mattis, and others  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-surround.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/scale-funcs.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable-transform.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FINITE
argument_list|)
end_if

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|finite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_ISFINITE
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|isfinite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|G_OS_WIN32
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|_finite(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"no FINITE() implementation available?!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|MIN4 (a,b,c,d)
define|#
directive|define
name|MIN4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MIN(MIN(a,b),MIN(c,d))
end_define

begin_define
DECL|macro|MAX4 (a,b,c,d)
define|#
directive|define
name|MAX4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MAX(MAX(a,b),MAX(c,d))
end_define

begin_comment
comment|/*  forward function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gboolean
name|supersample_dtest
parameter_list|(
name|gdouble
name|u0
parameter_list|,
name|gdouble
name|v0
parameter_list|,
name|gdouble
name|u1
parameter_list|,
name|gdouble
name|v1
parameter_list|,
name|gdouble
name|u2
parameter_list|,
name|gdouble
name|v2
parameter_list|,
name|gdouble
name|u3
parameter_list|,
name|gdouble
name|v3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gdouble
name|uc
parameter_list|,
name|gdouble
name|vc
parameter_list|,
name|gdouble
name|u0
parameter_list|,
name|gdouble
name|v0
parameter_list|,
name|gdouble
name|u1
parameter_list|,
name|gdouble
name|v1
parameter_list|,
name|gdouble
name|u2
parameter_list|,
name|gdouble
name|v2
parameter_list|,
name|gdouble
name|u3
parameter_list|,
name|gdouble
name|v3
parameter_list|,
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sample_lanczos
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|kernel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
modifier|*
name|kernel_lanczos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_affine (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,const GimpMatrix3 * matrix,GimpTransformDirection direction,GimpInterpolationType interpolation_type,gboolean supersample,gint recursion_level,gboolean clip_result,GimpProgress * progress)
name|gimp_drawable_transform_tiles_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gboolean
name|supersample
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|gboolean
name|clip_result
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|PixelRegion
name|destPR
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|GimpMatrix3
name|m
decl_stmt|;
name|GimpMatrix3
name|inv
decl_stmt|;
name|PixelSurround
name|surround
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/* target bounding box */
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* target coordinates */
name|gint
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|u2
decl_stmt|,
name|v2
decl_stmt|;
comment|/* source bounding box */
name|gdouble
name|uinc
decl_stmt|,
name|vinc
decl_stmt|,
name|winc
decl_stmt|;
comment|/* increments in source coordinates                                          pr horizontal target coordinate */
name|gdouble
name|u
index|[
literal|5
index|]
decl_stmt|,
name|v
index|[
literal|5
index|]
decl_stmt|;
comment|/* source coordinates,                                   2                                  / \    0 is sample in the centre of pixel                                 1 0 3   1..4 is offset 1 pixel in each                                  \ /    direction (in target space)                                   4                                        */
name|gdouble
name|tu
index|[
literal|5
index|]
decl_stmt|,
name|tv
index|[
literal|5
index|]
decl_stmt|,
name|tw
index|[
literal|5
index|]
decl_stmt|;
comment|/* undivided source coordinates and                                          divisor */
name|gdouble
modifier|*
name|kernel
init|=
name|NULL
decl_stmt|;
comment|/* Lanczos kernel                    */
name|gint
name|coords
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|matrix
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|progress
operator|==
name|NULL
operator|||
name|GIMP_IS_PROGRESS
argument_list|(
name|progress
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|matrix
expr_stmt|;
name|inv
operator|=
operator|*
name|matrix
expr_stmt|;
name|alpha
operator|=
literal|0
expr_stmt|;
comment|/*  turn interpolation off for simple transformations (e.g. rot90)  */
if|if
condition|(
name|gimp_matrix3_is_simple
argument_list|(
name|matrix
argument_list|)
condition|)
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
comment|/*  Get the background color  */
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|bg_color
index|[
name|ALPHA_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|bg_color
index|[
name|ALPHA_G_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_G_PIX
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|bg_color
index|[
name|ALPHA_I_PIX
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|alpha
operator|=
name|ALPHA_I_PIX
expr_stmt|;
comment|/*  If the image is indexed color, ignore interpolation value  */
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_NONE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
comment|/*  setting alpha = 0 will cause the channel's value to be treated    *  as alpha and the color channel loops never to be entered    */
if|if
condition|(
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|alpha
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|GIMP_TRANSFORM_BACKWARD
condition|)
block|{
comment|/*  keep the original matrix here, so we dont need to recalculate        *  the inverse later        */
name|gimp_matrix3_invert
argument_list|(
operator|&
name|inv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Find the inverse of the transformation matrix  */
name|gimp_matrix3_invert
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|u1
argument_list|,
operator|&
name|v1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|u1
operator|+
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|v2
operator|=
name|v1
operator|+
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
comment|/*  Always clip unfloated tiles since they must keep their size  */
if|if
condition|(
name|G_TYPE_FROM_INSTANCE
argument_list|(
name|drawable
argument_list|)
operator|==
name|GIMP_TYPE_CHANNEL
operator|&&
name|alpha
operator|==
literal|0
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/*  Find the bounding coordinates of target */
if|if
condition|(
name|clip_result
condition|)
block|{
name|x1
operator|=
name|u1
expr_stmt|;
name|y1
operator|=
name|v1
expr_stmt|;
name|x2
operator|=
name|u2
expr_stmt|;
name|y2
operator|=
name|v2
expr_stmt|;
block|}
else|else
block|{
name|gdouble
name|dx1
decl_stmt|,
name|dy1
decl_stmt|;
name|gdouble
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
name|gdouble
name|dx3
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|dx4
decl_stmt|,
name|dy4
decl_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|inv
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
operator|&
name|dx1
argument_list|,
operator|&
name|dy1
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|inv
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|,
operator|&
name|dx2
argument_list|,
operator|&
name|dy2
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|inv
argument_list|,
name|u1
argument_list|,
name|v2
argument_list|,
operator|&
name|dx3
argument_list|,
operator|&
name|dy3
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|inv
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|dx4
argument_list|,
operator|&
name|dy4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FINITE
argument_list|(
name|dx1
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dy1
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dx2
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dy2
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dx3
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dy3
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dx4
argument_list|)
operator|||
operator|!
name|FINITE
argument_list|(
name|dy4
argument_list|)
condition|)
block|{
comment|/*  fallback to clip_result if the passed matrix is broken  */
name|x1
operator|=
name|u1
expr_stmt|;
name|y1
operator|=
name|v1
expr_stmt|;
name|x2
operator|=
name|u2
expr_stmt|;
name|y2
operator|=
name|v2
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
operator|(
name|gint
operator|)
name|floor
argument_list|(
name|MIN4
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|,
name|dx3
argument_list|,
name|dx4
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
operator|(
name|gint
operator|)
name|floor
argument_list|(
name|MIN4
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|,
name|dy3
argument_list|,
name|dy4
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX4
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|,
name|dx3
argument_list|,
name|dx4
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX4
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|,
name|dy3
argument_list|,
name|dy4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
name|x2
operator|++
expr_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
name|y2
operator|++
expr_stmt|;
block|}
block|}
comment|/*  Get the new temporary buffer for the transformed result  */
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|tile_manager_bpp
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
comment|/*  If the image is too small for lanczos, switch to cubic interpolation  */
if|if
condition|(
name|interpolation_type
operator|==
name|GIMP_INTERPOLATION_LANCZOS
operator|&&
operator|(
name|x2
operator|-
name|x1
operator|<
name|LANCZOS_WIDTH2
operator|||
name|y2
operator|-
name|y1
operator|<
name|LANCZOS_WIDTH2
operator|)
condition|)
name|interpolation_type
operator|=
name|GIMP_INTERPOLATION_CUBIC
expr_stmt|;
comment|/* initialise the pixel_surround and pixel_cache accessors */
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|orig_tiles
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|orig_tiles
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|kernel
operator|=
name|kernel_lanczos
argument_list|()
expr_stmt|;
name|pixel_surround_init
argument_list|(
operator|&
name|surround
argument_list|,
name|orig_tiles
argument_list|,
name|LANCZOS_WIDTH2
argument_list|,
name|LANCZOS_WIDTH2
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
break|break;
block|}
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_manager_width
argument_list|(
name|new_tiles
argument_list|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|uinc
operator|=
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|vinc
operator|=
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|winc
operator|=
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|coords
operator|=
operator|(
name|interpolation_type
operator|!=
name|GIMP_INTERPOLATION_NONE
operator|)
condition|?
literal|5
else|:
literal|1
expr_stmt|;
comment|/* these loops could be rearranged, depending on which bit of code    * you'd most like to write more than once.    */
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
call|(
name|gdouble
call|)
argument_list|(
name|y
operator|-
name|y1
argument_list|)
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up inverse transform steps */
name|tu
index|[
literal|0
index|]
operator|=
name|uinc
operator|*
name|x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|=
name|vinc
operator|*
name|x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|0
index|]
operator|=
name|winc
operator|*
name|x1
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|interpolation_type
operator|!=
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|gdouble
name|xx
init|=
name|x1
decl_stmt|;
name|gdouble
name|yy
init|=
name|y
decl_stmt|;
name|tu
index|[
literal|1
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|1
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|2
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|2
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|2
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|-
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|3
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|3
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|3
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tu
index|[
literal|4
index|]
operator|=
name|uinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tv
index|[
literal|4
index|]
operator|=
name|vinc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|tw
index|[
literal|4
index|]
operator|=
name|winc
operator|*
operator|(
name|xx
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
operator|(
name|yy
operator|+
literal|1
operator|)
operator|+
name|m
operator|.
name|coeff
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<
name|x2
condition|;
name|x
operator|++
control|)
block|{
name|gint
name|i
decl_stmt|;
comment|/*  normalize homogeneous coords  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tw
index|[
name|i
index|]
operator|==
literal|1.0
condition|)
block|{
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tw
index|[
name|i
index|]
operator|!=
literal|0.0
condition|)
block|{
name|u
index|[
name|i
index|]
operator|=
name|tu
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
name|v
index|[
name|i
index|]
operator|=
name|tv
index|[
name|i
index|]
operator|/
name|tw
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"homogeneous coordinate = 0...\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Set the destination pixels  */
if|if
condition|(
name|interpolation_type
operator|==
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|guchar
name|color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|iu
init|=
operator|(
name|gint
operator|)
name|u
index|[
literal|0
index|]
decl_stmt|;
name|gint
name|iv
init|=
operator|(
name|gint
operator|)
name|v
index|[
literal|0
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|;
if|if
condition|(
name|iu
operator|>=
name|u1
operator|&&
name|iu
operator|<
name|u2
operator|&&
name|iv
operator|>=
name|v1
operator|&&
name|iv
operator|<
name|v2
condition|)
block|{
comment|/*  u, v coordinates into source tiles  */
name|gint
name|u
init|=
name|iu
operator|-
name|u1
decl_stmt|;
name|gint
name|v
init|=
name|iv
operator|-
name|v1
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|orig_tiles
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|color
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|color
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
comment|/* not in source range */
block|{
comment|/*  increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|gint
name|b
decl_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|<
name|u1
operator|||
name|v
index|[
literal|0
index|]
operator|<
name|v1
operator|||
name|u
index|[
literal|0
index|]
operator|>=
name|u2
operator|||
name|v
index|[
literal|0
index|]
operator|>=
name|v2
condition|)
block|{
comment|/* not in source range */
comment|/* increment the destination pointers  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|bg_color
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
block|{
name|guchar
name|color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/* clamp texture coordinates */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|5
condition|;
name|b
operator|++
control|)
block|{
name|u
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|u
index|[
name|b
index|]
argument_list|,
name|u1
argument_list|,
name|u2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|v
index|[
name|b
index|]
argument_list|,
name|v1
argument_list|,
name|v2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|supersample
operator|&&
name|supersample_dtest
argument_list|(
name|u
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|u
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|u
index|[
literal|3
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|u
index|[
literal|4
index|]
argument_list|,
name|v
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|sample_adapt
argument_list|(
name|orig_tiles
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|1
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|1
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|2
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|2
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|3
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|3
index|]
operator|-
name|v1
argument_list|,
name|u
index|[
literal|4
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|4
index|]
operator|-
name|v1
argument_list|,
name|recursion_level
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|sample_linear
argument_list|(
operator|&
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
name|sample_cubic
argument_list|(
operator|&
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|sample_lanczos
argument_list|(
operator|&
name|surround
argument_list|,
name|u
index|[
literal|0
index|]
operator|-
name|u1
argument_list|,
name|v
index|[
literal|0
index|]
operator|-
name|v1
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|,
name|kernel
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  Set the destination pixel  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|color
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coords
condition|;
name|i
operator|++
control|)
block|{
name|tu
index|[
name|i
index|]
operator|+=
name|uinc
expr_stmt|;
name|tv
index|[
name|i
index|]
operator|+=
name|vinc
expr_stmt|;
name|tw
index|[
name|i
index|]
operator|+=
name|winc
expr_stmt|;
block|}
block|}
comment|/*  set the pixel region row  */
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
literal|0
argument_list|,
operator|(
name|y
operator|-
name|y1
operator|)
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|interpolation_type
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_NONE
case|:
break|break;
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
name|pixel_surround_clear
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|pixel_surround_clear
argument_list|(
operator|&
name|surround
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|kernel
argument_list|)
expr_stmt|;
break|break;
block|}
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_flip (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,GimpOrientationType flip_type,gdouble axis,gboolean clip_result)
name|gimp_drawable_transform_tiles_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gint
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|orig_bpp
decl_stmt|;
name|gint
name|new_x
decl_stmt|,
name|new_y
decl_stmt|;
name|gint
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|orig_width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|new_x
operator|=
name|orig_x
expr_stmt|;
name|new_y
operator|=
name|orig_y
expr_stmt|;
name|new_width
operator|=
name|orig_width
expr_stmt|;
name|new_height
operator|=
name|orig_height
expr_stmt|;
switch|switch
condition|(
name|flip_type
condition|)
block|{
case|case
name|GIMP_ORIENTATION_HORIZONTAL
case|:
name|new_x
operator|=
name|RINT
argument_list|(
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|orig_x
operator|+
operator|(
name|gdouble
operator|)
name|orig_width
operator|-
name|axis
operator|)
operator|+
name|axis
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ORIENTATION_VERTICAL
case|:
name|new_y
operator|=
name|RINT
argument_list|(
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|orig_y
operator|+
operator|(
name|gdouble
operator|)
name|orig_height
operator|-
name|axis
operator|)
operator|+
name|axis
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|new_width
argument_list|,
name|new_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clip_result
operator|&&
operator|(
name|new_x
operator|!=
name|orig_y
operator|||
name|new_y
operator|!=
name|orig_y
operator|)
condition|)
block|{
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|clip_x
decl_stmt|,
name|clip_y
decl_stmt|;
name|gint
name|clip_width
decl_stmt|,
name|clip_height
decl_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|destPR
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_rectangle_intersect
argument_list|(
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
operator|&
name|clip_x
argument_list|,
operator|&
name|clip_y
argument_list|,
operator|&
name|clip_width
argument_list|,
operator|&
name|clip_height
argument_list|)
condition|)
block|{
name|orig_x
operator|=
name|new_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|orig_y
operator|=
name|new_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
block|}
name|orig_width
operator|=
name|new_width
operator|=
name|clip_width
expr_stmt|;
name|orig_height
operator|=
name|new_height
operator|=
name|clip_height
expr_stmt|;
block|}
else|else
block|{
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|)
expr_stmt|;
name|orig_x
operator|=
literal|0
expr_stmt|;
name|orig_y
operator|=
literal|0
expr_stmt|;
name|new_x
operator|=
literal|0
expr_stmt|;
name|new_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|new_width
operator|==
literal|0
operator|&&
name|new_height
operator|==
literal|0
condition|)
return|return
name|new_tiles
return|;
if|if
condition|(
name|flip_type
operator|==
name|GIMP_ORIENTATION_HORIZONTAL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|i
operator|+
name|orig_x
argument_list|,
name|orig_y
argument_list|,
literal|1
argument_list|,
name|orig_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
operator|+
name|new_width
operator|-
name|i
operator|-
literal|1
argument_list|,
name|new_y
argument_list|,
literal|1
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|orig_x
argument_list|,
name|i
operator|+
name|orig_y
argument_list|,
name|orig_width
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|new_height
operator|-
name|i
operator|-
literal|1
argument_list|,
name|new_width
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_drawable_transform_rotate_point (gint x,gint y,GimpRotationType rotate_type,gdouble center_x,gdouble center_y,gint * new_x,gint * new_y)
name|gimp_drawable_transform_rotate_point
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gint
modifier|*
name|new_x
parameter_list|,
name|gint
modifier|*
name|new_y
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|new_x
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|new_y
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|-
operator|(
name|gdouble
operator|)
name|y
operator|+
name|center_y
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|+
operator|(
name|gdouble
operator|)
name|x
operator|-
name|center_x
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|x
operator|-
name|center_x
operator|)
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|y
operator|-
name|center_y
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|+
operator|(
name|gdouble
operator|)
name|y
operator|-
name|center_y
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|-
operator|(
name|gdouble
operator|)
name|x
operator|+
name|center_x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_rotate (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,GimpRotationType rotate_type,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_drawable_transform_tiles_rotate
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|guchar
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|gint
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|orig_bpp
decl_stmt|;
name|gint
name|new_x
decl_stmt|,
name|new_y
decl_stmt|;
name|gint
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|orig_width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_height
expr_stmt|;
name|new_height
operator|=
name|orig_width
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
operator|+
name|orig_width
argument_list|,
name|orig_y
operator|+
name|orig_height
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_width
expr_stmt|;
name|new_height
operator|=
name|orig_height
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
operator|+
name|orig_width
argument_list|,
name|orig_y
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_height
expr_stmt|;
name|new_height
operator|=
name|orig_width
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|clip_result
operator|&&
operator|(
name|new_x
operator|!=
name|orig_x
operator|||
name|new_y
operator|!=
name|orig_y
operator|||
name|new_width
operator|!=
name|orig_width
operator|||
name|new_height
operator|!=
name|orig_height
operator|)
condition|)
block|{
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|clip_x
decl_stmt|,
name|clip_y
decl_stmt|;
name|gint
name|clip_width
decl_stmt|,
name|clip_height
decl_stmt|;
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|destPR
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_rectangle_intersect
argument_list|(
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
operator|&
name|clip_x
argument_list|,
operator|&
name|clip_y
argument_list|,
operator|&
name|clip_width
argument_list|,
operator|&
name|clip_height
argument_list|)
condition|)
block|{
name|gint
name|saved_orig_x
init|=
name|orig_x
decl_stmt|;
name|gint
name|saved_orig_y
init|=
name|orig_y
decl_stmt|;
name|new_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|new_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|clip_x
operator|+
name|clip_width
argument_list|,
name|clip_y
argument_list|,
name|GIMP_ROTATE_270
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|orig_x
operator|-=
name|saved_orig_x
expr_stmt|;
name|orig_y
operator|-=
name|saved_orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_height
expr_stmt|;
name|orig_height
operator|=
name|clip_width
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|orig_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|orig_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_width
expr_stmt|;
name|orig_height
operator|=
name|clip_height
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|clip_x
argument_list|,
name|clip_y
operator|+
name|clip_height
argument_list|,
name|GIMP_ROTATE_90
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|orig_x
operator|-=
name|saved_orig_x
expr_stmt|;
name|orig_y
operator|-=
name|saved_orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_height
expr_stmt|;
name|orig_height
operator|=
name|clip_width
expr_stmt|;
break|break;
block|}
block|}
name|new_width
operator|=
name|clip_width
expr_stmt|;
name|new_height
operator|=
name|clip_height
expr_stmt|;
block|}
else|else
block|{
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|new_width
argument_list|,
name|new_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|)
expr_stmt|;
name|orig_x
operator|=
literal|0
expr_stmt|;
name|orig_y
operator|=
literal|0
expr_stmt|;
name|new_x
operator|=
literal|0
expr_stmt|;
name|new_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|new_width
operator|==
literal|0
operator|&&
name|new_height
operator|==
literal|0
condition|)
return|return
name|new_tiles
return|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|g_assert
argument_list|(
name|new_height
operator|==
name|orig_width
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_height
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_width
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_set_col
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
operator|+
name|i
argument_list|,
name|new_y
argument_list|,
name|new_height
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|g_assert
argument_list|(
name|new_width
operator|==
name|orig_width
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_width
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_width
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|orig_width
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|guchar
modifier|*
name|left
init|=
name|buf
operator|+
name|j
operator|*
name|orig_bpp
decl_stmt|;
name|guchar
modifier|*
name|right
init|=
name|buf
operator|+
operator|(
name|orig_width
operator|-
literal|1
operator|-
name|j
operator|)
operator|*
name|orig_bpp
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|orig_bpp
condition|;
name|k
operator|++
control|)
block|{
name|guchar
name|tmp
init|=
name|left
index|[
name|k
index|]
decl_stmt|;
name|left
index|[
name|k
index|]
operator|=
name|right
index|[
name|k
index|]
expr_stmt|;
name|right
index|[
name|k
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|i
argument_list|,
name|new_width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|g_assert
argument_list|(
name|new_width
operator|==
name|orig_height
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_width
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_col
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
operator|+
name|orig_width
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_y
argument_list|,
name|orig_height
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|i
argument_list|,
name|new_width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_affine (GimpDrawable * drawable,GimpContext * context,const GimpMatrix3 * matrix,GimpTransformDirection direction,GimpInterpolationType interpolation_type,gboolean supersample,gint recursion_level,gboolean clip_result,GimpProgress * progress)
name|gimp_drawable_transform_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gboolean
name|supersample
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|gboolean
name|clip_result
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|matrix
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|progress
operator|==
name|NULL
operator|||
name|GIMP_IS_PROGRESS
argument_list|(
name|progress
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|_
argument_list|(
literal|"Transform"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_affine
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|matrix
argument_list|,
name|GIMP_TRANSFORM_FORWARD
argument_list|,
name|interpolation_type
argument_list|,
name|supersample
argument_list|,
name|recursion_level
argument_list|,
name|clip_result
argument_list|,
name|progress
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|success
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_flip (GimpDrawable * drawable,GimpContext * context,GimpOrientationType flip_type,gboolean auto_center,gdouble axis,gboolean clip_result)
name|gimp_drawable_transform_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gboolean
name|auto_center
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|Q_
argument_list|(
literal|"command|Flip"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|auto_center
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flip_type
condition|)
block|{
case|case
name|GIMP_ORIENTATION_HORIZONTAL
case|:
name|axis
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|off_x
operator|+
operator|(
name|gdouble
operator|)
name|width
operator|/
literal|2.0
operator|)
expr_stmt|;
break|break;
case|case
name|GIMP_ORIENTATION_VERTICAL
case|:
name|axis
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|off_y
operator|+
operator|(
name|gdouble
operator|)
name|height
operator|/
literal|2.0
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/* transform the buffer */
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_flip
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|flip_type
argument_list|,
name|axis
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_tiles
condition|)
block|{
name|success
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_rotate (GimpDrawable * drawable,GimpContext * context,GimpRotationType rotate_type,gboolean auto_center,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_drawable_transform_rotate
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gboolean
name|auto_center
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|Q_
argument_list|(
literal|"command|Rotate"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
if|if
condition|(
name|auto_center
condition|)
block|{
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|center_x
operator|=
operator|(
name|gdouble
operator|)
name|off_x
operator|+
operator|(
name|gdouble
operator|)
name|width
operator|/
literal|2.0
expr_stmt|;
name|center_y
operator|=
operator|(
name|gdouble
operator|)
name|off_y
operator|+
operator|(
name|gdouble
operator|)
name|height
operator|/
literal|2.0
expr_stmt|;
block|}
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_rotate
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|success
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_cut (GimpDrawable * drawable,GimpContext * context,gboolean * new_layer)
name|gimp_drawable_transform_cut
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
modifier|*
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|new_layer
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  extract the selected mask if there is a selection  */
if|if
condition|(
operator|!
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/* set the keep_indexed flag to FALSE here, since we use        * gimp_layer_new_from_tiles() later which assumes that the tiles        * are either RGB or GRAY.  Eeek!!!              (Sven)        */
if|if
condition|(
name|gimp_drawable_mask_intersect
argument_list|(
name|drawable
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|h
argument_list|)
condition|)
block|{
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tiles
operator|=
name|NULL
expr_stmt|;
operator|*
name|new_layer
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
comment|/*  otherwise, just copy the layer  */
block|{
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|context
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|tiles
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_drawable_transform_paste (GimpDrawable * drawable,TileManager * tiles,gboolean new_layer)
name|gimp_drawable_transform_paste
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|gboolean
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|undo_desc
init|=
name|NULL
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tiles
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
name|undo_desc
operator|=
name|_
argument_list|(
literal|"Transform Layer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|undo_desc
operator|=
name|_
argument_list|(
literal|"Transform Channel"
argument_list|)
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|tile_manager_get_offsets
argument_list|(
name|tiles
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_EDIT_PASTE
argument_list|,
name|undo_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_layer
condition|)
block|{
name|layer
operator|=
name|gimp_layer_new_from_tiles
argument_list|(
name|tiles
argument_list|,
name|image
argument_list|,
name|gimp_drawable_type_with_alpha
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Transformation"
argument_list|)
argument_list|,
name|GIMP_OPACITY_OPAQUE
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
operator|=
name|offset_x
expr_stmt|;
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
operator|=
name|offset_y
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|layer
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GimpImageType
name|drawable_type
decl_stmt|;
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|(
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
operator|==
literal|2
operator|||
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
operator|==
literal|4
operator|)
condition|)
block|{
name|drawable_type
operator|=
name|gimp_drawable_type_with_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_set_tiles_full
argument_list|(
name|drawable
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|tiles
argument_list|,
name|drawable_type
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
DECL|macro|BILINEAR (jk,j1k,jk1,j1k1,dx,dy)
define|#
directive|define
name|BILINEAR
parameter_list|(
name|jk
parameter_list|,
name|j1k
parameter_list|,
name|jk1
parameter_list|,
name|j1k1
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|((1 - dy) * (jk  + dx * (j1k  - jk)) + \                       dy  * (jk1 + dx * (j1k1 - jk1)))
end_define

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the two pixel coords around them:    *  iu to iu + 1, iv to iv + 1    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_linear (PixelSurround * surround,gdouble u,gdouble v,guchar * color,gint bytes,gint alpha)
name|sample_linear
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|guchar
modifier|*
name|alphachan
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha value of result pixel */
name|alphachan
operator|=
operator|&
name|data
index|[
name|alpha
index|]
expr_stmt|;
name|a_val
operator|=
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
argument_list|,
name|alphachan
index|[
name|row
index|]
argument_list|,
name|alphachan
index|[
name|row
operator|+
name|bytes
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>=
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bilinear (c * alpha) / bilinear (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
operator|(
name|a_recip
operator|*
name|BILINEAR
argument_list|(
name|alphachan
index|[
literal|0
index|]
operator|*
name|data
index|[
name|i
index|]
argument_list|,
name|alphachan
index|[
name|bytes
index|]
operator|*
name|data
index|[
name|bytes
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|row
index|]
operator|*
name|data
index|[
name|row
operator|+
name|i
index|]
argument_list|,
name|alphachan
index|[
name|row
operator|+
name|bytes
index|]
operator|*
name|data
index|[
name|row
operator|+
name|bytes
operator|+
name|i
index|]
argument_list|,
name|du
argument_list|,
name|dv
argument_list|)
operator|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_release
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* macros to handle conversion to/from fixed point, this fixed point code  * uses signed integers, by using 8 bits for the fractional part we have  *  *  1 bit  sign  * 21 bits integer part  *  8 bit  fractional part  *  * 1023 discrete subpixel sample positions should be enough for the needs  * of the supersampling algorithm, drawables where the dimensions have a need  * exceeding 2^21 ( 2097152px, will typically use terabytes of memory, when  * that is the common need, we can probably assume 64 bit integers and adjust  * FIXED_SHIFT accordingly.  */
end_comment

begin_define
DECL|macro|FIXED_SHIFT
define|#
directive|define
name|FIXED_SHIFT
value|10
end_define

begin_define
DECL|macro|FIXED_UNIT
define|#
directive|define
name|FIXED_UNIT
value|(1<< FIXED_SHIFT)
end_define

begin_define
DECL|macro|DOUBLE2FIXED (val)
define|#
directive|define
name|DOUBLE2FIXED
parameter_list|(
name|val
parameter_list|)
value|((val) * FIXED_UNIT)
end_define

begin_define
DECL|macro|FIXED2DOUBLE (val)
define|#
directive|define
name|FIXED2DOUBLE
parameter_list|(
name|val
parameter_list|)
value|((val) / FIXED_UNIT)
end_define

begin_comment
comment|/*     bilinear interpolation of a fixed point pixel */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_bi (TileManager * tm,gint x,gint y,guchar * color,guchar * bg_color,gint bpp,gint alpha)
name|sample_bi
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|guchar
name|C
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|xscale
init|=
operator|(
name|x
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|gint
name|yscale
init|=
operator|(
name|y
operator|&
operator|(
name|FIXED_UNIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|gint
name|x0
init|=
name|x
operator|>>
name|FIXED_SHIFT
decl_stmt|;
name|gint
name|y0
init|=
name|y
operator|>>
name|FIXED_SHIFT
decl_stmt|;
name|gint
name|x1
init|=
name|x0
operator|+
literal|1
decl_stmt|;
name|gint
name|y1
init|=
name|y0
operator|+
literal|1
decl_stmt|;
comment|/*  fill the color with default values, since read_pixel_data_1    *  does nothing, when accesses are out of bounds.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
operator|&
name|C
index|[
name|i
index|]
operator|)
operator|=
operator|*
operator|(
name|guint
operator|*
operator|)
operator|(
name|bg_color
operator|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y0
argument_list|,
name|C
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x0
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|tm
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|C
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
DECL|macro|lerp (v1,v2,r)
define|#
directive|define
name|lerp
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|r
parameter_list|)
define|\
value|(((guint)(v1) * (FIXED_UNIT - (guint)(r)) + \           (guint)(v2) * (guint)(r))>> FIXED_SHIFT)
name|color
index|[
name|alpha
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* to avoid problems, calculate with premultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|0
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|1
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|2
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
operator|(
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
operator|*
name|C
index|[
literal|3
index|]
index|[
name|alpha
index|]
operator|/
literal|255
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
name|lerp
argument_list|(
name|lerp
argument_list|(
name|C
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|,
name|C
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|lerp
argument_list|(
name|C
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|,
name|C
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|,
name|yscale
argument_list|)
argument_list|,
name|xscale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
undef|#
directive|undef
name|lerp
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if one of the deltas of the  * quad edge is> 1.0 (16.16 fixed values).  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|supersample_test (gint x0,gint y0,gint x1,gint y1,gint x2,gint y2,gint x3,gint y3)
name|supersample_test
parameter_list|(
name|gint
name|x0
parameter_list|,
name|gint
name|y0
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|x3
parameter_list|,
name|gint
name|y3
parameter_list|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
name|FIXED_UNIT
operator|||
name|abs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
name|FIXED_UNIT
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  *  Returns TRUE if one of the deltas of the  *  quad edge is> 1.0 (double values).  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|supersample_dtest (gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3)
name|supersample_dtest
parameter_list|(
name|gdouble
name|x0
parameter_list|,
name|gdouble
name|y0
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|gdouble
name|x3
parameter_list|,
name|gdouble
name|y3
parameter_list|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|x0
operator|-
name|x1
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x2
operator|-
name|x3
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|x3
operator|-
name|x0
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y0
operator|-
name|y1
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y2
operator|-
name|y3
argument_list|)
operator|>
literal|1.0
operator|||
name|fabs
argument_list|(
name|y3
operator|-
name|y0
argument_list|)
operator|>
literal|1.0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*     sample a grid that is spaced according to the quadraliteral's edges,     it subdivides a maximum of level times before sampling.     0..3 is a cycle around the quad */
end_comment

begin_function
specifier|static
name|void
DECL|function|get_sample (TileManager * tm,gint xc,gint yc,gint x0,gint y0,gint x1,gint y1,gint x2,gint y2,gint x3,gint y3,gint * cc,gint level,guint * color,guchar * bg_color,gint bpp,gint alpha)
name|get_sample
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xc
parameter_list|,
name|gint
name|yc
parameter_list|,
name|gint
name|x0
parameter_list|,
name|gint
name|y0
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|x3
parameter_list|,
name|gint
name|y3
parameter_list|,
name|gint
modifier|*
name|cc
parameter_list|,
name|gint
name|level
parameter_list|,
name|guint
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
if|if
condition|(
operator|!
name|level
operator|||
operator|!
name|supersample_test
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
condition|)
block|{
name|gint
name|i
decl_stmt|;
name|guchar
name|C
index|[
literal|4
index|]
decl_stmt|;
name|sample_bi
argument_list|(
name|tm
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|+=
name|C
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|cc
operator|)
operator|++
expr_stmt|;
comment|/* increase number of samples taken */
block|}
else|else
block|{
name|gint
name|tx
decl_stmt|,
name|lx
decl_stmt|,
name|rx
decl_stmt|,
name|bx
decl_stmt|,
name|tlx
decl_stmt|,
name|trx
decl_stmt|,
name|blx
decl_stmt|,
name|brx
decl_stmt|;
name|gint
name|ty
decl_stmt|,
name|ly
decl_stmt|,
name|ry
decl_stmt|,
name|by
decl_stmt|,
name|tly
decl_stmt|,
name|try
decl_stmt|,
name|bly
decl_stmt|,
name|bry
decl_stmt|;
comment|/* calculate subdivided corner coordinates (including centercoords          thus using a bilinear interpolation,. almost as good as          doing the perspective transform for each subpixel coordinate*/
name|tx
operator|=
operator|(
name|x0
operator|+
name|x1
operator|)
operator|/
literal|2
expr_stmt|;
name|tlx
operator|=
operator|(
name|x0
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|trx
operator|=
operator|(
name|x1
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|lx
operator|=
operator|(
name|x0
operator|+
name|x3
operator|)
operator|/
literal|2
expr_stmt|;
name|rx
operator|=
operator|(
name|x1
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|blx
operator|=
operator|(
name|x3
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|brx
operator|=
operator|(
name|x2
operator|+
name|xc
operator|)
operator|/
literal|2
expr_stmt|;
name|bx
operator|=
operator|(
name|x3
operator|+
name|x2
operator|)
operator|/
literal|2
expr_stmt|;
name|ty
operator|=
operator|(
name|y0
operator|+
name|y1
operator|)
operator|/
literal|2
expr_stmt|;
name|tly
operator|=
operator|(
name|y0
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|try
operator|=
operator|(
name|y1
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|ly
operator|=
operator|(
name|y0
operator|+
name|y3
operator|)
operator|/
literal|2
expr_stmt|;
name|ry
operator|=
operator|(
name|y1
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|bly
operator|=
operator|(
name|y3
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|bry
operator|=
operator|(
name|y2
operator|+
name|yc
operator|)
operator|/
literal|2
expr_stmt|;
name|by
operator|=
operator|(
name|y3
operator|+
name|y2
operator|)
operator|/
literal|2
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|tlx
argument_list|,
name|tly
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|trx
argument_list|,
name|try
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|brx
argument_list|,
name|bry
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|blx
argument_list|,
name|bly
argument_list|,
name|lx
argument_list|,
name|ly
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|bx
argument_list|,
name|by
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|cc
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|color
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|sample_adapt (TileManager * tm,gdouble xc,gdouble yc,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3,gint level,guchar * color,guchar * bg_color,gint bpp,gint alpha)
name|sample_adapt
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gdouble
name|xc
parameter_list|,
name|gdouble
name|yc
parameter_list|,
name|gdouble
name|x0
parameter_list|,
name|gdouble
name|y0
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|gdouble
name|x3
parameter_list|,
name|gdouble
name|y3
parameter_list|,
name|gint
name|level
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
modifier|*
name|bg_color
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gint
name|cc
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guint
name|C
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|C
index|[
literal|0
index|]
operator|=
name|C
index|[
literal|1
index|]
operator|=
name|C
index|[
literal|2
index|]
operator|=
name|C
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|get_sample
argument_list|(
name|tm
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|xc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|yc
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y0
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y1
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y2
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|x3
argument_list|)
argument_list|,
name|DOUBLE2FIXED
argument_list|(
name|y3
argument_list|)
argument_list|,
operator|&
name|cc
argument_list|,
name|level
argument_list|,
name|C
argument_list|,
name|bg_color
argument_list|,
name|bpp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc
condition|)
name|cc
operator|=
literal|1
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|C
index|[
name|alpha
index|]
operator|/
name|cc
expr_stmt|;
if|if
condition|(
name|color
index|[
name|alpha
index|]
condition|)
block|{
comment|/* go from premultiplied to postmultiplied alpha */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|C
index|[
name|i
index|]
operator|/
name|cc
operator|)
operator|*
literal|255
operator|)
operator|/
name|color
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
name|color
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* access interleaved pixels */
end_comment

begin_define
DECL|macro|CUBIC_ROW (dx,row,step)
define|#
directive|define
name|CUBIC_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx,\             (row)[0], (row)[step], (row)[step+step], (row)[step+step+step])
end_define

begin_define
DECL|macro|CUBIC_SCALED_ROW (dx,row,arow,step)
define|#
directive|define
name|CUBIC_SCALED_ROW
parameter_list|(
name|dx
parameter_list|,
name|row
parameter_list|,
name|arow
parameter_list|,
name|step
parameter_list|)
define|\
value|gimp_drawable_transform_cubic(dx, \             (arow)[0]              * (row)[0], \             (arow)[step]           * (row)[step], \             (arow)[step+step]      * (row)[step+step], \             (arow)[step+step+step] * (row)[step+step+step])
end_define

begin_comment
comment|/*  Note: cubic function no longer clips result. */
end_comment

begin_comment
comment|/*  Inlining this function makes sample_cubic() run about 10% faster. (Sven) */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|gimp_drawable_transform_cubic (gdouble dx,gint jm1,gint j,gint jp1,gint jp2)
name|gimp_drawable_transform_cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
block|{
name|gdouble
name|result
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Equivalent to Gimp 1.1.1 and earlier - some ringing */
block|result = ((( ( - jm1 + j - jp1 + jp2 ) * dx +                ( jm1 + jm1 - j - j + jp1 - jp2 ) ) * dx +                ( - jm1 + jp1 ) ) * dx + j );
comment|/* Recommended by Mitchell and Netravali - too blurred? */
block|result = ((( ( - 7 * jm1 + 21 * j - 21 * jp1 + 7 * jp2 ) * dx +                ( 15 * jm1 - 36 * j + 27 * jp1 - 6 * jp2 ) ) * dx +                ( - 9 * jm1 + 9 * jp1 ) ) * dx + (jm1 + 16 * j + jp1) ) / 18.0;
endif|#
directive|endif
comment|/* Catmull-Rom - not bad */
name|result
operator|=
operator|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
operator|)
operator|/
literal|2.0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  u& v are the subpixel coordinates of the point in    *  the original selection's floating buffer.    *  We need the four integer pixel coords around them:    *  iu to iu + 3, iv to iv + 3    */
end_comment

begin_function
specifier|static
name|void
DECL|function|sample_cubic (PixelSurround * surround,gdouble u,gdouble v,guchar * color,gint bytes,gint alpha)
name|sample_cubic
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|a_val
decl_stmt|,
name|a_recip
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
operator|-
literal|1
argument_list|,
name|iv
operator|-
literal|1
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
name|u
operator|-
name|iu
expr_stmt|;
name|dv
operator|=
name|v
operator|-
name|iv
expr_stmt|;
comment|/* calculate alpha of result */
name|a_val
operator|=
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_ROW
argument_list|(
name|du
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_val
operator|<=
literal|0.0
condition|)
block|{
name|a_recip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a_val
operator|>
literal|255.0
condition|)
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|a_recip
operator|=
literal|1.0
operator|/
name|a_val
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|a_val
argument_list|)
expr_stmt|;
block|}
comment|/*  for colour channels c,    *  result = bicubic (c * alpha) / bicubic (alpha)    *    *  never entered for alpha == 0    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|newval
init|=
operator|(
name|a_recip
operator|*
name|gimp_drawable_transform_cubic
argument_list|(
name|dv
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|0
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|0
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|1
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|1
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|2
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|2
argument_list|,
name|bytes
argument_list|)
argument_list|,
name|CUBIC_SCALED_ROW
argument_list|(
name|du
argument_list|,
name|i
operator|+
name|data
operator|+
name|row
operator|*
literal|3
argument_list|,
name|data
operator|+
name|alpha
operator|+
name|row
operator|*
literal|3
argument_list|,
name|bytes
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|color
index|[
name|i
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_release
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lanczos */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|sinc (gdouble x)
name|sinc
parameter_list|(
name|gdouble
name|x
parameter_list|)
block|{
name|gdouble
name|y
init|=
name|x
operator|*
name|G_PI
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|EPSILON
condition|)
return|return
literal|1.0
return|;
return|return
name|sin
argument_list|(
name|y
argument_list|)
operator|/
name|y
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum (const guchar * data,gdouble * l,gint row,gint bytes,gint byte)
name|lanczos_sum
parameter_list|(
specifier|const
name|guchar
modifier|*
name|data
parameter_list|,
name|gdouble
modifier|*
name|l
parameter_list|,
name|gint
name|row
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
operator|,
name|k
operator|+=
name|bytes
control|)
name|sum
operator|+=
operator|(
name|l
index|[
name|j
index|]
operator|*
name|data
index|[
name|row
operator|+
name|k
operator|+
name|byte
index|]
operator|)
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum_mul (const guchar * data,const gdouble * l,gint row,gint bytes,gint byte,gint alpha)
name|lanczos_sum_mul
parameter_list|(
specifier|const
name|guchar
modifier|*
name|data
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|l
parameter_list|,
name|gint
name|row
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LANCZOS_WIDTH2
condition|;
name|j
operator|++
operator|,
name|k
operator|+=
name|bytes
control|)
name|sum
operator|+=
operator|(
name|l
index|[
name|j
index|]
operator|*
name|data
index|[
name|row
operator|+
name|k
operator|+
name|byte
index|]
operator|*
name|data
index|[
name|row
operator|+
name|k
operator|+
name|alpha
index|]
operator|)
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|gdouble
modifier|*
DECL|function|kernel_lanczos (void)
name|kernel_lanczos
parameter_list|(
name|void
parameter_list|)
block|{
name|gdouble
modifier|*
name|kernel
decl_stmt|;
name|gdouble
name|x
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dx
init|=
operator|(
name|gdouble
operator|)
name|LANCZOS_WIDTH
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|LANCZOS_SAMPLES
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|kernel
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|LANCZOS_SAMPLES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_SAMPLES
condition|;
name|i
operator|++
control|)
block|{
name|kernel
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|LANCZOS_WIDTH
operator|)
condition|?
operator|(
name|sinc
argument_list|(
name|x
argument_list|)
operator|*
name|sinc
argument_list|(
name|x
operator|/
name|LANCZOS_WIDTH
argument_list|)
operator|)
else|:
literal|0.0
operator|)
expr_stmt|;
name|x
operator|+=
name|dx
expr_stmt|;
block|}
return|return
name|kernel
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|sample_lanczos (PixelSurround * surround,gdouble u,gdouble v,guchar * color,gint bytes,gint alpha,const gdouble * kernel)
name|sample_lanczos
parameter_list|(
name|PixelSurround
modifier|*
name|surround
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|alpha
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|kernel
parameter_list|)
block|{
name|gdouble
name|lu
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* Lanczos sample value              */
name|gdouble
name|lv
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* Lanczos sample value              */
name|gdouble
name|lusum
decl_stmt|,
name|lvsum
decl_stmt|,
name|weight
decl_stmt|;
comment|/* Lanczos weighting vars            */
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|row
decl_stmt|,
name|byte
decl_stmt|;
comment|/* loop vars to fill source window   */
name|gint
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gdouble
name|aval
decl_stmt|,
name|arecip
decl_stmt|;
comment|/* Handle alpha values               */
name|gdouble
name|newval
decl_stmt|;
comment|/* New interpolated RGB value        */
name|gint
name|iu
init|=
name|floor
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|gint
name|iv
init|=
name|floor
argument_list|(
name|v
argument_list|)
decl_stmt|;
comment|/* lock the pixel surround */
name|data
operator|=
name|pixel_surround_lock
argument_list|(
name|surround
argument_list|,
name|iu
operator|-
name|LANCZOS_WIDTH
argument_list|,
name|iv
operator|-
name|LANCZOS_WIDTH
argument_list|)
expr_stmt|;
name|row
operator|=
name|pixel_surround_rowstride
argument_list|(
name|surround
argument_list|)
expr_stmt|;
comment|/* the fractional error */
name|du
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|u
operator|-
name|iu
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
name|dv
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|v
operator|-
name|iv
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
for|for
control|(
name|lusum
operator|=
name|lvsum
operator|=
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|LANCZOS_WIDTH
operator|-
literal|1
init|;
name|j
operator|>=
operator|-
name|LANCZOS_WIDTH
condition|;
name|j
operator|--
operator|,
name|i
operator|++
control|)
block|{
name|lusum
operator|+=
name|lu
index|[
name|i
index|]
operator|=
name|kernel
index|[
name|ABS
argument_list|(
name|j
operator|*
name|LANCZOS_SPP
operator|+
name|du
argument_list|)
index|]
expr_stmt|;
name|lvsum
operator|+=
name|lv
index|[
name|i
index|]
operator|=
name|kernel
index|[
name|ABS
argument_list|(
name|j
operator|*
name|LANCZOS_SPP
operator|+
name|dv
argument_list|)
index|]
expr_stmt|;
block|}
name|weight
operator|=
name|lusum
operator|*
name|lvsum
expr_stmt|;
for|for
control|(
name|aval
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|aval
operator|+=
name|lv
index|[
name|i
index|]
operator|*
name|lanczos_sum
argument_list|(
name|data
argument_list|,
name|lu
argument_list|,
name|i
operator|*
name|row
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
comment|/* calculate alpha of result */
name|aval
operator|/=
name|weight
expr_stmt|;
if|if
condition|(
name|aval
operator|<=
literal|0.0
condition|)
block|{
name|arecip
operator|=
literal|0.0
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aval
operator|>
literal|255.0
condition|)
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|color
index|[
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|aval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|alpha
condition|;
name|byte
operator|++
control|)
block|{
for|for
control|(
name|newval
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|newval
operator|+=
name|lv
index|[
name|i
index|]
operator|*
name|lanczos_sum_mul
argument_list|(
name|data
argument_list|,
name|lu
argument_list|,
name|i
operator|*
name|row
argument_list|,
name|bytes
argument_list|,
name|byte
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|newval
operator|*=
name|arecip
expr_stmt|;
name|color
index|[
name|byte
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
name|pixel_surround_release
argument_list|(
name|surround
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

