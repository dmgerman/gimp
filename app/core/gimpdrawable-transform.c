begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995-2003 Spencer Kimball, Peter Mattis, and others  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimp-transform-region.h"
end_include

begin_include
include|#
directive|include
file|"gimp-transform-resize.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable-transform.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FINITE
argument_list|)
end_if

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|finite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_ISFINITE
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|isfinite(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|G_OS_WIN32
argument_list|)
end_elif

begin_define
DECL|macro|FINITE (x)
define|#
directive|define
name|FINITE
parameter_list|(
name|x
parameter_list|)
value|_finite(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"no FINITE() implementation available?!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|MIN4 (a,b,c,d)
define|#
directive|define
name|MIN4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MIN(MIN(a,b),MIN(c,d))
end_define

begin_define
DECL|macro|MAX4 (a,b,c,d)
define|#
directive|define
name|MAX4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MAX(MAX(a,b),MAX(c,d))
end_define

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_affine (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,const GimpMatrix3 * matrix,GimpTransformDirection direction,GimpInterpolationType interpolation_type,gint recursion_level,GimpTransformResize clip_result,GimpProgress * progress)
name|gimp_drawable_transform_tiles_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|GimpTransformResize
name|clip_result
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|PixelRegion
name|destPR
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|GimpMatrix3
name|m
decl_stmt|;
name|GimpMatrix3
name|inv
decl_stmt|;
name|gint
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|u2
decl_stmt|,
name|v2
decl_stmt|;
comment|/* source bounding box */
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/* target bounding box */
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|matrix
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|progress
operator|==
name|NULL
operator|||
name|GIMP_IS_PROGRESS
argument_list|(
name|progress
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|matrix
expr_stmt|;
name|inv
operator|=
operator|*
name|matrix
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|GIMP_TRANSFORM_BACKWARD
condition|)
block|{
comment|/*  keep the original matrix here, so we dont need to recalculate        *  the inverse later        */
name|gimp_matrix3_invert
argument_list|(
operator|&
name|inv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Find the inverse of the transformation matrix  */
name|gimp_matrix3_invert
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|u1
argument_list|,
operator|&
name|v1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|u1
operator|+
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|v2
operator|=
name|v1
operator|+
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
comment|/*  Always clip unfloated tiles since they must keep their size  */
if|if
condition|(
name|G_TYPE_FROM_INSTANCE
argument_list|(
name|drawable
argument_list|)
operator|==
name|GIMP_TYPE_CHANNEL
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|GIMP_TRANSFORM_RESIZE_CLIP
expr_stmt|;
comment|/*  Find the bounding coordinates of target */
name|gimp_transform_resize_boundary
argument_list|(
operator|&
name|inv
argument_list|,
name|clip_result
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
comment|/*  Get the new temporary buffer for the transformed result  */
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|gimp_transform_region
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
operator|&
name|destPR
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|inv
argument_list|,
name|interpolation_type
argument_list|,
name|recursion_level
argument_list|,
name|progress
argument_list|)
expr_stmt|;
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_flip (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,GimpOrientationType flip_type,gdouble axis,gboolean clip_result)
name|gimp_drawable_transform_tiles_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gint
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|orig_bpp
decl_stmt|;
name|gint
name|new_x
decl_stmt|,
name|new_y
decl_stmt|;
name|gint
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|orig_width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|new_x
operator|=
name|orig_x
expr_stmt|;
name|new_y
operator|=
name|orig_y
expr_stmt|;
name|new_width
operator|=
name|orig_width
expr_stmt|;
name|new_height
operator|=
name|orig_height
expr_stmt|;
switch|switch
condition|(
name|flip_type
condition|)
block|{
case|case
name|GIMP_ORIENTATION_HORIZONTAL
case|:
name|new_x
operator|=
name|RINT
argument_list|(
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|orig_x
operator|+
operator|(
name|gdouble
operator|)
name|orig_width
operator|-
name|axis
operator|)
operator|+
name|axis
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ORIENTATION_VERTICAL
case|:
name|new_y
operator|=
name|RINT
argument_list|(
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|orig_y
operator|+
operator|(
name|gdouble
operator|)
name|orig_height
operator|-
name|axis
operator|)
operator|+
name|axis
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ORIENTATION_UNKNOWN
case|:
name|g_return_val_if_reached
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|new_width
argument_list|,
name|new_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clip_result
operator|&&
operator|(
name|new_x
operator|!=
name|orig_x
operator|||
name|new_y
operator|!=
name|orig_y
operator|)
condition|)
block|{
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|clip_x
decl_stmt|,
name|clip_y
decl_stmt|;
name|gint
name|clip_width
decl_stmt|,
name|clip_height
decl_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|destPR
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_rectangle_intersect
argument_list|(
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
operator|&
name|clip_x
argument_list|,
operator|&
name|clip_y
argument_list|,
operator|&
name|clip_width
argument_list|,
operator|&
name|clip_height
argument_list|)
condition|)
block|{
name|orig_x
operator|=
name|new_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|orig_y
operator|=
name|new_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
block|}
name|orig_width
operator|=
name|new_width
operator|=
name|clip_width
expr_stmt|;
name|orig_height
operator|=
name|new_height
operator|=
name|clip_height
expr_stmt|;
block|}
else|else
block|{
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|)
expr_stmt|;
name|orig_x
operator|=
literal|0
expr_stmt|;
name|orig_y
operator|=
literal|0
expr_stmt|;
name|new_x
operator|=
literal|0
expr_stmt|;
name|new_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|new_width
operator|==
literal|0
operator|&&
name|new_height
operator|==
literal|0
condition|)
return|return
name|new_tiles
return|;
switch|switch
condition|(
name|flip_type
condition|)
block|{
case|case
name|GIMP_ORIENTATION_HORIZONTAL
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|i
operator|+
name|orig_x
argument_list|,
name|orig_y
argument_list|,
literal|1
argument_list|,
name|orig_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
operator|+
name|new_width
operator|-
name|i
operator|-
literal|1
argument_list|,
name|new_y
argument_list|,
literal|1
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ORIENTATION_VERTICAL
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|orig_x
argument_list|,
name|i
operator|+
name|orig_y
argument_list|,
name|orig_width
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|new_height
operator|-
name|i
operator|-
literal|1
argument_list|,
name|new_width
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ORIENTATION_UNKNOWN
case|:
break|break;
block|}
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_drawable_transform_rotate_point (gint x,gint y,GimpRotationType rotate_type,gdouble center_x,gdouble center_y,gint * new_x,gint * new_y)
name|gimp_drawable_transform_rotate_point
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gint
modifier|*
name|new_x
parameter_list|,
name|gint
modifier|*
name|new_y
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|new_x
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|new_y
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|-
operator|(
name|gdouble
operator|)
name|y
operator|+
name|center_y
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|+
operator|(
name|gdouble
operator|)
name|x
operator|-
name|center_x
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|x
operator|-
name|center_x
operator|)
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|-
operator|(
operator|(
name|gdouble
operator|)
name|y
operator|-
name|center_y
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
operator|*
name|new_x
operator|=
name|RINT
argument_list|(
name|center_x
operator|+
operator|(
name|gdouble
operator|)
name|y
operator|-
name|center_y
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|RINT
argument_list|(
name|center_y
operator|-
operator|(
name|gdouble
operator|)
name|x
operator|+
name|center_x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_tiles_rotate (GimpDrawable * drawable,GimpContext * context,TileManager * orig_tiles,GimpRotationType rotate_type,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_drawable_transform_tiles_rotate
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|TileManager
modifier|*
name|orig_tiles
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|guchar
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|gint
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|orig_bpp
decl_stmt|;
name|gint
name|new_x
decl_stmt|,
name|new_y
decl_stmt|;
name|gint
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|orig_tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|orig_width
operator|=
name|tile_manager_width
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_height
operator|=
name|tile_manager_height
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|orig_bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
name|tile_manager_get_offsets
argument_list|(
name|orig_tiles
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_height
expr_stmt|;
name|new_height
operator|=
name|orig_width
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
operator|+
name|orig_width
argument_list|,
name|orig_y
operator|+
name|orig_height
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_width
expr_stmt|;
name|new_height
operator|=
name|orig_height
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|orig_x
operator|+
name|orig_width
argument_list|,
name|orig_y
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|new_x
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
name|new_width
operator|=
name|orig_height
expr_stmt|;
name|new_height
operator|=
name|orig_width
expr_stmt|;
break|break;
default|default:
name|g_return_val_if_reached
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|clip_result
operator|&&
operator|(
name|new_x
operator|!=
name|orig_x
operator|||
name|new_y
operator|!=
name|orig_y
operator|||
name|new_width
operator|!=
name|orig_width
operator|||
name|new_height
operator|!=
name|orig_height
operator|)
condition|)
block|{
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|clip_x
decl_stmt|,
name|clip_y
decl_stmt|;
name|gint
name|clip_width
decl_stmt|,
name|clip_height
decl_stmt|;
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/*  "Outside" a channel is transparency, not the bg color  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|bg_color
index|[
literal|0
index|]
operator|=
name|TRANSPARENT_OPACITY
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|destPR
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_rectangle_intersect
argument_list|(
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
operator|&
name|clip_x
argument_list|,
operator|&
name|clip_y
argument_list|,
operator|&
name|clip_width
argument_list|,
operator|&
name|clip_height
argument_list|)
condition|)
block|{
name|gint
name|saved_orig_x
init|=
name|orig_x
decl_stmt|;
name|gint
name|saved_orig_y
init|=
name|orig_y
decl_stmt|;
name|new_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|new_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|clip_x
operator|+
name|clip_width
argument_list|,
name|clip_y
argument_list|,
name|GIMP_ROTATE_270
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|orig_x
operator|-=
name|saved_orig_x
expr_stmt|;
name|orig_y
operator|-=
name|saved_orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_height
expr_stmt|;
name|orig_height
operator|=
name|clip_width
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|orig_x
operator|=
name|clip_x
operator|-
name|orig_x
expr_stmt|;
name|orig_y
operator|=
name|clip_y
operator|-
name|orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_width
expr_stmt|;
name|orig_height
operator|=
name|clip_height
expr_stmt|;
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|gimp_drawable_transform_rotate_point
argument_list|(
name|clip_x
argument_list|,
name|clip_y
operator|+
name|clip_height
argument_list|,
name|GIMP_ROTATE_90
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|orig_x
operator|-=
name|saved_orig_x
expr_stmt|;
name|orig_y
operator|-=
name|saved_orig_y
expr_stmt|;
name|orig_width
operator|=
name|clip_height
expr_stmt|;
name|orig_height
operator|=
name|clip_width
expr_stmt|;
break|break;
block|}
block|}
name|new_width
operator|=
name|clip_width
expr_stmt|;
name|new_height
operator|=
name|clip_height
expr_stmt|;
block|}
else|else
block|{
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|new_width
argument_list|,
name|new_height
argument_list|,
name|orig_bpp
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|)
expr_stmt|;
name|orig_x
operator|=
literal|0
expr_stmt|;
name|orig_y
operator|=
literal|0
expr_stmt|;
name|new_x
operator|=
literal|0
expr_stmt|;
name|new_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|new_width
operator|==
literal|0
operator|&&
name|new_height
operator|==
literal|0
condition|)
return|return
name|new_tiles
return|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_tiles
argument_list|,
name|orig_x
argument_list|,
name|orig_y
argument_list|,
name|orig_width
argument_list|,
name|orig_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rotate_type
condition|)
block|{
case|case
name|GIMP_ROTATE_90
case|:
name|g_assert
argument_list|(
name|new_height
operator|==
name|orig_width
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_height
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_width
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_set_col
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
operator|+
name|i
argument_list|,
name|new_y
argument_list|,
name|new_height
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ROTATE_180
case|:
name|g_assert
argument_list|(
name|new_width
operator|==
name|orig_width
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_width
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
argument_list|,
name|orig_y
operator|+
name|orig_height
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_width
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|orig_width
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|guchar
modifier|*
name|left
init|=
name|buf
operator|+
name|j
operator|*
name|orig_bpp
decl_stmt|;
name|guchar
modifier|*
name|right
init|=
name|buf
operator|+
operator|(
name|orig_width
operator|-
literal|1
operator|-
name|j
operator|)
operator|*
name|orig_bpp
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|orig_bpp
condition|;
name|k
operator|++
control|)
block|{
name|guchar
name|tmp
init|=
name|left
index|[
name|k
index|]
decl_stmt|;
name|left
index|[
name|k
index|]
operator|=
name|right
index|[
name|k
index|]
expr_stmt|;
name|right
index|[
name|k
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|i
argument_list|,
name|new_width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_ROTATE_270
case|:
name|g_assert
argument_list|(
name|new_width
operator|==
name|orig_height
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new_width
operator|*
name|orig_bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_col
argument_list|(
operator|&
name|srcPR
argument_list|,
name|orig_x
operator|+
name|orig_width
operator|-
literal|1
operator|-
name|i
argument_list|,
name|orig_y
argument_list|,
name|orig_height
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_x
argument_list|,
name|new_y
operator|+
name|i
argument_list|,
name|new_width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|new_tiles
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_drawable_transform_affine (GimpDrawable * drawable,GimpContext * context,const GimpMatrix3 * matrix,GimpTransformDirection direction,GimpInterpolationType interpolation_type,gint recursion_level,GimpTransformResize clip_result,GimpProgress * progress)
name|gimp_drawable_transform_affine
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|matrix
parameter_list|,
name|GimpTransformDirection
name|direction
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|,
name|gint
name|recursion_level
parameter_list|,
name|GimpTransformResize
name|clip_result
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|GimpDrawable
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|matrix
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|progress
operator|==
name|NULL
operator|||
name|GIMP_IS_PROGRESS
argument_list|(
name|progress
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Transform"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|GIMP_TRANSFORM_RESIZE_CLIP
expr_stmt|;
comment|/*  also transform the mask if we are transforming an entire layer  */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
operator|&&
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|&&
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_item_transform
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|,
name|context
argument_list|,
name|matrix
argument_list|,
name|direction
argument_list|,
name|interpolation_type
argument_list|,
name|recursion_level
argument_list|,
name|clip_result
argument_list|,
name|progress
argument_list|)
expr_stmt|;
block|}
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_affine
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|matrix
argument_list|,
name|direction
argument_list|,
name|interpolation_type
argument_list|,
name|recursion_level
argument_list|,
name|clip_result
argument_list|,
name|progress
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|result
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_drawable_transform_flip (GimpDrawable * drawable,GimpContext * context,GimpOrientationType flip_type,gdouble axis,gboolean clip_result)
name|gimp_drawable_transform_flip
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|GimpDrawable
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Flip"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
init|=
name|NULL
decl_stmt|;
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/*  also transform the mask if we are transforming an entire layer  */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
operator|&&
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|&&
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_item_flip
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|,
name|context
argument_list|,
name|flip_type
argument_list|,
name|axis
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
block|}
comment|/* transform the buffer */
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_flip
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|flip_type
argument_list|,
name|axis
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_tiles
condition|)
block|{
name|result
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_drawable_transform_rotate (GimpDrawable * drawable,GimpContext * context,GimpRotationType rotate_type,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_drawable_transform_rotate
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotate_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|orig_tiles
decl_stmt|;
name|gboolean
name|new_layer
decl_stmt|;
name|GimpDrawable
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_TRANSFORM
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Rotate"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|orig_tiles
operator|=
name|gimp_drawable_transform_cut
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_tiles
condition|)
block|{
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
comment|/*  always clip unfloated tiles so they keep their size  */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
operator|&&
name|tile_manager_bpp
argument_list|(
name|orig_tiles
argument_list|)
operator|==
literal|1
condition|)
name|clip_result
operator|=
name|TRUE
expr_stmt|;
comment|/*  also transform the mask if we are transforming an entire layer  */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
operator|&&
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
operator|&&
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_item_rotate
argument_list|(
name|GIMP_ITEM
argument_list|(
name|mask
argument_list|)
argument_list|,
name|context
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
block|}
comment|/* transform the buffer */
name|new_tiles
operator|=
name|gimp_drawable_transform_tiles_rotate
argument_list|(
name|drawable
argument_list|,
name|context
argument_list|,
name|orig_tiles
argument_list|,
name|rotate_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_unref
argument_list|(
name|orig_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|result
operator|=
name|gimp_drawable_transform_paste
argument_list|(
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  push the undo group end  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_drawable_transform_cut (GimpDrawable * drawable,GimpContext * context,gboolean * new_layer)
name|gimp_drawable_transform_cut
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
modifier|*
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|new_layer
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  extract the selected mask if there is a selection  */
if|if
condition|(
operator|!
name|gimp_channel_is_empty
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/* set the keep_indexed flag to FALSE here, since we use        * gimp_layer_new_from_tiles() later which assumes that the tiles        * are either RGB or GRAY.  Eeek!!!              (Sven)        */
if|if
condition|(
name|gimp_item_mask_intersect
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|h
argument_list|)
condition|)
block|{
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|GIMP_SELECTION
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|context
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  clear the selection  */
name|gimp_channel_clear
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tiles
operator|=
name|NULL
expr_stmt|;
operator|*
name|new_layer
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
comment|/*  otherwise, just copy the layer  */
block|{
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|GIMP_SELECTION
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|context
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|new_layer
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|tiles
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_drawable_transform_paste (GimpDrawable * drawable,TileManager * tiles,gboolean new_layer)
name|gimp_drawable_transform_paste
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|gboolean
name|new_layer
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|undo_desc
init|=
name|NULL
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tiles
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
name|undo_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Transform Layer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|undo_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Transform Channel"
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
name|tile_manager_get_offsets
argument_list|(
name|tiles
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_EDIT_PASTE
argument_list|,
name|undo_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_layer
condition|)
block|{
name|layer
operator|=
name|gimp_layer_new_from_tiles
argument_list|(
name|tiles
argument_list|,
name|image
argument_list|,
name|gimp_drawable_type_with_alpha
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Transformation"
argument_list|)
argument_list|,
name|GIMP_OPACITY_OPAQUE
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|layer
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GimpImageType
name|drawable_type
decl_stmt|;
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
operator|&&
operator|(
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
operator|==
literal|2
operator|||
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
operator|==
literal|4
operator|)
condition|)
block|{
name|drawable_type
operator|=
name|gimp_drawable_type_with_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_set_tiles_full
argument_list|(
name|drawable
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|tiles
argument_list|,
name|drawable_type
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|drawable
return|;
block|}
end_function

end_unit

