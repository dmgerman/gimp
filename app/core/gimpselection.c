begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gdk-pixbuf/gdk-pixbuf.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-babl.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-gegl-apply-operation.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimp-edit.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable-private.h"
end_include

begin_include
include|#
directive|include
file|"gimperror.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-new.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_is_attached
parameter_list|(
specifier|const
name|GimpItem
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpItemTree
modifier|*
name|gimp_selection_get_tree
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_translate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_scale
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|new_offset_x
parameter_list|,
name|gint
name|new_offset_y
parameter_list|,
name|GimpInterpolationType
name|interp_type
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_resize
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_flip
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_rotate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotation_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_stroke
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpStrokeOptions
modifier|*
name|stroke_options
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_convert_type
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|dest_image
parameter_list|,
specifier|const
name|Babl
modifier|*
name|new_format
parameter_list|,
name|GimpImageBaseType
name|new_base_type
parameter_list|,
name|GimpPrecision
name|new_precision
parameter_list|,
name|gint
name|layer_dither_type
parameter_list|,
name|gint
name|mask_dither_type
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_invalidate_boundary
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_boundary
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|GimpBoundSeg
modifier|*
modifier|*
name|segs_in
parameter_list|,
specifier|const
name|GimpBoundSeg
modifier|*
modifier|*
name|segs_out
parameter_list|,
name|gint
modifier|*
name|num_segs_in
parameter_list|,
name|gint
modifier|*
name|num_segs_out
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_bounds
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
modifier|*
name|x1
parameter_list|,
name|gint
modifier|*
name|y1
parameter_list|,
name|gint
modifier|*
name|x2
parameter_list|,
name|gint
modifier|*
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_is_empty
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_feather
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gdouble
name|radius_x
parameter_list|,
name|gdouble
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_sharpen
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_clear
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_all
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_invert
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_border
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|feather
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_grow
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_shrink
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_TYPE (GimpSelection,gimp_selection,GIMP_TYPE_CHANNEL)
name|G_DEFINE_TYPE
argument_list|(
argument|GimpSelection
argument_list|,
argument|gimp_selection
argument_list|,
argument|GIMP_TYPE_CHANNEL
argument_list|)
end_macro

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_selection_parent_class
end_define

begin_function
specifier|static
name|void
name|gimp_selection_class_init
parameter_list|(
name|GimpSelectionClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpViewableClass
modifier|*
name|viewable_class
init|=
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpItemClass
modifier|*
name|item_class
init|=
name|GIMP_ITEM_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpDrawableClass
modifier|*
name|drawable_class
init|=
name|GIMP_DRAWABLE_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpChannelClass
modifier|*
name|channel_class
init|=
name|GIMP_CHANNEL_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|viewable_class
operator|->
name|default_icon_name
operator|=
literal|"gimp-selection"
expr_stmt|;
name|item_class
operator|->
name|is_attached
operator|=
name|gimp_selection_is_attached
expr_stmt|;
name|item_class
operator|->
name|get_tree
operator|=
name|gimp_selection_get_tree
expr_stmt|;
name|item_class
operator|->
name|translate
operator|=
name|gimp_selection_translate
expr_stmt|;
name|item_class
operator|->
name|scale
operator|=
name|gimp_selection_scale
expr_stmt|;
name|item_class
operator|->
name|resize
operator|=
name|gimp_selection_resize
expr_stmt|;
name|item_class
operator|->
name|flip
operator|=
name|gimp_selection_flip
expr_stmt|;
name|item_class
operator|->
name|rotate
operator|=
name|gimp_selection_rotate
expr_stmt|;
name|item_class
operator|->
name|stroke
operator|=
name|gimp_selection_stroke
expr_stmt|;
name|item_class
operator|->
name|default_name
operator|=
name|_
argument_list|(
literal|"Selection Mask"
argument_list|)
expr_stmt|;
name|item_class
operator|->
name|translate_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Move Selection"
argument_list|)
expr_stmt|;
name|item_class
operator|->
name|stroke_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Stroke Selection"
argument_list|)
expr_stmt|;
name|drawable_class
operator|->
name|convert_type
operator|=
name|gimp_selection_convert_type
expr_stmt|;
name|drawable_class
operator|->
name|invalidate_boundary
operator|=
name|gimp_selection_invalidate_boundary
expr_stmt|;
name|channel_class
operator|->
name|boundary
operator|=
name|gimp_selection_boundary
expr_stmt|;
name|channel_class
operator|->
name|bounds
operator|=
name|gimp_selection_bounds
expr_stmt|;
name|channel_class
operator|->
name|is_empty
operator|=
name|gimp_selection_is_empty
expr_stmt|;
name|channel_class
operator|->
name|feather
operator|=
name|gimp_selection_feather
expr_stmt|;
name|channel_class
operator|->
name|sharpen
operator|=
name|gimp_selection_sharpen
expr_stmt|;
name|channel_class
operator|->
name|clear
operator|=
name|gimp_selection_clear
expr_stmt|;
name|channel_class
operator|->
name|all
operator|=
name|gimp_selection_all
expr_stmt|;
name|channel_class
operator|->
name|invert
operator|=
name|gimp_selection_invert
expr_stmt|;
name|channel_class
operator|->
name|border
operator|=
name|gimp_selection_border
expr_stmt|;
name|channel_class
operator|->
name|grow
operator|=
name|gimp_selection_grow
expr_stmt|;
name|channel_class
operator|->
name|shrink
operator|=
name|gimp_selection_shrink
expr_stmt|;
name|channel_class
operator|->
name|feather_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Feather Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|sharpen_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Sharpen Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|clear_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Select None"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|all_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Select All"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|invert_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Invert Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|border_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Border Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|grow_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Grow Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|shrink_desc
operator|=
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Shrink Selection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_init (GimpSelection * selection)
name|gimp_selection_init
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|selection
operator|->
name|stroking_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_is_attached (const GimpItem * item)
name|gimp_selection_is_attached
parameter_list|(
specifier|const
name|GimpItem
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimp_item_get_image
argument_list|(
name|item
argument_list|)
argument_list|)
operator|&&
name|gimp_image_get_mask
argument_list|(
name|gimp_item_get_image
argument_list|(
name|item
argument_list|)
argument_list|)
operator|==
name|GIMP_CHANNEL
argument_list|(
name|item
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpItemTree
modifier|*
DECL|function|gimp_selection_get_tree (GimpItem * item)
name|gimp_selection_get_tree
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_translate (GimpItem * item,gint offset_x,gint offset_y,gboolean push_undo)
name|gimp_selection_translate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|translate
argument_list|(
name|item
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_scale (GimpItem * item,gint new_width,gint new_height,gint new_offset_x,gint new_offset_y,GimpInterpolationType interp_type,GimpProgress * progress)
name|gimp_selection_scale
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|new_offset_x
parameter_list|,
name|gint
name|new_offset_y
parameter_list|,
name|GimpInterpolationType
name|interp_type
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|scale
argument_list|(
name|item
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|new_offset_x
argument_list|,
name|new_offset_y
argument_list|,
name|interp_type
argument_list|,
name|progress
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_resize (GimpItem * item,GimpContext * context,gint new_width,gint new_height,gint offset_x,gint offset_y)
name|gimp_selection_resize
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|resize
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_flip (GimpItem * item,GimpContext * context,GimpOrientationType flip_type,gdouble axis,gboolean clip_result)
name|gimp_selection_flip
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|flip
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|flip_type
argument_list|,
name|axis
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_rotate (GimpItem * item,GimpContext * context,GimpRotationType rotation_type,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_selection_rotate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotation_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|rotate
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|rotation_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_stroke (GimpItem * item,GimpDrawable * drawable,GimpStrokeOptions * stroke_options,gboolean push_undo,GimpProgress * progress,GError ** error)
name|gimp_selection_stroke
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpStrokeOptions
modifier|*
name|stroke_options
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpSelection
modifier|*
name|selection
init|=
name|GIMP_SELECTION
argument_list|(
name|item
argument_list|)
decl_stmt|;
specifier|const
name|GimpBoundSeg
modifier|*
name|dummy_in
decl_stmt|;
specifier|const
name|GimpBoundSeg
modifier|*
name|dummy_out
decl_stmt|;
name|gint
name|num_dummy_in
decl_stmt|;
name|gint
name|num_dummy_out
decl_stmt|;
name|gboolean
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_channel_boundary
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
operator|&
name|dummy_in
argument_list|,
operator|&
name|dummy_out
argument_list|,
operator|&
name|num_dummy_in
argument_list|,
operator|&
name|num_dummy_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"There is no selection to stroke."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_selection_push_stroking
argument_list|(
name|selection
argument_list|)
expr_stmt|;
name|retval
operator|=
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|stroke
argument_list|(
name|item
argument_list|,
name|drawable
argument_list|,
name|stroke_options
argument_list|,
name|push_undo
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|gimp_selection_pop_stroking
argument_list|(
name|selection
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_convert_type (GimpDrawable * drawable,GimpImage * dest_image,const Babl * new_format,GimpImageBaseType new_base_type,GimpPrecision new_precision,gint layer_dither_type,gint mask_dither_type,gboolean push_undo)
name|gimp_selection_convert_type
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|dest_image
parameter_list|,
specifier|const
name|Babl
modifier|*
name|new_format
parameter_list|,
name|GimpImageBaseType
name|new_base_type
parameter_list|,
name|GimpPrecision
name|new_precision
parameter_list|,
name|gint
name|layer_dither_type
parameter_list|,
name|gint
name|mask_dither_type
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|new_format
operator|=
name|gimp_babl_mask_format
argument_list|(
name|new_precision
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|convert_type
argument_list|(
name|drawable
argument_list|,
name|dest_image
argument_list|,
name|new_format
argument_list|,
name|new_base_type
argument_list|,
name|new_precision
argument_list|,
name|layer_dither_type
argument_list|,
name|mask_dither_type
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_invalidate_boundary (GimpDrawable * drawable)
name|gimp_selection_invalidate_boundary
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
comment|/*  Turn the current selection off  */
name|gimp_image_selection_invalidate
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_boundary
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  If there is a floating selection, update it's area...    *  we need to do this since this selection mask can act as an additional    *  mask in the composition of the floating selection    */
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&&
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|gimp_drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  invalidate the preview  */
block|drawable->private->preview_valid = FALSE;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_boundary (GimpChannel * channel,const GimpBoundSeg ** segs_in,const GimpBoundSeg ** segs_out,gint * num_segs_in,gint * num_segs_out,gint unused1,gint unused2,gint unused3,gint unused4)
name|gimp_selection_boundary
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|GimpBoundSeg
modifier|*
modifier|*
name|segs_in
parameter_list|,
specifier|const
name|GimpBoundSeg
modifier|*
modifier|*
name|segs_out
parameter_list|,
name|gint
modifier|*
name|num_segs_in
parameter_list|,
name|gint
modifier|*
name|num_segs_out
parameter_list|,
name|gint
name|unused1
parameter_list|,
name|gint
name|unused2
parameter_list|,
name|gint
name|unused3
parameter_list|,
name|gint
name|unused4
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_get_floating_selection
argument_list|(
name|image
argument_list|)
operator|)
condition|)
block|{
comment|/*  If there is a floating selection, then        *  we need to do some slightly different boundaries.        *  Instead of inside and outside boundaries being defined        *  by the extents of the layer, the inside boundary (the one        *  that actually marches and is black/white) is the boundary of        *  the floating selection.  The outside boundary (doesn't move,        *  is black/gray) is defined as the normal selection mask        */
comment|/*  Find the selection mask boundary  */
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  Find the floating selection boundary  */
operator|*
name|segs_in
operator|=
name|floating_sel_boundary
argument_list|(
name|layer
argument_list|,
name|num_segs_in
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|drawable
operator|=
name|gimp_image_get_active_drawable
argument_list|(
name|image
argument_list|)
operator|)
operator|&&
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
comment|/*  Otherwise, return the boundary...if a channel is active  */
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
operator|)
condition|)
block|{
comment|/*  If a layer is active, we return multiple boundaries based        *  on the extents        */
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|offset_x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|offset_y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|offset_x
operator|+
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|offset_y
operator|+
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
return|;
block|}
operator|*
name|segs_in
operator|=
name|NULL
expr_stmt|;
operator|*
name|segs_out
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_segs_in
operator|=
literal|0
expr_stmt|;
operator|*
name|num_segs_out
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_bounds (GimpChannel * channel,gint * x1,gint * y1,gint * x2,gint * y2)
name|gimp_selection_bounds
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
modifier|*
name|x1
parameter_list|,
name|gint
modifier|*
name|y1
parameter_list|,
name|gint
modifier|*
name|x2
parameter_list|,
name|gint
modifier|*
name|y2
parameter_list|)
block|{
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|bounds
argument_list|(
name|channel
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_is_empty (GimpChannel * channel)
name|gimp_selection_is_empty
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|GimpSelection
modifier|*
name|selection
init|=
name|GIMP_SELECTION
argument_list|(
name|channel
argument_list|)
decl_stmt|;
comment|/*  in order to allow stroking of selections, we need to pretend here    *  that the selection mask is empty so that it doesn't mask the paint    *  during the stroke operation.    */
if|if
condition|(
name|selection
operator|->
name|stroking_count
operator|>
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|is_empty
argument_list|(
name|channel
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_feather (GimpChannel * channel,gdouble radius_x,gdouble radius_y,gboolean push_undo)
name|gimp_selection_feather
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gdouble
name|radius_x
parameter_list|,
name|gdouble
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|feather
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_sharpen (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_sharpen
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|sharpen
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_clear (GimpChannel * channel,const gchar * undo_desc,gboolean push_undo)
name|gimp_selection_clear
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|clear
argument_list|(
name|channel
argument_list|,
name|undo_desc
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_all (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_all
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|all
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_invert (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_invert
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invert
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_border (GimpChannel * channel,gint radius_x,gint radius_y,gboolean feather,gboolean edge_lock,gboolean push_undo)
name|gimp_selection_border
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|feather
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|border
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|feather
argument_list|,
name|edge_lock
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_grow (GimpChannel * channel,gint radius_x,gint radius_y,gboolean push_undo)
name|gimp_selection_grow
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|grow
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_shrink (GimpChannel * channel,gint radius_x,gint radius_y,gboolean edge_lock,gboolean push_undo)
name|gimp_selection_shrink
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|shrink
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|edge_lock
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_selection_new (GimpImage * image,gint width,gint height)
name|gimp_selection_new
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|GimpRGB
name|black
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.5
block|}
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|channel
operator|=
name|GIMP_CHANNEL
argument_list|(
name|gimp_drawable_new
argument_list|(
name|GIMP_TYPE_SELECTION
argument_list|,
name|image
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|gimp_image_get_mask_format
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_channel_set_color
argument_list|(
name|channel
argument_list|,
operator|&
name|black
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_channel_set_show_masked
argument_list|(
name|channel
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|channel
operator|->
name|x2
operator|=
name|width
expr_stmt|;
name|channel
operator|->
name|y2
operator|=
name|height
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_selection_push_stroking (GimpSelection * selection)
name|gimp_selection_push_stroking
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selection
operator|->
name|stroking_count
operator|++
expr_stmt|;
return|return
name|selection
operator|->
name|stroking_count
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_selection_pop_stroking (GimpSelection * selection)
name|gimp_selection_pop_stroking
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|selection
operator|->
name|stroking_count
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selection
operator|->
name|stroking_count
operator|--
expr_stmt|;
return|return
name|selection
operator|->
name|stroking_count
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_selection_load (GimpSelection * selection,GimpChannel * channel)
name|gimp_selection_load
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|height
operator|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|width
operator|==
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|height
operator|==
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_channel_push_undo
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Channel to Selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  copy the channel to the mask  */
name|gegl_buffer_copy
argument_list|(
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_selection_save (GimpSelection * selection)
name|gimp_selection_save
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpChannel
modifier|*
name|new_channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|new_channel
operator|=
name|GIMP_CHANNEL
argument_list|(
name|gimp_item_duplicate
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|,
name|GIMP_TYPE_CHANNEL
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  saved selections are not visible by default  */
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|new_channel
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image
argument_list|,
name|new_channel
argument_list|,
name|GIMP_IMAGE_ACTIVE_PARENT
argument_list|,
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|new_channel
return|;
block|}
end_function

begin_function
name|GeglBuffer
modifier|*
DECL|function|gimp_selection_extract (GimpSelection * selection,GimpPickable * pickable,GimpContext * context,gboolean cut_image,gboolean keep_indexed,gboolean add_alpha,gint * offset_x,gint * offset_y,GError ** error)
name|gimp_selection_extract
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpPickable
modifier|*
name|pickable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
name|cut_image
parameter_list|,
name|gboolean
name|keep_indexed
parameter_list|,
name|gboolean
name|add_alpha
parameter_list|,
name|gint
modifier|*
name|offset_x
parameter_list|,
name|gint
modifier|*
name|offset_y
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GeglBuffer
modifier|*
name|src_buffer
decl_stmt|;
name|GeglBuffer
modifier|*
name|dest_buffer
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|src_format
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|dest_format
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gboolean
name|non_empty
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_PICKABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_ITEM
argument_list|(
name|pickable
argument_list|)
condition|)
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|pickable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_pickable_get_image
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  If there are no bounds, then just extract the entire image    *  This may not be the correct behavior, but after getting rid    *  of floating selections, it's still tempting to "cut" or "copy"    *  a small layer and expect it to work, even though there is no    *  actual selection mask    */
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
name|non_empty
operator|=
name|gimp_item_mask_bounds
argument_list|(
name|GIMP_ITEM
argument_list|(
name|pickable
argument_list|)
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
name|gimp_channel_bounds
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_empty
operator|&&
operator|(
operator|(
name|x1
operator|==
name|x2
operator|)
operator|||
operator|(
name|y1
operator|==
name|y2
operator|)
operator|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unable to cut or copy because the "
literal|"selected region is empty."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  If there is a selection, we must add alpha because the selection    *  could have any shape.    */
if|if
condition|(
name|non_empty
condition|)
name|add_alpha
operator|=
name|TRUE
expr_stmt|;
name|src_format
operator|=
name|gimp_pickable_get_format
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  How many bytes in the temp buffer?  */
if|if
condition|(
name|babl_format_is_palette
argument_list|(
name|src_format
argument_list|)
operator|&&
operator|!
name|keep_indexed
condition|)
block|{
name|dest_format
operator|=
name|gimp_image_get_format
argument_list|(
name|image
argument_list|,
name|GIMP_RGB
argument_list|,
name|gimp_image_get_precision
argument_list|(
name|image
argument_list|)
argument_list|,
name|add_alpha
operator|||
name|babl_format_has_alpha
argument_list|(
name|src_format
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|add_alpha
condition|)
name|dest_format
operator|=
name|gimp_pickable_get_format_with_alpha
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
else|else
name|dest_format
operator|=
name|src_format
expr_stmt|;
block|}
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|pickable
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off_x
operator|=
name|off_y
operator|=
literal|0
expr_stmt|;
block|}
name|gimp_pickable_flush
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
name|src_buffer
operator|=
name|gimp_pickable_get_buffer
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  Allocate the temp buffer  */
name|dest_buffer
operator|=
name|gegl_buffer_new
argument_list|(
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
argument_list|,
name|dest_format
argument_list|)
expr_stmt|;
comment|/*  First, copy the pixels, possibly doing INDEXED->RGB and adding alpha  */
name|gegl_buffer_copy
argument_list|(
name|src_buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
name|dest_buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
block|{
comment|/*  If there is a selection, mask the dest_buffer with it  */
name|GeglBuffer
modifier|*
name|mask_buffer
decl_stmt|;
name|mask_buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_gegl_apply_opacity
argument_list|(
name|dest_buffer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dest_buffer
argument_list|,
name|mask_buffer
argument_list|,
operator|-
operator|(
name|off_x
operator|+
name|x1
operator|)
argument_list|,
operator|-
operator|(
name|off_y
operator|+
name|y1
operator|)
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut_image
operator|&&
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_edit_clear
argument_list|(
name|image
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cut_image
operator|&&
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
comment|/*  If we're cutting without selection, remove either the layer        *  (or floating selection), the layer mask, or the channel        */
if|if
condition|(
name|cut_image
operator|&&
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_image_remove_layer
argument_list|(
name|image
argument_list|,
name|GIMP_LAYER
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GIMP_IS_LAYER_MASK
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_layer_apply_mask
argument_list|(
name|gimp_layer_mask_get_layer
argument_list|(
name|GIMP_LAYER_MASK
argument_list|(
name|pickable
argument_list|)
argument_list|)
argument_list|,
name|GIMP_MASK_DISCARD
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_image_remove_channel
argument_list|(
name|image
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|offset_x
operator|=
name|x1
operator|+
name|off_x
expr_stmt|;
operator|*
name|offset_y
operator|=
name|y1
operator|+
name|off_y
expr_stmt|;
return|return
name|dest_buffer
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_selection_float (GimpSelection * selection,GimpDrawable * drawable,GimpContext * context,gboolean cut_image,gint off_x,gint off_y,GError ** error)
name|gimp_selection_float
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
name|cut_image
parameter_list|,
name|gint
name|off_x
parameter_list|,
name|gint
name|off_y
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Make sure there is a region to float...  */
if|if
condition|(
operator|!
name|gimp_item_mask_bounds
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
operator|||
operator|(
name|x1
operator|==
name|x2
operator|||
name|y1
operator|==
name|y2
operator|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"Cannot float selection because the selected "
literal|"region is empty."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Start an undo group  */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_FS_FLOAT
argument_list|,
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Float Selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Cut or copy the selected region  */
name|buffer
operator|=
name|gimp_selection_extract
argument_list|(
name|selection
argument_list|,
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|context
argument_list|,
name|cut_image
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Clear the selection  */
name|gimp_channel_clear
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Create a new layer from the buffer, using the drawable's type    *  because it may be different from the image's type if we cut from    *  a channel or layer mask    */
name|layer
operator|=
name|gimp_layer_new_from_gegl_buffer
argument_list|(
name|buffer
argument_list|,
name|image
argument_list|,
name|gimp_drawable_get_format_with_alpha
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Floated Layer"
argument_list|)
argument_list|,
name|GIMP_OPACITY_OPAQUE
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|,
name|NULL
argument_list|,
literal|0
comment|/* same image */
argument_list|)
expr_stmt|;
comment|/*  Set the offsets  */
name|gimp_item_set_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|x1
operator|+
name|off_x
argument_list|,
name|y1
operator|+
name|off_y
argument_list|)
expr_stmt|;
comment|/*  Free the temp buffer  */
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/*  Add the floating layer to the image  */
name|floating_sel_attach
argument_list|(
name|layer
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
comment|/*  End an undo group  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*  invalidate the image's boundary variables  */
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

end_unit

