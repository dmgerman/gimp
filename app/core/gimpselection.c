begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable-private.h"
end_include

begin_include
include|#
directive|include
file|"gimperror.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_is_attached
parameter_list|(
specifier|const
name|GimpItem
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpItemTree
modifier|*
name|gimp_selection_get_tree
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_translate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_scale
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|new_offset_x
parameter_list|,
name|gint
name|new_offset_y
parameter_list|,
name|GimpInterpolationType
name|interp_type
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_resize
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_flip
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_rotate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotation_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_stroke
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpStrokeOptions
modifier|*
name|stroke_options
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_invalidate_boundary
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_boundary
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|BoundSeg
modifier|*
modifier|*
name|segs_in
parameter_list|,
specifier|const
name|BoundSeg
modifier|*
modifier|*
name|segs_out
parameter_list|,
name|gint
modifier|*
name|num_segs_in
parameter_list|,
name|gint
modifier|*
name|num_segs_out
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_bounds
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
modifier|*
name|x1
parameter_list|,
name|gint
modifier|*
name|y1
parameter_list|,
name|gint
modifier|*
name|x2
parameter_list|,
name|gint
modifier|*
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_selection_is_empty
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_feather
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gdouble
name|radius_x
parameter_list|,
name|gdouble
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_sharpen
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_clear
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_all
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_invert
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_border
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|feather
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_grow
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_selection_shrink
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_TYPE (GimpSelection,gimp_selection,GIMP_TYPE_CHANNEL)
name|G_DEFINE_TYPE
argument_list|(
argument|GimpSelection
argument_list|,
argument|gimp_selection
argument_list|,
argument|GIMP_TYPE_CHANNEL
argument_list|)
end_macro

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_selection_parent_class
end_define

begin_function
specifier|static
name|void
name|gimp_selection_class_init
parameter_list|(
name|GimpSelectionClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpViewableClass
modifier|*
name|viewable_class
init|=
name|GIMP_VIEWABLE_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpItemClass
modifier|*
name|item_class
init|=
name|GIMP_ITEM_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpDrawableClass
modifier|*
name|drawable_class
init|=
name|GIMP_DRAWABLE_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpChannelClass
modifier|*
name|channel_class
init|=
name|GIMP_CHANNEL_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|viewable_class
operator|->
name|default_stock_id
operator|=
literal|"gimp-selection"
expr_stmt|;
name|item_class
operator|->
name|is_attached
operator|=
name|gimp_selection_is_attached
expr_stmt|;
name|item_class
operator|->
name|get_tree
operator|=
name|gimp_selection_get_tree
expr_stmt|;
name|item_class
operator|->
name|translate
operator|=
name|gimp_selection_translate
expr_stmt|;
name|item_class
operator|->
name|scale
operator|=
name|gimp_selection_scale
expr_stmt|;
name|item_class
operator|->
name|resize
operator|=
name|gimp_selection_resize
expr_stmt|;
name|item_class
operator|->
name|flip
operator|=
name|gimp_selection_flip
expr_stmt|;
name|item_class
operator|->
name|rotate
operator|=
name|gimp_selection_rotate
expr_stmt|;
name|item_class
operator|->
name|stroke
operator|=
name|gimp_selection_stroke
expr_stmt|;
name|item_class
operator|->
name|translate_desc
operator|=
name|_
argument_list|(
literal|"Move Selection"
argument_list|)
expr_stmt|;
name|item_class
operator|->
name|stroke_desc
operator|=
name|_
argument_list|(
literal|"Stroke Selection"
argument_list|)
expr_stmt|;
name|drawable_class
operator|->
name|invalidate_boundary
operator|=
name|gimp_selection_invalidate_boundary
expr_stmt|;
name|channel_class
operator|->
name|boundary
operator|=
name|gimp_selection_boundary
expr_stmt|;
name|channel_class
operator|->
name|bounds
operator|=
name|gimp_selection_bounds
expr_stmt|;
name|channel_class
operator|->
name|is_empty
operator|=
name|gimp_selection_is_empty
expr_stmt|;
name|channel_class
operator|->
name|feather
operator|=
name|gimp_selection_feather
expr_stmt|;
name|channel_class
operator|->
name|sharpen
operator|=
name|gimp_selection_sharpen
expr_stmt|;
name|channel_class
operator|->
name|clear
operator|=
name|gimp_selection_clear
expr_stmt|;
name|channel_class
operator|->
name|all
operator|=
name|gimp_selection_all
expr_stmt|;
name|channel_class
operator|->
name|invert
operator|=
name|gimp_selection_invert
expr_stmt|;
name|channel_class
operator|->
name|border
operator|=
name|gimp_selection_border
expr_stmt|;
name|channel_class
operator|->
name|grow
operator|=
name|gimp_selection_grow
expr_stmt|;
name|channel_class
operator|->
name|shrink
operator|=
name|gimp_selection_shrink
expr_stmt|;
name|channel_class
operator|->
name|feather_desc
operator|=
name|_
argument_list|(
literal|"Feather Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|sharpen_desc
operator|=
name|_
argument_list|(
literal|"Sharpen Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|clear_desc
operator|=
name|_
argument_list|(
literal|"Select None"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|all_desc
operator|=
name|_
argument_list|(
literal|"Select All"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|invert_desc
operator|=
name|_
argument_list|(
literal|"Invert Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|border_desc
operator|=
name|_
argument_list|(
literal|"Border Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|grow_desc
operator|=
name|_
argument_list|(
literal|"Grow Selection"
argument_list|)
expr_stmt|;
name|channel_class
operator|->
name|shrink_desc
operator|=
name|_
argument_list|(
literal|"Shrink Selection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_init (GimpSelection * selection)
name|gimp_selection_init
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|selection
operator|->
name|stroking_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_is_attached (const GimpItem * item)
name|gimp_selection_is_attached
parameter_list|(
specifier|const
name|GimpItem
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimp_item_get_image
argument_list|(
name|item
argument_list|)
argument_list|)
operator|&&
name|gimp_image_get_mask
argument_list|(
name|gimp_item_get_image
argument_list|(
name|item
argument_list|)
argument_list|)
operator|==
name|GIMP_CHANNEL
argument_list|(
name|item
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpItemTree
modifier|*
DECL|function|gimp_selection_get_tree (GimpItem * item)
name|gimp_selection_get_tree
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_translate (GimpItem * item,gint offset_x,gint offset_y,gboolean push_undo)
name|gimp_selection_translate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|translate
argument_list|(
name|item
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_scale (GimpItem * item,gint new_width,gint new_height,gint new_offset_x,gint new_offset_y,GimpInterpolationType interp_type,GimpProgress * progress)
name|gimp_selection_scale
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|new_offset_x
parameter_list|,
name|gint
name|new_offset_y
parameter_list|,
name|GimpInterpolationType
name|interp_type
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|scale
argument_list|(
name|item
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|new_offset_x
argument_list|,
name|new_offset_y
argument_list|,
name|interp_type
argument_list|,
name|progress
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_resize (GimpItem * item,GimpContext * context,gint new_width,gint new_height,gint offset_x,gint offset_y)
name|gimp_selection_resize
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|resize
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_flip (GimpItem * item,GimpContext * context,GimpOrientationType flip_type,gdouble axis,gboolean clip_result)
name|gimp_selection_flip
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpOrientationType
name|flip_type
parameter_list|,
name|gdouble
name|axis
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|flip
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|flip_type
argument_list|,
name|axis
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_rotate (GimpItem * item,GimpContext * context,GimpRotationType rotation_type,gdouble center_x,gdouble center_y,gboolean clip_result)
name|gimp_selection_rotate
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|GimpRotationType
name|rotation_type
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|,
name|gboolean
name|clip_result
parameter_list|)
block|{
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|rotate
argument_list|(
name|item
argument_list|,
name|context
argument_list|,
name|rotation_type
argument_list|,
name|center_x
argument_list|,
name|center_y
argument_list|,
name|clip_result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_stroke (GimpItem * item,GimpDrawable * drawable,GimpStrokeOptions * stroke_options,gboolean push_undo,GimpProgress * progress,GError ** error)
name|gimp_selection_stroke
parameter_list|(
name|GimpItem
modifier|*
name|item
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpStrokeOptions
modifier|*
name|stroke_options
parameter_list|,
name|gboolean
name|push_undo
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpSelection
modifier|*
name|selection
init|=
name|GIMP_SELECTION
argument_list|(
name|item
argument_list|)
decl_stmt|;
specifier|const
name|BoundSeg
modifier|*
name|dummy_in
decl_stmt|;
specifier|const
name|BoundSeg
modifier|*
name|dummy_out
decl_stmt|;
name|gint
name|num_dummy_in
decl_stmt|;
name|gint
name|num_dummy_out
decl_stmt|;
name|gboolean
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_channel_boundary
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
operator|&
name|dummy_in
argument_list|,
operator|&
name|dummy_out
argument_list|,
operator|&
name|num_dummy_in
argument_list|,
operator|&
name|num_dummy_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"There is no selection to stroke."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_selection_push_stroking
argument_list|(
name|selection
argument_list|)
expr_stmt|;
name|retval
operator|=
name|GIMP_ITEM_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|stroke
argument_list|(
name|item
argument_list|,
name|drawable
argument_list|,
name|stroke_options
argument_list|,
name|push_undo
argument_list|,
name|progress
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|gimp_selection_pop_stroking
argument_list|(
name|selection
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_invalidate_boundary (GimpDrawable * drawable)
name|gimp_selection_invalidate_boundary
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
comment|/*  Turn the current selection off  */
name|gimp_image_selection_control
argument_list|(
name|image
argument_list|,
name|GIMP_SELECTION_OFF
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invalidate_boundary
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  If there is a floating selection, update it's area...    *  we need to do this since this selection mask can act as an additional    *  mask in the composition of the floating selection    */
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&&
name|gimp_layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|gimp_drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the preview  */
name|drawable
operator|->
name|private
operator|->
name|preview_valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_boundary (GimpChannel * channel,const BoundSeg ** segs_in,const BoundSeg ** segs_out,gint * num_segs_in,gint * num_segs_out,gint unused1,gint unused2,gint unused3,gint unused4)
name|gimp_selection_boundary
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|BoundSeg
modifier|*
modifier|*
name|segs_in
parameter_list|,
specifier|const
name|BoundSeg
modifier|*
modifier|*
name|segs_out
parameter_list|,
name|gint
modifier|*
name|num_segs_in
parameter_list|,
name|gint
modifier|*
name|num_segs_out
parameter_list|,
name|gint
name|unused1
parameter_list|,
name|gint
name|unused2
parameter_list|,
name|gint
name|unused3
parameter_list|,
name|gint
name|unused4
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_get_floating_selection
argument_list|(
name|image
argument_list|)
operator|)
condition|)
block|{
comment|/*  If there is a floating selection, then        *  we need to do some slightly different boundaries.        *  Instead of inside and outside boundaries being defined        *  by the extents of the layer, the inside boundary (the one        *  that actually marches and is black/white) is the boundary of        *  the floating selection.  The outside boundary (doesn't move,        *  is black/gray) is defined as the normal selection mask        */
comment|/*  Find the selection mask boundary  */
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  Find the floating selection boundary  */
operator|*
name|segs_in
operator|=
name|floating_sel_boundary
argument_list|(
name|layer
argument_list|,
name|num_segs_in
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|drawable
operator|=
name|gimp_image_get_active_drawable
argument_list|(
name|image
argument_list|)
operator|)
operator|&&
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
comment|/*  Otherwise, return the boundary...if a channel is active  */
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
operator|)
condition|)
block|{
comment|/*  If a layer is active, we return multiple boundaries based        *  on the extents        */
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|offset_x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|offset_y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|offset_x
operator|+
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|offset_y
operator|+
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|boundary
argument_list|(
name|channel
argument_list|,
name|segs_in
argument_list|,
name|segs_out
argument_list|,
name|num_segs_in
argument_list|,
name|num_segs_out
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
return|;
block|}
operator|*
name|segs_in
operator|=
name|NULL
expr_stmt|;
operator|*
name|segs_out
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_segs_in
operator|=
literal|0
expr_stmt|;
operator|*
name|num_segs_out
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_bounds (GimpChannel * channel,gint * x1,gint * y1,gint * x2,gint * y2)
name|gimp_selection_bounds
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
modifier|*
name|x1
parameter_list|,
name|gint
modifier|*
name|y1
parameter_list|,
name|gint
modifier|*
name|x2
parameter_list|,
name|gint
modifier|*
name|y2
parameter_list|)
block|{
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|bounds
argument_list|(
name|channel
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_selection_is_empty (GimpChannel * channel)
name|gimp_selection_is_empty
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|GimpSelection
modifier|*
name|selection
init|=
name|GIMP_SELECTION
argument_list|(
name|channel
argument_list|)
decl_stmt|;
comment|/*  in order to allow stroking of selections, we need to pretend here    *  that the selection mask is empty so that it doesn't mask the paint    *  during the stroke operation.    */
if|if
condition|(
name|selection
operator|->
name|stroking_count
operator|>
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|is_empty
argument_list|(
name|channel
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_feather (GimpChannel * channel,gdouble radius_x,gdouble radius_y,gboolean push_undo)
name|gimp_selection_feather
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gdouble
name|radius_x
parameter_list|,
name|gdouble
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|feather
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_sharpen (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_sharpen
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|sharpen
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_clear (GimpChannel * channel,const gchar * undo_desc,gboolean push_undo)
name|gimp_selection_clear
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|gchar
modifier|*
name|undo_desc
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|clear
argument_list|(
name|channel
argument_list|,
name|undo_desc
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_all (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_all
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|all
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_invert (GimpChannel * channel,gboolean push_undo)
name|gimp_selection_invert
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|invert
argument_list|(
name|channel
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_border (GimpChannel * channel,gint radius_x,gint radius_y,gboolean feather,gboolean edge_lock,gboolean push_undo)
name|gimp_selection_border
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|feather
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|border
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|feather
argument_list|,
name|edge_lock
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_grow (GimpChannel * channel,gint radius_x,gint radius_y,gboolean push_undo)
name|gimp_selection_grow
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|grow
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_selection_shrink (GimpChannel * channel,gint radius_x,gint radius_y,gboolean edge_lock,gboolean push_undo)
name|gimp_selection_shrink
parameter_list|(
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|gint
name|radius_x
parameter_list|,
name|gint
name|radius_y
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|,
name|gboolean
name|push_undo
parameter_list|)
block|{
name|GIMP_CHANNEL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|shrink
argument_list|(
name|channel
argument_list|,
name|radius_x
argument_list|,
name|radius_y
argument_list|,
name|edge_lock
argument_list|,
name|push_undo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  public functions  */
end_comment

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_selection_new (GimpImage * image,gint width,gint height)
name|gimp_selection_new
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|GimpRGB
name|black
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.5
block|}
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|channel
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_SELECTION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_drawable_configure
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|GIMP_GRAY_IMAGE
argument_list|,
name|_
argument_list|(
literal|"Selection Mask"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_channel_set_color
argument_list|(
name|channel
argument_list|,
operator|&
name|black
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_channel_set_show_masked
argument_list|(
name|channel
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|channel
operator|->
name|x2
operator|=
name|width
expr_stmt|;
name|channel
operator|->
name|y2
operator|=
name|height
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_selection_push_stroking (GimpSelection * selection)
name|gimp_selection_push_stroking
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selection
operator|->
name|stroking_count
operator|++
expr_stmt|;
return|return
name|selection
operator|->
name|stroking_count
return|;
block|}
end_function

begin_function
name|gint
DECL|function|gimp_selection_pop_stroking (GimpSelection * selection)
name|gimp_selection_pop_stroking
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|selection
operator|->
name|stroking_count
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selection
operator|->
name|stroking_count
operator|--
expr_stmt|;
return|return
name|selection
operator|->
name|stroking_count
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_selection_load (GimpSelection * selection,GimpChannel * channel)
name|gimp_selection_load
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|PixelRegion
name|destPR
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|height
operator|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|width
operator|==
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|height
operator|==
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_channel_push_undo
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Channel to Selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  copy the channel to the mask  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|gimp_selection_save (GimpSelection * selection)
name|gimp_selection_save
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpChannel
modifier|*
name|new_channel
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
name|new_channel
operator|=
name|GIMP_CHANNEL
argument_list|(
name|gimp_item_duplicate
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|,
name|GIMP_TYPE_CHANNEL
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  saved selections are not visible by default  */
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|new_channel
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image
argument_list|,
name|new_channel
argument_list|,
name|GIMP_IMAGE_ACTIVE_PARENT
argument_list|,
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|new_channel
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_selection_extract (GimpSelection * selection,GimpPickable * pickable,GimpContext * context,gboolean cut_image,gboolean keep_indexed,gboolean add_alpha,GError ** error)
name|gimp_selection_extract
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpPickable
modifier|*
name|pickable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
name|cut_image
parameter_list|,
name|gboolean
name|keep_indexed
parameter_list|,
name|gboolean
name|add_alpha
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|guchar
name|bg_color
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|colormap
decl_stmt|;
name|GimpImageBaseType
name|base_type
init|=
name|GIMP_RGB
decl_stmt|;
name|gint
name|bytes
init|=
literal|0
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gboolean
name|non_empty
decl_stmt|;
name|gint
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_PICKABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_ITEM
argument_list|(
name|pickable
argument_list|)
condition|)
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|pickable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_pickable_get_image
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  If there are no bounds, then just extract the entire image    *  This may not be the correct behavior, but after getting rid    *  of floating selections, it's still tempting to "cut" or "copy"    *  a small layer and expect it to work, even though there is no    *  actual selection mask    */
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
name|non_empty
operator|=
name|gimp_drawable_mask_bounds
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
name|gimp_channel_bounds
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_empty
operator|&&
operator|(
operator|(
name|x1
operator|==
name|x2
operator|)
operator|||
operator|(
name|y1
operator|==
name|y2
operator|)
operator|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unable to cut or copy because the "
literal|"selected region is empty."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  If there is a selection, we must add alpha because the selection    *  could have any shape.    */
if|if
condition|(
name|non_empty
condition|)
name|add_alpha
operator|=
name|TRUE
expr_stmt|;
comment|/*  How many bytes in the temp buffer?  */
switch|switch
condition|(
name|GIMP_IMAGE_TYPE_BASE_TYPE
argument_list|(
name|gimp_pickable_get_image_type
argument_list|(
name|pickable
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|bytes
operator|=
name|add_alpha
condition|?
literal|4
else|:
name|gimp_pickable_get_bytes
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|GIMP_RGB
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|bytes
operator|=
name|add_alpha
condition|?
literal|2
else|:
name|gimp_pickable_get_bytes
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|GIMP_GRAY
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
if|if
condition|(
name|keep_indexed
condition|)
block|{
name|bytes
operator|=
name|add_alpha
condition|?
literal|2
else|:
name|gimp_pickable_get_bytes
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|GIMP_GRAY
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|=
operator|(
name|add_alpha
operator|||
name|GIMP_IMAGE_TYPE_HAS_ALPHA
argument_list|(
name|gimp_pickable_get_image_type
argument_list|(
name|pickable
argument_list|)
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|3
expr_stmt|;
name|base_type
operator|=
name|GIMP_INDEXED
expr_stmt|;
block|}
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
name|gimp_image_get_background
argument_list|(
name|image
argument_list|,
name|context
argument_list|,
name|gimp_pickable_get_image_type
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|bg_color
argument_list|)
expr_stmt|;
comment|/*  If a cut was specified, and the selection mask is not empty,    *  push an undo    */
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
if|if
condition|(
name|cut_image
operator|&&
name|non_empty
condition|)
name|gimp_drawable_push_undo
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|pickable
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|colormap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off_x
operator|=
name|off_y
operator|=
literal|0
expr_stmt|;
name|colormap
operator|=
name|NULL
expr_stmt|;
block|}
name|gimp_pickable_flush
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/*  Allocate the temp buffer  */
name|tiles
operator|=
name|tile_manager_new
argument_list|(
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|tile_manager_set_offsets
argument_list|(
name|tiles
argument_list|,
name|x1
operator|+
name|off_x
argument_list|,
name|y1
operator|+
name|off_y
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|gimp_pickable_get_tiles
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|cut_image
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
comment|/*  If there is a selection, extract from it  */
block|{
name|PixelRegion
name|maskPR
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|+
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|+
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|extract_from_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|colormap
argument_list|,
name|bg_color
argument_list|,
name|base_type
argument_list|,
name|cut_image
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
operator|&&
name|cut_image
condition|)
block|{
comment|/*  Update the region  */
name|gimp_drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/*  Otherwise, get the entire active layer  */
block|{
if|if
condition|(
name|base_type
operator|==
name|GIMP_INDEXED
operator|&&
operator|!
name|keep_indexed
condition|)
block|{
comment|/*  If the layer is indexed...we need to extract pixels  */
name|extract_from_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|colormap
argument_list|,
name|bg_color
argument_list|,
name|base_type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
name|srcPR
operator|.
name|bytes
condition|)
block|{
comment|/*  If the layer doesn't have an alpha channel, add one  */
name|add_alpha_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Otherwise, do a straight copy  */
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
comment|/*  If we're cutting, remove either the layer (or floating selection),        *  the layer mask, or the channel        */
if|if
condition|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|pickable
argument_list|)
operator|&&
name|cut_image
condition|)
block|{
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_image_remove_layer
argument_list|(
name|image
argument_list|,
name|GIMP_LAYER
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GIMP_IS_LAYER_MASK
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_layer_apply_mask
argument_list|(
name|gimp_layer_mask_get_layer
argument_list|(
name|GIMP_LAYER_MASK
argument_list|(
name|pickable
argument_list|)
argument_list|)
argument_list|,
name|GIMP_MASK_DISCARD
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|pickable
argument_list|)
condition|)
block|{
name|gimp_image_remove_channel
argument_list|(
name|image
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|tiles
return|;
block|}
end_function

begin_function
name|GimpLayer
modifier|*
DECL|function|gimp_selection_float (GimpSelection * selection,GimpDrawable * drawable,GimpContext * context,gboolean cut_image,gint off_x,gint off_y,GError ** error)
name|gimp_selection_float
parameter_list|(
name|GimpSelection
modifier|*
name|selection
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpContext
modifier|*
name|context
parameter_list|,
name|gboolean
name|cut_image
parameter_list|,
name|gint
name|off_x
parameter_list|,
name|gint
name|off_y
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|TileManager
modifier|*
name|tiles
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_SELECTION
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|gimp_item_is_attached
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_CONTEXT
argument_list|(
name|context
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Make sure there is a region to float...  */
if|if
condition|(
operator|!
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
operator|||
operator|(
name|x1
operator|==
name|x2
operator|||
name|y1
operator|==
name|y2
operator|)
condition|)
block|{
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|GIMP_ERROR
argument_list|,
name|GIMP_FAILED
argument_list|,
name|_
argument_list|(
literal|"Cannot float selection because the selected "
literal|"region is empty."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Start an undo group  */
name|gimp_image_undo_group_start
argument_list|(
name|image
argument_list|,
name|GIMP_UNDO_GROUP_FS_FLOAT
argument_list|,
name|_
argument_list|(
literal|"Float Selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Cut or copy the selected region  */
name|tiles
operator|=
name|gimp_selection_extract
argument_list|(
name|selection
argument_list|,
name|GIMP_PICKABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|context
argument_list|,
name|cut_image
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Clear the selection  */
name|gimp_channel_clear
argument_list|(
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Create a new layer from the buffer, using the drawable's type    *  because it may be different from the image's type if we cut from    *  a channel or layer mask    */
name|layer
operator|=
name|gimp_layer_new_from_tiles
argument_list|(
name|tiles
argument_list|,
name|image
argument_list|,
name|gimp_drawable_type_with_alpha
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Floated Layer"
argument_list|)
argument_list|,
name|GIMP_OPACITY_OPAQUE
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
comment|/*  Set the offsets  */
name|tile_manager_get_offsets
argument_list|(
name|tiles
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|x1
operator|+
name|off_x
argument_list|,
name|y1
operator|+
name|off_y
argument_list|)
expr_stmt|;
comment|/*  Free the temp buffer  */
name|tile_manager_unref
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
comment|/*  Add the floating layer to the image  */
name|floating_sel_attach
argument_list|(
name|layer
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
comment|/*  End an undo group  */
name|gimp_image_undo_group_end
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*  invalidate the image's boundary variables  */
name|GIMP_CHANNEL
argument_list|(
name|selection
argument_list|)
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

end_unit

