begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"colormaps.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"disp_callbacks.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gdisplayP.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay_color.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay_ops.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"gximage.h"
end_include

begin_include
include|#
directive|include
file|"image_render.h"
end_include

begin_include
include|#
directive|include
file|"info_window.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"lc_dialog.h"
end_include

begin_include
include|#
directive|include
file|"menus.h"
end_include

begin_include
include|#
directive|include
file|"nav_window.h"
end_include

begin_include
include|#
directive|include
file|"plug_in.h"
end_include

begin_include
include|#
directive|include
file|"qmask.h"
end_include

begin_include
include|#
directive|include
file|"scale.h"
end_include

begin_include
include|#
directive|include
file|"scroll.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_comment
comment|/* ick. (not alone either) */
end_comment

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_define
DECL|macro|OVERHEAD
define|#
directive|define
name|OVERHEAD
value|25
end_define

begin_comment
DECL|macro|OVERHEAD
comment|/*  in units of pixel area  */
end_comment

begin_define
DECL|macro|EPSILON
define|#
directive|define
name|EPSILON
value|5
end_define

begin_define
DECL|macro|MAX_TITLE_BUF
define|#
directive|define
name|MAX_TITLE_BUF
value|256
end_define

begin_comment
comment|/* variable declarations */
end_comment

begin_decl_stmt
DECL|variable|display_list
name|GSList
modifier|*
name|display_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|display_num
specifier|static
name|int
name|display_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|default_gdisplay_cursor
specifier|static
name|GdkCursorType
name|default_gdisplay_cursor
init|=
name|GDK_TOP_LEFT_ARROW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|gdisplay_format_title
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_delete
parameter_list|(
name|GDisplay
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|gdisplay_free_area_list
parameter_list|(
name|GSList
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|gdisplay_process_area_list
parameter_list|(
name|GSList
modifier|*
parameter_list|,
name|GArea
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_add_update_area
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_add_display_area
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_paint_area
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_draw_cursor
parameter_list|(
name|GDisplay
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_display_area
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|gdisplay_hash
parameter_list|(
name|GDisplay
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdisplay_cleandirty_handler
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|display_ht
specifier|static
name|GHashTable
modifier|*
name|display_ht
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|GDisplay
modifier|*
DECL|function|gdisplay_new (GimpImage * gimage,unsigned int scale)
name|gdisplay_new
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|unsigned
name|int
name|scale
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|char
name|title
index|[
name|MAX_TITLE_BUF
index|]
decl_stmt|;
comment|/*  If there isn't an interface, never create a gdisplay  */
if|if
condition|(
name|no_interface
condition|)
return|return
name|NULL
return|;
comment|/*    *  Set all GDisplay parameters...    */
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GDisplay
argument_list|)
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|offset_x
operator|=
name|gdisp
operator|->
name|offset_y
operator|=
literal|0
expr_stmt|;
name|gdisp
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|gdisp
operator|->
name|dot_for_dot
operator|=
name|TRUE
expr_stmt|;
name|gdisp
operator|->
name|gimage
operator|=
name|gimage
expr_stmt|;
name|gdisp
operator|->
name|window_info_dialog
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|window_nav_dialog
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|depth
operator|=
name|g_visual
operator|->
name|depth
expr_stmt|;
name|gdisp
operator|->
name|select
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|ID
operator|=
name|display_num
operator|++
expr_stmt|;
name|gdisp
operator|->
name|instance
operator|=
name|gimage
operator|->
name|instance_count
expr_stmt|;
name|gdisp
operator|->
name|update_areas
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|display_areas
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|disp_xoffset
operator|=
literal|0
expr_stmt|;
name|gdisp
operator|->
name|disp_yoffset
operator|=
literal|0
expr_stmt|;
name|gdisp
operator|->
name|current_cursor
operator|=
operator|-
literal|1
expr_stmt|;
name|gdisp
operator|->
name|draw_guides
operator|=
name|TRUE
expr_stmt|;
name|gdisp
operator|->
name|snap_to_guides
operator|=
name|TRUE
expr_stmt|;
name|gdisp
operator|->
name|draw_cursor
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|proximity
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|have_cursor
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|using_override_cursor
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|progressid
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|idleid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*gdisp->idle_render.handlerid = -1;*/
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|active
operator|=
name|FALSE
expr_stmt|;
name|gdisp
operator|->
name|cd_list
operator|=
name|NULL
expr_stmt|;
comment|/* format the title */
name|gdisplay_format_title
argument_list|(
name|gdisp
argument_list|,
name|title
argument_list|,
name|MAX_TITLE_BUF
argument_list|)
expr_stmt|;
comment|/*  add the new display to the list so that it isn't lost  */
name|display_list
operator|=
name|g_slist_append
argument_list|(
name|display_list
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  create the shell for the image  */
name|create_display_shell
argument_list|(
name|gdisp
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|title
argument_list|,
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update the title to correct the initially displayed scale */
name|gdisplay_update_title
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  set the gdisplay colormap type and install the appropriate colormap  */
name|gdisp
operator|->
name|color_type
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
operator|)
condition|?
name|GRAY
else|:
name|RGB
expr_stmt|;
comment|/* set the qmask buttons */
name|qmask_buttons_update
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  set the user data  */
if|if
condition|(
operator|!
name|display_ht
condition|)
name|display_ht
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|gdisplay_hash
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|display_ht
argument_list|,
name|gdisp
operator|->
name|shell
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|display_ht
argument_list|,
name|gdisp
operator|->
name|canvas
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  set the current tool cursor  */
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|default_gdisplay_cursor
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|instance_count
operator|++
expr_stmt|;
name|gimage
operator|->
name|ref_count
operator|++
expr_stmt|;
name|lc_dialog_preview_update
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/* We're interested in clean and dirty signals so we can update the    * title if need be. */
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|"dirty"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gdisplay_cleandirty_handler
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|"clean"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gdisplay_cleandirty_handler
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
return|return
name|gdisp
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|print
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|G_GNUC_PRINTF
parameter_list|(
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
DECL|function|print (char * buf,int len,int start,const char * fmt,...)
name|print
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|printed
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printed
operator|=
name|g_vsnprintf
argument_list|(
name|buf
operator|+
name|start
argument_list|,
name|len
operator|-
name|start
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|printed
operator|<
literal|0
condition|)
name|printed
operator|=
name|len
operator|-
name|start
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|printed
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_format_title (GDisplay * gdisp,char * title,int title_len)
name|gdisplay_format_title
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|char
modifier|*
name|title
parameter_list|,
name|int
name|title_len
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|image_type_str
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|gimage
operator|=
name|gdisp
operator|->
name|gimage
expr_stmt|;
name|empty
operator|=
name|gimage_is_empty
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
name|image_type_str
operator|=
operator|(
name|empty
operator|)
condition|?
name|_
argument_list|(
literal|"RGB-empty"
argument_list|)
else|:
name|_
argument_list|(
literal|"RGB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|image_type_str
operator|=
operator|(
name|empty
operator|)
condition|?
name|_
argument_list|(
literal|"grayscale-empty"
argument_list|)
else|:
name|_
argument_list|(
literal|"grayscale"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED
case|:
name|image_type_str
operator|=
operator|(
name|empty
operator|)
condition|?
name|_
argument_list|(
literal|"indexed-empty"
argument_list|)
else|:
name|_
argument_list|(
literal|"indexed"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|image_type_str
operator|=
name|NULL
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|image_title_format
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|title_len
operator|&&
operator|*
name|format
condition|)
block|{
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'%'
case|:
name|format
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|0
case|:
name|g_warning
argument_list|(
literal|"image-title-format string ended within %%-sequence"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|title
index|[
name|i
operator|++
index|]
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* pruned filename */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%s"
argument_list|,
name|g_basename
argument_list|(
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* full filename */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%s"
argument_list|,
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* PDB id */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%d"
argument_list|,
name|pdb_image_to_id
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* instance */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%d"
argument_list|,
name|gdisp
operator|->
name|instance
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* type */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%s"
argument_list|,
name|image_type_str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* user source zoom factor */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%d"
argument_list|,
name|SCALESRC
argument_list|(
name|gdisp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* user destination zoom factor */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%d"
argument_list|,
name|SCALEDEST
argument_list|(
name|gdisp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* user zoom factor (percentage) */
name|i
operator|+=
name|print
argument_list|(
name|title
argument_list|,
name|title_len
argument_list|,
name|i
argument_list|,
literal|"%d"
argument_list|,
literal|100
operator|*
name|SCALEDEST
argument_list|(
name|gdisp
argument_list|)
operator|/
name|SCALESRC
argument_list|(
name|gdisp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* dirty flag */
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|g_warning
argument_list|(
literal|"image-title-format string ended within %%D-sequence"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gimage
operator|->
name|dirty
condition|)
name|title
index|[
name|i
operator|++
index|]
operator|=
name|format
index|[
literal|1
index|]
expr_stmt|;
name|format
operator|++
expr_stmt|;
break|break;
comment|/* Other cool things to be added: 	   * %m = memory used by picture 	   * some kind of resolution / image size thing 	   * people seem to want to know the active layer name 	   */
default|default:
name|g_warning
argument_list|(
literal|"image-title-format contains unknown format sequence '%%%c'"
argument_list|,
operator|*
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|title
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format
expr_stmt|;
break|break;
block|}
name|format
operator|++
expr_stmt|;
block|}
name|title
index|[
name|MIN
argument_list|(
name|i
argument_list|,
name|title_len
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_delete (GDisplay * gdisp)
name|gdisplay_delete
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpContext
modifier|*
name|context
decl_stmt|;
name|g_hash_table_remove
argument_list|(
name|display_ht
argument_list|,
name|gdisp
operator|->
name|shell
argument_list|)
expr_stmt|;
name|g_hash_table_remove
argument_list|(
name|display_ht
argument_list|,
name|gdisp
operator|->
name|canvas
argument_list|)
expr_stmt|;
comment|/*  stop any active tool  */
name|active_tool_control
argument_list|(
name|HALT
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  clear out the pointer to this gdisp from the active tool  */
if|if
condition|(
name|active_tool
operator|&&
name|active_tool
operator|->
name|gdisp_ptr
operator|==
name|gdisp
condition|)
block|{
name|active_tool
operator|->
name|drawable
operator|=
name|NULL
expr_stmt|;
name|active_tool
operator|->
name|gdisp_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  free the selection structure  */
name|selection_free
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
comment|/* If this gdisplay was idlerendering at the time when it was deleted,      deactivate the idlerendering thread before deletion! */
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|active
condition|)
block|{
name|gtk_idle_remove
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|idleid
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|active
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* get rid of signals handled by this display */
name|gtk_signal_disconnect_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|scroll_gc
condition|)
name|gdk_gc_destroy
argument_list|(
name|gdisp
operator|->
name|scroll_gc
argument_list|)
expr_stmt|;
comment|/*  free the area lists  */
name|gdisplay_free_area_list
argument_list|(
name|gdisp
operator|->
name|update_areas
argument_list|)
expr_stmt|;
name|gdisplay_free_area_list
argument_list|(
name|gdisp
operator|->
name|display_areas
argument_list|)
expr_stmt|;
name|gdisplay_free_area_list
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
argument_list|)
expr_stmt|;
comment|/*  free the gimage  */
name|gimage_delete
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
comment|/*  insure that if a window information dialog exists, it is removed  */
if|if
condition|(
name|gdisp
operator|->
name|window_info_dialog
condition|)
name|info_window_free
argument_list|(
name|gdisp
operator|->
name|window_info_dialog
argument_list|)
expr_stmt|;
comment|/* Remove navigation dialog if we have one */
if|if
condition|(
name|gdisp
operator|->
name|window_nav_dialog
condition|)
name|nav_window_free
argument_list|(
name|gdisp
operator|->
name|window_nav_dialog
argument_list|)
expr_stmt|;
comment|/*  set the active display to NULL if it was this display  */
name|context
operator|=
name|gimp_context_get_user
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimp_context_get_display
argument_list|(
name|context
argument_list|)
operator|==
name|gdisp
condition|)
name|gimp_context_set_display
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_unref
argument_list|(
name|gdisp
operator|->
name|shell
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|gdisplay_free_area_list (GSList * list)
name|gdisplay_free_area_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|)
block|{
name|GSList
modifier|*
name|l
init|=
name|list
decl_stmt|;
name|GArea
modifier|*
name|ga
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
comment|/*  free the data  */
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|l
operator|->
name|data
expr_stmt|;
name|g_free
argument_list|(
name|ga
argument_list|)
expr_stmt|;
name|l
operator|=
name|g_slist_next
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
condition|)
name|g_slist_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * As far as I can tell, this function takes a GArea and unifies it with  *  an existing list of GAreas, trying to avoid overdraw.  [adam]  */
end_comment

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|gdisplay_process_area_list (GSList * list,GArea * ga1)
name|gdisplay_process_area_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|GArea
modifier|*
name|ga1
parameter_list|)
block|{
name|GSList
modifier|*
name|new_list
decl_stmt|;
name|GSList
modifier|*
name|l
init|=
name|list
decl_stmt|;
name|int
name|area1
decl_stmt|,
name|area2
decl_stmt|,
name|area3
decl_stmt|;
name|GArea
modifier|*
name|ga2
decl_stmt|;
comment|/*  start new list off  */
name|new_list
operator|=
name|g_slist_prepend
argument_list|(
name|NULL
argument_list|,
name|ga1
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
comment|/*  process the data  */
name|ga2
operator|=
operator|(
name|GArea
operator|*
operator|)
name|l
operator|->
name|data
expr_stmt|;
name|area1
operator|=
operator|(
name|ga1
operator|->
name|x2
operator|-
name|ga1
operator|->
name|x1
operator|)
operator|*
operator|(
name|ga1
operator|->
name|y2
operator|-
name|ga1
operator|->
name|y1
operator|)
operator|+
name|OVERHEAD
expr_stmt|;
name|area2
operator|=
operator|(
name|ga2
operator|->
name|x2
operator|-
name|ga2
operator|->
name|x1
operator|)
operator|*
operator|(
name|ga2
operator|->
name|y2
operator|-
name|ga2
operator|->
name|y1
operator|)
operator|+
name|OVERHEAD
expr_stmt|;
name|area3
operator|=
operator|(
name|MAXIMUM
argument_list|(
name|ga2
operator|->
name|x2
argument_list|,
name|ga1
operator|->
name|x2
argument_list|)
operator|-
name|MINIMUM
argument_list|(
name|ga2
operator|->
name|x1
argument_list|,
name|ga1
operator|->
name|x1
argument_list|)
operator|)
operator|*
operator|(
name|MAXIMUM
argument_list|(
name|ga2
operator|->
name|y2
argument_list|,
name|ga1
operator|->
name|y2
argument_list|)
operator|-
name|MINIMUM
argument_list|(
name|ga2
operator|->
name|y1
argument_list|,
name|ga1
operator|->
name|y1
argument_list|)
operator|)
operator|+
name|OVERHEAD
expr_stmt|;
if|if
condition|(
operator|(
name|area1
operator|+
name|area2
operator|)
operator|<
name|area3
condition|)
name|new_list
operator|=
name|g_slist_prepend
argument_list|(
name|new_list
argument_list|,
name|ga2
argument_list|)
expr_stmt|;
else|else
block|{
name|ga1
operator|->
name|x1
operator|=
name|MINIMUM
argument_list|(
name|ga1
operator|->
name|x1
argument_list|,
name|ga2
operator|->
name|x1
argument_list|)
expr_stmt|;
name|ga1
operator|->
name|y1
operator|=
name|MINIMUM
argument_list|(
name|ga1
operator|->
name|y1
argument_list|,
name|ga2
operator|->
name|y1
argument_list|)
expr_stmt|;
name|ga1
operator|->
name|x2
operator|=
name|MAXIMUM
argument_list|(
name|ga1
operator|->
name|x2
argument_list|,
name|ga2
operator|->
name|x2
argument_list|)
expr_stmt|;
name|ga1
operator|->
name|y2
operator|=
name|MAXIMUM
argument_list|(
name|ga1
operator|->
name|y2
argument_list|,
name|ga2
operator|->
name|y2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ga2
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|g_slist_next
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
condition|)
name|g_slist_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|new_list
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|idle_render_next_area (GDisplay * gdisp)
name|idle_render_next_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GArea
modifier|*
name|ga
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
operator|=
name|g_slist_remove
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
argument_list|,
name|ga
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|x
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
operator|=
name|ga
operator|->
name|x1
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|y
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basey
operator|=
name|ga
operator|->
name|y1
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|width
operator|=
name|ga
operator|->
name|x2
operator|-
name|ga
operator|->
name|x1
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|height
operator|=
name|ga
operator|->
name|y2
operator|-
name|ga
operator|->
name|y1
expr_stmt|;
name|g_free
argument_list|(
name|ga
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Unless specified otherwise, display re-rendering is organised  by IdleRender, which amalgamates areas to be re-rendered and  breaks them into bite-sized chunks which are chewed on in a low-  priority idle thread.  This greatly improves responsiveness for  many GIMP operations.  -- Adam */
end_comment

begin_function
specifier|static
name|int
DECL|function|idlerender_callback (gpointer data)
name|idlerender_callback
parameter_list|(
name|gpointer
name|data
parameter_list|)
block|{
specifier|const
name|int
name|CHUNK_WIDTH
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|CHUNK_HEIGHT
init|=
literal|128
decl_stmt|;
name|int
name|workx
decl_stmt|,
name|worky
decl_stmt|,
name|workw
decl_stmt|,
name|workh
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
init|=
name|data
decl_stmt|;
name|workw
operator|=
name|CHUNK_WIDTH
expr_stmt|;
name|workh
operator|=
name|CHUNK_HEIGHT
expr_stmt|;
name|workx
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|x
expr_stmt|;
name|worky
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|workx
operator|+
name|workw
operator|>
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|width
condition|)
block|{
name|workw
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|width
operator|-
name|workx
expr_stmt|;
block|}
if|if
condition|(
name|worky
operator|+
name|workh
operator|>
name|gdisp
operator|->
name|idle_render
operator|.
name|basey
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|height
condition|)
block|{
name|workh
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basey
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|height
operator|-
name|worky
expr_stmt|;
block|}
name|gdisplay_paint_area
argument_list|(
name|gdisp
argument_list|,
name|workx
argument_list|,
name|worky
argument_list|,
name|workw
argument_list|,
name|workh
argument_list|)
expr_stmt|;
name|gdisplay_flush_displays_only
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|x
operator|+=
name|CHUNK_WIDTH
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|x
operator|>=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|width
condition|)
block|{
name|gdisp
operator|->
name|idle_render
operator|.
name|x
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|y
operator|+=
name|CHUNK_HEIGHT
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|y
operator|>=
name|gdisp
operator|->
name|idle_render
operator|.
name|basey
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|height
condition|)
block|{
if|if
condition|(
name|idle_render_next_area
argument_list|(
name|gdisp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* FINISHED */
name|gdisp
operator|->
name|idle_render
operator|.
name|active
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* Still work to do. */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_idlerender_init (GDisplay * gdisp)
name|gdisplay_idlerender_init
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|GArea
modifier|*
name|ga
decl_stmt|,
modifier|*
name|new_ga
decl_stmt|;
comment|/*  gdisplay_install_override_cursor(gdisp, GDK_CIRCLE); */
comment|/* We need to merge the IdleRender's and the GDisplay's update_areas list      to keep track of which of the updates have been flushed and hence need      to be drawn.   */
name|list
operator|=
name|gdisp
operator|->
name|update_areas
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|new_ga
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GArea
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_ga
argument_list|,
name|ga
argument_list|,
sizeof|sizeof
argument_list|(
name|GArea
argument_list|)
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
operator|=
name|gdisplay_process_area_list
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
argument_list|,
name|new_ga
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* If an idlerender was already running, merge the remainder of its      unrendered area with the update_areas list, and make it start work      on the next unrendered area in the list. */
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|active
condition|)
block|{
name|new_ga
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GArea
argument_list|)
argument_list|)
expr_stmt|;
name|new_ga
operator|->
name|x1
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
expr_stmt|;
name|new_ga
operator|->
name|y1
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|y
expr_stmt|;
name|new_ga
operator|->
name|x2
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|basex
operator|+
name|gdisp
operator|->
name|idle_render
operator|.
name|width
expr_stmt|;
name|new_ga
operator|->
name|y2
operator|=
name|gdisp
operator|->
name|idle_render
operator|.
name|y
operator|+
operator|(
name|gdisp
operator|->
name|idle_render
operator|.
name|height
operator|-
operator|(
name|gdisp
operator|->
name|idle_render
operator|.
name|y
operator|-
name|gdisp
operator|->
name|idle_render
operator|.
name|basey
operator|)
operator|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
operator|=
name|gdisplay_process_area_list
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
argument_list|,
name|new_ga
argument_list|)
expr_stmt|;
name|idle_render_next_area
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|update_areas
operator|==
name|NULL
condition|)
block|{
name|g_warning
argument_list|(
literal|"Wanted to start idlerender thread with no update_areas. (+memleak)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|idle_render_next_area
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|active
operator|=
name|TRUE
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|idleid
operator|=
name|gtk_idle_add_priority
argument_list|(
name|GTK_PRIORITY_LOW
argument_list|,
name|idlerender_callback
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
comment|/* Caller frees gdisp->update_areas */
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_flush_displays_only (GDisplay * gdisp)
name|gdisplay_flush_displays_only
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|GArea
modifier|*
name|ga
decl_stmt|;
name|list
operator|=
name|gdisp
operator|->
name|display_areas
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
comment|/*  stop the currently active tool  */
name|active_tool_control
argument_list|(
name|PAUSE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
comment|/*  Paint the area specified by the GArea  */
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gdisplay_display_area
argument_list|(
name|gdisp
argument_list|,
name|ga
operator|->
name|x1
argument_list|,
name|ga
operator|->
name|y1
argument_list|,
operator|(
name|ga
operator|->
name|x2
operator|-
name|ga
operator|->
name|x1
operator|)
argument_list|,
operator|(
name|ga
operator|->
name|y2
operator|-
name|ga
operator|->
name|y1
operator|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Free the update lists  */
name|gdisp
operator|->
name|display_areas
operator|=
name|gdisplay_free_area_list
argument_list|(
name|gdisp
operator|->
name|display_areas
argument_list|)
expr_stmt|;
comment|/* draw the guides */
name|gdisplay_draw_guides
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/* and the cursor (if we have a software cursor */
if|if
condition|(
name|gdisp
operator|->
name|have_cursor
condition|)
name|gdisplay_draw_cursor
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/* restart (and recalculate) the selection boundaries */
name|selection_start
argument_list|(
name|gdisp
operator|->
name|select
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* start the currently active tool */
name|active_tool_control
argument_list|(
name|RESUME
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_flush_whenever (GDisplay * gdisp,gboolean now)
name|gdisplay_flush_whenever
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gboolean
name|now
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|GArea
modifier|*
name|ga
decl_stmt|;
comment|/*  Flush the items in the displays and updates lists -    *  but only if gdisplay has been mapped and exposed    */
if|if
condition|(
operator|!
name|gdisp
operator|->
name|select
condition|)
return|return;
comment|/*  First the updates...  */
if|if
condition|(
name|now
condition|)
block|{
comment|/* Synchronous */
name|list
operator|=
name|gdisp
operator|->
name|update_areas
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
comment|/*  Paint the area specified by the GArea  */
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|ga
operator|->
name|x1
operator|!=
name|ga
operator|->
name|x2
operator|)
operator|&&
operator|(
name|ga
operator|->
name|y1
operator|!=
name|ga
operator|->
name|y2
operator|)
condition|)
block|{
name|gdisplay_paint_area
argument_list|(
name|gdisp
argument_list|,
name|ga
operator|->
name|x1
argument_list|,
name|ga
operator|->
name|y1
argument_list|,
operator|(
name|ga
operator|->
name|x2
operator|-
name|ga
operator|->
name|x1
operator|)
argument_list|,
operator|(
name|ga
operator|->
name|y2
operator|-
name|ga
operator|->
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Asynchronous */
if|if
condition|(
name|gdisp
operator|->
name|update_areas
condition|)
name|gdisplay_idlerender_init
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
comment|/*  Free the update lists  */
name|gdisp
operator|->
name|update_areas
operator|=
name|gdisplay_free_area_list
argument_list|(
name|gdisp
operator|->
name|update_areas
argument_list|)
expr_stmt|;
comment|/*  Next the displays...  */
name|gdisplay_flush_displays_only
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  update the gdisplay's info dialog  */
if|if
condition|(
name|gdisp
operator|->
name|window_info_dialog
condition|)
name|info_window_update
argument_list|(
name|gdisp
operator|->
name|window_info_dialog
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
comment|/* update the gdisplay's qmask buttons */
name|qmask_buttons_update
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
comment|/*  ensure the consistency of the tear-off menus  */
if|if
condition|(
name|gimp_context_get_display
argument_list|(
name|gimp_context_get_user
argument_list|()
argument_list|)
operator|==
name|gdisp
condition|)
name|gdisplay_set_menu_sensitivity
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_flush (GDisplay * gdisp)
name|gdisplay_flush
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Redraw on idle time */
name|gdisplay_flush_whenever
argument_list|(
name|gdisp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_flush_now (GDisplay * gdisp)
name|gdisplay_flush_now
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Redraw NOW */
name|gdisplay_flush_whenever
argument_list|(
name|gdisp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force all gdisplays to finish their idlerender projection */
end_comment

begin_function
DECL|function|gdisplays_finish_draw (void)
name|void
name|gdisplays_finish_draw
parameter_list|(
name|void
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|active
condition|)
block|{
name|gtk_idle_remove
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|idleid
argument_list|)
expr_stmt|;
while|while
condition|(
name|idlerender_callback
argument_list|(
name|gdisp
argument_list|)
condition|)
empty_stmt|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_draw_guides (GDisplay * gdisp)
name|gdisplay_draw_guides
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GList
modifier|*
name|tmp_list
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|draw_guides
condition|)
block|{
name|tmp_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|tmp_list
condition|)
block|{
name|guide
operator|=
name|tmp_list
operator|->
name|data
expr_stmt|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
expr_stmt|;
name|gdisplay_draw_guide
argument_list|(
name|gdisp
argument_list|,
name|guide
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_draw_guide (GDisplay * gdisp,Guide * guide,int active)
name|gdisplay_draw_guide
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|,
name|int
name|active
parameter_list|)
block|{
specifier|static
name|GdkGC
modifier|*
name|normal_hgc
init|=
name|NULL
decl_stmt|;
specifier|static
name|GdkGC
modifier|*
name|active_hgc
init|=
name|NULL
decl_stmt|;
specifier|static
name|GdkGC
modifier|*
name|normal_vgc
init|=
name|NULL
decl_stmt|;
specifier|static
name|GdkGC
modifier|*
name|active_vgc
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|initialize
init|=
name|TRUE
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|initialize
condition|)
block|{
name|GdkGCValues
name|values
decl_stmt|;
specifier|const
name|char
name|stipple
index|[]
init|=
block|{
literal|0xF0
block|,
comment|/*  ####----  */
literal|0xE1
block|,
comment|/*  ###----#  */
literal|0xC3
block|,
comment|/*  ##----##  */
literal|0x87
block|,
comment|/*  #----###  */
literal|0x0F
block|,
comment|/*  ----####  */
literal|0x1E
block|,
comment|/*  ---####-  */
literal|0x3C
block|,
comment|/*  --####--  */
literal|0x78
block|,
comment|/*  -####---  */
block|}
decl_stmt|;
name|initialize
operator|=
name|FALSE
expr_stmt|;
name|values
operator|.
name|foreground
operator|.
name|pixel
operator|=
name|gdisplay_black_pixel
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|values
operator|.
name|background
operator|.
name|pixel
operator|=
name|g_normal_guide_pixel
expr_stmt|;
name|values
operator|.
name|fill
operator|=
name|GDK_OPAQUE_STIPPLED
expr_stmt|;
name|values
operator|.
name|stipple
operator|=
name|gdk_bitmap_create_from_data
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stipple
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|normal_hgc
operator|=
name|gdk_gc_new_with_values
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|&
name|values
argument_list|,
name|GDK_GC_FOREGROUND
operator||
name|GDK_GC_BACKGROUND
operator||
name|GDK_GC_FILL
operator||
name|GDK_GC_STIPPLE
argument_list|)
expr_stmt|;
name|values
operator|.
name|background
operator|.
name|pixel
operator|=
name|g_active_guide_pixel
expr_stmt|;
name|active_hgc
operator|=
name|gdk_gc_new_with_values
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|&
name|values
argument_list|,
name|GDK_GC_FOREGROUND
operator||
name|GDK_GC_BACKGROUND
operator||
name|GDK_GC_FILL
operator||
name|GDK_GC_STIPPLE
argument_list|)
expr_stmt|;
name|values
operator|.
name|foreground
operator|.
name|pixel
operator|=
name|gdisplay_black_pixel
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|values
operator|.
name|background
operator|.
name|pixel
operator|=
name|g_normal_guide_pixel
expr_stmt|;
name|values
operator|.
name|fill
operator|=
name|GDK_OPAQUE_STIPPLED
expr_stmt|;
name|values
operator|.
name|stipple
operator|=
name|gdk_bitmap_create_from_data
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stipple
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|normal_vgc
operator|=
name|gdk_gc_new_with_values
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|&
name|values
argument_list|,
name|GDK_GC_FOREGROUND
operator||
name|GDK_GC_BACKGROUND
operator||
name|GDK_GC_FILL
operator||
name|GDK_GC_STIPPLE
argument_list|)
expr_stmt|;
name|values
operator|.
name|background
operator|.
name|pixel
operator|=
name|g_active_guide_pixel
expr_stmt|;
name|active_vgc
operator|=
name|gdk_gc_new_with_values
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|&
name|values
argument_list|,
name|GDK_GC_FOREGROUND
operator||
name|GDK_GC_BACKGROUND
operator||
name|GDK_GC_FILL
operator||
name|GDK_GC_STIPPLE
argument_list|)
expr_stmt|;
block|}
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdk_window_get_size
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|<
literal|0
condition|)
name|x1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
name|y1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x2
operator|>
name|w
condition|)
name|x2
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|y2
operator|>
name|h
condition|)
name|y2
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|orientation
operator|==
name|ORIENTATION_HORIZONTAL
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
name|guide
operator|->
name|position
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|active_hgc
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|normal_hgc
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|guide
operator|->
name|orientation
operator|==
name|ORIENTATION_VERTICAL
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|guide
operator|->
name|position
argument_list|,
literal|0
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|active_vgc
argument_list|,
name|x
argument_list|,
name|y1
argument_list|,
name|x
argument_list|,
name|y2
argument_list|)
expr_stmt|;
else|else
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|normal_vgc
argument_list|,
name|x
argument_list|,
name|y1
argument_list|,
name|x
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gdisplay_find_guide (GDisplay * gdisp,int x,int y)
name|gdisplay_find_guide
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|GList
modifier|*
name|tmp_list
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|double
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|draw_guides
condition|)
block|{
name|offset_x
operator|=
name|gdisp
operator|->
name|offset_x
operator|-
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
name|offset_y
operator|=
name|gdisp
operator|->
name|offset_y
operator|-
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|tmp_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|tmp_list
condition|)
block|{
name|guide
operator|=
name|tmp_list
operator|->
name|data
expr_stmt|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|scaley
operator|*
name|guide
operator|->
name|position
operator|-
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|guide
operator|->
name|position
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|pos
operator|>
operator|(
name|y
operator|-
name|EPSILON
operator|)
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|y
operator|+
name|EPSILON
operator|)
operator|)
condition|)
return|return
name|guide
return|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|scalex
operator|*
name|guide
operator|->
name|position
operator|-
name|offset_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|guide
operator|->
name|position
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|pos
operator|>
operator|(
name|x
operator|-
name|EPSILON
operator|)
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|x
operator|+
name|EPSILON
operator|)
operator|)
condition|)
return|return
name|guide
return|;
break|break;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_snap_point (GDisplay * gdisp,gdouble x,gdouble y,gdouble * tx,gdouble * ty)
name|gdisplay_snap_point
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|gdouble
modifier|*
name|tx
parameter_list|,
name|gdouble
modifier|*
name|ty
parameter_list|)
block|{
name|GList
modifier|*
name|tmp_list
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|double
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|int
name|minhdist
decl_stmt|,
name|minvdist
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|dist
decl_stmt|;
operator|*
name|tx
operator|=
name|x
expr_stmt|;
operator|*
name|ty
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|draw_guides
operator|&&
name|gdisp
operator|->
name|snap_to_guides
operator|&&
name|gdisp
operator|->
name|gimage
operator|->
name|guides
condition|)
block|{
name|offset_x
operator|=
name|gdisp
operator|->
name|offset_x
operator|-
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
name|offset_y
operator|=
name|gdisp
operator|->
name|offset_y
operator|-
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|minhdist
operator|=
name|G_MAXINT
expr_stmt|;
name|minvdist
operator|=
name|G_MAXINT
expr_stmt|;
name|tmp_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|tmp_list
condition|)
block|{
name|guide
operator|=
name|tmp_list
operator|->
name|data
expr_stmt|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|scaley
operator|*
name|guide
operator|->
name|position
operator|-
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pos
operator|>
operator|(
name|y
operator|-
name|EPSILON
operator|)
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|y
operator|+
name|EPSILON
operator|)
operator|)
condition|)
block|{
name|dist
operator|=
name|pos
operator|-
name|y
expr_stmt|;
name|dist
operator|=
name|ABS
argument_list|(
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|minhdist
condition|)
block|{
name|minhdist
operator|=
name|dist
expr_stmt|;
operator|*
name|ty
operator|=
name|pos
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|scalex
operator|*
name|guide
operator|->
name|position
operator|-
name|offset_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pos
operator|>
operator|(
name|x
operator|-
name|EPSILON
operator|)
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|x
operator|+
name|EPSILON
operator|)
operator|)
condition|)
block|{
name|dist
operator|=
name|pos
operator|-
name|x
expr_stmt|;
name|dist
operator|=
name|ABS
argument_list|(
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|minvdist
condition|)
block|{
name|minvdist
operator|=
name|dist
expr_stmt|;
operator|*
name|tx
operator|=
name|pos
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_snap_rectangle (GDisplay * gdisp,int x1,int y1,int x2,int y2,int * tx1,int * ty1)
name|gdisplay_snap_rectangle
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
name|int
modifier|*
name|tx1
parameter_list|,
name|int
modifier|*
name|ty1
parameter_list|)
block|{
name|double
name|nx1
decl_stmt|,
name|ny1
decl_stmt|;
name|double
name|nx2
decl_stmt|,
name|ny2
decl_stmt|;
operator|*
name|tx1
operator|=
name|x1
expr_stmt|;
operator|*
name|ty1
operator|=
name|y1
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|draw_guides
operator|&&
name|gdisp
operator|->
name|snap_to_guides
operator|&&
name|gdisp
operator|->
name|gimage
operator|->
name|guides
condition|)
block|{
name|gdisplay_snap_point
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|nx1
argument_list|,
operator|&
name|ny1
argument_list|)
expr_stmt|;
name|gdisplay_snap_point
argument_list|(
name|gdisp
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|nx2
argument_list|,
operator|&
name|ny2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|!=
operator|(
name|int
operator|)
name|nx1
condition|)
operator|*
name|tx1
operator|=
name|nx1
expr_stmt|;
elseif|else
if|if
condition|(
name|x2
operator|!=
operator|(
name|int
operator|)
name|nx2
condition|)
operator|*
name|tx1
operator|=
name|x1
operator|+
operator|(
name|nx2
operator|-
name|x2
operator|)
expr_stmt|;
if|if
condition|(
name|y1
operator|!=
operator|(
name|int
operator|)
name|ny1
condition|)
operator|*
name|ty1
operator|=
name|ny1
expr_stmt|;
elseif|else
if|if
condition|(
name|y2
operator|!=
operator|(
name|int
operator|)
name|ny2
condition|)
operator|*
name|ty1
operator|=
name|y1
operator|+
operator|(
name|ny2
operator|-
name|y2
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_draw_cursor (GDisplay * gdisp)
name|gdisplay_draw_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|int
name|x
init|=
name|gdisp
operator|->
name|cursor_x
decl_stmt|;
name|int
name|y
init|=
name|gdisp
operator|->
name|cursor_y
decl_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|white_gc
argument_list|,
name|x
operator|-
literal|7
argument_list|,
name|y
operator|-
literal|1
argument_list|,
name|x
operator|+
literal|7
argument_list|,
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|black_gc
argument_list|,
name|x
operator|-
literal|7
argument_list|,
name|y
argument_list|,
name|x
operator|+
literal|7
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|white_gc
argument_list|,
name|x
operator|-
literal|7
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|x
operator|+
literal|7
argument_list|,
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|white_gc
argument_list|,
name|x
operator|-
literal|1
argument_list|,
name|y
operator|-
literal|7
argument_list|,
name|x
operator|-
literal|1
argument_list|,
name|y
operator|+
literal|7
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|black_gc
argument_list|,
name|x
argument_list|,
name|y
operator|-
literal|7
argument_list|,
name|x
argument_list|,
name|y
operator|+
literal|7
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|white_gc
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
operator|-
literal|7
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
operator|+
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_update_cursor (GDisplay * gdisp,int x,int y)
name|gdisplay_update_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|new_cursor
decl_stmt|;
name|char
name|buffer
index|[
name|CURSOR_STR_LENGTH
index|]
decl_stmt|;
name|int
name|t_x
decl_stmt|,
name|t_y
decl_stmt|;
name|GimpDrawable
modifier|*
name|active_drawable
decl_stmt|;
name|new_cursor
operator|=
name|gdisp
operator|->
name|draw_cursor
operator|&&
name|gdisp
operator|->
name|proximity
expr_stmt|;
comment|/* Erase old cursor, if necessary */
if|if
condition|(
name|gdisp
operator|->
name|have_cursor
operator|&&
operator|(
operator|!
name|new_cursor
operator|||
name|x
operator|!=
name|gdisp
operator|->
name|cursor_x
operator|||
name|y
operator|!=
name|gdisp
operator|->
name|cursor_y
operator|)
condition|)
block|{
name|gdisplay_expose_area
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|cursor_x
operator|-
literal|7
argument_list|,
name|gdisp
operator|->
name|cursor_y
operator|-
literal|7
argument_list|,
literal|15
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_cursor
condition|)
block|{
name|gdisp
operator|->
name|have_cursor
operator|=
name|FALSE
expr_stmt|;
name|gdisplay_flush
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|t_x
argument_list|,
operator|&
name|t_y
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|active_drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_drawable
condition|)
block|{
if|if
condition|(
name|t_x
operator|<
literal|0
operator|||
name|t_y
operator|<
literal|0
operator|||
name|t_x
operator|>=
name|active_drawable
operator|->
name|width
operator|||
name|t_y
operator|>=
name|active_drawable
operator|->
name|height
condition|)
block|{
name|gtk_label_set
argument_list|(
name|GTK_LABEL
argument_list|(
name|gdisp
operator|->
name|cursor_label
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|info_window_update_RGB
argument_list|(
name|gdisp
operator|->
name|window_info_dialog
argument_list|,
name|gdisp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gdisp
operator|->
name|dot_for_dot
condition|)
block|{
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
name|CURSOR_STR_LENGTH
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
literal|""
argument_list|,
name|t_x
argument_list|,
literal|", "
argument_list|,
name|t_y
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* show real world units */
block|{
name|double
name|unit_factor
init|=
name|gimp_unit_get_factor
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
decl_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
name|CURSOR_STR_LENGTH
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
literal|""
argument_list|,
operator|(
name|double
operator|)
name|t_x
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|xresolution
argument_list|,
literal|", "
argument_list|,
operator|(
name|double
operator|)
name|t_y
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|yresolution
argument_list|)
expr_stmt|;
block|}
name|gtk_label_set
argument_list|(
name|GTK_LABEL
argument_list|(
name|gdisp
operator|->
name|cursor_label
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|info_window_update_RGB
argument_list|(
name|gdisp
operator|->
name|window_info_dialog
argument_list|,
name|gdisp
argument_list|,
name|t_x
argument_list|,
name|t_y
argument_list|)
expr_stmt|;
block|}
block|}
name|gdisp
operator|->
name|have_cursor
operator|=
name|new_cursor
expr_stmt|;
name|gdisp
operator|->
name|cursor_x
operator|=
name|x
expr_stmt|;
name|gdisp
operator|->
name|cursor_y
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|new_cursor
condition|)
name|gdisplay_flush
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_set_dot_for_dot (GDisplay * gdisp,int value)
name|gdisplay_set_dot_for_dot
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
name|gdisp
operator|->
name|dot_for_dot
condition|)
block|{
name|gdisp
operator|->
name|dot_for_dot
operator|=
name|value
expr_stmt|;
name|gdisplay_resize_cursor_label
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|resize_display
argument_list|(
name|gdisp
argument_list|,
name|allow_resize_windows
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_resize_cursor_label (GDisplay * gdisp)
name|gdisplay_resize_cursor_label
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Set a proper size for the coordinates display in the statusbar. */
name|char
name|buffer
index|[
name|CURSOR_STR_LENGTH
index|]
decl_stmt|;
name|int
name|cursor_label_width
decl_stmt|;
name|int
name|label_frame_size_difference
decl_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|dot_for_dot
condition|)
block|{
name|g_snprintf
argument_list|(
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
sizeof|sizeof
argument_list|(
name|gdisp
operator|->
name|cursor_format_str
argument_list|)
argument_list|,
literal|"%%s%%d%%s%%d"
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
literal|""
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
literal|", "
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* show real world units */
block|{
name|gdouble
name|unit_factor
init|=
name|gimp_unit_get_factor
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
decl_stmt|;
name|g_snprintf
argument_list|(
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
sizeof|sizeof
argument_list|(
name|gdisp
operator|->
name|cursor_format_str
argument_list|)
argument_list|,
literal|"%%s%%.%df%%s%%.%df %s"
argument_list|,
name|gimp_unit_get_digits
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
argument_list|,
name|gimp_unit_get_digits
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
argument_list|,
name|gimp_unit_get_symbol
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
literal|""
argument_list|,
operator|(
name|gdouble
operator|)
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|xresolution
argument_list|,
literal|", "
argument_list|,
operator|(
name|gdouble
operator|)
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|yresolution
argument_list|)
expr_stmt|;
block|}
name|cursor_label_width
operator|=
name|gdk_string_width
argument_list|(
name|gtk_widget_get_style
argument_list|(
name|gdisp
operator|->
name|cursor_label
argument_list|)
operator|->
name|font
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/*  find out how many pixels the label's parent frame is bigger than    *  the label itself    */
name|label_frame_size_difference
operator|=
name|gdisp
operator|->
name|cursor_label
operator|->
name|parent
operator|->
name|allocation
operator|.
name|width
operator|-
name|gdisp
operator|->
name|cursor_label
operator|->
name|allocation
operator|.
name|width
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|gdisp
operator|->
name|cursor_label
argument_list|,
name|cursor_label_width
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_frame_size_difference
condition|)
comment|/* don't resize if this is a new display */
name|gtk_widget_set_usize
argument_list|(
name|gdisp
operator|->
name|cursor_label
operator|->
name|parent
argument_list|,
name|cursor_label_width
operator|+
name|label_frame_size_difference
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gdisplay_update_cursor
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|cursor_x
argument_list|,
name|gdisp
operator|->
name|cursor_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_remove_and_delete (GDisplay * gdisp)
name|gdisplay_remove_and_delete
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* remove the display from the list */
name|display_list
operator|=
name|g_slist_remove
argument_list|(
name|display_list
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gdisp
argument_list|)
expr_stmt|;
name|gdisplay_delete
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_add_update_area (GDisplay * gdisp,int x,int y,int w,int h)
name|gdisplay_add_update_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|GArea
modifier|*
name|ga
decl_stmt|;
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GArea
argument_list|)
argument_list|)
expr_stmt|;
name|ga
operator|->
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|ga
operator|->
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|ga
operator|->
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|ga
operator|->
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|update_areas
operator|=
name|gdisplay_process_area_list
argument_list|(
name|gdisp
operator|->
name|update_areas
argument_list|,
name|ga
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_add_display_area (GDisplay * gdisp,int x,int y,int w,int h)
name|gdisplay_add_display_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|GArea
modifier|*
name|ga
decl_stmt|;
name|ga
operator|=
operator|(
name|GArea
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GArea
argument_list|)
argument_list|)
expr_stmt|;
name|ga
operator|->
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
name|ga
operator|->
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
name|ga
operator|->
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
name|ga
operator|->
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|display_areas
operator|=
name|gdisplay_process_area_list
argument_list|(
name|gdisp
operator|->
name|display_areas
argument_list|,
name|ga
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_paint_area (GDisplay * gdisp,int x,int y,int w,int h)
name|gdisplay_paint_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/*  Bounds check  */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x
operator|=
name|x1
expr_stmt|;
name|y
operator|=
name|y1
expr_stmt|;
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
comment|/*  calculate the extents of the update as limited by what's visible  */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage_invalidate
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/*  display the area  */
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x
operator|+
name|w
argument_list|,
name|y
operator|+
name|h
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdisplay_expose_area
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplay_display_area (GDisplay * gdisp,int x,int y,int w,int h)
name|gdisplay_display_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sx
operator|=
name|SCALEX
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|sy
operator|=
name|SCALEY
argument_list|(
name|gdisp
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/*  Bounds check  */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|y1
operator|<
name|gdisp
operator|->
name|disp_yoffset
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_NORMAL
index|]
argument_list|,
literal|1
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|gdisp
operator|->
name|disp_yoffset
operator|-
name|y
argument_list|)
expr_stmt|;
comment|/* X X X          . # .          . . . */
name|y1
operator|=
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
block|}
if|if
condition|(
name|x1
operator|<
name|gdisp
operator|->
name|disp_xoffset
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_NORMAL
index|]
argument_list|,
literal|1
argument_list|,
name|x
argument_list|,
name|y1
argument_list|,
name|gdisp
operator|->
name|disp_xoffset
operator|-
name|x
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* . . .          X # .          X . . */
name|x1
operator|=
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
block|}
if|if
condition|(
name|x2
operator|>
operator|(
name|gdisp
operator|->
name|disp_xoffset
operator|+
name|sx
operator|)
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_NORMAL
index|]
argument_list|,
literal|1
argument_list|,
name|gdisp
operator|->
name|disp_xoffset
operator|+
name|sx
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
operator|(
name|gdisp
operator|->
name|disp_xoffset
operator|+
name|sx
operator|)
argument_list|,
name|h
operator|-
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|)
expr_stmt|;
comment|/* . . .          . # X          . . X */
name|x2
operator|=
name|gdisp
operator|->
name|disp_xoffset
operator|+
name|sx
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|>
operator|(
name|gdisp
operator|->
name|disp_yoffset
operator|+
name|sy
operator|)
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_NORMAL
index|]
argument_list|,
literal|1
argument_list|,
name|x1
argument_list|,
name|gdisp
operator|->
name|disp_yoffset
operator|+
name|sy
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
operator|(
name|gdisp
operator|->
name|disp_yoffset
operator|+
name|sy
operator|)
argument_list|)
expr_stmt|;
comment|/* . . .          . # .          . X . */
name|y2
operator|=
name|gdisp
operator|->
name|disp_yoffset
operator|+
name|sy
expr_stmt|;
block|}
comment|/*  display the image in GXIMAGE_WIDTH x GXIMAGE_HEIGHT sized chunks */
for|for
control|(
name|i
operator|=
name|y1
init|;
name|i
operator|<
name|y2
condition|;
name|i
operator|+=
name|GXIMAGE_HEIGHT
control|)
for|for
control|(
name|j
operator|=
name|x1
init|;
name|j
operator|<
name|x2
condition|;
name|j
operator|+=
name|GXIMAGE_WIDTH
control|)
block|{
name|dx
operator|=
name|MIN
argument_list|(
name|x2
operator|-
name|j
argument_list|,
name|GXIMAGE_WIDTH
argument_list|)
expr_stmt|;
name|dy
operator|=
name|MIN
argument_list|(
name|y2
operator|-
name|i
argument_list|,
name|GXIMAGE_HEIGHT
argument_list|)
expr_stmt|;
name|render_image
argument_list|(
name|gdisp
argument_list|,
name|j
operator|-
name|gdisp
operator|->
name|disp_xoffset
argument_list|,
name|i
operator|-
name|gdisp
operator|->
name|disp_yoffset
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Invalidate the projection just after we render it! */
block|gimage_invalidate_without_render (gdisp->gimage, 					      j - gdisp->disp_xoffset, 					      i - gdisp->disp_yoffset, 					      dx, dy, 					      0, 0, 0, 0);
endif|#
directive|endif
name|gximage_put
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|gdisp
operator|->
name|offset_x
argument_list|,
name|gdisp
operator|->
name|offset_y
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gdisplay_mask_value (GDisplay * gdisp,int x,int y)
name|gdisplay_mask_value
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
comment|/*  move the coordinates from screen space to image space  */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gimage_mask_value
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gdisplay_mask_bounds (GDisplay * gdisp,int * x1,int * y1,int * x2,int * y2)
name|gdisplay_mask_bounds
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
modifier|*
name|x1
parameter_list|,
name|int
modifier|*
name|y1
parameter_list|,
name|int
modifier|*
name|x2
parameter_list|,
name|int
modifier|*
name|y2
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  If there is a floating selection, handle things differently  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|)
condition|)
block|{
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel_bounds
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
condition|)
block|{
operator|*
name|x1
operator|=
name|off_x
expr_stmt|;
operator|*
name|y1
operator|=
name|off_y
expr_stmt|;
operator|*
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|x1
operator|=
name|MINIMUM
argument_list|(
name|off_x
argument_list|,
operator|*
name|x1
argument_list|)
expr_stmt|;
operator|*
name|y1
operator|=
name|MINIMUM
argument_list|(
name|off_y
argument_list|,
operator|*
name|y1
argument_list|)
expr_stmt|;
operator|*
name|x2
operator|=
name|MAXIMUM
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|*
name|x2
argument_list|)
expr_stmt|;
operator|*
name|y2
operator|=
name|MAXIMUM
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|*
name|y2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|channel_bounds
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
operator|*
name|x1
argument_list|,
operator|*
name|y1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
operator|*
name|x2
argument_list|,
operator|*
name|y2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  Make sure the extents are within bounds  */
operator|*
name|x1
operator|=
name|BOUNDS
argument_list|(
operator|*
name|x1
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
operator|*
name|y1
operator|=
name|BOUNDS
argument_list|(
operator|*
name|y1
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
operator|*
name|x2
operator|=
name|BOUNDS
argument_list|(
operator|*
name|x2
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|)
expr_stmt|;
operator|*
name|y2
operator|=
name|BOUNDS
argument_list|(
operator|*
name|y2
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_transform_coords (GDisplay * gdisp,int x,int y,int * nx,int * ny,int use_offsets)
name|gdisplay_transform_coords
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
modifier|*
name|nx
parameter_list|,
name|int
modifier|*
name|ny
parameter_list|,
name|int
name|use_offsets
parameter_list|)
block|{
name|double
name|scalex
decl_stmt|;
name|double
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
comment|/*  transform from image coordinates to screen coordinates  */
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_offsets
condition|)
name|drawable_offsets
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
else|else
block|{
name|offset_x
operator|=
name|offset_y
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|scalex
operator|*
operator|(
name|x
operator|+
name|offset_x
operator|)
operator|-
name|gdisp
operator|->
name|offset_x
argument_list|)
expr_stmt|;
operator|*
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|scaley
operator|*
operator|(
name|y
operator|+
name|offset_y
operator|)
operator|-
name|gdisp
operator|->
name|offset_y
argument_list|)
expr_stmt|;
operator|*
name|nx
operator|+=
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
operator|*
name|ny
operator|+=
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_untransform_coords (GDisplay * gdisp,int x,int y,int * nx,int * ny,int round,int use_offsets)
name|gdisplay_untransform_coords
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
modifier|*
name|nx
parameter_list|,
name|int
modifier|*
name|ny
parameter_list|,
name|int
name|round
parameter_list|,
name|int
name|use_offsets
parameter_list|)
block|{
name|double
name|scalex
decl_stmt|;
name|double
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|x
operator|-=
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
name|y
operator|-=
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
comment|/*  transform from screen coordinates to image coordinates  */
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_offsets
condition|)
name|drawable_offsets
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
else|else
block|{
name|offset_x
operator|=
name|offset_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|round
condition|)
block|{
operator|*
name|nx
operator|=
name|ROUND
argument_list|(
operator|(
name|x
operator|+
name|gdisp
operator|->
name|offset_x
operator|)
operator|/
name|scalex
operator|-
name|offset_x
argument_list|)
expr_stmt|;
operator|*
name|ny
operator|=
name|ROUND
argument_list|(
operator|(
name|y
operator|+
name|gdisp
operator|->
name|offset_y
operator|)
operator|/
name|scaley
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|x
operator|+
name|gdisp
operator|->
name|offset_x
operator|)
operator|/
name|scalex
operator|-
name|offset_x
argument_list|)
expr_stmt|;
operator|*
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
name|gdisp
operator|->
name|offset_y
operator|)
operator|/
name|scaley
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_transform_coords_f (GDisplay * gdisp,double x,double y,double * nx,double * ny,int use_offsets)
name|gdisplay_transform_coords_f
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
modifier|*
name|nx
parameter_list|,
name|double
modifier|*
name|ny
parameter_list|,
name|int
name|use_offsets
parameter_list|)
block|{
name|double
name|scalex
decl_stmt|;
name|double
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
comment|/*  transform from gimp coordinates to screen coordinates  */
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_offsets
condition|)
name|drawable_offsets
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
else|else
block|{
name|offset_x
operator|=
name|offset_y
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nx
operator|=
name|scalex
operator|*
operator|(
name|x
operator|+
name|offset_x
operator|)
operator|-
name|gdisp
operator|->
name|offset_x
expr_stmt|;
operator|*
name|ny
operator|=
name|scaley
operator|*
operator|(
name|y
operator|+
name|offset_y
operator|)
operator|-
name|gdisp
operator|->
name|offset_y
expr_stmt|;
operator|*
name|nx
operator|+=
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
operator|*
name|ny
operator|+=
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_untransform_coords_f (GDisplay * gdisp,double x,double y,double * nx,double * ny,int use_offsets)
name|gdisplay_untransform_coords_f
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
modifier|*
name|nx
parameter_list|,
name|double
modifier|*
name|ny
parameter_list|,
name|int
name|use_offsets
parameter_list|)
block|{
name|double
name|scalex
decl_stmt|;
name|double
name|scaley
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|x
operator|-=
name|gdisp
operator|->
name|disp_xoffset
expr_stmt|;
name|y
operator|-=
name|gdisp
operator|->
name|disp_yoffset
expr_stmt|;
comment|/*  transform from screen coordinates to gimp coordinates  */
name|scalex
operator|=
name|SCALEFACTOR_X
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|scaley
operator|=
name|SCALEFACTOR_Y
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_offsets
condition|)
name|drawable_offsets
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
else|else
block|{
name|offset_x
operator|=
name|offset_y
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nx
operator|=
operator|(
name|x
operator|+
name|gdisp
operator|->
name|offset_x
operator|)
operator|/
name|scalex
operator|-
name|offset_x
expr_stmt|;
operator|*
name|ny
operator|=
operator|(
name|y
operator|+
name|gdisp
operator|->
name|offset_y
operator|)
operator|/
name|scaley
operator|-
name|offset_y
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  install and remove tool cursor from gdisplay...  */
end_comment

begin_function
name|void
DECL|function|gdisplay_install_tool_cursor (GDisplay * gdisp,GdkCursorType cursor_type)
name|gdisplay_install_tool_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GdkCursorType
name|cursor_type
parameter_list|)
block|{
if|if
condition|(
name|gdisp
operator|->
name|current_cursor
operator|!=
operator|(
name|int
operator|)
name|cursor_type
condition|)
block|{
name|gdisp
operator|->
name|current_cursor
operator|=
operator|(
name|int
operator|)
name|cursor_type
expr_stmt|;
if|if
condition|(
operator|!
name|gdisp
operator|->
name|using_override_cursor
condition|)
block|{
name|change_win_cursor
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|cursor_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  install an override-cursor on gdisplay...  */
end_comment

begin_function
name|void
DECL|function|gdisplay_install_override_cursor (GDisplay * gdisp,GdkCursorType cursor_type)
name|gdisplay_install_override_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GdkCursorType
name|cursor_type
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|gdisp
operator|->
name|using_override_cursor
operator|)
operator|||
operator|(
operator|(
name|gdisp
operator|->
name|using_override_cursor
operator|)
operator|&&
operator|(
name|gdisp
operator|->
name|override_cursor
operator|!=
name|cursor_type
operator|)
operator|)
condition|)
block|{
name|gdisp
operator|->
name|override_cursor
operator|=
name|cursor_type
expr_stmt|;
name|gdisp
operator|->
name|using_override_cursor
operator|=
name|TRUE
expr_stmt|;
name|change_win_cursor
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|cursor_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  remove an override-cursor from gdisplay...  */
end_comment

begin_function
name|void
DECL|function|gdisplay_remove_override_cursor (GDisplay * gdisp)
name|gdisplay_remove_override_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
if|if
condition|(
name|gdisp
operator|->
name|using_override_cursor
condition|)
block|{
name|gdisp
operator|->
name|using_override_cursor
operator|=
name|FALSE
expr_stmt|;
name|change_win_cursor
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|gdisp
operator|->
name|current_cursor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* g_warning ("Tried to remove override-cursor from un-overridden gdisp."); */
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_remove_tool_cursor (GDisplay * gdisp)
name|gdisplay_remove_tool_cursor
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|unset_win_cursor
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_set_menu_sensitivity (GDisplay * gdisp)
name|gdisplay_set_menu_sensitivity
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gint
name|fs
init|=
name|FALSE
decl_stmt|;
name|gint
name|aux
init|=
name|FALSE
decl_stmt|;
name|gint
name|lm
init|=
name|FALSE
decl_stmt|;
name|gint
name|lp
init|=
name|FALSE
decl_stmt|;
name|gint
name|alpha
init|=
name|FALSE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|GimpImageBaseType
name|base_type
init|=
literal|0
decl_stmt|;
name|GimpImageType
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|lind
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|lnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gdisp
condition|)
block|{
name|fs
operator|=
operator|(
name|gimage_floating_sel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|aux
operator|=
operator|(
name|gimage_get_active_channel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|lm
operator|=
operator|(
name|layer
operator|->
name|mask
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|base_type
operator|=
name|gimage_base_type
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|(
name|gdisp
operator|->
name|gimage
operator|->
name|layers
operator|!=
name|NULL
operator|)
expr_stmt|;
name|alpha
operator|=
name|layer
operator|&&
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|type
operator|=
name|drawable_type
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|lind
operator|=
name|gimage_get_layer_index
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
argument_list|)
expr_stmt|;
name|lnum
operator|=
name|g_slist_length
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
block|}
block|}
DECL|macro|SET_SENSITIVE (menu,condition)
define|#
directive|define
name|SET_SENSITIVE
parameter_list|(
name|menu
parameter_list|,
name|condition
parameter_list|)
define|\
value|menus_set_sensitive_locale ("<Image>", (menu), (condition) != 0)
DECL|macro|SET_STATE (menu,condition)
define|#
directive|define
name|SET_STATE
parameter_list|(
name|menu
parameter_list|,
name|condition
parameter_list|)
define|\
value|menus_set_state_locale ("<Image>", (menu), (condition) != 0)
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/File/Save"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/File/Save as"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/File/Revert"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/File/Close"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
condition|)
block|{
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Cut"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Copy"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Paste"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Paste Into"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Paste As New"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Clear"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Fill"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Stroke"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Cut Named"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Copy Named"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Edit/Paste Named"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Select"
argument_list|)
argument_list|,
name|gdisp
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Select/Save To Channel"
argument_list|)
argument_list|,
operator|!
name|fs
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/View"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
condition|)
block|{
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Toggle Selection"
argument_list|)
argument_list|,
operator|!
name|gdisp
operator|->
name|select
operator|->
name|hidden
argument_list|)
expr_stmt|;
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Toggle Rulers"
argument_list|)
argument_list|,
name|GTK_WIDGET_VISIBLE
argument_list|(
name|gdisp
operator|->
name|origin
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Toggle Guides"
argument_list|)
argument_list|,
name|gdisp
operator|->
name|draw_guides
argument_list|)
expr_stmt|;
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Snap To Guides"
argument_list|)
argument_list|,
name|gdisp
operator|->
name|snap_to_guides
argument_list|)
expr_stmt|;
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Toggle Statusbar"
argument_list|)
argument_list|,
name|GTK_WIDGET_VISIBLE
argument_list|(
name|gdisp
operator|->
name|statusarea
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_STATE
argument_list|(
name|N_
argument_list|(
literal|"/View/Dot for dot"
argument_list|)
argument_list|,
name|gdisp
operator|->
name|dot_for_dot
argument_list|)
expr_stmt|;
block|}
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Channel Ops"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Alpha"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
condition|)
block|{
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/RGB"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|RGB
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Grayscale"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|GRAY
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Indexed"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Histogram"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Threshold"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Posterize"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Equalize"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Invert"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Color Balance"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|==
name|RGB
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Brightness-Contrast"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Hue-Saturation"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|==
name|RGB
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Curves"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Levels"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|!=
name|INDEXED
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Colors/Desaturate"
argument_list|)
argument_list|,
operator|(
name|base_type
operator|==
name|RGB
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Alpha/Add Alpha Channel"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
operator|!
name|lm
operator|&&
operator|!
name|alpha
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Image/Channel Ops/Offset"
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack"
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
condition|)
block|{
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Previous Layer"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|lind
operator|>
literal|0
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Next Layer"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|lind
operator|<
operator|(
name|lnum
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Raise Layer"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|alpha
operator|&&
name|lind
operator|>
literal|0
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Lower Layer"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|alpha
operator|&&
name|lind
operator|<
operator|(
name|lnum
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Layer to Top"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|alpha
operator|&&
name|lind
operator|>
literal|0
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Stack/Layer to Bottom"
argument_list|)
argument_list|,
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|alpha
operator|&&
name|lind
operator|<
operator|(
name|lnum
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Anchor Layer"
argument_list|)
argument_list|,
name|gdisp
operator|&&
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Merge Visible Layers"
argument_list|)
argument_list|,
name|gdisp
operator|&&
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Flatten Image"
argument_list|)
argument_list|,
name|gdisp
operator|&&
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Alpha To Selection"
argument_list|)
argument_list|,
name|gdisp
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
name|alpha
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Mask To Selection"
argument_list|)
argument_list|,
name|gdisp
operator|&&
operator|!
name|aux
operator|&&
name|lm
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Layers/Add Alpha Channel"
argument_list|)
argument_list|,
name|gdisp
operator|&&
operator|!
name|fs
operator|&&
operator|!
name|aux
operator|&&
name|lp
operator|&&
operator|!
name|lm
operator|&&
operator|!
name|alpha
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Filters"
argument_list|)
argument_list|,
name|gdisp
operator|&&
name|lp
argument_list|)
expr_stmt|;
name|SET_SENSITIVE
argument_list|(
name|N_
argument_list|(
literal|"/Script-Fu"
argument_list|)
argument_list|,
name|gdisp
operator|&&
name|lp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET_STATE
undef|#
directive|undef
name|SET_SENSITIVE
name|plug_in_set_menu_sensitivity
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_expose_area (GDisplay * gdisp,int x,int y,int w,int h)
name|gdisplay_expose_area
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|gdisplay_add_display_area
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_expose_guide (GDisplay * gdisp,Guide * guide)
name|gdisplay_expose_guide
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|guide
operator|->
name|position
operator|<
literal|0
condition|)
return|return;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|guide
operator|->
name|position
argument_list|,
name|guide
operator|->
name|position
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|guide
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_HORIZONTAL
case|:
name|gdisplay_expose_area
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORIENTATION_VERTICAL
case|:
name|gdisplay_expose_area
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_expose_full (GDisplay * gdisp)
name|gdisplay_expose_full
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|gdisplay_add_display_area
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************/
end_comment

begin_comment
comment|/*  Functions independent of a specific gdisplay  */
end_comment

begin_comment
comment|/**************************************************/
end_comment

begin_function
name|GDisplay
modifier|*
DECL|function|gdisplay_active ()
name|gdisplay_active
parameter_list|()
block|{
name|GdkEvent
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|gtk_get_current_event
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|gdk_event_free
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_context_get_display
argument_list|(
name|gimp_context_get_user
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|GDisplay
modifier|*
DECL|function|gdisplay_get_ID (int ID)
name|gdisplay_get_ID
parameter_list|(
name|int
name|ID
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  Traverse the list of displays, returning the one that matches the ID  */
comment|/*  If no display in the list is a match, return NULL.                    */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|ID
operator|==
name|ID
condition|)
return|return
name|gdisp
return|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_update_title (GDisplay * gdisp)
name|gdisplay_update_title
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|char
name|title
index|[
name|MAX_TITLE_BUF
index|]
decl_stmt|;
name|guint
name|context_id
decl_stmt|;
comment|/* format the title */
name|gdisplay_format_title
argument_list|(
name|gdisp
argument_list|,
name|title
argument_list|,
name|MAX_TITLE_BUF
argument_list|)
expr_stmt|;
name|gdk_window_set_title
argument_list|(
name|gdisp
operator|->
name|shell
operator|->
name|window
argument_list|,
name|title
argument_list|)
expr_stmt|;
comment|/* update the statusbar */
name|context_id
operator|=
name|gtk_statusbar_get_context_id
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
literal|"title"
argument_list|)
expr_stmt|;
name|gtk_statusbar_pop
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|context_id
argument_list|)
expr_stmt|;
name|gtk_statusbar_push
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|context_id
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_update_title (GimpImage * gimage)
name|gdisplays_update_title
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
name|gdisplay_update_title
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_resize_cursor_label (GimpImage * gimage)
name|gdisplays_resize_cursor_label
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
name|gdisplay_resize_cursor_label
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_update_area (GimpImage * gimage,int x,int y,int w,int h)
name|gdisplays_update_area
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/* int x1, y1, x2, y2; */
comment|/*  int count = 0; */
comment|/*  traverse the linked list of displays  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
block|{
comment|/*  We only need to update the first instance that 	      we find of this gimage ID.  Otherwise, we would 	      be reconverting the same region unnecessarily.   */
comment|/* Um.. I don't think so. If you only do this to the first 	     instance, you don't update other gdisplays pointing to this 	     gimage.  I'm going to comment this out to show how it was in 	     case we need to change it back.  msw 4/15/1998 	  */
comment|/* 	  if (! count) 	    gdisplay_add_update_area (gdisp, x, y, w, h); 	  else 	    { 	      gdisplay_transform_coords (gdisp, x, y,&x1,&y1, 0); 	      gdisplay_transform_coords (gdisp, x + w, y + h,&x2,&y2, 0); 	      gdisplay_add_display_area (gdisp, x1, y1, (x2 - x1), (y2 - y1)); 	    } 	  */
name|gdisplay_add_update_area
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Seems like this isn't needed, it's done in 	     gdisplay_flush. -la 	  gdisplay_transform_coords (gdisp, x, y,&x1,&y1, 0); 	  gdisplay_transform_coords (gdisp, x + w, y + h,&x2,&y2, 0); 	  gdisplay_add_display_area (gdisp, x1, y1, (x2 - x1), (y2 - y1)); 	  */
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_expose_guides (GimpImage * gimage)
name|gdisplays_expose_guides
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GList
modifier|*
name|tmp_list
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
name|list
operator|=
name|display_list
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
block|{
name|tmp_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|guides
expr_stmt|;
while|while
condition|(
name|tmp_list
condition|)
block|{
name|gdisplay_expose_guide
argument_list|(
name|gdisp
argument_list|,
name|tmp_list
operator|->
name|data
argument_list|)
expr_stmt|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
expr_stmt|;
block|}
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_expose_guide (GimpImage * gimage,Guide * guide)
name|gdisplays_expose_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
name|list
operator|=
name|display_list
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
name|gdisplay_expose_guide
argument_list|(
name|gdisp
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_update_full (GimpImage * gimage)
name|gdisplays_update_full
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
block|{
if|if
condition|(
operator|!
name|count
condition|)
name|gdisplay_add_update_area
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
else|else
name|gdisplay_add_display_area
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|disp_width
argument_list|,
name|gdisp
operator|->
name|disp_height
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_shrink_wrap (GimpImage * gimage)
name|gdisplays_shrink_wrap
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
name|shrink_wrap_display
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_expose_full ()
name|gdisplays_expose_full
parameter_list|()
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gdisplay_expose_full
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_selection_visibility (GimpImage * gimage,SelectionControl function)
name|gdisplays_selection_visibility
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|SelectionControl
name|function
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/*  traverse the linked list of displays, handling each one  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
operator|&&
name|gdisp
operator|->
name|select
condition|)
block|{
switch|switch
condition|(
name|function
condition|)
block|{
case|case
name|SelectionOff
case|:
name|selection_invis
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
break|break;
case|case
name|SelectionLayerOff
case|:
name|selection_layer_invis
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
break|break;
case|case
name|SelectionOn
case|:
name|selection_start
argument_list|(
name|gdisp
operator|->
name|select
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SelectionPause
case|:
name|selection_pause
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
break|break;
case|case
name|SelectionResume
case|:
name|selection_resume
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gdisplays_dirty ()
name|gdisplays_dirty
parameter_list|()
block|{
name|int
name|dirty
init|=
literal|0
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  traverse the linked list of displays  */
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
operator|)
operator|->
name|gimage
operator|->
name|dirty
operator|!=
literal|0
condition|)
name|dirty
operator|=
literal|1
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_delete ()
name|gdisplays_delete
parameter_list|()
block|{
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
comment|/*  traverse the linked list of displays  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|gdisp
operator|->
name|shell
argument_list|)
expr_stmt|;
block|}
comment|/*  free up linked list data  */
name|g_slist_free
argument_list|(
name|display_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GDisplay
modifier|*
DECL|function|gdisplays_check_valid (GDisplay * gtest,GimpImage * gimage)
name|gdisplays_check_valid
parameter_list|(
name|GDisplay
modifier|*
name|gtest
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/* Give a gdisp check that it is still valid and points to the require    * GimpImage. If not return the first gDisplay that does point to the     * gimage. If none found return NULL;    */
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp_found
init|=
name|NULL
decl_stmt|;
comment|/*  traverse the linked list of displays  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gdisp
operator|==
name|gtest
condition|)
return|return
operator|(
name|gtest
operator|)
return|;
if|if
condition|(
operator|!
name|gdisp_found
operator|&&
name|gdisp
operator|->
name|gimage
operator|==
name|gimage
condition|)
name|gdisp_found
operator|=
name|gdisp
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gdisp_found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gdisplays_flush_whenever (gboolean now)
name|gdisplays_flush_whenever
parameter_list|(
name|gboolean
name|now
parameter_list|)
block|{
specifier|static
name|int
name|flushing
init|=
name|FALSE
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|display_list
decl_stmt|;
comment|/*  no flushing necessary without an interface  */
if|if
condition|(
name|no_interface
condition|)
return|return;
comment|/*  this prevents multiple recursive calls to this procedure  */
if|if
condition|(
name|flushing
operator|==
name|TRUE
condition|)
block|{
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"gdisplays_flush() called recursively."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|flushing
operator|=
name|TRUE
expr_stmt|;
comment|/*  traverse the linked list of displays  */
while|while
condition|(
name|list
condition|)
block|{
name|gdisplay_flush_whenever
argument_list|(
operator|(
name|GDisplay
operator|*
operator|)
name|list
operator|->
name|data
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  for convenience, we call the L&C flush here  */
name|lc_dialog_flush
argument_list|()
expr_stmt|;
name|flushing
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_flush (void)
name|gdisplays_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|gdisplays_flush_whenever
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplays_flush_now (void)
name|gdisplays_flush_now
parameter_list|(
name|void
parameter_list|)
block|{
name|gdisplays_flush_whenever
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|gdisplay_hash (GDisplay * display)
name|gdisplay_hash
parameter_list|(
name|GDisplay
modifier|*
name|display
parameter_list|)
block|{
return|return
operator|(
name|gulong
operator|)
name|display
return|;
block|}
end_function

begin_function
name|void
DECL|function|gdisplay_reconnect (GDisplay * gdisp,GimpImage * gimage)
name|gdisplay_reconnect
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|int
name|instance
decl_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|idle_render
operator|.
name|active
condition|)
block|{
name|gtk_idle_remove
argument_list|(
name|gdisp
operator|->
name|idle_render
operator|.
name|idleid
argument_list|)
expr_stmt|;
name|gdisp
operator|->
name|idle_render
operator|.
name|active
operator|=
name|FALSE
expr_stmt|;
block|}
name|gtk_signal_disconnect_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|gimage_delete
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|instance
operator|=
name|gimage
operator|->
name|instance_count
expr_stmt|;
name|gimage
operator|->
name|instance_count
operator|++
expr_stmt|;
name|gimage
operator|->
name|ref_count
operator|++
expr_stmt|;
name|gdisp
operator|->
name|gimage
operator|=
name|gimage
expr_stmt|;
name|gdisp
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
comment|/* reconnect our clean / dirty signals */
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|"dirty"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gdisplay_cleandirty_handler
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|"clean"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gdisplay_cleandirty_handler
argument_list|)
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|gdisplays_update_title
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gdisplay_expose_full
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
name|gdisplay_flush
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called whenever the underlying gimage is dirtied or cleaned */
end_comment

begin_function
specifier|static
name|void
DECL|function|gdisplay_cleandirty_handler (GimpImage * gimage,void * data)
name|gdisplay_cleandirty_handler
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
init|=
name|data
decl_stmt|;
name|gdisplay_update_title
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

