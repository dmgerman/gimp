begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  * Copyright (C) 1997-2004 Adam D. Moss<adam@gimp.org>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * 2004-12-12 - Use a slower but much nicer technique for finding the  *  two best colours to dither between when using fixed/positional  *  dither methods.  Makes positional dither much less lame.  [adam@gimp.org]  *  * 2002-02-10 - Quantizer version 3.0 (the rest of the commit started  *  a year ago -- whoops).  Divide colours within CIE L*a*b* space using  *  CPercep module (cpercep.[ch]), colour-match and dither likewise,  *  change the underlying box selection criteria and division point  *  logic, bump luminance precision upwards, etc.etc.  Generally  *  chooses a much richer colour set, especially for low numbers of  *  colours.  n.b.: Less luminance-sloppy in straight remapping which is  *  good for colour but a bit worse for high-frequency detail (that's  *  partly what fs-dithering is for -- use it).  [adam@gimp.org]  *  * 2001-03-25 - Define accessor function/macro for histogram reads and  *  writes.  This slows us down a little because we avoid some of the  *  dirty tricks we used when we knew that the histogram was a straight  *  3d array, so I've recovered some of the speed loss by implementing  *  a 5d accessor function with good locality of reference.  This change  *  is the first step towards quantizing in a more interesting colourspace  *  than frumpy old RGB.  [Adam]  *  * 2000/01/30 - Use palette_selector instead of option_menu for custom  *  palette. Use libgimp callback functions.  [Sven]  *  * 99/09/01 - Created a low-bleed FS-dither option.  [Adam]  *  * 99/08/29 - Deterministic colour dithering to arbitrary palettes.  *  Ideal for animations that are going to be delta-optimized or simply  *  don't want to look 'busy' in static areas.  Also a bunch of bugfixes  *  and tweaks.  [Adam]  *  * 99/08/28 - Deterministic alpha dithering over layers, reduced bleeding  *  of transparent values into opaque values, added optional stage to  *  remove duplicate or unused colour entries from final colourmap. [Adam]  *  * 99/02/24 - Many revisions to the box-cut quantizer used in RGB->INDEXED  *  conversion.  Box to be cut is chosen on the basis of posessing an axis  *  with the largest sum of weighted perceptible error, rather than based on  *  volume or population.  The box is split along this axis rather than its  *  longest axis, at the point of error mean rather than simply at its centre.  *  Error-limiting in the F-S dither has been disabled - it may become optional  *  again later.  If you're convinced that you have an image where the old  *  dither looks better, let me know.  [Adam]  *  * 99/01/10 - Hourglass... [Adam]  *  * 98/07/25 - Convert-to-indexed now remembers the last invocation's  *  settings.  Also, GRAY->INDEXED is more flexible.  [Adam]  *  * 98/07/05 - Sucked the warning about quantizing to too many colours into  *  a text widget embedded in the dialog, improved intelligence of dialog  *  to default 'custom palette' selection to 'Web' if available, and  *  in this case not bother to present the native WWW-palette radio  *  button.  [Adam]  *  * 98/04/13 - avoid a division by zero when converting an empty gray-scale  *  image (who would like to do such a thing anyway??)  [Sven ]  *  * 98/03/23 - fixed a longstanding fencepost - hopefully the *right*  *  way, *again*.  [Adam]  *  * 97/11/14 - added a proper pdb interface and support for dithering  *  to custom palettes (based on a patch by Eric Hernes) [Yosh]  *  * 97/11/04 - fixed the accidental use of the colour-counting case  *  when palette_type is WEB or MONO. [Adam]  *  * 97/10/25 - colour-counting implemented (could use some hashing, but  *  performance actually seems okay) - now RGB->INDEXED conversion isn't  *  destructive if it doesn't have to be. [Adam]  *  * 97/10/14 - fixed divide-by-zero when converting a completely transparent  *  RGB image to indexed. [Adam]  *  * 97/07/01 - started todo/revision log.  Put code back in to  *  eliminate full-alpha pixels from RGB histogram.  *  [Adam D. Moss - adam@gimp.org]  */
end_comment

begin_comment
comment|/* TODO for Convert:    *    * . Tweak, tweak, tweak.  Old RGB code was tuned muchly.    *    * . Re-enable Heckbert locality for matching, benchmark it    *    * . Try faster fixed-point sRGB<->L*a*b* pixel conversion (see cpercep.c)    *    * . Use palette of another open INDEXED image?    *    * . Do error-splitting trick for GREY->INDEXED (hardly worth it)    */
end_comment

begin_comment
comment|/* CODE READABILITY BUGS:    *    * . Most uses of variants of the R,G,B variable naming convention    *   are referring to L*a*b* co-ordinates, not RGB co-ordinates!    *    * . Each said variable is usually one of the following, but it is    *   rarely clear which one:    *     - (assumed sRGB) raw non-linear 8-bit RGB co-ordinates    *     - 'full'-precision (unshifted) 8-bit L*a*b* co-ordinates    *     - box-space (reduced-precision shifted L*a*b*) co-ordinates    */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-undo-push.h"
end_include

begin_include
include|#
directive|include
file|"gimplist.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"gimppalette.h"
end_include

begin_include
include|#
directive|include
file|"gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"cpercep.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-convert-fsdither.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-convert-data.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage-convert.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DM_RANGE
end_ifndef

begin_define
DECL|macro|DM_RANGE
define|#
directive|define
name|DM_RANGE
value|63
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* basic memory/quality tradeoff */
end_comment

begin_define
DECL|macro|PRECISION_R
define|#
directive|define
name|PRECISION_R
value|8
end_define

begin_define
DECL|macro|PRECISION_G
define|#
directive|define
name|PRECISION_G
value|6
end_define

begin_define
DECL|macro|PRECISION_B
define|#
directive|define
name|PRECISION_B
value|6
end_define

begin_define
DECL|macro|HIST_R_ELEMS
define|#
directive|define
name|HIST_R_ELEMS
value|(1<<PRECISION_R)
end_define

begin_define
DECL|macro|HIST_G_ELEMS
define|#
directive|define
name|HIST_G_ELEMS
value|(1<<PRECISION_G)
end_define

begin_define
DECL|macro|HIST_B_ELEMS
define|#
directive|define
name|HIST_B_ELEMS
value|(1<<PRECISION_B)
end_define

begin_define
DECL|macro|MR
define|#
directive|define
name|MR
value|(HIST_G_ELEMS*HIST_B_ELEMS)
end_define

begin_define
DECL|macro|MG
define|#
directive|define
name|MG
value|HIST_B_ELEMS
end_define

begin_define
DECL|macro|BITS_IN_SAMPLE
define|#
directive|define
name|BITS_IN_SAMPLE
value|8
end_define

begin_define
DECL|macro|R_SHIFT
define|#
directive|define
name|R_SHIFT
value|(BITS_IN_SAMPLE-PRECISION_R)
end_define

begin_define
DECL|macro|G_SHIFT
define|#
directive|define
name|G_SHIFT
value|(BITS_IN_SAMPLE-PRECISION_G)
end_define

begin_define
DECL|macro|B_SHIFT
define|#
directive|define
name|B_SHIFT
value|(BITS_IN_SAMPLE-PRECISION_B)
end_define

begin_comment
comment|/* we've stretched our non-cubic L*a*b* volume to touch the    faces of the logical cube we've allocated for it, so re-scale    again in inverse proportion to get back to linear proportions. */
end_comment

begin_define
DECL|macro|R_SCALE
define|#
directive|define
name|R_SCALE
value|13
end_define

begin_comment
DECL|macro|R_SCALE
comment|/*  scale R (L*) distances by this much  */
end_comment

begin_define
DECL|macro|G_SCALE
define|#
directive|define
name|G_SCALE
value|24
end_define

begin_comment
DECL|macro|G_SCALE
comment|/*  scale G (a*) distances by this much  */
end_comment

begin_define
DECL|macro|B_SCALE
define|#
directive|define
name|B_SCALE
value|26
end_define

begin_comment
DECL|macro|B_SCALE
comment|/*  and B (b*) by this much              */
end_comment

begin_typedef
DECL|typedef|Color
typedef|typedef
name|struct
name|_Color
name|Color
typedef|;
end_typedef

begin_typedef
DECL|typedef|QuantizeObj
typedef|typedef
name|struct
name|_QuantizeObj
name|QuantizeObj
typedef|;
end_typedef

begin_typedef
DECL|typedef|Pass1_Func
typedef|typedef
name|void
function_decl|(
modifier|*
name|Pass1_Func
function_decl|)
parameter_list|(
name|QuantizeObj
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|Pass2i_Func
typedef|typedef
name|void
function_decl|(
modifier|*
name|Pass2i_Func
function_decl|)
parameter_list|(
name|QuantizeObj
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|Pass2_Func
typedef|typedef
name|void
function_decl|(
modifier|*
name|Pass2_Func
function_decl|)
parameter_list|(
name|QuantizeObj
modifier|*
parameter_list|,
name|GimpLayer
modifier|*
parameter_list|,
name|TileManager
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|Cleanup_Func
typedef|typedef
name|void
function_decl|(
modifier|*
name|Cleanup_Func
function_decl|)
parameter_list|(
name|QuantizeObj
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|ColorFreq
typedef|typedef
name|unsigned
name|long
name|ColorFreq
typedef|;
end_typedef

begin_typedef
DECL|typedef|CFHistogram
typedef|typedef
name|ColorFreq
modifier|*
name|CFHistogram
typedef|;
end_typedef

begin_typedef
DECL|enum|__anon2b4c0d200103
DECL|enumerator|AXIS_UNDEF
DECL|enumerator|AXIS_RED
DECL|enumerator|AXIS_BLUE
DECL|enumerator|AXIS_GREEN
DECL|typedef|axisType
typedef|typedef
enum|enum
block|{
name|AXIS_UNDEF
block|,
name|AXIS_RED
block|,
name|AXIS_BLUE
block|,
name|AXIS_GREEN
block|}
name|axisType
typedef|;
end_typedef

begin_typedef
DECL|typedef|etype
typedef|typedef
name|double
name|etype
typedef|;
end_typedef

begin_comment
comment|/*   We provide two different histogram access interfaces.  HIST_LIN()   accesses the histogram in histogram-native space, taking absolute   histogram co-ordinates.  HIST_RGB() accesses the histogram in RGB   space.  This latter takes unsigned 8-bit co-ordinates, internally   converts those co-ordinates to histogram-native space and returns   the access pointer to the corresponding histogram cell.    Using these two interfaces we can import RGB data into a more   interesting space and efficiently work in the latter space until   it is time to output the quantized values in RGB again.  For   this final conversion we implement the function lin_to_rgb().    We effectively pull our three-dimensional space into five dimensions   such that the most-entropic bits lay in the lowest bits of the resulting   array index.  This gives significantly better locality of reference   and hence a small speedup despite the extra work involved in calculating   the index.    Why not six dimensions?  The expansion of dimensionality is good for random   access such as histogram population and the query pattern typical of   dithering but we have some code which iterates in a scanning manner, for   which the expansion is suboptimal.  The compromise is to leave the B   dimension unmolested in the lower-order bits of the index, since this is   the dimension most commonly iterated through in the inner loop of the   scans.    --adam    RhGhRlGlB */
end_comment

begin_define
DECL|macro|VOL_GBITS
define|#
directive|define
name|VOL_GBITS
value|(PRECISION_G)
end_define

begin_define
DECL|macro|VOL_BBITS
define|#
directive|define
name|VOL_BBITS
value|(PRECISION_B)
end_define

begin_define
DECL|macro|VOL_RBITS
define|#
directive|define
name|VOL_RBITS
value|(PRECISION_R)
end_define

begin_define
DECL|macro|VOL_GBITSh
define|#
directive|define
name|VOL_GBITSh
value|(VOL_GBITS - 3)
end_define

begin_define
DECL|macro|VOL_GBITSl
define|#
directive|define
name|VOL_GBITSl
value|(VOL_GBITS - VOL_GBITSh)
end_define

begin_define
DECL|macro|VOL_BBITSh
define|#
directive|define
name|VOL_BBITSh
value|(VOL_BBITS - 4)
end_define

begin_define
DECL|macro|VOL_BBITSl
define|#
directive|define
name|VOL_BBITSl
value|(VOL_BBITS - VOL_BBITSh)
end_define

begin_define
DECL|macro|VOL_RBITSh
define|#
directive|define
name|VOL_RBITSh
value|(VOL_RBITS - 3)
end_define

begin_define
DECL|macro|VOL_RBITSl
define|#
directive|define
name|VOL_RBITSl
value|(VOL_RBITS - VOL_RBITSh)
end_define

begin_define
DECL|macro|VOL_GMASKh
define|#
directive|define
name|VOL_GMASKh
value|(((1<<VOL_GBITSh)-1)<< VOL_GBITSl)
end_define

begin_define
DECL|macro|VOL_GMASKl
define|#
directive|define
name|VOL_GMASKl
value|((1<<VOL_GBITSl)-1)
end_define

begin_define
DECL|macro|VOL_BMASKh
define|#
directive|define
name|VOL_BMASKh
value|(((1<<VOL_BBITSh)-1)<< VOL_BBITSl)
end_define

begin_define
DECL|macro|VOL_BMASKl
define|#
directive|define
name|VOL_BMASKl
value|((1<<VOL_BBITSl)-1)
end_define

begin_define
DECL|macro|VOL_RMASKh
define|#
directive|define
name|VOL_RMASKh
value|(((1<<VOL_RBITSh)-1)<< VOL_RBITSl)
end_define

begin_define
DECL|macro|VOL_RMASKl
define|#
directive|define
name|VOL_RMASKl
value|((1<<VOL_RBITSl)-1)
end_define

begin_comment
comment|/* The 5d compromise thing. */
end_comment

begin_define
DECL|macro|REF_FUNC (r,g,b)
define|#
directive|define
name|REF_FUNC
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
define|\
value|( \  (((r)& VOL_RMASKh)<< (VOL_BBITS + VOL_GBITS)) | \  (((r)& VOL_RMASKl)<< (VOL_GBITSl + VOL_BBITS)) | \  (((g)& VOL_GMASKh)<< (VOL_RBITSl + VOL_BBITS)) | \  (((g)& VOL_GMASKl)<< (VOL_BBITS)) | \  (b) \ )
end_define

begin_comment
comment|/* The full-on 6d thing. */
end_comment

begin_comment
comment|/* #define REF_FUNC(r,g,b) \ ( \  (((r)& VOL_RMASKh)<< (VOL_BBITS + VOL_GBITS)) | \  (((r)& VOL_RMASKl)<< (VOL_GBITSl + VOL_BBITSl)) | \  (((g)& VOL_GMASKh)<< (VOL_RBITSl + VOL_BBITS)) | \  (((g)& VOL_GMASKl)<< (VOL_BBITSl)) | \  (((b)& VOL_BMASKh)<< (VOL_RBITSl + VOL_GBITSl)) | \  ((b)& VOL_BMASKl) \ ) */
end_comment

begin_comment
comment|/* The boring old 3d thing. */
end_comment

begin_comment
comment|/* #define REF_FUNC(r,g,b) (((r)<<(PRECISION_G+PRECISION_B)) | ((g)<<(PRECISION_B)) | (b)) */
end_comment

begin_comment
comment|/* You even get to choose whether you want the accessor function    implemented as a macro or an inline function.  Don't say I never    give you anything. */
end_comment

begin_comment
comment|/* #define HIST_LIN(hist_ptr,r,g,b) (&(hist_ptr)[REF_FUNC((r),(g),(b))]) */
end_comment

begin_function
specifier|static
specifier|inline
DECL|function|HIST_LIN (ColorFreq * hist_ptr,const int r,const int g,const int b)
name|ColorFreq
modifier|*
name|HIST_LIN
parameter_list|(
name|ColorFreq
modifier|*
name|hist_ptr
parameter_list|,
specifier|const
name|int
name|r
parameter_list|,
specifier|const
name|int
name|g
parameter_list|,
specifier|const
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
operator|&
operator|(
name|hist_ptr
operator|)
index|[
name|REF_FUNC
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|LOWA
define|#
directive|define
name|LOWA
value|(-86.181F)
end_define

begin_define
DECL|macro|LOWB
define|#
directive|define
name|LOWB
value|(-107.858F)
end_define

begin_define
DECL|macro|HIGHA
define|#
directive|define
name|HIGHA
value|(98.237F)
end_define

begin_define
DECL|macro|HIGHB
define|#
directive|define
name|HIGHB
value|(94.480F)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_define
DECL|macro|LRAT
define|#
directive|define
name|LRAT
value|(2.55F)
end_define

begin_define
DECL|macro|ARAT
define|#
directive|define
name|ARAT
value|(255.0F / (HIGHA - LOWA))
end_define

begin_define
DECL|macro|BRAT
define|#
directive|define
name|BRAT
value|(255.0F / (HIGHB - LOWB))
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|LRAT
define|#
directive|define
name|LRAT
value|(1.0F)
end_define

begin_define
DECL|macro|ARAT
define|#
directive|define
name|ARAT
value|(1.0F)
end_define

begin_define
DECL|macro|BRAT
define|#
directive|define
name|BRAT
value|(1.0F)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
DECL|function|rgb_to_unshifted_lin (const unsigned char r,const unsigned char g,const unsigned char b,int * hr,int * hg,int * hb)
name|void
name|rgb_to_unshifted_lin
parameter_list|(
specifier|const
name|unsigned
name|char
name|r
parameter_list|,
specifier|const
name|unsigned
name|char
name|g
parameter_list|,
specifier|const
name|unsigned
name|char
name|b
parameter_list|,
name|int
modifier|*
name|hr
parameter_list|,
name|int
modifier|*
name|hg
parameter_list|,
name|int
modifier|*
name|hb
parameter_list|)
block|{
name|double
name|sL
decl_stmt|,
name|sa
decl_stmt|,
name|sb
decl_stmt|;
name|int
name|or
decl_stmt|,
name|og
decl_stmt|,
name|ob
decl_stmt|;
name|cpercep_rgb_to_space
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|sL
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, " %d-%d-%d -> %0.3f,%0.3f,%0.3f ", r, g, b, sL, sa, sb);*/
name|or
operator|=
name|RINT
argument_list|(
name|sL
operator|*
name|LRAT
argument_list|)
expr_stmt|;
name|og
operator|=
name|RINT
argument_list|(
operator|(
name|sa
operator|-
name|LOWA
operator|)
operator|*
name|ARAT
argument_list|)
expr_stmt|;
name|ob
operator|=
name|RINT
argument_list|(
operator|(
name|sb
operator|-
name|LOWB
operator|)
operator|*
name|BRAT
argument_list|)
expr_stmt|;
comment|/*  fprintf(stderr, " %d-%d-%d ", or, og, ob); */
if|#
directive|if
literal|0
block|if (or< 0 || or> 255)     fprintf(stderr, " \007R%d ", or);   if (og< 0 || og> 255)     fprintf(stderr, " \007G%d ", og);   if (ob< 0 || ob> 255)     fprintf(stderr, " \007B%d ", ob);
endif|#
directive|endif
operator|*
name|hr
operator|=
name|CLAMP
argument_list|(
name|or
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
operator|*
name|hg
operator|=
name|CLAMP
argument_list|(
name|og
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
operator|*
name|hb
operator|=
name|CLAMP
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/*  fprintf(stderr, " %d:%d:%d ", *hr, *hg, *hb); */
block|}
end_function

begin_function
specifier|static
specifier|inline
DECL|function|rgb_to_lin (const unsigned char r,const unsigned char g,const unsigned char b,int * hr,int * hg,int * hb)
name|void
name|rgb_to_lin
parameter_list|(
specifier|const
name|unsigned
name|char
name|r
parameter_list|,
specifier|const
name|unsigned
name|char
name|g
parameter_list|,
specifier|const
name|unsigned
name|char
name|b
parameter_list|,
name|int
modifier|*
name|hr
parameter_list|,
name|int
modifier|*
name|hg
parameter_list|,
name|int
modifier|*
name|hb
parameter_list|)
block|{
name|int
name|or
decl_stmt|,
name|og
decl_stmt|,
name|ob
decl_stmt|;
comment|/*   double sL, sa, sb;   {     double low_l = 999.0, low_a = 999.9, low_b = 999.0;     double high_l = -999.0, high_a = -999.0, high_b = -999.0;      int r,g,b;      for (r=0; r<256; r++)       for (g=0; g<256; g++) 	for (b=0; b<256; b++) 	  { 	    cpercep_rgb_to_space(r,g,b,&sL,&sa,&sb);  	    if (sL> high_l) 	      high_l = sL; 	    if (sL< low_l) 	      low_l = sL; 	    if (sa> high_a) 	      high_a = sa; 	    if (sa< low_a) 	      low_a = sa; 	    if (sb> high_b) 	      high_b = sb; 	    if (sb< low_b) 	      low_b = sb; 	  }      fprintf(stderr, " [L: %0.3f -> %0.3f / a: %0.3f -> %0.3f / b: %0.3f -> %0.3f]\t", low_l, high_l, low_a, high_a, low_b, high_b);      exit(-1);   }   */
name|rgb_to_unshifted_lin
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|or
argument_list|,
operator|&
name|og
argument_list|,
operator|&
name|ob
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
define|#
directive|define
name|RSDF
parameter_list|(
name|r
parameter_list|)
value|((r)>= ((HIST_R_ELEMS-1)<< R_SHIFT) ? HIST_R_ELEMS-1 : \ 		 ((r) + ((1<<R_SHIFT)>>1) )>> R_SHIFT)
define|#
directive|define
name|GSDF
parameter_list|(
name|g
parameter_list|)
value|((g)>= ((HIST_G_ELEMS-1)<< G_SHIFT) ? HIST_G_ELEMS-1 : \ 		 ((g) + ((1<<G_SHIFT)>>1) )>> G_SHIFT)
define|#
directive|define
name|BSDF
parameter_list|(
name|b
parameter_list|)
value|((b)>= ((HIST_B_ELEMS-1)<< B_SHIFT) ? HIST_B_ELEMS-1 : \ 		 ((b) + ((1<<B_SHIFT)>>1) )>> B_SHIFT)
else|#
directive|else
DECL|macro|RSDF (r)
define|#
directive|define
name|RSDF
parameter_list|(
name|r
parameter_list|)
value|((r)>> R_SHIFT)
DECL|macro|GSDF (g)
define|#
directive|define
name|GSDF
parameter_list|(
name|g
parameter_list|)
value|((g)>> G_SHIFT)
DECL|macro|BSDF (b)
define|#
directive|define
name|BSDF
parameter_list|(
name|b
parameter_list|)
value|((b)>> B_SHIFT)
endif|#
directive|endif
name|or
operator|=
name|RSDF
argument_list|(
name|or
argument_list|)
expr_stmt|;
name|og
operator|=
name|GSDF
argument_list|(
name|og
argument_list|)
expr_stmt|;
name|ob
operator|=
name|BSDF
argument_list|(
name|ob
argument_list|)
expr_stmt|;
operator|*
name|hr
operator|=
name|or
expr_stmt|;
operator|*
name|hg
operator|=
name|og
expr_stmt|;
operator|*
name|hb
operator|=
name|ob
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
DECL|function|HIST_RGB (ColorFreq * hist_ptr,const int r,const int g,const int b)
name|ColorFreq
modifier|*
name|HIST_RGB
parameter_list|(
name|ColorFreq
modifier|*
name|hist_ptr
parameter_list|,
specifier|const
name|int
name|r
parameter_list|,
specifier|const
name|int
name|g
parameter_list|,
specifier|const
name|int
name|b
parameter_list|)
block|{
name|int
name|hr
decl_stmt|,
name|hg
decl_stmt|,
name|hb
decl_stmt|;
name|rgb_to_lin
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|hr
argument_list|,
operator|&
name|hg
argument_list|,
operator|&
name|hb
argument_list|)
expr_stmt|;
return|return
operator|(
name|HIST_LIN
argument_list|(
name|hist_ptr
argument_list|,
name|hr
argument_list|,
name|hg
argument_list|,
name|hb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
DECL|function|lin_to_rgb (const double hr,const double hg,const double hb,unsigned char * r,unsigned char * g,unsigned char * b)
name|void
name|lin_to_rgb
parameter_list|(
specifier|const
name|double
name|hr
parameter_list|,
specifier|const
name|double
name|hg
parameter_list|,
specifier|const
name|double
name|hb
parameter_list|,
name|unsigned
name|char
modifier|*
name|r
parameter_list|,
name|unsigned
name|char
modifier|*
name|g
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
name|double
name|sr
decl_stmt|,
name|sg
decl_stmt|,
name|sb
decl_stmt|;
name|double
name|ir
decl_stmt|,
name|ig
decl_stmt|,
name|ib
decl_stmt|;
comment|/*  fprintf(stderr, "%d.%d.%d ", hr,hg,hb); */
if|#
directive|if
literal|0
block|ir = (hr * ((double) (1<< R_SHIFT))) + (((double)(1<<R_SHIFT))*0.5);   ig = (hg * ((double) (1<< G_SHIFT))) + (((double)(1<<G_SHIFT))*0.5);   ib = (hb * ((double) (1<< B_SHIFT))) + (((double)(1<<B_SHIFT))*0.5);
else|#
directive|else
comment|/* w/ artificial widening of dynamic range */
name|ir
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|hr
argument_list|)
operator|)
operator|*
literal|255.0F
operator|/
call|(
name|double
call|)
argument_list|(
name|HIST_R_ELEMS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ig
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|hg
argument_list|)
operator|)
operator|*
literal|255.0F
operator|/
call|(
name|double
call|)
argument_list|(
name|HIST_G_ELEMS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ib
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|hb
argument_list|)
operator|)
operator|*
literal|255.0F
operator|/
call|(
name|double
call|)
argument_list|(
name|HIST_B_ELEMS
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ir
operator|=
name|ir
operator|/
name|LRAT
expr_stmt|;
name|ig
operator|=
operator|(
name|ig
operator|/
name|ARAT
operator|)
operator|+
name|LOWA
expr_stmt|;
name|ib
operator|=
operator|(
name|ib
operator|/
name|BRAT
operator|)
operator|+
name|LOWB
expr_stmt|;
comment|/*  fprintf(stderr, "%0.1f,%0.1f,%0.1f ", ir,ig,ib); */
name|cpercep_space_to_rgb
argument_list|(
name|ir
argument_list|,
name|ig
argument_list|,
name|ib
argument_list|,
operator|&
name|sr
argument_list|,
operator|&
name|sg
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|RINT
argument_list|(
name|CLAMP
argument_list|(
name|sr
argument_list|,
literal|0.0F
argument_list|,
literal|255.0F
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|g
operator|=
name|RINT
argument_list|(
name|CLAMP
argument_list|(
name|sg
argument_list|,
literal|0.0F
argument_list|,
literal|255.0F
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
name|RINT
argument_list|(
name|CLAMP
argument_list|(
name|sb
argument_list|,
literal|0.0F
argument_list|,
literal|255.0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  fprintf(stderr, "%d,%d,%d ", *r, *g, *b); */
block|}
end_function

begin_struct
DECL|struct|_Color
struct|struct
name|_Color
block|{
DECL|member|red
name|int
name|red
decl_stmt|;
DECL|member|green
name|int
name|green
decl_stmt|;
DECL|member|blue
name|int
name|blue
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_QuantizeObj
struct|struct
name|_QuantizeObj
block|{
DECL|member|first_pass
name|Pass1_Func
name|first_pass
decl_stmt|;
comment|/* first pass over image data creates colormap  */
DECL|member|second_pass_init
name|Pass2i_Func
name|second_pass_init
decl_stmt|;
comment|/* Initialize data which persists over invocations */
DECL|member|second_pass
name|Pass2_Func
name|second_pass
decl_stmt|;
comment|/* second pass maps from image data to colormap */
DECL|member|delete_func
name|Cleanup_Func
name|delete_func
decl_stmt|;
comment|/* function to clean up data associated with private */
DECL|member|desired_number_of_colors
name|int
name|desired_number_of_colors
decl_stmt|;
comment|/* Number of colors we will allow    */
DECL|member|actual_number_of_colors
name|int
name|actual_number_of_colors
decl_stmt|;
comment|/* Number of colors actually needed  */
DECL|member|cmap
name|Color
name|cmap
index|[
literal|256
index|]
decl_stmt|;
comment|/* colormap created by quantization  */
DECL|member|clin
name|Color
name|clin
index|[
literal|256
index|]
decl_stmt|;
comment|/* .. converted back to linear space */
DECL|member|index_used_count
name|gulong
name|index_used_count
index|[
literal|256
index|]
decl_stmt|;
comment|/* how many times an index was used */
DECL|member|histogram
name|CFHistogram
name|histogram
decl_stmt|;
comment|/* holds the histogram               */
DECL|member|want_alpha_dither
name|gboolean
name|want_alpha_dither
decl_stmt|;
DECL|member|error_freedom
name|int
name|error_freedom
decl_stmt|;
comment|/* 0=much bleed, 1=controlled bleed */
DECL|member|progress
name|GimpProgress
modifier|*
name|progress
decl_stmt|;
DECL|member|nth_layer
name|gint
name|nth_layer
decl_stmt|;
DECL|member|n_layers
name|gint
name|n_layers
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2b4c0d200208
block|{
comment|/*  The bounds of the box (inclusive); expressed as histogram indexes  */
DECL|member|Rmin
DECL|member|Rmax
name|int
name|Rmin
decl_stmt|,
name|Rmax
decl_stmt|;
DECL|member|Rhalferror
name|int
name|Rhalferror
decl_stmt|;
DECL|member|Gmin
DECL|member|Gmax
name|int
name|Gmin
decl_stmt|,
name|Gmax
decl_stmt|;
DECL|member|Ghalferror
name|int
name|Ghalferror
decl_stmt|;
DECL|member|Bmin
DECL|member|Bmax
name|int
name|Bmin
decl_stmt|,
name|Bmax
decl_stmt|;
DECL|member|Bhalferror
name|int
name|Bhalferror
decl_stmt|;
comment|/*  The volume (actually 2-norm) of the box  */
DECL|member|volume
name|int
name|volume
decl_stmt|;
comment|/*  The number of nonzero histogram cells within this box  */
DECL|member|colorcount
name|long
name|colorcount
decl_stmt|;
comment|/* The sum of the weighted error within this box */
DECL|member|error
name|guint64
name|error
decl_stmt|;
comment|/* The sum of the unweighted error within this box */
DECL|member|rerror
name|guint64
name|rerror
decl_stmt|;
DECL|member|gerror
name|guint64
name|gerror
decl_stmt|;
DECL|member|berror
name|guint64
name|berror
decl_stmt|;
DECL|typedef|box
DECL|typedef|boxptr
block|}
name|box
operator|,
typedef|*
name|boxptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2b4c0d200308
block|{
DECL|member|ncolors
name|long
name|ncolors
decl_stmt|;
DECL|member|dither
name|long
name|dither
decl_stmt|;
DECL|typedef|Options
block|}
name|Options
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|zero_histogram_gray
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_histogram_rgb
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_histogram_gray
parameter_list|(
name|CFHistogram
name|hostogram
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_histogram_rgb
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|col_limit
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|gint
name|nth_layer
parameter_list|,
name|gint
name|n_layers
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|QuantizeObj
modifier|*
name|initialize_median_cut
parameter_list|(
name|GimpImageBaseType
name|old_type
parameter_list|,
name|gint
name|num_cols
parameter_list|,
name|GimpConvertDitherType
name|dither_type
parameter_list|,
name|GimpConvertPaletteType
name|palette_type
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_color_lin8
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|,
specifier|const
name|int
name|icolor
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|found_cols
specifier|static
name|guchar
name|found_cols
index|[
name|MAXNUMCOLORS
index|]
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_found_cols
specifier|static
name|gint
name|num_found_cols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|needs_quantize
specifier|static
name|gboolean
name|needs_quantize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|theCustomPalette
specifier|static
name|GimpPalette
modifier|*
name|theCustomPalette
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2b4c0d200408
block|{
DECL|member|used_count
name|signed
name|long
name|used_count
decl_stmt|;
DECL|member|initial_index
name|unsigned
name|char
name|initial_index
decl_stmt|;
DECL|typedef|palentryStruct
block|}
name|palentryStruct
typedef|;
end_typedef

begin_function
specifier|static
name|int
DECL|function|mapping_compare (const void * a,const void * b)
name|mapping_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|palentryStruct
modifier|*
name|m1
init|=
operator|(
name|palentryStruct
operator|*
operator|)
name|a
decl_stmt|;
name|palentryStruct
modifier|*
name|m2
init|=
operator|(
name|palentryStruct
operator|*
operator|)
name|b
decl_stmt|;
return|return
operator|(
name|m2
operator|->
name|used_count
operator|-
name|m1
operator|->
name|used_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FWIW, the make_remap_table() and mapping_compare() function source    and palentryStruct may be re-used under the XFree86-style license.<adam@gimp.org> */
end_comment

begin_function
specifier|static
name|void
DECL|function|make_remap_table (const unsigned char old_palette[],unsigned char new_palette[],const unsigned long index_used_count[],unsigned char remap_table[],int * num_entries)
name|make_remap_table
parameter_list|(
specifier|const
name|unsigned
name|char
name|old_palette
index|[]
parameter_list|,
name|unsigned
name|char
name|new_palette
index|[]
parameter_list|,
specifier|const
name|unsigned
name|long
name|index_used_count
index|[]
parameter_list|,
name|unsigned
name|char
name|remap_table
index|[]
parameter_list|,
name|int
modifier|*
name|num_entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|char
name|temppal
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|unsigned
name|long
name|tempuse
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|long
name|transmap
index|[
literal|256
index|]
decl_stmt|;
name|palentryStruct
modifier|*
name|palentries
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|temppal
argument_list|,
literal|0
argument_list|,
literal|256
operator|*
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tempuse
argument_list|,
literal|0
argument_list|,
literal|256
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|transmap
argument_list|,
literal|255
argument_list|,
literal|256
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* First pass - only collect entries which are marked as      being used at all in index_used_count. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|index_used_count
index|[
name|i
index|]
condition|)
block|{
name|temppal
index|[
name|used
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|temppal
index|[
name|used
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|temppal
index|[
name|used
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
name|tempuse
index|[
name|used
index|]
operator|=
name|index_used_count
index|[
name|i
index|]
expr_stmt|;
name|transmap
index|[
name|i
index|]
operator|=
name|used
expr_stmt|;
name|used
operator|++
expr_stmt|;
block|}
block|}
comment|/* Second pass - remove duplicates. (O(n^3), could do better!) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temppal
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|==
name|temppal
index|[
name|j
operator|*
literal|3
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|temppal
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|==
name|temppal
index|[
name|j
operator|*
literal|3
operator|+
literal|0
index|]
operator|)
operator|&&
operator|(
name|temppal
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|==
name|temppal
index|[
name|j
operator|*
literal|3
operator|+
literal|2
index|]
operator|)
operator|&&
name|tempuse
index|[
name|j
index|]
operator|&&
name|tempuse
index|[
name|i
index|]
condition|)
block|{
comment|/* Move the 'used' tally from one to the other. */
name|tempuse
index|[
name|i
index|]
operator|+=
name|tempuse
index|[
name|j
index|]
expr_stmt|;
comment|/* zero one of them, deactivating its entry. */
name|tempuse
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* change all mappings from this dead index 		 to the live one. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|*
name|num_entries
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|index_used_count
index|[
name|k
index|]
operator|&&
operator|(
name|transmap
index|[
name|k
index|]
operator|==
name|j
operator|)
condition|)
name|transmap
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Third pass - rank all used indicies to the beginning of the      palette. */
name|palentries
operator|=
name|g_malloc
argument_list|(
name|used
operator|*
sizeof|sizeof
argument_list|(
name|palentryStruct
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used
condition|;
name|i
operator|++
control|)
block|{
name|palentries
index|[
name|i
index|]
operator|.
name|initial_index
operator|=
name|i
expr_stmt|;
name|palentries
index|[
name|i
index|]
operator|.
name|used_count
operator|=
name|tempuse
index|[
name|i
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|palentries
argument_list|,
name|used
argument_list|,
sizeof|sizeof
argument_list|(
name|palentryStruct
argument_list|)
argument_list|,
operator|&
name|mapping_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|index_used_count
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|used
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|transmap
index|[
name|i
index|]
operator|==
name|palentries
index|[
name|j
index|]
operator|.
name|initial_index
operator|)
operator|&&
operator|(
name|palentries
index|[
name|j
index|]
operator|.
name|used_count
operator|)
condition|)
block|{
name|remap_table
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|index_used_count
index|[
name|i
index|]
condition|)
block|{
name|new_palette
index|[
name|remap_table
index|[
name|i
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|new_palette
index|[
name|remap_table
index|[
name|i
index|]
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|new_palette
index|[
name|remap_table
index|[
name|i
index|]
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|old_palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
operator|*
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|used
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|palentries
index|[
name|j
index|]
operator|.
name|used_count
condition|)
block|{
operator|(
operator|*
name|num_entries
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|palentries
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|remap_indexed_layer (GimpLayer * layer,unsigned char * remap_table,int num_entries)
name|remap_indexed_layer
parameter_list|(
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|unsigned
name|char
modifier|*
name|remap_table
parameter_list|,
name|int
name|num_entries
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gint
name|pixels
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
name|pixels
operator|=
name|srcPR
operator|.
name|h
operator|*
name|srcPR
operator|.
name|w
expr_stmt|;
while|while
condition|(
name|pixels
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|has_alpha
operator|)
operator|||
operator|(
name|has_alpha
operator|&&
name|src
index|[
name|ALPHA_I_PIX
index|]
operator|)
condition|)
block|{
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|remap_table
index|[
name|src
index|[
name|INDEXED_PIX
index|]
index|]
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
DECL|function|color_quicksort (const void * c1,const void * c2)
name|color_quicksort
parameter_list|(
specifier|const
name|void
modifier|*
name|c1
parameter_list|,
specifier|const
name|void
modifier|*
name|c2
parameter_list|)
block|{
name|Color
modifier|*
name|color1
init|=
operator|(
name|Color
operator|*
operator|)
name|c1
decl_stmt|;
name|Color
modifier|*
name|color2
init|=
operator|(
name|Color
operator|*
operator|)
name|c2
decl_stmt|;
name|double
name|v1
init|=
name|GIMP_RGB_INTENSITY
argument_list|(
name|color1
operator|->
name|red
argument_list|,
name|color1
operator|->
name|green
argument_list|,
name|color1
operator|->
name|blue
argument_list|)
decl_stmt|;
name|double
name|v2
init|=
name|GIMP_RGB_INTENSITY
argument_list|(
name|color2
operator|->
name|red
argument_list|,
name|color2
operator|->
name|green
argument_list|,
name|color2
operator|->
name|blue
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|v1
operator|>
name|v2
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_convert (GimpImage * gimage,GimpImageBaseType new_type,gint num_cols,GimpConvertDitherType dither,gboolean alpha_dither,gboolean remove_dups,GimpConvertPaletteType palette_type,GimpPalette * custom_palette,GimpProgress * progress)
name|gimp_image_convert
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpImageBaseType
name|new_type
parameter_list|,
comment|/* The following three params used only for 		     * new_type == GIMP_INDEXED 		     */
name|gint
name|num_cols
parameter_list|,
name|GimpConvertDitherType
name|dither
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|,
name|gboolean
name|remove_dups
parameter_list|,
name|GimpConvertPaletteType
name|palette_type
parameter_list|,
name|GimpPalette
modifier|*
name|custom_palette
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|QuantizeObj
modifier|*
name|quantobj
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpImageBaseType
name|old_type
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GimpImageType
name|new_layer_type
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|undo_desc
init|=
name|NULL
decl_stmt|;
name|gint
name|nth_layer
decl_stmt|,
name|n_layers
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|new_type
operator|!=
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|progress
operator|==
name|NULL
operator|||
name|GIMP_IS_PROGRESS
argument_list|(
name|progress
argument_list|)
argument_list|)
expr_stmt|;
name|theCustomPalette
operator|=
name|custom_palette
expr_stmt|;
name|gimp_set_busy
argument_list|(
name|gimage
operator|->
name|gimp
argument_list|)
expr_stmt|;
name|n_layers
operator|=
name|g_list_length
argument_list|(
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|undo_desc
operator|=
name|_
argument_list|(
literal|"Convert Image to RGB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|undo_desc
operator|=
name|_
argument_list|(
literal|"Convert Image to Grayscale"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|undo_desc
operator|=
name|_
argument_list|(
literal|"Convert Image to Indexed"
argument_list|)
expr_stmt|;
break|break;
block|}
name|g_object_freeze_notify
argument_list|(
name|G_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_start
argument_list|(
name|gimage
argument_list|,
name|GIMP_UNDO_GROUP_IMAGE_CONVERT
argument_list|,
name|undo_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
name|floating_sel_relax
argument_list|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image type to the stack  */
name|gimp_image_undo_push_image_type
argument_list|(
name|gimage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Set the new base type  */
name|old_type
operator|=
name|gimage
operator|->
name|base_type
expr_stmt|;
name|g_object_set
argument_list|(
name|gimage
argument_list|,
literal|"base-type"
argument_list|,
name|new_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize the colour conversion routines */
name|cpercep_init_conversions
argument_list|()
expr_stmt|;
comment|/*  Convert to indexed?  Build histogram if necessary.  */
if|if
condition|(
name|new_type
operator|==
name|GIMP_INDEXED
condition|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* fprintf(stderr, " TO INDEXED(%d) ", num_cols); */
comment|/* don't dither if the input is grayscale and we are simply        * mapping every color        */
if|if
condition|(
name|old_type
operator|==
name|GIMP_GRAY
operator|&&
name|num_cols
operator|==
literal|256
operator|&&
name|palette_type
operator|==
name|GIMP_MAKE_PALETTE
condition|)
block|{
name|dither
operator|=
name|GIMP_NO_DITHER
expr_stmt|;
block|}
name|quantobj
operator|=
name|initialize_median_cut
argument_list|(
name|old_type
argument_list|,
name|num_cols
argument_list|,
name|dither
argument_list|,
name|palette_type
argument_list|,
name|alpha_dither
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|palette_type
operator|==
name|GIMP_MAKE_PALETTE
condition|)
block|{
if|if
condition|(
name|old_type
operator|==
name|GIMP_GRAY
condition|)
name|zero_histogram_gray
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
else|else
name|zero_histogram_rgb
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
comment|/* To begin, assume that there are fewer colours in 	   *  the image than the user actually asked for.  In that 	   *  case, we don't need to quantize or colour-dither. 	   */
name|needs_quantize
operator|=
name|FALSE
expr_stmt|;
name|num_found_cols
operator|=
literal|0
expr_stmt|;
comment|/*  Build the histogram  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
operator|,
name|nth_layer
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
operator|,
name|nth_layer
operator|++
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|old_type
operator|==
name|GIMP_GRAY
condition|)
name|generate_histogram_gray
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|,
name|layer
argument_list|,
name|alpha_dither
argument_list|)
expr_stmt|;
else|else
name|generate_histogram_rgb
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|,
name|layer
argument_list|,
name|num_cols
argument_list|,
name|alpha_dither
argument_list|,
name|progress
argument_list|,
name|nth_layer
argument_list|,
name|n_layers
argument_list|)
expr_stmt|;
comment|/* 	       * Note: generate_histogram_rgb may set needs_quantize if 	       *  the image contains more colours than the limit specified 	       *  by the user. 	       */
block|}
block|}
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_text
argument_list|(
name|progress
argument_list|,
name|_
argument_list|(
literal|"Converting to indexed (stage 2)..."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_type
operator|==
name|GIMP_RGB
operator|&&
operator|!
name|needs_quantize
operator|&&
name|palette_type
operator|==
name|GIMP_MAKE_PALETTE
condition|)
block|{
comment|/* If this is an RGB image, and the user wanted a custom-built            *  generated palette, and this image has no more colours than            *  the user asked for, we don't need the first pass (quantization).            *            * There's also no point in dithering, since there's no error to            *  spread.  So we destroy the old quantobj and make a new one            *  with the remapping function set to a special LUT-based            *  no-dither remapper.            */
name|quantobj
operator|->
name|delete_func
argument_list|(
name|quantobj
argument_list|)
expr_stmt|;
name|quantobj
operator|=
name|initialize_median_cut
argument_list|(
name|old_type
argument_list|,
name|num_cols
argument_list|,
name|GIMP_NODESTRUCT_DITHER
argument_list|,
name|palette_type
argument_list|,
name|alpha_dither
argument_list|,
name|progress
argument_list|)
expr_stmt|;
comment|/* We can skip the first pass (palette creation) */
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
name|num_found_cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_found_cols
condition|;
name|i
operator|++
control|)
block|{
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
operator|=
name|found_cols
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
operator|=
name|found_cols
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|found_cols
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
call|(
modifier|*
name|quantobj
operator|->
name|first_pass
call|)
argument_list|(
name|quantobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|palette_type
operator|==
name|GIMP_MAKE_PALETTE
condition|)
name|qsort
argument_list|(
name|quantobj
operator|->
name|cmap
argument_list|,
name|quantobj
operator|->
name|actual_number_of_colors
argument_list|,
sizeof|sizeof
argument_list|(
name|Color
argument_list|)
argument_list|,
name|color_quicksort
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_text
argument_list|(
name|progress
argument_list|,
name|_
argument_list|(
literal|"Converting to indexed (stage 3)..."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialise data which must persist across indexed layer iterations */
switch|switch
condition|(
name|new_type
condition|)
block|{
case|case
name|GIMP_INDEXED
case|:
if|if
condition|(
name|quantobj
operator|->
name|second_pass_init
condition|)
call|(
modifier|*
name|quantobj
operator|->
name|second_pass_init
call|)
argument_list|(
name|quantobj
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  Convert all layers  */
if|if
condition|(
name|quantobj
condition|)
name|quantobj
operator|->
name|n_layers
operator|=
name|n_layers
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
operator|,
name|nth_layer
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
operator|,
name|nth_layer
operator|++
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|new_layer_type
operator|=
name|GIMP_IMAGE_TYPE_FROM_BASE_TYPE
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|new_layer_type
operator|=
name|GIMP_IMAGE_TYPE_WITH_ALPHA
argument_list|(
name|new_layer_type
argument_list|)
expr_stmt|;
name|new_tiles
operator|=
name|tile_manager_new
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|GIMP_IMAGE_TYPE_BYTES
argument_list|(
name|new_layer_type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|gimp_drawable_convert_rgb
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|new_tiles
argument_list|,
name|old_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
name|gimp_drawable_convert_grayscale
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|new_tiles
argument_list|,
name|old_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|quantobj
operator|->
name|nth_layer
operator|=
name|nth_layer
expr_stmt|;
call|(
modifier|*
name|quantobj
operator|->
name|second_pass
call|)
argument_list|(
name|quantobj
argument_list|,
name|layer
argument_list|,
name|new_tiles
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|gimp_drawable_set_tiles_full
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|new_tiles
argument_list|,
name|new_layer_type
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|new_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
case|case
name|GIMP_GRAY
case|:
if|if
condition|(
name|old_type
operator|==
name|GIMP_INDEXED
condition|)
name|gimp_image_set_colormap
argument_list|(
name|gimage
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|gimp_image_undo_push_image_colormap
argument_list|(
name|gimage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|GIMP_IMAGE_COLORMAP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_dups
operator|&&
operator|(
operator|(
name|palette_type
operator|==
name|GIMP_WEB_PALETTE
operator|)
operator|||
operator|(
name|palette_type
operator|==
name|GIMP_CUSTOM_PALETTE
operator|)
operator|)
condition|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
name|old_palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|guchar
name|new_palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|guchar
name|remap_table
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|num_entries
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|i
operator|++
control|)
block|{
name|old_palette
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|old_palette
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|old_palette
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
block|}
name|num_entries
operator|=
name|quantobj
operator|->
name|actual_number_of_colors
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Generate a remapping table */
name|make_remap_table
argument_list|(
name|old_palette
argument_list|,
name|new_palette
argument_list|,
name|quantobj
operator|->
name|index_used_count
argument_list|,
name|remap_table
argument_list|,
operator|&
name|num_entries
argument_list|)
expr_stmt|;
comment|/*  Convert all layers  */
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|remap_indexed_layer
argument_list|(
name|layer
argument_list|,
name|remap_table
argument_list|,
name|num_entries
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|memcpy
argument_list|(
name|new_palette
argument_list|,
name|old_palette
argument_list|,
literal|256
operator|*
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|cmap
index|[
name|j
index|]
operator|=
name|new_palette
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|j
index|]
operator|=
name|new_palette
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|j
index|]
operator|=
name|new_palette
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|gimage
operator|->
name|num_cols
operator|=
name|num_entries
expr_stmt|;
block|}
else|else
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
block|}
name|gimage
operator|->
name|num_cols
operator|=
name|quantobj
operator|->
name|actual_number_of_colors
expr_stmt|;
block|}
name|gimp_image_colormap_changed
argument_list|(
name|gimage
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  Delete the quantizer object, if there is one */
if|if
condition|(
name|quantobj
condition|)
name|quantobj
operator|->
name|delete_func
argument_list|(
name|quantobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
name|floating_sel_rigor
argument_list|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_image_undo_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_invalidate_layer_previews
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_mode_changed
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|g_object_thaw_notify
argument_list|(
name|G_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_unset_busy
argument_list|(
name|gimage
operator|->
name|gimp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_drawable_convert_rgb (GimpDrawable * drawable,TileManager * new_tiles,GimpImageBaseType old_base_type)
name|gimp_drawable_convert_rgb
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|,
name|GimpImageBaseType
name|old_base_type
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|offset
decl_stmt|;
name|gint
name|has_alpha
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|new_tiles
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile_manager_bpp
argument_list|(
name|new_tiles
argument_list|)
operator|==
operator|(
name|has_alpha
condition|?
literal|4
else|:
literal|3
operator|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
switch|switch
condition|(
name|old_base_type
condition|)
block|{
case|case
name|GIMP_GRAY
case|:
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|d
index|[
name|RED_PIX
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|d
index|[
name|GREEN_PIX
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|d
index|[
name|BLUE_PIX
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|d
operator|+=
literal|3
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXED
case|:
name|cmap
operator|=
name|gimp_drawable_cmap
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|offset
operator|=
operator|*
name|s
operator|++
operator|*
literal|3
expr_stmt|;
name|d
index|[
name|RED_PIX
index|]
operator|=
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
expr_stmt|;
name|d
index|[
name|GREEN_PIX
index|]
operator|=
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
name|d
index|[
name|BLUE_PIX
index|]
operator|=
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
expr_stmt|;
name|d
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_drawable_convert_grayscale (GimpDrawable * drawable,TileManager * new_tiles,GimpImageBaseType old_base_type)
name|gimp_drawable_convert_grayscale
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|,
name|GimpImageBaseType
name|old_base_type
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|new_tiles
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile_manager_bpp
argument_list|(
name|new_tiles
argument_list|)
operator|==
operator|(
name|has_alpha
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
switch|switch
condition|(
name|old_base_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|val
operator|=
name|GIMP_RGB_INTENSITY
argument_list|(
name|s
index|[
name|RED_PIX
index|]
argument_list|,
name|s
index|[
name|GREEN_PIX
index|]
argument_list|,
name|s
index|[
name|BLUE_PIX
index|]
argument_list|)
operator|+
literal|0.5
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|(
name|guchar
operator|)
name|val
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXED
case|:
name|cmap
operator|=
name|gimp_drawable_cmap
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|offset
operator|=
operator|*
name|s
operator|++
operator|*
literal|3
expr_stmt|;
name|val
operator|=
name|GIMP_RGB_INTENSITY
argument_list|(
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|)
operator|+
literal|0.5
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|(
name|guchar
operator|)
name|val
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Indexed color conversion machinery  */
end_comment

begin_function
specifier|static
name|void
DECL|function|zero_histogram_gray (CFHistogram histogram)
name|zero_histogram_gray
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|histogram
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|zero_histogram_rgb (CFHistogram histogram)
name|zero_histogram_rgb
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|)
block|{
name|memset
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|,
name|HIST_R_ELEMS
operator|*
name|HIST_G_ELEMS
operator|*
name|HIST_B_ELEMS
operator|*
sizeof|sizeof
argument_list|(
name|ColorFreq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|generate_histogram_gray (CFHistogram histogram,GimpLayer * layer,gboolean alpha_dither)
name|generate_histogram_gray
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|srcPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|data
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|size
operator|=
name|srcPR
operator|.
name|w
operator|*
name|srcPR
operator|.
name|h
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|histogram
index|[
operator|*
name|data
index|]
operator|++
expr_stmt|;
name|data
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|generate_histogram_rgb (CFHistogram histogram,GimpLayer * layer,gint col_limit,gboolean alpha_dither,GimpProgress * progress,gint nth_layer,gint n_layers)
name|generate_histogram_rgb
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gint
name|col_limit
parameter_list|,
name|gboolean
name|alpha_dither
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|,
name|gint
name|nth_layer
parameter_list|,
name|gint
name|n_layers
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|ColorFreq
modifier|*
name|colfreq
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gint
name|nfc_iter
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|,
name|coledge
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|glong
name|total_size
init|=
literal|0
decl_stmt|,
name|layer_size
decl_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
comment|/*  g_print ("col_limit = %d, nfc = %d\n", col_limit, num_found_cols);*/
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|layer_size
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
operator|*
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|srcPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|data
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|size
operator|=
name|srcPR
operator|.
name|w
operator|*
name|srcPR
operator|.
name|h
expr_stmt|;
name|total_size
operator|+=
name|size
expr_stmt|;
comment|/*fprintf(stderr, " [%d,%d - %d,%d]", srcPR.x, srcPR.y, offsetx, offsety);*/
if|if
condition|(
name|needs_quantize
condition|)
block|{
if|if
condition|(
name|alpha_dither
condition|)
block|{
comment|/* if alpha-dithering, we need to be deterministic w.r.t. offsets */
name|col
operator|=
name|srcPR
operator|.
name|x
operator|+
name|offsetx
expr_stmt|;
name|coledge
operator|=
name|col
operator|+
name|srcPR
operator|.
name|w
expr_stmt|;
name|row
operator|=
name|srcPR
operator|.
name|y
operator|+
name|offsety
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|has_alpha
operator|&&
operator|(
operator|(
name|data
index|[
name|ALPHA_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
name|col
operator|&
name|DM_WIDTHMASK
index|]
index|[
name|row
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|has_alpha
operator|)
condition|)
block|{
name|colfreq
operator|=
name|HIST_RGB
argument_list|(
name|histogram
argument_list|,
name|data
index|[
name|RED_PIX
index|]
argument_list|,
name|data
index|[
name|GREEN_PIX
index|]
argument_list|,
name|data
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|colfreq
operator|)
operator|++
expr_stmt|;
block|}
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|col
operator|==
name|coledge
condition|)
block|{
name|col
operator|=
name|srcPR
operator|.
name|x
operator|+
name|offsetx
expr_stmt|;
name|row
operator|++
expr_stmt|;
block|}
name|data
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|has_alpha
operator|&&
operator|(
operator|(
name|data
index|[
name|ALPHA_PIX
index|]
operator|>
literal|127
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|has_alpha
operator|)
condition|)
block|{
name|colfreq
operator|=
name|HIST_RGB
argument_list|(
name|histogram
argument_list|,
name|data
index|[
name|RED_PIX
index|]
argument_list|,
name|data
index|[
name|GREEN_PIX
index|]
argument_list|,
name|data
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|colfreq
operator|)
operator|++
expr_stmt|;
block|}
name|data
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* if alpha-dithering, we need to be deterministic w.r.t. offsets */
name|col
operator|=
name|srcPR
operator|.
name|x
operator|+
name|offsetx
expr_stmt|;
name|coledge
operator|=
name|col
operator|+
name|srcPR
operator|.
name|w
expr_stmt|;
name|row
operator|=
name|srcPR
operator|.
name|y
operator|+
name|offsety
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|has_alpha
operator|&&
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|data
index|[
name|ALPHA_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
name|col
operator|&
name|DM_WIDTHMASK
index|]
index|[
name|row
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|data
index|[
name|ALPHA_PIX
index|]
operator|>
literal|127
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|has_alpha
operator|)
condition|)
block|{
name|colfreq
operator|=
name|HIST_RGB
argument_list|(
name|histogram
argument_list|,
name|data
index|[
name|RED_PIX
index|]
argument_list|,
name|data
index|[
name|GREEN_PIX
index|]
argument_list|,
name|data
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|colfreq
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|needs_quantize
condition|)
block|{
for|for
control|(
name|nfc_iter
operator|=
literal|0
init|;
name|nfc_iter
operator|<
name|num_found_cols
condition|;
name|nfc_iter
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|data
index|[
name|RED_PIX
index|]
operator|==
name|found_cols
index|[
name|nfc_iter
index|]
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|data
index|[
name|GREEN_PIX
index|]
operator|==
name|found_cols
index|[
name|nfc_iter
index|]
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|data
index|[
name|BLUE_PIX
index|]
operator|==
name|found_cols
index|[
name|nfc_iter
index|]
index|[
literal|2
index|]
operator|)
condition|)
goto|goto
name|already_found
goto|;
block|}
comment|/* Colour was not in the table of 		       * existing colours 		       */
name|num_found_cols
operator|++
expr_stmt|;
if|if
condition|(
name|num_found_cols
operator|>
name|col_limit
condition|)
block|{
comment|/* There are more colours in the image 			   *  than were allowed.  We switch to plain 			   *  histogram calculation with a view to 			   *  quantizing at a later stage. 			   */
name|needs_quantize
operator|=
name|TRUE
expr_stmt|;
comment|/*			  g_print ("\nmax colours exceeded - needs quantize.\n");*/
goto|goto
name|already_found
goto|;
block|}
else|else
block|{
comment|/* Remember the new colour we just found. 			   */
name|found_cols
index|[
name|num_found_cols
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|data
index|[
name|RED_PIX
index|]
expr_stmt|;
name|found_cols
index|[
name|num_found_cols
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|data
index|[
name|GREEN_PIX
index|]
expr_stmt|;
name|found_cols
index|[
name|num_found_cols
operator|-
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|data
index|[
name|BLUE_PIX
index|]
expr_stmt|;
block|}
block|}
block|}
name|already_found
label|:
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|col
operator|==
name|coledge
condition|)
block|{
name|col
operator|=
name|srcPR
operator|.
name|x
operator|+
name|offsetx
expr_stmt|;
name|row
operator|++
expr_stmt|;
block|}
name|data
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|nth_layer
operator|+
operator|(
operator|(
name|gdouble
operator|)
name|total_size
operator|)
operator|/
name|layer_size
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|n_layers
argument_list|)
expr_stmt|;
block|}
comment|/*  g_print ("O: col_limit = %d, nfc = %d\n", col_limit, num_found_cols);*/
block|}
end_function

begin_function
specifier|static
name|boxptr
DECL|function|find_split_candidate (const boxptr boxlist,const int numboxes,axisType * which_axis,const int desired_colors)
name|find_split_candidate
parameter_list|(
specifier|const
name|boxptr
name|boxlist
parameter_list|,
specifier|const
name|int
name|numboxes
parameter_list|,
name|axisType
modifier|*
name|which_axis
parameter_list|,
specifier|const
name|int
name|desired_colors
parameter_list|)
block|{
name|boxptr
name|boxp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|etype
name|maxc
init|=
literal|0
decl_stmt|;
name|boxptr
name|which
init|=
name|NULL
decl_stmt|;
name|double
name|Lbias
decl_stmt|;
operator|*
name|which_axis
operator|=
name|AXIS_UNDEF
expr_stmt|;
comment|/* we only perform the initial L-split bias /at all/ if the final      number of desired colours is quite low, otherwise it all comes      out in the wash anyway and this initial bias generally only hurts      us in the long run. */
if|if
condition|(
name|desired_colors
operator|<=
literal|16
condition|)
block|{
DECL|macro|BIAS_FACTOR
define|#
directive|define
name|BIAS_FACTOR
value|2.66F
DECL|macro|BIAS_NUMBER
define|#
directive|define
name|BIAS_NUMBER
value|2
comment|/* 0 */
comment|/* we bias towards splitting across L* for first few colours */
name|Lbias
operator|=
operator|(
name|numboxes
operator|>
name|BIAS_NUMBER
operator|)
condition|?
literal|1.0F
else|:
operator|(
call|(
name|double
call|)
argument_list|(
name|BIAS_NUMBER
operator|+
literal|1
argument_list|)
operator|-
operator|(
operator|(
name|double
operator|)
name|numboxes
operator|)
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|BIAS_NUMBER
operator|/
name|BIAS_FACTOR
operator|)
expr_stmt|;
comment|/*Lbias = 1.0; 	fprintf(stderr, " [[%d]] ", numboxes); 	fprintf(stderr, "Using ramped L-split bias.\n"); 	fprintf(stderr, "R\n");       */
block|}
else|else
name|Lbias
operator|=
literal|1.0F
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|boxp
operator|=
name|boxlist
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
operator|,
name|boxp
operator|++
control|)
block|{
if|if
condition|(
name|boxp
operator|->
name|volume
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|_MSC_VER
name|etype
name|rpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
name|boxp
operator|->
name|rerror
operator|)
operator|*
name|R_SCALE
operator|*
name|R_SCALE
argument_list|)
decl_stmt|;
name|etype
name|gpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
name|boxp
operator|->
name|gerror
operator|)
operator|*
name|G_SCALE
operator|*
name|G_SCALE
argument_list|)
decl_stmt|;
name|etype
name|bpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
name|boxp
operator|->
name|berror
operator|)
operator|*
name|B_SCALE
operator|*
name|B_SCALE
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* 	   * Sorry about the mess, otherwise would get : 	   * error C2520: conversion from unsigned __int64 to double 	   *              not implemented, use signed __int64 	   */
name|etype
name|rpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|__int64
operator|)
name|boxp
operator|->
name|rerror
operator|)
operator|*
name|R_SCALE
operator|*
name|R_SCALE
argument_list|)
decl_stmt|;
name|etype
name|gpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|__int64
operator|)
name|boxp
operator|->
name|gerror
operator|)
operator|*
name|G_SCALE
operator|*
name|G_SCALE
argument_list|)
decl_stmt|;
name|etype
name|bpe
init|=
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|__int64
operator|)
name|boxp
operator|->
name|berror
operator|)
operator|*
name|B_SCALE
operator|*
name|B_SCALE
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Lbias
operator|*
name|rpe
operator|>
name|maxc
operator|&&
name|boxp
operator|->
name|Rmin
operator|<
name|boxp
operator|->
name|Rmax
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxc
operator|=
name|Lbias
operator|*
name|rpe
expr_stmt|;
operator|*
name|which_axis
operator|=
name|AXIS_RED
expr_stmt|;
block|}
if|if
condition|(
name|gpe
operator|>
name|maxc
operator|&&
name|boxp
operator|->
name|Gmin
operator|<
name|boxp
operator|->
name|Gmax
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxc
operator|=
name|gpe
expr_stmt|;
operator|*
name|which_axis
operator|=
name|AXIS_GREEN
expr_stmt|;
block|}
if|if
condition|(
name|bpe
operator|>
name|maxc
operator|&&
name|boxp
operator|->
name|Bmin
operator|<
name|boxp
operator|->
name|Bmax
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxc
operator|=
name|bpe
expr_stmt|;
operator|*
name|which_axis
operator|=
name|AXIS_BLUE
expr_stmt|;
block|}
block|}
block|}
comment|/*  fprintf(stderr, " %f,%p ", maxc, which); */
comment|/*  fprintf(stderr, " %llu ", maxc); */
return|return
name|which
return|;
block|}
end_function

begin_function
specifier|static
name|boxptr
DECL|function|find_biggest_volume (const boxptr boxlist,const int numboxes)
name|find_biggest_volume
parameter_list|(
specifier|const
name|boxptr
name|boxlist
parameter_list|,
specifier|const
name|int
name|numboxes
parameter_list|)
comment|/* Find the splittable box with the largest (scaled) volume */
comment|/* Returns NULL if no splittable boxes remain */
block|{
name|boxptr
name|boxp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|maxv
init|=
literal|0
decl_stmt|;
name|boxptr
name|which
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|boxp
operator|=
name|boxlist
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
operator|,
name|boxp
operator|++
control|)
block|{
if|if
condition|(
name|boxp
operator|->
name|volume
operator|>
name|maxv
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxv
operator|=
name|boxp
operator|->
name|volume
expr_stmt|;
block|}
block|}
return|return
name|which
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|update_box_gray (const CFHistogram histogram,boxptr boxp)
name|update_box_gray
parameter_list|(
specifier|const
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|)
comment|/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
comment|/* and recompute its volume and population */
block|{
name|int
name|i
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
name|dist
decl_stmt|;
name|ColorFreq
name|ccount
decl_stmt|;
name|min
operator|=
name|boxp
operator|->
name|Rmin
expr_stmt|;
name|max
operator|=
name|boxp
operator|->
name|Rmax
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|min
condition|)
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histogram
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Rmin
operator|=
name|min
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|max
operator|>
name|min
condition|)
for|for
control|(
name|i
operator|=
name|max
init|;
name|i
operator|>=
name|min
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|histogram
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Rmax
operator|=
name|max
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Update box volume.    * We use 2-norm rather than real volume here; this biases the method    * against making long narrow boxes, and it has the side benefit that    * a box is splittable iff norm> 0.    * Since the differences are expressed in histogram-cell units,    * we have to shift back to JSAMPLE units to get consistent distances;    * after which, we scale according to the selected distance scale factors.    */
name|dist
operator|=
name|max
operator|-
name|min
expr_stmt|;
name|boxp
operator|->
name|volume
operator|=
name|dist
operator|*
name|dist
expr_stmt|;
comment|/* Now scan remaining volume of box and compute population */
name|ccount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|histogram
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|ccount
operator|++
expr_stmt|;
name|boxp
operator|->
name|colorcount
operator|=
name|ccount
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|update_box_rgb (const CFHistogram histogram,boxptr boxp,const int cells_remaining)
name|update_box_rgb
parameter_list|(
specifier|const
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|,
specifier|const
name|int
name|cells_remaining
parameter_list|)
comment|/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
comment|/* and recompute its volume, population and error */
block|{
name|int
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|int
name|Rmin
decl_stmt|,
name|Rmax
decl_stmt|,
name|Gmin
decl_stmt|,
name|Gmax
decl_stmt|,
name|Bmin
decl_stmt|,
name|Bmax
decl_stmt|;
name|int
name|dist0
decl_stmt|,
name|dist1
decl_stmt|,
name|dist2
decl_stmt|;
name|ColorFreq
name|ccount
decl_stmt|;
comment|/*   guint64 tempRerror;   guint64 tempGerror;   guint64 tempBerror;   */
name|QuantizeObj
name|dummyqo
decl_stmt|;
name|box
name|dummybox
decl_stmt|;
comment|/* fprintf(stderr, "U"); */
name|Rmin
operator|=
name|boxp
operator|->
name|Rmin
expr_stmt|;
name|Rmax
operator|=
name|boxp
operator|->
name|Rmax
expr_stmt|;
name|Gmin
operator|=
name|boxp
operator|->
name|Gmin
expr_stmt|;
name|Gmax
operator|=
name|boxp
operator|->
name|Gmax
expr_stmt|;
name|Bmin
operator|=
name|boxp
operator|->
name|Bmin
expr_stmt|;
name|Bmax
operator|=
name|boxp
operator|->
name|Bmax
expr_stmt|;
if|if
condition|(
name|Rmax
operator|>
name|Rmin
condition|)
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Rmin
operator|=
name|Rmin
operator|=
name|R
expr_stmt|;
goto|goto
name|have_Rmin
goto|;
block|}
block|}
block|}
name|have_Rmin
label|:
if|if
condition|(
name|Rmax
operator|>
name|Rmin
condition|)
for|for
control|(
name|R
operator|=
name|Rmax
init|;
name|R
operator|>=
name|Rmin
condition|;
name|R
operator|--
control|)
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Rmax
operator|=
name|Rmax
operator|=
name|R
expr_stmt|;
goto|goto
name|have_Rmax
goto|;
block|}
block|}
block|}
name|have_Rmax
label|:
if|if
condition|(
name|Gmax
operator|>
name|Gmin
condition|)
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Gmin
operator|=
name|Gmin
operator|=
name|G
expr_stmt|;
goto|goto
name|have_Gmin
goto|;
block|}
block|}
block|}
name|have_Gmin
label|:
if|if
condition|(
name|Gmax
operator|>
name|Gmin
condition|)
for|for
control|(
name|G
operator|=
name|Gmax
init|;
name|G
operator|>=
name|Gmin
condition|;
name|G
operator|--
control|)
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Gmax
operator|=
name|Gmax
operator|=
name|G
expr_stmt|;
goto|goto
name|have_Gmax
goto|;
block|}
block|}
block|}
name|have_Gmax
label|:
if|if
condition|(
name|Bmax
operator|>
name|Bmin
condition|)
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
block|{
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Bmin
operator|=
name|Bmin
operator|=
name|B
expr_stmt|;
goto|goto
name|have_Bmin
goto|;
block|}
block|}
block|}
name|have_Bmin
label|:
if|if
condition|(
name|Bmax
operator|>
name|Bmin
condition|)
for|for
control|(
name|B
operator|=
name|Bmax
init|;
name|B
operator|>=
name|Bmin
condition|;
name|B
operator|--
control|)
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
block|{
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|Bmax
operator|=
name|Bmax
operator|=
name|B
expr_stmt|;
goto|goto
name|have_Bmax
goto|;
block|}
block|}
block|}
name|have_Bmax
label|:
comment|/* Update box volume.    * We use 2-norm rather than real volume here; this biases the method    * against making long narrow boxes, and it has the side benefit that    * a box is splittable iff norm> 0. (ADM: note: this isn't true.)    * Since the differences are expressed in histogram-cell units,    * we have to shift back to JSAMPLE units to get consistent distances;    * after which, we scale according to the selected distance scale factors.    */
name|dist0
operator|=
operator|(
operator|(
literal|1
operator|+
name|Rmax
operator|-
name|Rmin
operator|)
operator|<<
name|R_SHIFT
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|dist1
operator|=
operator|(
operator|(
literal|1
operator|+
name|Gmax
operator|-
name|Gmin
operator|)
operator|<<
name|G_SHIFT
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|dist2
operator|=
operator|(
operator|(
literal|1
operator|+
name|Bmax
operator|-
name|Bmin
operator|)
operator|<<
name|B_SHIFT
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|boxp
operator|->
name|volume
operator|=
name|dist0
operator|*
name|dist0
operator|+
name|dist1
operator|*
name|dist1
operator|+
name|dist2
operator|*
name|dist2
expr_stmt|;
comment|/*  boxp->volume = dist0 * dist1 * dist2; */
name|compute_color_lin8
argument_list|(
operator|&
name|dummyqo
argument_list|,
name|histogram
argument_list|,
name|boxp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*printf("(%d %d %d)\n", dummyqo.cmap[0].red,dummyqo.cmap[0].green,dummyqo.cmap[0].blue);     fflush(stdout);*/
comment|/* Now scan remaining volume of box and compute population */
name|ccount
operator|=
literal|0
expr_stmt|;
name|boxp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|boxp
operator|->
name|rerror
operator|=
literal|0
expr_stmt|;
name|boxp
operator|->
name|gerror
operator|=
literal|0
expr_stmt|;
name|boxp
operator|->
name|berror
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
block|{
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
name|ColorFreq
name|freq_here
decl_stmt|;
name|freq_here
operator|=
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_here
operator|!=
literal|0
condition|)
block|{
name|int
name|ge
decl_stmt|,
name|be
decl_stmt|,
name|re
decl_stmt|;
name|dummybox
operator|.
name|Rmin
operator|=
name|dummybox
operator|.
name|Rmax
operator|=
name|R
expr_stmt|;
name|dummybox
operator|.
name|Gmin
operator|=
name|dummybox
operator|.
name|Gmax
operator|=
name|G
expr_stmt|;
name|dummybox
operator|.
name|Bmin
operator|=
name|dummybox
operator|.
name|Bmax
operator|=
name|B
expr_stmt|;
name|compute_color_lin8
argument_list|(
operator|&
name|dummyqo
argument_list|,
name|histogram
argument_list|,
operator|&
name|dummybox
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|re
operator|=
name|dummyqo
operator|.
name|cmap
index|[
literal|0
index|]
operator|.
name|red
operator|-
name|dummyqo
operator|.
name|cmap
index|[
literal|1
index|]
operator|.
name|red
expr_stmt|;
name|ge
operator|=
name|dummyqo
operator|.
name|cmap
index|[
literal|0
index|]
operator|.
name|green
operator|-
name|dummyqo
operator|.
name|cmap
index|[
literal|1
index|]
operator|.
name|green
expr_stmt|;
name|be
operator|=
name|dummyqo
operator|.
name|cmap
index|[
literal|0
index|]
operator|.
name|blue
operator|-
name|dummyqo
operator|.
name|cmap
index|[
literal|1
index|]
operator|.
name|blue
expr_stmt|;
name|boxp
operator|->
name|rerror
operator|+=
name|freq_here
operator|*
operator|(
name|re
operator|)
operator|*
operator|(
name|re
operator|)
expr_stmt|;
name|boxp
operator|->
name|gerror
operator|+=
name|freq_here
operator|*
operator|(
name|ge
operator|)
operator|*
operator|(
name|ge
operator|)
expr_stmt|;
name|boxp
operator|->
name|berror
operator|+=
name|freq_here
operator|*
operator|(
name|be
operator|)
operator|*
operator|(
name|be
operator|)
expr_stmt|;
name|ccount
operator|+=
name|freq_here
expr_stmt|;
block|}
block|}
block|}
block|}
if|#
directive|if
literal|0
block|fg d;flg fd;kg fld;gflkfld
comment|/* Scan again, taking note of halfway error point for red axis */
block|tempRerror = 0;   boxp->Rhalferror = Rmin;
warning|#
directive|warning
warning|r<=?
block|for (R = Rmin; R<= Rmax; R++)     {       for (G = Gmin; G<= Gmax; G++) 	{ 	  for (B = Bmin; B<= Bmax; B++) 	    { 	      ColorFreq freq_here; 	      freq_here = *HIST_LIN(histogram, R, G, B); 	      if (freq_here != 0) 		{ 		  int re; 		  int idist; 		  double dist;  		  dummybox.Rmin = dummybox.Rmax = R; 		  dummybox.Gmin = dummybox.Gmax = G; 		  dummybox.Bmin = dummybox.Bmax = B; 		  compute_color_lin8(&dummyqo, histogram,&dummybox, 1);  		  re = dummyqo.cmap[0].red   - dummyqo.cmap[1].red;  		  tempRerror += freq_here * (re) * (re);  		  if (tempRerror*2>= boxp->rerror) 		    goto green_axisscan; 		  else 		    boxp->Rhalferror = R; 		} 	    } 	}     }   fprintf(stderr, " D:");  green_axisscan:    fprintf(stderr, "<%d: %llu/%llu> ", R, tempRerror, boxp->rerror);
comment|/* Scan again, taking note of halfway error point for green axis */
block|tempGerror = 0;   boxp->Ghalferror = Gmin;
warning|#
directive|warning
warning|G<=?
block|for (G = Gmin; G<= Gmax; G++)     {       for (R = Rmin; R<= Rmax; R++) 	{ 	  for (B = Bmin; B<= Bmax; B++) 	    { 	      ColorFreq freq_here; 	      freq_here = *HIST_LIN(histogram, R, G, B); 	      if (freq_here != 0) 		{ 		  int ge; 		  dummybox.Rmin = dummybox.Rmax = R; 		  dummybox.Gmin = dummybox.Gmax = G; 		  dummybox.Bmin = dummybox.Bmax = B; 		  compute_color_lin8(&dummyqo, histogram,&dummybox, 1);  		  ge = dummyqo.cmap[0].green - dummyqo.cmap[1].green;  		  tempGerror += freq_here * (ge) * (ge);  		  if (tempGerror*2>= boxp->gerror) 		    goto blue_axisscan; 		  else 		    boxp->Ghalferror = G; 		} 	    } 	}     }   blue_axisscan:
comment|/* Scan again, taking note of halfway error point for blue axis */
block|tempBerror = 0;   boxp->Bhalferror = Bmin;
warning|#
directive|warning
warning|B<=?
block|for (B = Bmin; B<= Bmax; B++)     {       for (R = Rmin; R<= Rmax; R++) 	{ 	  for (G = Gmin; G<= Gmax; G++) 	    { 	      ColorFreq freq_here; 	      freq_here = *HIST_LIN(histogram, R, G, B); 	      if (freq_here != 0) 		{ 		  int be; 		  dummybox.Rmin = dummybox.Rmax = R; 		  dummybox.Gmin = dummybox.Gmax = G; 		  dummybox.Bmin = dummybox.Bmax = B; 		  compute_color_lin8(&dummyqo, histogram,&dummybox, 1);  		  be = dummyqo.cmap[0].blue  - dummyqo.cmap[1].blue;  		  tempBerror += freq_here * (be) * (be);  		  if (tempBerror*2>= boxp->berror) 		    goto finished_axesscan; 		  else 		    boxp->Bhalferror = B; 		} 	    } 	}     }  finished_axesscan:
else|#
directive|else
name|boxp
operator|->
name|Rhalferror
operator|=
name|Rmin
operator|+
operator|(
name|Rmax
operator|-
name|Rmin
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|boxp
operator|->
name|Ghalferror
operator|=
name|Gmin
operator|+
operator|(
name|Gmax
operator|-
name|Gmin
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|boxp
operator|->
name|Bhalferror
operator|=
name|Bmin
operator|+
operator|(
name|Bmax
operator|-
name|Bmin
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dist0
operator|&&
name|dist1
operator|&&
name|dist2
condition|)
block|{
name|axisType
name|longest_ax
init|=
name|AXIS_UNDEF
decl_stmt|,
name|longest_ax2
init|=
name|AXIS_UNDEF
decl_stmt|;
name|int
name|longest_length
init|=
literal|0
decl_stmt|,
name|longest_length2
init|=
literal|0
decl_stmt|;
name|int
name|ratio
decl_stmt|;
comment|/*     fprintf(stderr, "[%d,%d,%d=%d,%d,%d] ", 	    (Rmax - Rmin), (Gmax - Gmin), (Bmax - Bmin), 	    dist0, dist1, dist2);     */
if|if
condition|(
name|dist0
operator|>=
name|longest_length
condition|)
block|{
name|longest_length2
operator|=
name|longest_length
expr_stmt|;
name|longest_ax2
operator|=
name|longest_ax
expr_stmt|;
name|longest_length
operator|=
name|dist0
expr_stmt|;
name|longest_ax
operator|=
name|AXIS_RED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dist0
operator|>=
name|longest_length2
condition|)
block|{
name|longest_length2
operator|=
name|dist0
expr_stmt|;
name|longest_ax2
operator|=
name|AXIS_RED
expr_stmt|;
block|}
if|if
condition|(
name|dist1
operator|>=
name|longest_length
condition|)
block|{
name|longest_length2
operator|=
name|longest_length
expr_stmt|;
name|longest_ax2
operator|=
name|longest_ax
expr_stmt|;
name|longest_length
operator|=
name|dist1
expr_stmt|;
name|longest_ax
operator|=
name|AXIS_GREEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dist1
operator|>=
name|longest_length2
condition|)
block|{
name|longest_length2
operator|=
name|dist1
expr_stmt|;
name|longest_ax2
operator|=
name|AXIS_GREEN
expr_stmt|;
block|}
if|if
condition|(
name|dist2
operator|>=
name|longest_length
condition|)
block|{
name|longest_length2
operator|=
name|longest_length
expr_stmt|;
name|longest_ax2
operator|=
name|longest_ax
expr_stmt|;
name|longest_length
operator|=
name|dist2
expr_stmt|;
name|longest_ax
operator|=
name|AXIS_BLUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dist2
operator|>=
name|longest_length2
condition|)
block|{
name|longest_length2
operator|=
name|dist2
expr_stmt|;
name|longest_ax2
operator|=
name|AXIS_BLUE
expr_stmt|;
block|}
if|if
condition|(
name|longest_length2
operator|==
literal|0
condition|)
name|longest_length2
operator|=
literal|1
expr_stmt|;
name|ratio
operator|=
operator|(
name|longest_length
operator|+
name|longest_length2
operator|/
literal|2
operator|)
operator|/
name|longest_length2
expr_stmt|;
comment|/* fprintf(stderr, " ratio:(%d/%d)=%d ", longest_length, longest_length2, ratio);        fprintf(stderr, "C%d ", cells_remaining); */
if|if
condition|(
name|ratio
operator|>
name|cells_remaining
operator|+
literal|1
condition|)
name|ratio
operator|=
name|cells_remaining
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ratio
operator|>
literal|2
condition|)
block|{
switch|switch
condition|(
name|longest_ax
condition|)
block|{
case|case
name|AXIS_RED
case|:
if|if
condition|(
name|Rmin
operator|+
operator|(
name|Rmax
operator|-
name|Rmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
operator|<
name|Rmax
condition|)
block|{
comment|/* fprintf(stderr, "FR%d \007\n",ratio);*/
name|boxp
operator|->
name|Rhalferror
operator|=
name|Rmin
operator|+
operator|(
name|Rmax
operator|-
name|Rmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
expr_stmt|;
block|}
break|break;
case|case
name|AXIS_GREEN
case|:
if|if
condition|(
name|Gmin
operator|+
operator|(
name|Gmax
operator|-
name|Gmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
operator|<
name|Gmax
condition|)
block|{
comment|/* fprintf(stderr, "FG%d \007\n",ratio);*/
name|boxp
operator|->
name|Ghalferror
operator|=
name|Gmin
operator|+
operator|(
name|Gmax
operator|-
name|Gmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
expr_stmt|;
block|}
break|break;
case|case
name|AXIS_BLUE
case|:
if|if
condition|(
name|Bmin
operator|+
operator|(
name|Bmax
operator|-
name|Bmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
operator|<
name|Bmax
condition|)
block|{
comment|/* fprintf(stderr, "FB%d \007\n",ratio);*/
name|boxp
operator|->
name|Bhalferror
operator|=
name|Bmin
operator|+
operator|(
name|Bmax
operator|-
name|Bmin
operator|+
name|ratio
operator|/
literal|2
operator|)
operator|/
name|ratio
expr_stmt|;
block|}
break|break;
default|default:
name|g_warning
argument_list|(
literal|"GRR, UNDEF LONGEST AXIS\007\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|boxp
operator|->
name|Rhalferror
operator|==
name|Rmax
condition|)
name|boxp
operator|->
name|Rhalferror
operator|=
name|Rmin
expr_stmt|;
if|if
condition|(
name|boxp
operator|->
name|Ghalferror
operator|==
name|Gmax
condition|)
name|boxp
operator|->
name|Ghalferror
operator|=
name|Gmin
expr_stmt|;
if|if
condition|(
name|boxp
operator|->
name|Bhalferror
operator|==
name|Bmax
condition|)
name|boxp
operator|->
name|Bhalferror
operator|=
name|Bmin
expr_stmt|;
comment|/*   boxp->Rhalferror = RSDF(dummyqo.cmap[0].red);   boxp->Ghalferror = GSDF(dummyqo.cmap[0].green);   boxp->Bhalferror = BSDF(dummyqo.cmap[0].blue);   */
comment|/*   boxp->Rhalferror = (RSDF(dummyqo.cmap[0].red) + (Rmin+Rmax)/2)/2;   boxp->Ghalferror = (GSDF(dummyqo.cmap[0].green) + (Gmin+Gmax)/2)/2;   boxp->Bhalferror = (BSDF(dummyqo.cmap[0].blue) + (Bmin+Bmax)/2)/2;   */
endif|#
directive|endif
comment|/*   fprintf(stderr, " %d,%d", dummyqo.cmap[0].blue, boxp->Bmax);    g_assert(boxp->Rhalferror>= boxp->Rmin);   g_assert(boxp->Rhalferror< boxp->Rmax);   g_assert(boxp->Ghalferror>= boxp->Gmin);   g_assert(boxp->Ghalferror< boxp->Gmax);   g_assert(boxp->Bhalferror>= boxp->Bmin);   g_assert(boxp->Bhalferror< boxp->Bmax);*/
comment|/*boxp->error = (sqrt((double)(boxp->error/ccount)));*/
comment|/*  boxp->rerror = (sqrt((double)((boxp->rerror)/ccount)));   boxp->gerror = (sqrt((double)((boxp->gerror)/ccount)));   boxp->berror = (sqrt((double)((boxp->berror)/ccount)));*/
comment|/*printf(":%lld / %ld: ", boxp->error, ccount);   printf("(%d-%d-%d)(%d-%d-%d)(%d-%d-%d)\n", 	 Rmin, boxp->Rhalferror, Rmax, 	 Gmin, boxp->Ghalferror, Gmax, 	 Bmin, boxp->Bhalferror, Bmax 	 ); 	 fflush(stdout);*/
name|boxp
operator|->
name|colorcount
operator|=
name|ccount
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|median_cut_gray (CFHistogram histogram,boxptr boxlist,int numboxes,int desired_colors)
name|median_cut_gray
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxlist
parameter_list|,
name|int
name|numboxes
parameter_list|,
name|int
name|desired_colors
parameter_list|)
comment|/* Repeatedly select and split the largest box until we have enough boxes */
block|{
name|int
name|lb
decl_stmt|;
name|boxptr
name|b1
decl_stmt|,
name|b2
decl_stmt|;
while|while
condition|(
name|numboxes
operator|<
name|desired_colors
condition|)
block|{
comment|/* Select box to split.        * Current algorithm: by population for first half, then by volume.        */
name|b1
operator|=
name|find_biggest_volume
argument_list|(
name|boxlist
argument_list|,
name|numboxes
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|NULL
condition|)
comment|/* no splittable boxes left! */
break|break;
name|b2
operator|=
name|boxlist
operator|+
name|numboxes
expr_stmt|;
comment|/* where new box will go */
comment|/* Copy the color bounds to the new box. */
name|b2
operator|->
name|Rmax
operator|=
name|b1
operator|->
name|Rmax
expr_stmt|;
name|b2
operator|->
name|Rmin
operator|=
name|b1
operator|->
name|Rmin
expr_stmt|;
comment|/* Current algorithm: split at halfway point.        * (Since the box has been shrunk to minimum volume,        * any split will produce two nonempty subboxes.)        * Note that lb value is max for lower box, so must be< old max.        */
name|lb
operator|=
operator|(
name|b1
operator|->
name|Rmax
operator|+
name|b1
operator|->
name|Rmin
operator|)
operator|/
literal|2
expr_stmt|;
name|b1
operator|->
name|Rmax
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|Rmin
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
comment|/* Update stats for boxes */
name|update_box_gray
argument_list|(
name|histogram
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|update_box_gray
argument_list|(
name|histogram
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|numboxes
operator|++
expr_stmt|;
block|}
return|return
name|numboxes
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|median_cut_rgb (CFHistogram histogram,boxptr boxlist,int numboxes,int desired_colors,GimpProgress * progress)
name|median_cut_rgb
parameter_list|(
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxlist
parameter_list|,
name|int
name|numboxes
parameter_list|,
name|int
name|desired_colors
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
comment|/* Repeatedly select and split the largest box until we have enough boxes */
block|{
name|int
name|lb
decl_stmt|;
name|boxptr
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|axisType
name|which_axis
decl_stmt|;
while|while
condition|(
name|numboxes
operator|<
name|desired_colors
condition|)
block|{
name|b1
operator|=
name|find_split_candidate
argument_list|(
name|boxlist
argument_list|,
name|numboxes
argument_list|,
operator|&
name|which_axis
argument_list|,
name|desired_colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|NULL
condition|)
comment|/* no splittable boxes left! */
break|break;
name|b2
operator|=
name|boxlist
operator|+
name|numboxes
expr_stmt|;
comment|/* where new box will go */
comment|/* Copy the color bounds to the new box. */
name|b2
operator|->
name|Rmax
operator|=
name|b1
operator|->
name|Rmax
expr_stmt|;
name|b2
operator|->
name|Gmax
operator|=
name|b1
operator|->
name|Gmax
expr_stmt|;
name|b2
operator|->
name|Bmax
operator|=
name|b1
operator|->
name|Bmax
expr_stmt|;
name|b2
operator|->
name|Rmin
operator|=
name|b1
operator|->
name|Rmin
expr_stmt|;
name|b2
operator|->
name|Gmin
operator|=
name|b1
operator|->
name|Gmin
expr_stmt|;
name|b2
operator|->
name|Bmin
operator|=
name|b1
operator|->
name|Bmin
expr_stmt|;
comment|/* Choose split point along selected axis, and update box bounds.        * Note that lb value is max for lower box, so must be< old max.        */
switch|switch
condition|(
name|which_axis
condition|)
block|{
case|case
name|AXIS_RED
case|:
name|lb
operator|=
name|b1
operator|->
name|Rhalferror
expr_stmt|;
comment|/* *0 + (b1->Rmax + b1->Rmin) / 2; */
name|b1
operator|->
name|Rmax
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|Rmin
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
name|g_assert
argument_list|(
name|b1
operator|->
name|Rmax
operator|>=
name|b1
operator|->
name|Rmin
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|b2
operator|->
name|Rmax
operator|>=
name|b2
operator|->
name|Rmin
argument_list|)
expr_stmt|;
break|break;
case|case
name|AXIS_GREEN
case|:
name|lb
operator|=
name|b1
operator|->
name|Ghalferror
expr_stmt|;
comment|/* *0 + (b1->Gmax + b1->Gmin) / 2; */
name|b1
operator|->
name|Gmax
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|Gmin
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
name|g_assert
argument_list|(
name|b1
operator|->
name|Gmax
operator|>=
name|b1
operator|->
name|Gmin
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|b2
operator|->
name|Gmax
operator|>=
name|b2
operator|->
name|Gmin
argument_list|)
expr_stmt|;
break|break;
case|case
name|AXIS_BLUE
case|:
name|lb
operator|=
name|b1
operator|->
name|Bhalferror
expr_stmt|;
comment|/* *0 + (b1->Bmax + b1->Bmin) / 2; */
name|b1
operator|->
name|Bmax
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|Bmin
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
name|g_assert
argument_list|(
name|b1
operator|->
name|Bmax
operator|>=
name|b1
operator|->
name|Bmin
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|b2
operator|->
name|Bmax
operator|>=
name|b2
operator|->
name|Bmin
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"Uh-oh."
argument_list|)
expr_stmt|;
block|}
comment|/* Update stats for boxes */
name|numboxes
operator|++
expr_stmt|;
if|if
condition|(
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|progress
argument_list|,
operator|(
name|gdouble
operator|)
name|numboxes
operator|/
name|desired_colors
argument_list|)
expr_stmt|;
name|update_box_rgb
argument_list|(
name|histogram
argument_list|,
name|b1
argument_list|,
name|desired_colors
operator|-
name|numboxes
argument_list|)
expr_stmt|;
name|update_box_rgb
argument_list|(
name|histogram
argument_list|,
name|b2
argument_list|,
name|desired_colors
operator|-
name|numboxes
argument_list|)
expr_stmt|;
block|}
return|return
name|numboxes
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_color_gray (QuantizeObj * quantobj,CFHistogram histogram,boxptr boxp,int icolor)
name|compute_color_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|,
name|int
name|icolor
parameter_list|)
comment|/* Compute representative color for a box, put it in colormap[icolor] */
block|{
name|int
name|i
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|total
decl_stmt|;
name|long
name|gtotal
decl_stmt|;
name|min
operator|=
name|boxp
operator|->
name|Rmin
expr_stmt|;
name|max
operator|=
name|boxp
operator|->
name|Rmax
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|gtotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|=
name|histogram
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
name|count
expr_stmt|;
name|gtotal
operator|+=
name|i
operator|*
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|total
operator|!=
literal|0
condition|)
block|{
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
operator|(
name|gtotal
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
expr_stmt|;
block|}
else|else
comment|/* The only situation where total==0 is if the image was null or 	*  all-transparent.  In that case we just put a dummy value in 	*  the colourmap. 	*/
block|{
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_color_rgb (QuantizeObj * quantobj,CFHistogram histogram,boxptr boxp,int icolor)
name|compute_color_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|,
name|int
name|icolor
parameter_list|)
comment|/* Compute representative color for a box, put it in colormap[icolor] */
block|{
comment|/* Current algorithm: mean weighted by pixels (not colors) */
comment|/* Note it is important to get the rounding correct! */
name|int
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|int
name|Rmin
decl_stmt|,
name|Rmax
decl_stmt|;
name|int
name|Gmin
decl_stmt|,
name|Gmax
decl_stmt|;
name|int
name|Bmin
decl_stmt|,
name|Bmax
decl_stmt|;
name|ColorFreq
name|total
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Rtotal
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Gtotal
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Btotal
init|=
literal|0
decl_stmt|;
name|Rmin
operator|=
name|boxp
operator|->
name|Rmin
expr_stmt|;
name|Rmax
operator|=
name|boxp
operator|->
name|Rmax
expr_stmt|;
name|Gmin
operator|=
name|boxp
operator|->
name|Gmin
expr_stmt|;
name|Gmax
operator|=
name|boxp
operator|->
name|Gmax
expr_stmt|;
name|Bmin
operator|=
name|boxp
operator|->
name|Bmin
expr_stmt|;
name|Bmax
operator|=
name|boxp
operator|->
name|Bmax
expr_stmt|;
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
name|ColorFreq
name|this_freq
init|=
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_freq
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
name|this_freq
expr_stmt|;
name|Rtotal
operator|+=
name|R
operator|*
name|this_freq
expr_stmt|;
name|Gtotal
operator|+=
name|G
operator|*
name|this_freq
expr_stmt|;
name|Btotal
operator|+=
name|B
operator|*
name|this_freq
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|lin_to_rgb
argument_list|(
comment|/*(Rtotal + (total>>1)) / total, 		 (Gtotal + (total>>1)) / total, 		 (Btotal + (total>>1)) / total,*/
operator|(
name|double
operator|)
name|Rtotal
operator|/
operator|(
name|double
operator|)
name|total
argument_list|,
operator|(
name|double
operator|)
name|Gtotal
operator|/
operator|(
name|double
operator|)
name|total
argument_list|,
operator|(
name|double
operator|)
name|Btotal
operator|/
operator|(
name|double
operator|)
name|total
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
block|}
else|else
comment|/* The only situation where total==0 is if the image was null or 	*  all-transparent.  In that case we just put a dummy value in 	*  the colourmap. 	*/
block|{
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_color_lin8 (QuantizeObj * quantobj,CFHistogram histogram,boxptr boxp,const int icolor)
name|compute_color_lin8
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|boxptr
name|boxp
parameter_list|,
specifier|const
name|int
name|icolor
parameter_list|)
comment|/* Compute representative color for a box, put it in colormap[icolor] */
block|{
comment|/* Current algorithm: mean weighted by pixels (not colors) */
comment|/* Note it is important to get the rounding correct! */
name|int
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|int
name|Rmin
decl_stmt|,
name|Rmax
decl_stmt|;
name|int
name|Gmin
decl_stmt|,
name|Gmax
decl_stmt|;
name|int
name|Bmin
decl_stmt|,
name|Bmax
decl_stmt|;
name|ColorFreq
name|total
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Rtotal
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Gtotal
init|=
literal|0
decl_stmt|;
name|ColorFreq
name|Btotal
init|=
literal|0
decl_stmt|;
name|Rmin
operator|=
name|boxp
operator|->
name|Rmin
expr_stmt|;
name|Rmax
operator|=
name|boxp
operator|->
name|Rmax
expr_stmt|;
name|Gmin
operator|=
name|boxp
operator|->
name|Gmin
expr_stmt|;
name|Gmax
operator|=
name|boxp
operator|->
name|Gmax
expr_stmt|;
name|Bmin
operator|=
name|boxp
operator|->
name|Bmin
expr_stmt|;
name|Bmax
operator|=
name|boxp
operator|->
name|Bmax
expr_stmt|;
for|for
control|(
name|R
operator|=
name|Rmin
init|;
name|R
operator|<=
name|Rmax
condition|;
name|R
operator|++
control|)
for|for
control|(
name|G
operator|=
name|Gmin
init|;
name|G
operator|<=
name|Gmax
condition|;
name|G
operator|++
control|)
block|{
for|for
control|(
name|B
operator|=
name|Bmin
init|;
name|B
operator|<=
name|Bmax
condition|;
name|B
operator|++
control|)
block|{
name|ColorFreq
name|this_freq
init|=
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_freq
operator|!=
literal|0
condition|)
block|{
name|Rtotal
operator|+=
name|R
operator|*
name|this_freq
expr_stmt|;
name|Gtotal
operator|+=
name|G
operator|*
name|this_freq
expr_stmt|;
name|Btotal
operator|+=
name|B
operator|*
name|this_freq
expr_stmt|;
name|total
operator|+=
name|this_freq
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|total
operator|!=
literal|0
condition|)
block|{
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
operator|(
operator|(
name|Rtotal
operator|<<
name|R_SHIFT
operator|)
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
operator|(
operator|(
name|Gtotal
operator|<<
name|G_SHIFT
operator|)
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
operator|(
operator|(
name|Btotal
operator|<<
name|B_SHIFT
operator|)
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
block|}
else|else
comment|/* The only situation where total==0 is if the image was null or 	*  all-transparent.  In that case we just put a dummy value in 	*  the colourmap. 	*/
block|{
name|g_warning
argument_list|(
literal|"eep."
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|red
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|green
operator|=
literal|128
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|icolor
index|]
operator|.
name|blue
operator|=
literal|128
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|select_colors_gray (QuantizeObj * quantobj,CFHistogram histogram)
name|select_colors_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|)
comment|/* Master routine for color selection */
block|{
name|boxptr
name|boxlist
decl_stmt|;
name|int
name|numboxes
decl_stmt|;
name|int
name|desired
init|=
name|quantobj
operator|->
name|desired_number_of_colors
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate workspace for box list */
name|boxlist
operator|=
operator|(
name|boxptr
operator|)
name|g_malloc
argument_list|(
name|desired
operator|*
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize one box containing whole space */
name|numboxes
operator|=
literal|1
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Rmin
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Rmax
operator|=
literal|255
expr_stmt|;
comment|/* Shrink it to actually-used volume and set its statistics */
name|update_box_gray
argument_list|(
name|histogram
argument_list|,
name|boxlist
argument_list|)
expr_stmt|;
comment|/* Perform median-cut to produce final box list */
name|numboxes
operator|=
name|median_cut_gray
argument_list|(
name|histogram
argument_list|,
name|boxlist
argument_list|,
name|numboxes
argument_list|,
name|desired
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
name|numboxes
expr_stmt|;
comment|/* Compute the representative color for each box, fill colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
control|)
name|compute_color_gray
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|boxlist
operator|+
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|select_colors_rgb (QuantizeObj * quantobj,CFHistogram histogram)
name|select_colors_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|)
comment|/* Master routine for color selection */
block|{
name|boxptr
name|boxlist
decl_stmt|;
name|int
name|numboxes
decl_stmt|;
name|int
name|desired
init|=
name|quantobj
operator|->
name|desired_number_of_colors
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate workspace for box list */
name|boxlist
operator|=
operator|(
name|boxptr
operator|)
name|g_malloc
argument_list|(
name|desired
operator|*
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize one box containing whole space */
name|numboxes
operator|=
literal|1
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Rmin
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Rmax
operator|=
name|HIST_R_ELEMS
operator|-
literal|1
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Gmin
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Gmax
operator|=
name|HIST_G_ELEMS
operator|-
literal|1
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Bmin
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|Bmax
operator|=
name|HIST_B_ELEMS
operator|-
literal|1
expr_stmt|;
comment|/* Shrink it to actually-used volume and set its statistics */
name|update_box_rgb
argument_list|(
name|histogram
argument_list|,
operator|&
name|boxlist
index|[
literal|0
index|]
argument_list|,
name|quantobj
operator|->
name|desired_number_of_colors
argument_list|)
expr_stmt|;
comment|/* Perform median-cut to produce final box list */
name|numboxes
operator|=
name|median_cut_rgb
argument_list|(
name|histogram
argument_list|,
name|boxlist
argument_list|,
name|numboxes
argument_list|,
name|desired
argument_list|,
name|quantobj
operator|->
name|progress
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
name|numboxes
expr_stmt|;
comment|/* Compute the representative color for each box, fill colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
control|)
block|{
name|compute_color_rgb
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
operator|&
name|boxlist
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * These routines are concerned with the time-critical task of mapping input  * colors to the nearest color in the selected colormap.  *  * We re-use the histogram space as an "inverse color map", essentially a  * cache for the results of nearest-color searches.  All colors within a  * histogram cell will be mapped to the same colormap entry, namely the one  * closest to the cell's center.  This may not be quite the closest entry to  * the actual input color, but it's almost as good.  A zero in the cache  * indicates we haven't found the nearest color for that cell yet; the array  * is cleared to zeroes before starting the mapping pass.  When we find the  * nearest color for a cell, its colormap index plus one is recorded in the  * cache for future use.  The pass2 scanning routines call fill_inverse_cmap  * when they need to use an unfilled entry in the cache.  *  * Our method of efficiently finding nearest colors is based on the "locally  * sorted search" idea described by Heckbert and on the incremental distance  * calculation described by Spencer W. Thomas in chapter III.1 of Graphics  * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that  * the distances from a given colormap entry to each cell of the histogram can  * be computed quickly using an incremental method: the differences between  * distances to adjacent cells themselves differ by a constant.  This allows a  * fairly fast implementation of the "brute force" approach of computing the  * distance from every colormap entry to every histogram cell.  Unfortunately,  * it needs a work array to hold the best-distance-so-far for each histogram  * cell (because the inner loop has to be over cells, not colormap entries).  * The work array elements have to be ints, so the work array would need  * 256Kb at our recommended precision.  This is not feasible in DOS machines.  *  * To get around these problems, we apply Thomas' method to compute the  * nearest colors for only the cells within a small subbox of the histogram.  * The work array need be only as big as the subbox, so the memory usage  * problem is solved.  Furthermore, we need not fill subboxes that are never  * referenced in pass2; many images use only part of the color gamut, so a  * fair amount of work is saved.  An additional advantage of this  * approach is that we can apply Heckbert's locality criterion to quickly  * eliminate colormap entries that are far away from the subbox; typically  * three-fourths of the colormap entries are rejected by Heckbert's criterion,  * and we need not compute their distances to individual cells in the subbox.  * The speed of this approach is heavily influenced by the subbox size: too  * small means too much overhead, too big loses because Heckbert's criterion  * can't eliminate as many colormap entries.  Empirically the best subbox  * size seems to be about 1/512th of the histogram (1/8th in each direction).  *  * Thomas' article also describes a refined method which is asymptotically  * faster than the brute-force method, but it is also far more complex and  * cannot efficiently be applied to small subboxes.  It is therefore not  * useful for programs intended to be portable to DOS machines.  On machines  * with plenty of memory, filling the whole histogram in one shot with Thomas'  * refined method might be faster than the present code --- but then again,  * it might not be any faster, and it's certainly more complicated.  */
end_comment

begin_comment
comment|/* log2(histogram cells in update box) for each axis; this can be adjusted */
end_comment

begin_comment
comment|/*#define BOX_R_LOG  (PRECISION_R-3)   #define BOX_G_LOG  (PRECISION_G-3)   #define BOX_B_LOG  (PRECISION_B-3)*/
end_comment

begin_comment
comment|/*adam*/
end_comment

begin_define
DECL|macro|BOX_R_LOG
define|#
directive|define
name|BOX_R_LOG
value|0
end_define

begin_define
DECL|macro|BOX_G_LOG
define|#
directive|define
name|BOX_G_LOG
value|0
end_define

begin_define
DECL|macro|BOX_B_LOG
define|#
directive|define
name|BOX_B_LOG
value|0
end_define

begin_define
DECL|macro|BOX_R_ELEMS
define|#
directive|define
name|BOX_R_ELEMS
value|(1<<BOX_R_LOG)
end_define

begin_comment
DECL|macro|BOX_R_ELEMS
comment|/* # of hist cells in update box */
end_comment

begin_define
DECL|macro|BOX_G_ELEMS
define|#
directive|define
name|BOX_G_ELEMS
value|(1<<BOX_G_LOG)
end_define

begin_define
DECL|macro|BOX_B_ELEMS
define|#
directive|define
name|BOX_B_ELEMS
value|(1<<BOX_B_LOG)
end_define

begin_define
DECL|macro|BOX_R_SHIFT
define|#
directive|define
name|BOX_R_SHIFT
value|(R_SHIFT + BOX_R_LOG)
end_define

begin_define
DECL|macro|BOX_G_SHIFT
define|#
directive|define
name|BOX_G_SHIFT
value|(G_SHIFT + BOX_G_LOG)
end_define

begin_define
DECL|macro|BOX_B_SHIFT
define|#
directive|define
name|BOX_B_SHIFT
value|(B_SHIFT + BOX_B_LOG)
end_define

begin_comment
comment|/*  * The next three routines implement inverse colormap filling.  They could  * all be folded into one big routine, but splitting them up this way saves  * some stack space (the mindist[] and bestdist[] arrays need not coexist)  * and may allow some compilers to produce better code by registerizing more  * inner-loop variables.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|find_nearby_colors (QuantizeObj * quantobj,int minR,int minG,int minB,int colorlist[])
name|find_nearby_colors
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|int
name|minR
parameter_list|,
name|int
name|minG
parameter_list|,
name|int
name|minB
parameter_list|,
name|int
name|colorlist
index|[]
parameter_list|)
comment|/* Locate the colormap entries close enough to an update box to be candidates  * for the nearest entry to some cell(s) in the update box.  The update box  * is specified by the center coordinates of its first cell.  The number of  * candidate colormap entries is returned, and their colormap indexes are  * placed in colorlist[].  * This routine uses Heckbert's "locally sorted search" criterion to select  * the colors that need further consideration.  */
block|{
name|int
name|numcolors
init|=
name|quantobj
operator|->
name|actual_number_of_colors
decl_stmt|;
name|int
name|maxR
decl_stmt|,
name|maxG
decl_stmt|,
name|maxB
decl_stmt|;
name|int
name|centerR
decl_stmt|,
name|centerG
decl_stmt|,
name|centerB
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|ncolors
decl_stmt|;
name|int
name|minmaxdist
decl_stmt|,
name|min_dist
decl_stmt|,
name|max_dist
decl_stmt|,
name|tdist
decl_stmt|;
name|int
name|mindist
index|[
name|MAXNUMCOLORS
index|]
decl_stmt|;
comment|/* min distance to colormap entry i */
comment|/* Compute true coordinates of update box's upper corner and center.    * Actually we compute the coordinates of the center of the upper-corner    * histogram cell, which are the upper bounds of the volume we care about.    * Note that since ">>" rounds down, the "center" values may be closer to    * min than to max; hence comparisons to them must be "<=", not "<".    */
name|maxR
operator|=
name|minR
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_R_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|R_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerR
operator|=
operator|(
name|minR
operator|+
name|maxR
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|maxG
operator|=
name|minG
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_G_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|G_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerG
operator|=
operator|(
name|minG
operator|+
name|maxG
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|maxB
operator|=
name|minB
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_B_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|B_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerB
operator|=
operator|(
name|minB
operator|+
name|maxB
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* For each color in colormap, find:    *  1. its minimum squared-distance to any point in the update box    *     (zero if color is within update box);    *  2. its maximum squared-distance to any point in the update box.    * Both of these can be found by considering only the corners of the box.    * We save the minimum distance for each color in mindist[];    * only the smallest maximum distance is of interest.    */
name|minmaxdist
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
comment|/* We compute the squared-R-distance term, then add in the other two. */
name|x
operator|=
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minR
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|min_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxR
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|min_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
name|min_dist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<=
name|centerR
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minR
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|x
operator|=
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minG
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxG
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
if|if
condition|(
name|x
operator|<=
name|centerG
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minG
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|x
operator|=
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minB
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxB
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
if|if
condition|(
name|x
operator|<=
name|centerB
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minB
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|mindist
index|[
name|i
index|]
operator|=
name|min_dist
expr_stmt|;
comment|/* save away the results */
if|if
condition|(
name|max_dist
operator|<
name|minmaxdist
condition|)
name|minmaxdist
operator|=
name|max_dist
expr_stmt|;
block|}
comment|/* Now we know that no cell in the update box is more than minmaxdist    * away from some colormap entry.  Therefore, only colors that are    * within minmaxdist of some part of the box need be considered.    */
name|ncolors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mindist
index|[
name|i
index|]
operator|<=
name|minmaxdist
condition|)
name|colorlist
index|[
name|ncolors
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
name|ncolors
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_best_colors (QuantizeObj * quantobj,int minR,int minG,int minB,int numcolors,int colorlist[],int bestcolor[])
name|find_best_colors
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|int
name|minR
parameter_list|,
name|int
name|minG
parameter_list|,
name|int
name|minB
parameter_list|,
name|int
name|numcolors
parameter_list|,
name|int
name|colorlist
index|[]
parameter_list|,
name|int
name|bestcolor
index|[]
parameter_list|)
comment|/* Find the closest colormap entry for each cell in the update box,  * given the list of candidate colors prepared by find_nearby_colors.  * Return the indexes of the closest entries in the bestcolor[] array.  * This routine uses Thomas' incremental distance calculation method to  * find the distance from a colormap entry to successive cells in the box.  */
block|{
name|int
name|iR
decl_stmt|,
name|iG
decl_stmt|,
name|iB
decl_stmt|;
name|int
name|i
decl_stmt|,
name|icolor
decl_stmt|;
name|int
modifier|*
name|bptr
decl_stmt|;
comment|/* pointer into bestdist[] array */
name|int
modifier|*
name|cptr
decl_stmt|;
comment|/* pointer into bestcolor[] array */
name|int
name|dist0
decl_stmt|,
name|dist1
decl_stmt|;
comment|/* initial distance values */
name|int
name|dist2
decl_stmt|;
comment|/* current distance in inner loop */
name|int
name|xx0
decl_stmt|,
name|xx1
decl_stmt|;
comment|/* distance increments */
name|int
name|xx2
decl_stmt|;
name|int
name|inR
decl_stmt|,
name|inG
decl_stmt|,
name|inB
decl_stmt|;
comment|/* initial values for increments */
comment|/* This array holds the distance to the nearest-so-far color for each cell */
name|int
name|bestdist
index|[
name|BOX_R_ELEMS
operator|*
name|BOX_G_ELEMS
operator|*
name|BOX_B_ELEMS
index|]
decl_stmt|;
comment|/* Initialize best-distance for each cell of the update box */
name|bptr
operator|=
name|bestdist
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BOX_R_ELEMS
operator|*
name|BOX_G_ELEMS
operator|*
name|BOX_B_ELEMS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|bptr
operator|++
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
comment|/* For each color selected by find_nearby_colors,    * compute its distance to the center of each cell in the box.    * If that's less than best-so-far, update best distance and color number.    */
comment|/* Nominal steps between cell centers ("x" in Thomas article) */
DECL|macro|STEP_R
define|#
directive|define
name|STEP_R
value|((1<< R_SHIFT) * R_SCALE)
DECL|macro|STEP_G
define|#
directive|define
name|STEP_G
value|((1<< G_SHIFT) * G_SCALE)
DECL|macro|STEP_B
define|#
directive|define
name|STEP_B
value|((1<< B_SHIFT) * B_SCALE)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
name|icolor
operator|=
name|colorlist
index|[
name|i
index|]
expr_stmt|;
comment|/* Compute (square of) distance from minR/G/B to this color */
name|inR
operator|=
operator|(
name|minR
operator|-
name|quantobj
operator|->
name|clin
index|[
name|icolor
index|]
operator|.
name|red
operator|)
operator|*
name|R_SCALE
expr_stmt|;
name|dist0
operator|=
name|inR
operator|*
name|inR
expr_stmt|;
comment|/* special-case for L*==0: chroma diffs irrelevant */
comment|/*    if (minR> 0 || quantobj->clin[icolor].red> 0) */
block|{
name|inG
operator|=
operator|(
name|minG
operator|-
name|quantobj
operator|->
name|clin
index|[
name|icolor
index|]
operator|.
name|green
operator|)
operator|*
name|G_SCALE
expr_stmt|;
name|dist0
operator|+=
name|inG
operator|*
name|inG
expr_stmt|;
name|inB
operator|=
operator|(
name|minB
operator|-
name|quantobj
operator|->
name|clin
index|[
name|icolor
index|]
operator|.
name|blue
operator|)
operator|*
name|B_SCALE
expr_stmt|;
name|dist0
operator|+=
name|inB
operator|*
name|inB
expr_stmt|;
block|}
comment|/*    else             { 		inG = 0; 		inB = 0; 		} */
comment|/* Form the initial difference increments */
name|inR
operator|=
name|inR
operator|*
operator|(
literal|2
operator|*
name|STEP_R
operator|)
operator|+
name|STEP_R
operator|*
name|STEP_R
expr_stmt|;
name|inG
operator|=
name|inG
operator|*
operator|(
literal|2
operator|*
name|STEP_G
operator|)
operator|+
name|STEP_G
operator|*
name|STEP_G
expr_stmt|;
name|inB
operator|=
name|inB
operator|*
operator|(
literal|2
operator|*
name|STEP_B
operator|)
operator|+
name|STEP_B
operator|*
name|STEP_B
expr_stmt|;
comment|/* Now loop over all cells in box, updating distance per Thomas method */
name|bptr
operator|=
name|bestdist
expr_stmt|;
name|cptr
operator|=
name|bestcolor
expr_stmt|;
name|xx0
operator|=
name|inR
expr_stmt|;
for|for
control|(
name|iR
operator|=
name|BOX_R_ELEMS
operator|-
literal|1
init|;
name|iR
operator|>=
literal|0
condition|;
name|iR
operator|--
control|)
block|{
name|dist1
operator|=
name|dist0
expr_stmt|;
name|xx1
operator|=
name|inG
expr_stmt|;
for|for
control|(
name|iG
operator|=
name|BOX_G_ELEMS
operator|-
literal|1
init|;
name|iG
operator|>=
literal|0
condition|;
name|iG
operator|--
control|)
block|{
name|dist2
operator|=
name|dist1
expr_stmt|;
name|xx2
operator|=
name|inB
expr_stmt|;
for|for
control|(
name|iB
operator|=
name|BOX_B_ELEMS
operator|-
literal|1
init|;
name|iB
operator|>=
literal|0
condition|;
name|iB
operator|--
control|)
block|{
if|if
condition|(
name|dist2
operator|<
operator|*
name|bptr
condition|)
block|{
operator|*
name|bptr
operator|=
name|dist2
expr_stmt|;
operator|*
name|cptr
operator|=
name|icolor
expr_stmt|;
block|}
name|dist2
operator|+=
name|xx2
expr_stmt|;
name|xx2
operator|+=
literal|2
operator|*
name|STEP_B
operator|*
name|STEP_B
expr_stmt|;
name|bptr
operator|++
expr_stmt|;
name|cptr
operator|++
expr_stmt|;
block|}
name|dist1
operator|+=
name|xx1
expr_stmt|;
name|xx1
operator|+=
literal|2
operator|*
name|STEP_G
operator|*
name|STEP_G
expr_stmt|;
block|}
name|dist0
operator|+=
name|xx0
expr_stmt|;
name|xx0
operator|+=
literal|2
operator|*
name|STEP_R
operator|*
name|STEP_R
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fill_inverse_cmap_gray (QuantizeObj * quantobj,CFHistogram histogram,int pixel)
name|fill_inverse_cmap_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|int
name|pixel
parameter_list|)
comment|/* Fill the inverse-colormap entries in the update box that contains */
comment|/* histogram cell R/G/B.  (Only that one cell MUST be filled, but */
comment|/* we can fill as many others as we wish.) */
block|{
name|Color
modifier|*
name|cmap
decl_stmt|;
name|long
name|dist
decl_stmt|;
name|long
name|mindist
decl_stmt|;
name|int
name|mindisti
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cmap
operator|=
name|quantobj
operator|->
name|cmap
expr_stmt|;
name|mindist
operator|=
literal|65536
expr_stmt|;
name|mindisti
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|i
operator|++
control|)
block|{
name|dist
operator|=
name|pixel
operator|-
name|cmap
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|dist
operator|*=
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|mindist
condition|)
block|{
name|mindist
operator|=
name|dist
expr_stmt|;
name|mindisti
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|histogram
index|[
name|pixel
index|]
operator|=
name|mindisti
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fill_inverse_cmap_rgb (QuantizeObj * quantobj,CFHistogram histogram,int R,int G,int B)
name|fill_inverse_cmap_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|CFHistogram
name|histogram
parameter_list|,
name|int
name|R
parameter_list|,
name|int
name|G
parameter_list|,
name|int
name|B
parameter_list|)
comment|/* Fill the inverse-colormap entries in the update box that contains */
comment|/* histogram cell R/G/B.  (Only that one cell MUST be filled, but */
comment|/* we can fill as many others as we wish.) */
block|{
name|int
name|minR
decl_stmt|,
name|minG
decl_stmt|,
name|minB
decl_stmt|;
comment|/* lower left corner of update box */
name|int
name|iR
decl_stmt|,
name|iG
decl_stmt|,
name|iB
decl_stmt|;
name|int
modifier|*
name|cptr
decl_stmt|;
comment|/* pointer into bestcolor[] array */
comment|/* This array lists the candidate colormap indexes. */
name|int
name|colorlist
index|[
name|MAXNUMCOLORS
index|]
decl_stmt|;
name|int
name|numcolors
decl_stmt|;
comment|/* number of candidate colors */
comment|/* This array holds the actually closest colormap index for each cell. */
name|int
name|bestcolor
index|[
name|BOX_R_ELEMS
operator|*
name|BOX_G_ELEMS
operator|*
name|BOX_B_ELEMS
index|]
decl_stmt|;
comment|/* Convert cell coordinates to update box id */
name|R
operator|>>=
name|BOX_R_LOG
expr_stmt|;
name|G
operator|>>=
name|BOX_G_LOG
expr_stmt|;
name|B
operator|>>=
name|BOX_B_LOG
expr_stmt|;
comment|/* Compute true coordinates of update box's origin corner.    * Actually we compute the coordinates of the center of the corner    * histogram cell, which are the lower bounds of the volume we care about.    */
name|minR
operator|=
operator|(
name|R
operator|<<
name|BOX_R_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|R_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|minG
operator|=
operator|(
name|G
operator|<<
name|BOX_G_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|G_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|minB
operator|=
operator|(
name|B
operator|<<
name|BOX_B_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|B_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Determine which colormap entries are close enough to be candidates    * for the nearest entry to some cell in the update box.    */
name|numcolors
operator|=
name|find_nearby_colors
argument_list|(
name|quantobj
argument_list|,
name|minR
argument_list|,
name|minG
argument_list|,
name|minB
argument_list|,
name|colorlist
argument_list|)
expr_stmt|;
comment|/* Determine the actually nearest colors. */
name|find_best_colors
argument_list|(
name|quantobj
argument_list|,
name|minR
argument_list|,
name|minG
argument_list|,
name|minB
argument_list|,
name|numcolors
argument_list|,
name|colorlist
argument_list|,
name|bestcolor
argument_list|)
expr_stmt|;
comment|/* Save the best color numbers (plus 1) in the main cache array */
name|R
operator|<<=
name|BOX_R_LOG
expr_stmt|;
comment|/* convert id back to base cell indexes */
name|G
operator|<<=
name|BOX_G_LOG
expr_stmt|;
name|B
operator|<<=
name|BOX_B_LOG
expr_stmt|;
name|cptr
operator|=
name|bestcolor
expr_stmt|;
for|for
control|(
name|iR
operator|=
literal|0
init|;
name|iR
operator|<
name|BOX_R_ELEMS
condition|;
name|iR
operator|++
control|)
block|{
for|for
control|(
name|iG
operator|=
literal|0
init|;
name|iG
operator|<
name|BOX_G_ELEMS
condition|;
name|iG
operator|++
control|)
block|{
for|for
control|(
name|iB
operator|=
literal|0
init|;
name|iB
operator|<
name|BOX_B_ELEMS
condition|;
name|iB
operator|++
control|)
block|{
operator|*
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
operator|+
name|iR
argument_list|,
name|G
operator|+
name|iG
argument_list|,
name|B
operator|+
name|iB
argument_list|)
operator|=
operator|(
operator|*
name|cptr
operator|++
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  This is pass 1  */
end_comment

begin_function
specifier|static
name|void
DECL|function|median_cut_pass1_gray (QuantizeObj * quantobj)
name|median_cut_pass1_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|select_colors_gray
argument_list|(
name|quantobj
argument_list|,
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass1_rgb (QuantizeObj * quantobj)
name|median_cut_pass1_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|select_colors_rgb
argument_list|(
name|quantobj
argument_list|,
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|monopal_pass1 (QuantizeObj * quantobj)
name|monopal_pass1
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
literal|2
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|0
index|]
operator|.
name|red
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|0
index|]
operator|.
name|green
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|0
index|]
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|1
index|]
operator|.
name|red
operator|=
literal|255
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|1
index|]
operator|.
name|green
operator|=
literal|255
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
literal|1
index|]
operator|.
name|blue
operator|=
literal|255
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|webpal_pass1 (QuantizeObj * quantobj)
name|webpal_pass1
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
literal|216
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|216
condition|;
name|i
operator|++
control|)
block|{
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
operator|=
name|webpal
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
operator|=
name|webpal
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|webpal
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|custompal_pass1 (QuantizeObj * quantobj)
name|custompal_pass1
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GimpPaletteEntry
modifier|*
name|entry
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
comment|/* fprintf(stderr, "custompal_pass1: using (theCustomPalette %s) from (file %s)\n", 			 theCustomPalette->name, theCustomPalette->filename); */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|list
operator|=
name|theCustomPalette
operator|->
name|colors
init|;
name|list
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|entry
operator|=
operator|(
name|GimpPaletteEntry
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|entry
operator|->
name|color
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
operator|=
operator|(
name|gint
operator|)
name|r
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|(
name|gint
operator|)
name|g
expr_stmt|;
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|gint
operator|)
name|b
expr_stmt|;
block|}
name|quantobj
operator|->
name|actual_number_of_colors
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map some rows of pixels to the output colormapped representation.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_no_dither_gray (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_no_dither_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|pixel
decl_stmt|;
name|gint
name|has_alpha
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
comment|/* get pixel value and index into the cache */
name|pixel
operator|=
name|src
index|[
name|GRAY_PIX
index|]
expr_stmt|;
name|cachep
operator|=
operator|&
name|histogram
index|[
name|pixel
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest colormap entry */
comment|/* and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_gray
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|+
name|srcPR
operator|.
name|x
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|+
name|srcPR
operator|.
name|y
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|)
condition|)
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
operator|*
name|cachep
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Now emit the colormap index for this cell */
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
operator|*
name|cachep
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_fixed_dither_gray (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_fixed_dither_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|gint
name|pixval1
init|=
literal|0
decl_stmt|,
name|pixval2
init|=
literal|0
decl_stmt|;
name|gint
name|err1
decl_stmt|,
name|err2
decl_stmt|;
name|Color
modifier|*
name|color1
decl_stmt|;
name|Color
modifier|*
name|color2
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|pixel
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
specifier|const
name|int
name|dmval
init|=
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|+
name|srcPR
operator|.
name|x
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|+
name|srcPR
operator|.
name|y
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
decl_stmt|;
comment|/* get pixel value and index into the cache */
name|pixel
operator|=
name|src
index|[
name|GRAY_PIX
index|]
expr_stmt|;
name|cachep
operator|=
operator|&
name|histogram
index|[
name|pixel
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest colormap entry */
comment|/* and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_gray
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|pixval1
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|color1
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval1
index|]
expr_stmt|;
if|if
condition|(
name|quantobj
operator|->
name|actual_number_of_colors
operator|>
literal|2
condition|)
block|{
specifier|const
name|int
name|re
init|=
name|src
index|[
name|GRAY_PIX
index|]
operator|-
operator|(
name|int
operator|)
name|color1
operator|->
name|red
decl_stmt|;
name|int
name|RV
init|=
name|src
index|[
name|GRAY_PIX
index|]
operator|+
name|re
decl_stmt|;
do|do
block|{
specifier|const
name|gint
name|R
init|=
name|CLAMP0255
argument_list|(
name|RV
argument_list|)
decl_stmt|;
name|cachep
operator|=
operator|&
name|histogram
index|[
name|R
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest                      colormap entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
block|{
name|fill_inverse_cmap_gray
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|R
argument_list|)
expr_stmt|;
block|}
name|pixval2
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|RV
operator|+=
name|re
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pixval1
operator|==
name|pixval2
operator|)
operator|&&
operator|(
operator|!
operator|(
name|RV
operator|>
literal|255
operator|||
name|RV
operator|<
literal|0
operator|)
operator|)
operator|&&
name|re
condition|)
do|;
block|}
else|else
block|{
comment|/* not enough colours to bother looking for an 'alternative'                    colour (we may fail to do so anyway), so decide that                    the alternative colour is simply the other cmap entry. */
name|pixval2
operator|=
operator|(
name|pixval1
operator|+
literal|1
operator|)
operator|%
operator|(
name|quantobj
operator|->
name|actual_number_of_colors
operator|)
expr_stmt|;
block|}
comment|/* always deterministically sort pixval1 and pixval2, to                  avoid artifacts in the dither range due to inverting our                  relative colour viewpoint -- most obvious in 1-bit dither. */
if|if
condition|(
name|pixval1
operator|>
name|pixval2
condition|)
block|{
name|gint
name|tmpval
init|=
name|pixval1
decl_stmt|;
name|pixval1
operator|=
name|pixval2
expr_stmt|;
name|pixval2
operator|=
name|tmpval
expr_stmt|;
name|color1
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval1
index|]
expr_stmt|;
block|}
name|color2
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval2
index|]
expr_stmt|;
name|err1
operator|=
name|ABS
argument_list|(
name|color1
operator|->
name|red
operator|-
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
name|err2
operator|=
name|ABS
argument_list|(
name|color2
operator|->
name|red
operator|-
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err1
operator|||
name|err2
condition|)
block|{
specifier|const
name|int
name|proportion2
init|=
operator|(
literal|256
operator|*
name|DM_RANGE
operator|*
name|err2
operator|)
operator|/
operator|(
name|err1
operator|+
name|err2
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|dmval
operator|*
literal|256
operator|)
operator|>
name|proportion2
condition|)
block|{
name|pixval1
operator|=
name|pixval2
expr_stmt|;
comment|/* use color2 instead of color1*/
block|}
block|}
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|dmval
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|)
condition|)
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|pixval1
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Now emit the colormap index for this cell, barfbarf */
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|pixval1
index|]
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_no_dither_rgb (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_no_dither_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|gint
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|red_pix
init|=
name|RED_PIX
decl_stmt|;
name|gint
name|green_pix
init|=
name|GREEN_PIX
decl_stmt|;
name|gint
name|blue_pix
init|=
name|BLUE_PIX
decl_stmt|;
name|gint
name|alpha_pix
init|=
name|ALPHA_PIX
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|glong
name|total_size
init|=
literal|0
decl_stmt|;
name|glong
name|layer_size
decl_stmt|;
name|gint
name|nth_layer
init|=
name|quantobj
operator|->
name|nth_layer
decl_stmt|;
name|gint
name|n_layers
init|=
name|quantobj
operator|->
name|n_layers
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
comment|/*  In the case of web/mono palettes, we actually force    *   grayscale drawables through the rgb pass2 functions    */
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|red_pix
operator|=
name|green_pix
operator|=
name|blue_pix
operator|=
name|GRAY_PIX
expr_stmt|;
name|alpha_pix
operator|=
name|ALPHA_G_PIX
expr_stmt|;
block|}
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer_size
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
operator|*
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
name|total_size
operator|+=
name|srcPR
operator|.
name|h
operator|*
name|srcPR
operator|.
name|w
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|+
name|srcPR
operator|.
name|x
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|+
name|srcPR
operator|.
name|y
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|next_pixel
goto|;
block|}
block|}
comment|/* get pixel value and index into the cache */
name|rgb_to_lin
argument_list|(
name|src
index|[
name|red_pix
index|]
argument_list|,
name|src
index|[
name|green_pix
index|]
argument_list|,
name|src
index|[
name|blue_pix
index|]
argument_list|,
operator|&
name|R
argument_list|,
operator|&
name|G
argument_list|,
operator|&
name|B
argument_list|)
expr_stmt|;
name|cachep
operator|=
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* If we have not seen this color before, find nearest 		 colormap entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_rgb
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* Now emit the colormap index for this cell, barfbarf */
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
operator|*
name|cachep
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|next_pixel
label|:
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quantobj
operator|->
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|quantobj
operator|->
name|progress
argument_list|,
operator|(
name|nth_layer
operator|+
operator|(
operator|(
name|gdouble
operator|)
name|total_size
operator|)
operator|/
name|layer_size
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|n_layers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_fixed_dither_rgb (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_fixed_dither_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|gint
name|pixval1
init|=
literal|0
decl_stmt|,
name|pixval2
init|=
literal|0
decl_stmt|;
name|Color
modifier|*
name|color1
decl_stmt|;
name|Color
modifier|*
name|color2
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|gint
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|gint
name|err1
decl_stmt|,
name|err2
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|red_pix
init|=
name|RED_PIX
decl_stmt|;
name|gint
name|green_pix
init|=
name|GREEN_PIX
decl_stmt|;
name|gint
name|blue_pix
init|=
name|BLUE_PIX
decl_stmt|;
name|gint
name|alpha_pix
init|=
name|ALPHA_PIX
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|glong
name|total_size
init|=
literal|0
decl_stmt|;
name|glong
name|layer_size
decl_stmt|;
name|gint
name|nth_layer
init|=
name|quantobj
operator|->
name|nth_layer
decl_stmt|;
name|gint
name|n_layers
init|=
name|quantobj
operator|->
name|n_layers
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
comment|/*  In the case of web/mono palettes, we actually force    *   grayscale drawables through the rgb pass2 functions    */
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|red_pix
operator|=
name|green_pix
operator|=
name|blue_pix
operator|=
name|GRAY_PIX
expr_stmt|;
name|alpha_pix
operator|=
name|ALPHA_G_PIX
expr_stmt|;
block|}
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer_size
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
operator|*
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
name|total_size
operator|+=
name|srcPR
operator|.
name|h
operator|*
name|srcPR
operator|.
name|w
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
specifier|const
name|int
name|dmval
init|=
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|+
name|srcPR
operator|.
name|x
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|+
name|srcPR
operator|.
name|y
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
decl_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|dmval
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|next_pixel
goto|;
block|}
block|}
comment|/* get pixel value and index into the cache */
name|rgb_to_lin
argument_list|(
name|src
index|[
name|red_pix
index|]
argument_list|,
name|src
index|[
name|green_pix
index|]
argument_list|,
name|src
index|[
name|blue_pix
index|]
argument_list|,
operator|&
name|R
argument_list|,
operator|&
name|G
argument_list|,
operator|&
name|B
argument_list|)
expr_stmt|;
name|cachep
operator|=
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* If we have not seen this color before, find nearest 		 colormap entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_rgb
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* We now try to find a colour which, when mixed in some fashion                  with the closest match, yields something closer to the                  desired colour.  We do this by repeatedly extrapolating the                  colour vector from one to the other until we find another                  colour cell.  Then we assess the distance of both mixer                  colours from the intended colour to determine their relative                  probabilities of being chosen. */
name|pixval1
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|color1
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval1
index|]
expr_stmt|;
if|if
condition|(
name|quantobj
operator|->
name|actual_number_of_colors
operator|>
literal|2
condition|)
block|{
specifier|const
name|int
name|re
init|=
name|src
index|[
name|red_pix
index|]
operator|-
operator|(
name|int
operator|)
name|color1
operator|->
name|red
decl_stmt|;
specifier|const
name|int
name|ge
init|=
name|src
index|[
name|green_pix
index|]
operator|-
operator|(
name|int
operator|)
name|color1
operator|->
name|green
decl_stmt|;
specifier|const
name|int
name|be
init|=
name|src
index|[
name|blue_pix
index|]
operator|-
operator|(
name|int
operator|)
name|color1
operator|->
name|blue
decl_stmt|;
name|int
name|RV
init|=
name|src
index|[
name|red_pix
index|]
operator|+
name|re
decl_stmt|;
name|int
name|GV
init|=
name|src
index|[
name|green_pix
index|]
operator|+
name|ge
decl_stmt|;
name|int
name|BV
init|=
name|src
index|[
name|blue_pix
index|]
operator|+
name|be
decl_stmt|;
do|do
block|{
name|rgb_to_lin
argument_list|(
operator|(
name|CLAMP0255
argument_list|(
name|RV
argument_list|)
operator|)
argument_list|,
operator|(
name|CLAMP0255
argument_list|(
name|GV
argument_list|)
operator|)
argument_list|,
operator|(
name|CLAMP0255
argument_list|(
name|BV
argument_list|)
operator|)
argument_list|,
operator|&
name|R
argument_list|,
operator|&
name|G
argument_list|,
operator|&
name|B
argument_list|)
expr_stmt|;
name|cachep
operator|=
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* If we have not seen this color before, find nearest                      colormap entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
block|{
name|fill_inverse_cmap_rgb
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
name|pixval2
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|RV
operator|+=
name|re
expr_stmt|;
name|GV
operator|+=
name|ge
expr_stmt|;
name|BV
operator|+=
name|be
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pixval1
operator|==
name|pixval2
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|RV
operator|>
literal|255
operator|||
name|RV
operator|<
literal|0
operator|)
operator|||
operator|(
name|GV
operator|>
literal|255
operator|||
name|GV
operator|<
literal|0
operator|)
operator|||
operator|(
name|BV
operator|>
literal|255
operator|||
name|BV
operator|<
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|re
operator|||
name|ge
operator|||
name|be
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|quantobj
operator|->
name|actual_number_of_colors
operator|<=
literal|2
comment|/* || pixval1 == pixval2 */
condition|)
block|{
comment|/* not enough colours to bother looking for an 'alternative'                    colour (we may fail to do so anyway), so decide that                    the alternative colour is simply the other cmap entry. */
name|pixval2
operator|=
operator|(
name|pixval1
operator|+
literal|1
operator|)
operator|%
operator|(
name|quantobj
operator|->
name|actual_number_of_colors
operator|)
expr_stmt|;
block|}
comment|/* always deterministically sort pixval1 and pixval2, to                  avoid artifacts in the dither range due to inverting our                  relative colour viewpoint -- most obvious in 1-bit dither. */
if|if
condition|(
name|pixval1
operator|>
name|pixval2
condition|)
block|{
name|gint
name|tmpval
init|=
name|pixval1
decl_stmt|;
name|pixval1
operator|=
name|pixval2
expr_stmt|;
name|pixval2
operator|=
name|tmpval
expr_stmt|;
name|color1
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval1
index|]
expr_stmt|;
block|}
name|color2
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|pixval2
index|]
expr_stmt|;
comment|/* now figure out the relative probabilites of choosing                  either of our candidates. */
DECL|macro|DISTP (R1,G1,B1,R2,G2,B2,D)
define|#
directive|define
name|DISTP
parameter_list|(
name|R1
parameter_list|,
name|G1
parameter_list|,
name|B1
parameter_list|,
name|R2
parameter_list|,
name|G2
parameter_list|,
name|B2
parameter_list|,
name|D
parameter_list|)
value|do {D = sqrt( 30*SQR((R1)-(R2)) + \                                                  59*SQR((G1)-(G2)) + \                                                  11*SQR((B1)-(B2)) ); }while(0)
DECL|macro|LIN_DISTP (R1,G1,B1,R2,G2,B2,D)
define|#
directive|define
name|LIN_DISTP
parameter_list|(
name|R1
parameter_list|,
name|G1
parameter_list|,
name|B1
parameter_list|,
name|R2
parameter_list|,
name|G2
parameter_list|,
name|B2
parameter_list|,
name|D
parameter_list|)
value|do { \                 int spacer1, spaceg1, spaceb1; \                 int spacer2, spaceg2, spaceb2; \                 rgb_to_unshifted_lin(R1,G1,B1,&spacer1,&spaceg1,&spaceb1); \                 rgb_to_unshifted_lin(R2,G2,B2,&spacer2,&spaceg2,&spaceb2); \                 D = sqrt(R_SCALE * SQR((spacer1)-(spacer2)) + \                          G_SCALE * SQR((spaceg1)-(spaceg2)) + \                          B_SCALE * SQR((spaceb1)-(spaceb2))); \               } while(0)
comment|/* although LIN_DISTP is more correct, DISTP is much faster and                  barely distinguishable. */
name|DISTP
argument_list|(
name|color1
operator|->
name|red
argument_list|,
name|color1
operator|->
name|green
argument_list|,
name|color1
operator|->
name|blue
argument_list|,
name|src
index|[
name|red_pix
index|]
argument_list|,
name|src
index|[
name|green_pix
index|]
argument_list|,
name|src
index|[
name|blue_pix
index|]
argument_list|,
name|err1
argument_list|)
expr_stmt|;
name|DISTP
argument_list|(
name|color2
operator|->
name|red
argument_list|,
name|color2
operator|->
name|green
argument_list|,
name|color2
operator|->
name|blue
argument_list|,
name|src
index|[
name|red_pix
index|]
argument_list|,
name|src
index|[
name|green_pix
index|]
argument_list|,
name|src
index|[
name|blue_pix
index|]
argument_list|,
name|err2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err1
operator|||
name|err2
condition|)
block|{
specifier|const
name|int
name|proportion2
init|=
operator|(
name|DM_RANGE
operator|*
name|err2
operator|)
operator|/
operator|(
name|err1
operator|+
name|err2
operator|)
decl_stmt|;
if|if
condition|(
name|dmval
operator|>
name|proportion2
condition|)
block|{
name|pixval1
operator|=
name|pixval2
expr_stmt|;
comment|/* use color2 instead of color1*/
block|}
block|}
comment|/* Now emit the colormap index for this cell, barfbarf */
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|pixval1
index|]
operator|++
expr_stmt|;
name|next_pixel
label|:
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quantobj
operator|->
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|quantobj
operator|->
name|progress
argument_list|,
operator|(
name|nth_layer
operator|+
operator|(
operator|(
name|gdouble
operator|)
name|total_size
operator|)
operator|/
name|layer_size
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|n_layers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_nodestruct_dither_rgb (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_nodestruct_dither_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|red_pix
init|=
name|RED_PIX
decl_stmt|;
name|gint
name|green_pix
init|=
name|GREEN_PIX
decl_stmt|;
name|gint
name|blue_pix
init|=
name|BLUE_PIX
decl_stmt|;
name|gint
name|alpha_pix
init|=
name|ALPHA_PIX
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|lastindex
init|=
literal|0
decl_stmt|;
name|gint
name|lastred
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|lastgreen
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|lastblue
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|has_alpha
operator|&&
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
name|col
operator|+
name|srcPR
operator|.
name|x
operator|+
name|offsetx
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|srcPR
operator|.
name|y
operator|+
name|offsety
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|>
literal|127
operator|)
operator|)
operator|)
operator|||
operator|!
name|has_alpha
condition|)
block|{
if|if
condition|(
operator|(
name|lastred
operator|==
name|src
index|[
name|red_pix
index|]
operator|)
operator|&&
operator|(
name|lastgreen
operator|==
name|src
index|[
name|green_pix
index|]
operator|)
operator|&&
operator|(
name|lastblue
operator|==
name|src
index|[
name|blue_pix
index|]
operator|)
condition|)
block|{
comment|/*  same pixel colour as last time  */
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|lastindex
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
operator|==
name|src
index|[
name|green_pix
index|]
operator|)
operator|&&
operator|(
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
operator|==
name|src
index|[
name|red_pix
index|]
operator|)
operator|&&
operator|(
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
operator|==
name|src
index|[
name|blue_pix
index|]
operator|)
condition|)
block|{
name|lastred
operator|=
name|src
index|[
name|red_pix
index|]
expr_stmt|;
name|lastgreen
operator|=
name|src
index|[
name|green_pix
index|]
expr_stmt|;
name|lastblue
operator|=
name|src
index|[
name|blue_pix
index|]
expr_stmt|;
name|lastindex
operator|=
name|i
expr_stmt|;
goto|goto
name|got_colour
goto|;
block|}
block|}
name|g_error
argument_list|(
literal|"Non-existant colour was expected to "
literal|"be in non-destructive colourmap."
argument_list|)
expr_stmt|;
name|got_colour
label|:
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|lastindex
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  have alpha, and transparent  */
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the error-limiting transfer function (lookup table).  * The raw F-S error computation can potentially compute error values of up to  * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be  * much less, otherwise obviously wrong pixels will be created.  (Typical  * effects include weird fringes at color-area boundaries, isolated bright  * pixels in a dark area, etc.)  The standard advice for avoiding this problem  * is to ensure that the "corners" of the color cube are allocated as output  * colors; then repeated errors in the same direction cannot cause cascading  * error buildup.  However, that only prevents the error from getting  * completely out of hand; Aaron Giles reports that error limiting improves  * the results even with corner colors allocated.  * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty  * well, but the smoother transfer function used below is even better.  Thanks  * to Aaron Giles for this idea.  */
end_comment

begin_function
specifier|static
name|int
modifier|*
DECL|function|init_error_limit (const int error_freedom)
name|init_error_limit
parameter_list|(
specifier|const
name|int
name|error_freedom
parameter_list|)
comment|/* Allocate and fill in the error_limiter table */
block|{
name|int
modifier|*
name|table
decl_stmt|;
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* #define STEPSIZE 16 */
comment|/* #define STEPSIZE 200 */
name|table
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
literal|255
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|table
operator|+=
literal|255
expr_stmt|;
comment|/* so we can index -255 ... +255 */
if|if
condition|(
name|error_freedom
operator|==
literal|0
condition|)
block|{
comment|/* Coarse function, much bleeding. */
specifier|const
name|int
name|STEPSIZE
init|=
literal|190
decl_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|STEPSIZE
condition|;
name|in
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|in
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|in
expr_stmt|;
block|}
for|for
control|(
init|;
name|in
operator|<=
literal|255
condition|;
name|in
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|STEPSIZE
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|STEPSIZE
expr_stmt|;
block|}
return|return
operator|(
name|table
operator|)
return|;
block|}
else|else
block|{
comment|/* Smooth function, bleeding more constrained */
specifier|const
name|int
name|STEPSIZE
init|=
literal|24
decl_stmt|;
comment|/* Map errors 1:1 up to +- STEPSIZE */
name|out
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|STEPSIZE
condition|;
name|in
operator|++
operator|,
name|out
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
comment|/* Map errors 1:2 up to +- 3*STEPSIZE */
for|for
control|(
init|;
name|in
operator|<
name|STEPSIZE
operator|*
literal|3
condition|;
name|in
operator|++
operator|,
name|out
operator|+=
operator|(
name|in
operator|&
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
comment|/* Clamp the rest to final out value (which is STEPSIZE*2) */
for|for
control|(
init|;
name|in
operator|<=
literal|255
condition|;
name|in
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map some rows of pixels to the output colormapped representation.  * Perform floyd-steinberg dithering.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_fs_dither_gray (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_fs_dither_gray
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|Color
modifier|*
name|color
decl_stmt|;
name|gint
modifier|*
name|error_limiter
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|fs_err1
decl_stmt|,
modifier|*
name|fs_err2
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|fs_err3
decl_stmt|,
modifier|*
name|fs_err4
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|range_limiter
decl_stmt|;
name|gint
name|src_bytes
decl_stmt|,
name|dest_bytes
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|guchar
modifier|*
name|src_buf
decl_stmt|,
modifier|*
name|dest_buf
decl_stmt|;
name|gint
modifier|*
name|next_row
decl_stmt|,
modifier|*
name|prev_row
decl_stmt|;
name|gint
modifier|*
name|nr
decl_stmt|,
modifier|*
name|pr
decl_stmt|;
name|gint
modifier|*
name|tmp
decl_stmt|;
name|gint
name|pixel
decl_stmt|;
name|gint
name|pixele
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|step_dest
decl_stmt|,
name|step_src
decl_stmt|;
name|gint
name|odd_row
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|src_bytes
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|bytes
expr_stmt|;
name|dest_bytes
operator|=
name|tile_manager_bpp
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
name|width
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
expr_stmt|;
name|error_limiter
operator|=
name|init_error_limit
argument_list|(
name|quantobj
operator|->
name|error_freedom
argument_list|)
expr_stmt|;
name|range_limiter
operator|=
name|range_array
operator|+
literal|256
expr_stmt|;
name|src_buf
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|src_bytes
argument_list|)
expr_stmt|;
name|dest_buf
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|dest_bytes
argument_list|)
expr_stmt|;
name|next_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gint
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|prev_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gint
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|prev_row
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fs_err1
operator|=
name|floyd_steinberg_error1
operator|+
literal|511
expr_stmt|;
name|fs_err2
operator|=
name|floyd_steinberg_error2
operator|+
literal|511
expr_stmt|;
name|fs_err3
operator|=
name|floyd_steinberg_error3
operator|+
literal|511
expr_stmt|;
name|fs_err4
operator|=
name|floyd_steinberg_error4
operator|+
literal|511
expr_stmt|;
name|odd_row
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|width
argument_list|,
name|src_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|src_buf
expr_stmt|;
name|dest
operator|=
name|dest_buf
expr_stmt|;
name|nr
operator|=
name|next_row
expr_stmt|;
name|pr
operator|=
name|prev_row
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|odd_row
condition|)
block|{
name|step_dest
operator|=
operator|-
name|dest_bytes
expr_stmt|;
name|step_src
operator|=
operator|-
name|src_bytes
expr_stmt|;
name|src
operator|+=
operator|(
name|width
operator|*
name|src_bytes
operator|)
operator|-
name|src_bytes
expr_stmt|;
name|dest
operator|+=
operator|(
name|width
operator|*
name|dest_bytes
operator|)
operator|-
name|dest_bytes
expr_stmt|;
name|nr
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
name|pr
operator|+=
name|width
expr_stmt|;
operator|*
operator|(
name|nr
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|step_dest
operator|=
name|dest_bytes
expr_stmt|;
name|step_src
operator|=
name|src_bytes
expr_stmt|;
operator|*
operator|(
name|nr
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|pixel
operator|=
name|range_limiter
index|[
name|src
index|[
name|GRAY_PIX
index|]
operator|+
name|error_limiter
index|[
operator|*
name|pr
index|]
index|]
expr_stmt|;
name|cachep
operator|=
operator|&
name|histogram
index|[
name|pixel
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest colormap entry */
comment|/* and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_gray
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
name|odd_row
condition|)
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
operator|(
name|width
operator|-
name|col
operator|)
operator|+
name|offsetx
operator|-
literal|1
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|--
expr_stmt|;
name|nr
operator|--
expr_stmt|;
operator|*
operator|(
name|nr
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_pixel
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|ALPHA_G_PIX
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
operator|*
operator|(
name|nr
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_pixel
goto|;
block|}
block|}
block|}
name|index
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|index_used_count
index|[
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|index
index|]
operator|++
expr_stmt|;
name|color
operator|=
operator|&
name|quantobj
operator|->
name|cmap
index|[
name|index
index|]
expr_stmt|;
name|pixele
operator|=
name|pixel
operator|-
name|color
operator|->
name|red
expr_stmt|;
if|if
condition|(
name|odd_row
condition|)
block|{
operator|*
operator|(
operator|--
name|pr
operator|)
operator|+=
name|fs_err1
index|[
name|pixele
index|]
expr_stmt|;
operator|*
name|nr
operator|--
operator|+=
name|fs_err2
index|[
name|pixele
index|]
expr_stmt|;
operator|*
name|nr
operator|+=
name|fs_err3
index|[
name|pixele
index|]
expr_stmt|;
operator|*
operator|(
name|nr
operator|-
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|pixele
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|++
name|pr
operator|)
operator|+=
name|fs_err1
index|[
name|pixele
index|]
expr_stmt|;
operator|*
name|nr
operator|++
operator|+=
name|fs_err2
index|[
name|pixele
index|]
expr_stmt|;
operator|*
name|nr
operator|+=
name|fs_err3
index|[
name|pixele
index|]
expr_stmt|;
operator|*
operator|(
name|nr
operator|+
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|pixele
index|]
expr_stmt|;
block|}
name|next_pixel
label|:
name|dest
operator|+=
name|step_dest
expr_stmt|;
name|src
operator|+=
name|step_src
expr_stmt|;
block|}
name|tmp
operator|=
name|next_row
expr_stmt|;
name|next_row
operator|=
name|prev_row
expr_stmt|;
name|prev_row
operator|=
name|tmp
expr_stmt|;
name|odd_row
operator|=
operator|!
name|odd_row
expr_stmt|;
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|width
argument_list|,
name|dest_buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|error_limiter
operator|-
literal|255
argument_list|)
expr_stmt|;
comment|/* good lord. */
name|g_free
argument_list|(
name|next_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|prev_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_rgb_init (QuantizeObj * quantobj)
name|median_cut_pass2_rgb_init
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zero_histogram_rgb
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
comment|/* Mark all indices as currently unused */
name|memset
argument_list|(
name|quantobj
operator|->
name|index_used_count
argument_list|,
literal|0
argument_list|,
literal|256
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* Make a version of our discovered colourmap in linear space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|i
operator|++
control|)
block|{
name|rgb_to_unshifted_lin
argument_list|(
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|red
argument_list|,
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|green
argument_list|,
name|quantobj
operator|->
name|cmap
index|[
name|i
index|]
operator|.
name|blue
argument_list|,
operator|&
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|red
argument_list|,
operator|&
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|green
argument_list|,
operator|&
name|quantobj
operator|->
name|clin
index|[
name|i
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_gray_init (QuantizeObj * quantobj)
name|median_cut_pass2_gray_init
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|zero_histogram_gray
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
comment|/* Mark all indices as currently unused */
name|memset
argument_list|(
name|quantobj
operator|->
name|index_used_count
argument_list|,
literal|0
argument_list|,
literal|256
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|median_cut_pass2_fs_dither_rgb (QuantizeObj * quantobj,GimpLayer * layer,TileManager * new_tiles)
name|median_cut_pass2_fs_dither_rgb
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|TileManager
modifier|*
name|new_tiles
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|CFHistogram
name|histogram
init|=
name|quantobj
operator|->
name|histogram
decl_stmt|;
name|ColorFreq
modifier|*
name|cachep
decl_stmt|;
name|Color
modifier|*
name|color
decl_stmt|;
name|gint
modifier|*
name|error_limiter
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|fs_err1
decl_stmt|,
modifier|*
name|fs_err2
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|fs_err3
decl_stmt|,
modifier|*
name|fs_err4
decl_stmt|;
specifier|const
name|gshort
modifier|*
name|range_limiter
decl_stmt|;
name|gint
name|src_bytes
decl_stmt|,
name|dest_bytes
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|guchar
modifier|*
name|src_buf
decl_stmt|,
modifier|*
name|dest_buf
decl_stmt|;
name|gint
modifier|*
name|red_n_row
decl_stmt|,
modifier|*
name|red_p_row
decl_stmt|;
name|gint
modifier|*
name|grn_n_row
decl_stmt|,
modifier|*
name|grn_p_row
decl_stmt|;
name|gint
modifier|*
name|blu_n_row
decl_stmt|,
modifier|*
name|blu_p_row
decl_stmt|;
name|gint
modifier|*
name|rnr
decl_stmt|,
modifier|*
name|rpr
decl_stmt|;
name|gint
modifier|*
name|gnr
decl_stmt|,
modifier|*
name|gpr
decl_stmt|;
name|gint
modifier|*
name|bnr
decl_stmt|,
modifier|*
name|bpr
decl_stmt|;
name|gint
modifier|*
name|tmp
decl_stmt|;
name|gint
name|re
decl_stmt|,
name|ge
decl_stmt|,
name|be
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|step_dest
decl_stmt|,
name|step_src
decl_stmt|;
name|gint
name|odd_row
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|red_pix
init|=
name|RED_PIX
decl_stmt|;
name|gint
name|green_pix
init|=
name|GREEN_PIX
decl_stmt|;
name|gint
name|blue_pix
init|=
name|BLUE_PIX
decl_stmt|;
name|gint
name|alpha_pix
init|=
name|ALPHA_PIX
decl_stmt|;
name|gint
name|offsetx
decl_stmt|,
name|offsety
decl_stmt|;
name|gboolean
name|alpha_dither
init|=
name|quantobj
operator|->
name|want_alpha_dither
decl_stmt|;
name|gulong
modifier|*
name|index_used_count
init|=
name|quantobj
operator|->
name|index_used_count
decl_stmt|;
name|gint
name|global_rmax
init|=
literal|0
decl_stmt|,
name|global_rmin
init|=
name|G_MAXINT
decl_stmt|;
name|gint
name|global_gmax
init|=
literal|0
decl_stmt|,
name|global_gmin
init|=
name|G_MAXINT
decl_stmt|;
name|gint
name|global_bmax
init|=
literal|0
decl_stmt|,
name|global_bmin
init|=
name|G_MAXINT
decl_stmt|;
name|gint
name|nth_layer
init|=
name|quantobj
operator|->
name|nth_layer
decl_stmt|;
name|gint
name|n_layers
init|=
name|quantobj
operator|->
name|n_layers
decl_stmt|;
name|gimp_item_offsets
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offsetx
argument_list|,
operator|&
name|offsety
argument_list|)
expr_stmt|;
comment|/*  In the case of web/mono palettes, we actually force    *   grayscale drawables through the rgb pass2 functions    */
if|if
condition|(
name|gimp_drawable_is_gray
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|red_pix
operator|=
name|green_pix
operator|=
name|blue_pix
operator|=
name|GRAY_PIX
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|new_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|src_bytes
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|bytes
expr_stmt|;
name|dest_bytes
operator|=
name|tile_manager_bpp
argument_list|(
name|new_tiles
argument_list|)
expr_stmt|;
name|width
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|height
expr_stmt|;
name|error_limiter
operator|=
name|init_error_limit
argument_list|(
name|quantobj
operator|->
name|error_freedom
argument_list|)
expr_stmt|;
name|range_limiter
operator|=
name|range_array
operator|+
literal|256
expr_stmt|;
comment|/* find the bounding box of the palette colours --      we use this for hard-clamping our error-corrected      values so that we can't continuously accelerate outside      of our attainable gamut, which looks icky. */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|quantobj
operator|->
name|actual_number_of_colors
condition|;
name|index
operator|++
control|)
block|{
name|global_rmax
operator|=
name|MAX
argument_list|(
name|global_rmax
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|red
argument_list|)
expr_stmt|;
name|global_rmin
operator|=
name|MIN
argument_list|(
name|global_rmin
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|red
argument_list|)
expr_stmt|;
name|global_gmax
operator|=
name|MAX
argument_list|(
name|global_gmax
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|green
argument_list|)
expr_stmt|;
name|global_gmin
operator|=
name|MIN
argument_list|(
name|global_gmin
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|green
argument_list|)
expr_stmt|;
name|global_bmax
operator|=
name|MAX
argument_list|(
name|global_bmax
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
name|global_bmin
operator|=
name|MIN
argument_list|(
name|global_bmin
argument_list|,
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
name|src_buf
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|src_bytes
argument_list|)
expr_stmt|;
name|dest_buf
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|dest_bytes
argument_list|)
expr_stmt|;
name|red_n_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|red_p_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grn_n_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grn_p_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|blu_n_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|blu_p_row
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|red_p_row
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|grn_p_row
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blu_p_row
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fs_err1
operator|=
name|floyd_steinberg_error1
operator|+
literal|511
expr_stmt|;
name|fs_err2
operator|=
name|floyd_steinberg_error2
operator|+
literal|511
expr_stmt|;
name|fs_err3
operator|=
name|floyd_steinberg_error3
operator|+
literal|511
expr_stmt|;
name|fs_err4
operator|=
name|floyd_steinberg_error4
operator|+
literal|511
expr_stmt|;
name|odd_row
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
operator|&
name|srcPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|width
argument_list|,
name|src_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|src_buf
expr_stmt|;
name|dest
operator|=
name|dest_buf
expr_stmt|;
name|rnr
operator|=
name|red_n_row
expr_stmt|;
name|gnr
operator|=
name|grn_n_row
expr_stmt|;
name|bnr
operator|=
name|blu_n_row
expr_stmt|;
name|rpr
operator|=
name|red_p_row
operator|+
literal|1
expr_stmt|;
name|gpr
operator|=
name|grn_p_row
operator|+
literal|1
expr_stmt|;
name|bpr
operator|=
name|blu_p_row
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|odd_row
condition|)
block|{
name|step_dest
operator|=
operator|-
name|dest_bytes
expr_stmt|;
name|step_src
operator|=
operator|-
name|src_bytes
expr_stmt|;
name|src
operator|+=
operator|(
name|width
operator|*
name|src_bytes
operator|)
operator|-
name|src_bytes
expr_stmt|;
name|dest
operator|+=
operator|(
name|width
operator|*
name|dest_bytes
operator|)
operator|-
name|dest_bytes
expr_stmt|;
name|rnr
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
name|gnr
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
name|bnr
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
name|rpr
operator|+=
name|width
expr_stmt|;
name|gpr
operator|+=
name|width
expr_stmt|;
name|bpr
operator|+=
name|width
expr_stmt|;
operator|*
operator|(
name|rnr
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
name|gnr
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
name|bnr
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|step_dest
operator|=
name|dest_bytes
expr_stmt|;
name|step_src
operator|=
name|src_bytes
expr_stmt|;
operator|*
operator|(
name|rnr
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|gnr
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|bnr
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|rnr
operator|=
operator|*
name|gnr
operator|=
operator|*
name|bnr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
name|odd_row
condition|)
block|{
comment|/* I get goosebumps over this expression. */
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
operator|(
name|width
operator|-
name|col
operator|)
operator|+
name|offsetx
operator|-
literal|1
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|rpr
operator|--
expr_stmt|;
name|gpr
operator|--
expr_stmt|;
name|bpr
operator|--
expr_stmt|;
name|rnr
operator|--
expr_stmt|;
name|gnr
operator|--
expr_stmt|;
name|bnr
operator|--
expr_stmt|;
operator|*
operator|(
name|rnr
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
name|gnr
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
name|bnr
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_pixel
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dest
index|[
name|ALPHA_I_PIX
index|]
operator|=
operator|(
name|alpha_dither
condition|?
operator|(
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|<<
literal|6
operator|)
operator|>
operator|(
literal|255
operator|*
name|DM
index|[
operator|(
name|col
operator|+
name|offsetx
operator|)
operator|&
name|DM_WIDTHMASK
index|]
index|[
operator|(
name|row
operator|+
name|offsety
operator|)
operator|&
name|DM_HEIGHTMASK
index|]
operator|)
operator|)
else|:
operator|(
name|src
index|[
name|alpha_pix
index|]
operator|>
literal|127
operator|)
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|rpr
operator|++
expr_stmt|;
name|gpr
operator|++
expr_stmt|;
name|bpr
operator|++
expr_stmt|;
name|rnr
operator|++
expr_stmt|;
name|gnr
operator|++
expr_stmt|;
name|bnr
operator|++
expr_stmt|;
operator|*
operator|(
name|rnr
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|gnr
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|bnr
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_pixel
goto|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* hmm. */
block|r = range_limiter[src[red_pix] + error_limiter[*rpr]]; 	  g = range_limiter[src[green_pix] + error_limiter[*gpr]]; 	  b = range_limiter[src[blue_pix] + error_limiter[*bpr]];  	  re = r>> R_SHIFT; 	  ge = g>> G_SHIFT; 	  be = b>> B_SHIFT;  	  rgb_to_lin (r, g, b,&re,&ge,&be);
endif|#
directive|endif
name|rgb_to_unshifted_lin
argument_list|(
name|src
index|[
name|red_pix
index|]
argument_list|,
name|src
index|[
name|green_pix
index|]
argument_list|,
name|src
index|[
name|blue_pix
index|]
argument_list|,
operator|&
name|re
argument_list|,
operator|&
name|ge
argument_list|,
operator|&
name|be
argument_list|)
expr_stmt|;
comment|/* 	    re = CLAMP(re, global_rmin, global_rmax); 	    ge = CLAMP(ge, global_gmin, global_gmax); 	    be = CLAMP(be, global_bmin, global_bmax);*/
name|re
operator|=
name|range_limiter
index|[
name|re
operator|+
name|error_limiter
index|[
operator|*
name|rpr
index|]
index|]
expr_stmt|;
name|ge
operator|=
name|range_limiter
index|[
name|ge
operator|+
name|error_limiter
index|[
operator|*
name|gpr
index|]
index|]
expr_stmt|;
name|be
operator|=
name|range_limiter
index|[
name|be
operator|+
name|error_limiter
index|[
operator|*
name|bpr
index|]
index|]
expr_stmt|;
name|cachep
operator|=
name|HIST_LIN
argument_list|(
name|histogram
argument_list|,
name|RSDF
argument_list|(
name|re
argument_list|)
argument_list|,
name|GSDF
argument_list|(
name|ge
argument_list|)
argument_list|,
name|BSDF
argument_list|(
name|be
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have not seen this color before, find nearest 	     colormap entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap_rgb
argument_list|(
name|quantobj
argument_list|,
name|histogram
argument_list|,
name|RSDF
argument_list|(
name|re
argument_list|)
argument_list|,
name|GSDF
argument_list|(
name|ge
argument_list|)
argument_list|,
name|BSDF
argument_list|(
name|be
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
operator|*
name|cachep
operator|-
literal|1
expr_stmt|;
name|index_used_count
index|[
name|index
index|]
operator|++
expr_stmt|;
name|dest
index|[
name|INDEXED_PIX
index|]
operator|=
name|index
expr_stmt|;
comment|/*if (re> global_rmax) 	    re = (re + 3*global_rmax) / 4; 	  else if (re< global_rmin) 	  re = (re + 3*global_rmin) / 4;*/
comment|/* We constrain chroma error extra-hard so that it 	     doesn't run away and steal the thunder from the 	     lightness error where all the detail usually is. */
if|if
condition|(
name|ge
operator|>
name|global_gmax
condition|)
name|ge
operator|=
operator|(
name|ge
operator|+
literal|3
operator|*
name|global_gmax
operator|)
operator|/
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ge
operator|<
name|global_gmin
condition|)
name|ge
operator|=
operator|(
name|ge
operator|+
literal|3
operator|*
name|global_gmin
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|be
operator|>
name|global_bmax
condition|)
name|be
operator|=
operator|(
name|be
operator|+
literal|3
operator|*
name|global_bmax
operator|)
operator|/
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|be
operator|<
name|global_bmin
condition|)
name|be
operator|=
operator|(
name|be
operator|+
literal|3
operator|*
name|global_bmin
operator|)
operator|/
literal|4
expr_stmt|;
name|color
operator|=
operator|&
name|quantobj
operator|->
name|clin
index|[
name|index
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|if ((re> 0&& re< 255)
comment|/* HMM&& 	      ge>= 0&& ge<= 255&& 	      be>= 0&& be<= 255*/
block|) 	    { 	      ge = ge - color->green; 	      be = be - color->blue; 	      re = re - color->red; 	    } 	  else 	    {
comment|/* colour pretty much undefined now; nullify error. */
block|re = ge = be = 0; 	    }
endif|#
directive|endif
if|if
condition|(
name|re
operator|<=
literal|0
operator|||
name|re
operator|>=
literal|255
condition|)
name|re
operator|=
name|ge
operator|=
name|be
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|re
operator|=
name|re
operator|-
name|color
operator|->
name|red
expr_stmt|;
name|ge
operator|=
name|ge
operator|-
name|color
operator|->
name|green
expr_stmt|;
name|be
operator|=
name|be
operator|-
name|color
operator|->
name|blue
expr_stmt|;
block|}
if|if
condition|(
name|odd_row
condition|)
block|{
operator|*
operator|(
operator|--
name|rpr
operator|)
operator|+=
name|fs_err1
index|[
name|re
index|]
expr_stmt|;
operator|*
operator|(
operator|--
name|gpr
operator|)
operator|+=
name|fs_err1
index|[
name|ge
index|]
expr_stmt|;
operator|*
operator|(
operator|--
name|bpr
operator|)
operator|+=
name|fs_err1
index|[
name|be
index|]
expr_stmt|;
operator|*
name|rnr
operator|--
operator|+=
name|fs_err2
index|[
name|re
index|]
expr_stmt|;
operator|*
name|gnr
operator|--
operator|+=
name|fs_err2
index|[
name|ge
index|]
expr_stmt|;
operator|*
name|bnr
operator|--
operator|+=
name|fs_err2
index|[
name|be
index|]
expr_stmt|;
operator|*
name|rnr
operator|+=
name|fs_err3
index|[
name|re
index|]
expr_stmt|;
operator|*
name|gnr
operator|+=
name|fs_err3
index|[
name|ge
index|]
expr_stmt|;
operator|*
name|bnr
operator|+=
name|fs_err3
index|[
name|be
index|]
expr_stmt|;
operator|*
operator|(
name|rnr
operator|-
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|re
index|]
expr_stmt|;
operator|*
operator|(
name|gnr
operator|-
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|ge
index|]
expr_stmt|;
operator|*
operator|(
name|bnr
operator|-
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|be
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|++
name|rpr
operator|)
operator|+=
name|fs_err1
index|[
name|re
index|]
expr_stmt|;
operator|*
operator|(
operator|++
name|gpr
operator|)
operator|+=
name|fs_err1
index|[
name|ge
index|]
expr_stmt|;
operator|*
operator|(
operator|++
name|bpr
operator|)
operator|+=
name|fs_err1
index|[
name|be
index|]
expr_stmt|;
operator|*
name|rnr
operator|++
operator|+=
name|fs_err2
index|[
name|re
index|]
expr_stmt|;
operator|*
name|gnr
operator|++
operator|+=
name|fs_err2
index|[
name|ge
index|]
expr_stmt|;
operator|*
name|bnr
operator|++
operator|+=
name|fs_err2
index|[
name|be
index|]
expr_stmt|;
operator|*
name|rnr
operator|+=
name|fs_err3
index|[
name|re
index|]
expr_stmt|;
operator|*
name|gnr
operator|+=
name|fs_err3
index|[
name|ge
index|]
expr_stmt|;
operator|*
name|bnr
operator|+=
name|fs_err3
index|[
name|be
index|]
expr_stmt|;
operator|*
operator|(
name|rnr
operator|+
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|re
index|]
expr_stmt|;
operator|*
operator|(
name|gnr
operator|+
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|ge
index|]
expr_stmt|;
operator|*
operator|(
name|bnr
operator|+
literal|1
operator|)
operator|=
name|fs_err4
index|[
name|be
index|]
expr_stmt|;
block|}
name|next_pixel
label|:
name|dest
operator|+=
name|step_dest
expr_stmt|;
name|src
operator|+=
name|step_src
expr_stmt|;
block|}
name|tmp
operator|=
name|red_n_row
expr_stmt|;
name|red_n_row
operator|=
name|red_p_row
expr_stmt|;
name|red_p_row
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|grn_n_row
expr_stmt|;
name|grn_n_row
operator|=
name|grn_p_row
expr_stmt|;
name|grn_p_row
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|blu_n_row
expr_stmt|;
name|blu_n_row
operator|=
name|blu_p_row
expr_stmt|;
name|blu_p_row
operator|=
name|tmp
expr_stmt|;
name|odd_row
operator|=
operator|!
name|odd_row
expr_stmt|;
name|pixel_region_set_row
argument_list|(
operator|&
name|destPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|width
argument_list|,
name|dest_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|quantobj
operator|->
name|progress
condition|)
name|gimp_progress_set_value
argument_list|(
name|quantobj
operator|->
name|progress
argument_list|,
operator|(
name|nth_layer
operator|+
operator|(
operator|(
name|gdouble
operator|)
name|row
operator|)
operator|/
name|height
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|n_layers
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|error_limiter
operator|-
literal|255
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|red_n_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|red_p_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|grn_n_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|grn_p_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|blu_n_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|blu_p_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|delete_median_cut (QuantizeObj * quantobj)
name|delete_median_cut
parameter_list|(
name|QuantizeObj
modifier|*
name|quantobj
parameter_list|)
block|{
name|g_free
argument_list|(
name|quantobj
operator|->
name|histogram
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|quantobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_function
specifier|static
name|QuantizeObj
modifier|*
DECL|function|initialize_median_cut (GimpImageBaseType type,gint num_colors,GimpConvertDitherType dither_type,GimpConvertPaletteType palette_type,gboolean want_alpha_dither,GimpProgress * progress)
name|initialize_median_cut
parameter_list|(
name|GimpImageBaseType
name|type
parameter_list|,
name|gint
name|num_colors
parameter_list|,
name|GimpConvertDitherType
name|dither_type
parameter_list|,
name|GimpConvertPaletteType
name|palette_type
parameter_list|,
name|gboolean
name|want_alpha_dither
parameter_list|,
name|GimpProgress
modifier|*
name|progress
parameter_list|)
block|{
name|QuantizeObj
modifier|*
name|quantobj
decl_stmt|;
comment|/* Initialize the data structures */
name|quantobj
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QuantizeObj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|GIMP_GRAY
operator|&&
name|palette_type
operator|==
name|GIMP_MAKE_PALETTE
condition|)
name|quantobj
operator|->
name|histogram
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ColorFreq
argument_list|)
operator|*
literal|256
argument_list|)
expr_stmt|;
else|else
name|quantobj
operator|->
name|histogram
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ColorFreq
argument_list|)
operator|*
name|HIST_R_ELEMS
operator|*
name|HIST_G_ELEMS
operator|*
name|HIST_B_ELEMS
argument_list|)
expr_stmt|;
name|quantobj
operator|->
name|desired_number_of_colors
operator|=
name|num_colors
expr_stmt|;
name|quantobj
operator|->
name|want_alpha_dither
operator|=
name|want_alpha_dither
expr_stmt|;
name|quantobj
operator|->
name|progress
operator|=
name|progress
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GIMP_GRAY
case|:
switch|switch
condition|(
name|palette_type
condition|)
block|{
case|case
name|GIMP_MAKE_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|median_cut_pass1_gray
expr_stmt|;
break|break;
case|case
name|GIMP_WEB_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|webpal_pass1
expr_stmt|;
break|break;
case|case
name|GIMP_CUSTOM_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|custompal_pass1
expr_stmt|;
name|needs_quantize
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GIMP_MONO_PALETTE
case|:
default|default:
name|quantobj
operator|->
name|first_pass
operator|=
name|monopal_pass1
expr_stmt|;
block|}
if|if
condition|(
name|palette_type
operator|==
name|GIMP_WEB_PALETTE
operator|||
name|palette_type
operator|==
name|GIMP_MONO_PALETTE
operator|||
name|palette_type
operator|==
name|GIMP_CUSTOM_PALETTE
condition|)
block|{
switch|switch
condition|(
name|dither_type
condition|)
block|{
case|case
name|GIMP_NODESTRUCT_DITHER
case|:
default|default:
name|g_warning
argument_list|(
literal|"Uh-oh, bad dither type, W1"
argument_list|)
expr_stmt|;
case|case
name|GIMP_NO_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_no_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FS_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FSLOWBLEED_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|1
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FIXED_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fixed_dither_rgb
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|dither_type
condition|)
block|{
case|case
name|GIMP_NODESTRUCT_DITHER
case|:
default|default:
name|g_warning
argument_list|(
literal|"Uh-oh, bad dither type, W2"
argument_list|)
expr_stmt|;
case|case
name|GIMP_NO_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_gray_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_no_dither_gray
expr_stmt|;
break|break;
case|case
name|GIMP_FS_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_gray_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_gray
expr_stmt|;
break|break;
case|case
name|GIMP_FSLOWBLEED_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|1
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_gray_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_gray
expr_stmt|;
break|break;
case|case
name|GIMP_FIXED_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_gray_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fixed_dither_gray
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|GIMP_RGB
case|:
switch|switch
condition|(
name|palette_type
condition|)
block|{
case|case
name|GIMP_MAKE_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|median_cut_pass1_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_WEB_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|webpal_pass1
expr_stmt|;
name|needs_quantize
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GIMP_CUSTOM_PALETTE
case|:
name|quantobj
operator|->
name|first_pass
operator|=
name|custompal_pass1
expr_stmt|;
name|needs_quantize
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GIMP_MONO_PALETTE
case|:
default|default:
name|quantobj
operator|->
name|first_pass
operator|=
name|monopal_pass1
expr_stmt|;
block|}
switch|switch
condition|(
name|dither_type
condition|)
block|{
case|case
name|GIMP_NO_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_no_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FS_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|0
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FSLOWBLEED_DITHER
case|:
name|quantobj
operator|->
name|error_freedom
operator|=
literal|1
expr_stmt|;
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fs_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_NODESTRUCT_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|NULL
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_nodestruct_dither_rgb
expr_stmt|;
break|break;
case|case
name|GIMP_FIXED_DITHER
case|:
name|quantobj
operator|->
name|second_pass_init
operator|=
name|median_cut_pass2_rgb_init
expr_stmt|;
name|quantobj
operator|->
name|second_pass
operator|=
name|median_cut_pass2_fixed_dither_rgb
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
name|quantobj
operator|->
name|delete_func
operator|=
name|delete_median_cut
expr_stmt|;
return|return
name|quantobj
return|;
block|}
end_function

end_unit

