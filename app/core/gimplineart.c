begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Copyright (C) 2017 SÃ©bastien Fourey& David TchumperlÃ©  * Copyright (C) 2018 Jehan  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gdk-pixbuf/gdk-pixbuf.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-gegl-loops.h"
end_include

begin_include
include|#
directive|include
file|"gegl/gimp-gegl-utils.h"
end_include

begin_include
include|#
directive|include
file|"gimp-parallel.h"
end_include

begin_include
include|#
directive|include
file|"gimp-priorities.h"
end_include

begin_include
include|#
directive|include
file|"gimp-utils.h"
end_include

begin_comment
comment|/* GIMP_TIMER */
end_comment

begin_include
include|#
directive|include
file|"gimpasync.h"
end_include

begin_include
include|#
directive|include
file|"gimpcancelable.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimplineart.h"
end_include

begin_include
include|#
directive|include
file|"gimpmarshal.h"
end_include

begin_include
include|#
directive|include
file|"gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"gimpprojection.h"
end_include

begin_include
include|#
directive|include
file|"gimpviewable.h"
end_include

begin_include
include|#
directive|include
file|"gimpwaitable.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_enum
enum|enum
DECL|enum|__anon28a5b29b0103
block|{
DECL|enumerator|COMPUTING_START
name|COMPUTING_START
block|,
DECL|enumerator|COMPUTING_END
name|COMPUTING_END
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|, }
enum|;
end_enum

begin_enum
enum|enum
DECL|enum|__anon28a5b29b0203
block|{
DECL|enumerator|PROP_0
name|PROP_0
block|,
DECL|enumerator|PROP_SELECT_TRANSPARENT
name|PROP_SELECT_TRANSPARENT
block|,
DECL|enumerator|PROP_MAX_GROW
name|PROP_MAX_GROW
block|,
DECL|enumerator|PROP_THRESHOLD
name|PROP_THRESHOLD
block|,
DECL|enumerator|PROP_SPLINE_MAX_LEN
name|PROP_SPLINE_MAX_LEN
block|,
DECL|enumerator|PROP_SEGMENT_MAX_LEN
name|PROP_SEGMENT_MAX_LEN
block|, }
enum|;
end_enum

begin_typedef
DECL|typedef|GimpLineArtPrivate
typedef|typedef
name|struct
name|_GimpLineArtPrivate
name|GimpLineArtPrivate
typedef|;
end_typedef

begin_struct
DECL|struct|_GimpLineArtPrivate
struct|struct
name|_GimpLineArtPrivate
block|{
DECL|member|frozen
name|gboolean
name|frozen
decl_stmt|;
DECL|member|compute_after_thaw
name|gboolean
name|compute_after_thaw
decl_stmt|;
DECL|member|async
name|GimpAsync
modifier|*
name|async
decl_stmt|;
DECL|member|idle_id
name|gint
name|idle_id
decl_stmt|;
DECL|member|input
name|GimpPickable
modifier|*
name|input
decl_stmt|;
DECL|member|closed
name|GeglBuffer
modifier|*
name|closed
decl_stmt|;
DECL|member|distmap
name|gfloat
modifier|*
name|distmap
decl_stmt|;
comment|/* Used in the closing step. */
DECL|member|select_transparent
name|gboolean
name|select_transparent
decl_stmt|;
DECL|member|threshold
name|gdouble
name|threshold
decl_stmt|;
DECL|member|spline_max_len
name|gint
name|spline_max_len
decl_stmt|;
DECL|member|segment_max_len
name|gint
name|segment_max_len
decl_stmt|;
DECL|member|max_len_bound
name|gboolean
name|max_len_bound
decl_stmt|;
comment|/* Used in the grow step. */
DECL|member|max_grow
name|gint
name|max_grow
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28a5b29b0308
block|{
DECL|member|buffer
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
DECL|member|select_transparent
name|gboolean
name|select_transparent
decl_stmt|;
DECL|member|threshold
name|gdouble
name|threshold
decl_stmt|;
DECL|member|spline_max_len
name|gint
name|spline_max_len
decl_stmt|;
DECL|member|segment_max_len
name|gint
name|segment_max_len
decl_stmt|;
DECL|typedef|LineArtData
block|}
name|LineArtData
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28a5b29b0408
block|{
DECL|member|closed
name|GeglBuffer
modifier|*
name|closed
decl_stmt|;
DECL|member|distmap
name|gfloat
modifier|*
name|distmap
decl_stmt|;
DECL|typedef|LineArtResult
block|}
name|LineArtResult
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|DeltaX
specifier|static
name|int
name|DeltaX
index|[
literal|4
index|]
init|=
block|{
operator|+
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|DeltaY
specifier|static
name|int
name|DeltaY
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|+
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|Direction2Normal
specifier|static
specifier|const
name|GimpVector2
name|Direction2Normal
index|[
literal|4
index|]
init|=
block|{
block|{
literal|1.0f
block|,
literal|0.0f
block|}
block|,
block|{
operator|-
literal|1.0f
block|,
literal|0.0f
block|}
block|,
block|{
literal|0.0f
block|,
literal|1.0f
block|}
block|,
block|{
literal|0.0f
block|,
operator|-
literal|1.0f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|enum|_Direction
typedef|typedef
enum|enum
name|_Direction
block|{
DECL|enumerator|XPlusDirection
name|XPlusDirection
init|=
literal|0
block|,
DECL|enumerator|XMinusDirection
name|XMinusDirection
init|=
literal|1
block|,
DECL|enumerator|YPlusDirection
name|YPlusDirection
init|=
literal|2
block|,
DECL|enumerator|YMinusDirection
name|YMinusDirection
init|=
literal|3
DECL|typedef|Direction
block|}
name|Direction
typedef|;
end_typedef

begin_typedef
DECL|typedef|Pixel
typedef|typedef
name|GimpVector2
name|Pixel
typedef|;
end_typedef

begin_typedef
DECL|struct|_SplineCandidate
typedef|typedef
struct|struct
name|_SplineCandidate
block|{
DECL|member|p1
name|Pixel
name|p1
decl_stmt|;
DECL|member|p2
name|Pixel
name|p2
decl_stmt|;
DECL|member|quality
name|float
name|quality
decl_stmt|;
DECL|typedef|SplineCandidate
block|}
name|SplineCandidate
typedef|;
end_typedef

begin_typedef
DECL|struct|_Edgel
typedef|typedef
struct|struct
name|_Edgel
block|{
DECL|member|x
DECL|member|y
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
DECL|member|direction
name|Direction
name|direction
decl_stmt|;
DECL|member|x_normal
name|gfloat
name|x_normal
decl_stmt|;
DECL|member|y_normal
name|gfloat
name|y_normal
decl_stmt|;
DECL|member|curvature
name|gfloat
name|curvature
decl_stmt|;
DECL|member|next
DECL|member|previous
name|guint
name|next
decl_stmt|,
name|previous
decl_stmt|;
DECL|typedef|Edgel
block|}
name|Edgel
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|gimp_line_art_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for asynchronous computation. */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_line_art_compute
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_compute_cb
parameter_list|(
name|GimpAsync
modifier|*
name|async
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpAsync
modifier|*
name|gimp_line_art_prepare_async
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|,
name|gint
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_prepare_async_func
parameter_list|(
name|GimpAsync
modifier|*
name|async
parameter_list|,
name|LineArtData
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LineArtData
modifier|*
name|line_art_data_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|line_art_data_free
parameter_list|(
name|LineArtData
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LineArtResult
modifier|*
name|line_art_result_new
parameter_list|(
name|GeglBuffer
modifier|*
name|line_art
parameter_list|,
name|gfloat
modifier|*
name|distmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|line_art_result_free
parameter_list|(
name|LineArtResult
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_line_art_idle
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_input_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* All actual computation functions. */
end_comment

begin_function_decl
specifier|static
name|GeglBuffer
modifier|*
name|gimp_line_art_close
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gboolean
name|select_transparent
parameter_list|,
name|gdouble
name|stroke_threshold
parameter_list|,
name|gint
name|spline_max_length
parameter_list|,
name|gint
name|segment_max_length
parameter_list|,
name|gint
name|minimal_lineart_area
parameter_list|,
name|gint
name|normal_estimate_mask_size
parameter_list|,
name|gfloat
name|end_point_rate
parameter_list|,
name|gfloat
name|spline_max_angle
parameter_list|,
name|gint
name|end_point_connectivity
parameter_list|,
name|gfloat
name|spline_roundness
parameter_list|,
name|gboolean
name|allow_self_intersections
parameter_list|,
name|gint
name|created_regions_significant_area
parameter_list|,
name|gint
name|created_regions_minimum_area
parameter_list|,
name|gboolean
name|small_segments_from_spline_sources
parameter_list|,
name|gfloat
modifier|*
modifier|*
name|lineart_distmap
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_lineart_denoise
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_lineart_compute_normals_curvatures
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gfloat
modifier|*
name|smoothed_curvatures
parameter_list|,
name|int
name|normal_estimate_mask_size
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gfloat
modifier|*
name|gimp_lineart_get_smooth_curvatures
parameter_list|(
name|GArray
modifier|*
name|edgelset
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_curvature_extremums
parameter_list|(
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gfloat
modifier|*
name|smoothed_curvatures
parameter_list|,
name|gint
name|curvatures_width
parameter_list|,
name|gint
name|curvatures_height
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|gimp_spline_candidate_cmp
parameter_list|(
specifier|const
name|SplineCandidate
modifier|*
name|a
parameter_list|,
specifier|const
name|SplineCandidate
modifier|*
name|b
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GList
modifier|*
name|gimp_lineart_find_spline_candidates
parameter_list|(
name|GArray
modifier|*
name|max_positions
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|distance_threshold
parameter_list|,
name|gfloat
name|max_angle_deg
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_discrete_spline
parameter_list|(
name|Pixel
name|p0
parameter_list|,
name|GimpVector2
name|n0
parameter_list|,
name|Pixel
name|p1
parameter_list|,
name|GimpVector2
name|n1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|gimp_number_of_transitions
parameter_list|(
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_line_art_allow_closure
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GList
modifier|*
modifier|*
name|fill_pixels
parameter_list|,
name|int
name|significant_size
parameter_list|,
name|int
name|minimum_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_line_segment_until_hit
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Pixel
name|start
parameter_list|,
name|GimpVector2
name|direction
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gfloat
modifier|*
name|gimp_lineart_estimate_strokes_radii
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_line_art_simple_fill
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
modifier|*
name|counter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Some callback-type functions. */
end_comment

begin_function_decl
specifier|static
name|guint
name|visited_hash_fun
parameter_list|(
name|Pixel
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|visited_equal_fun
parameter_list|(
name|Pixel
modifier|*
name|e1
parameter_list|,
name|Pixel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gboolean
name|border_in_direction
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|p
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|GimpVector2
name|pair2normal
parameter_list|(
name|Pixel
name|p
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edgel */
end_comment

begin_function_decl
specifier|static
name|Edgel
modifier|*
name|gimp_edgel_new
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgel_init
parameter_list|(
name|Edgel
modifier|*
name|edgel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgel_clear
parameter_list|(
name|Edgel
modifier|*
modifier|*
name|edgel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gimp_edgel_cmp
parameter_list|(
specifier|const
name|Edgel
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edgel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|edgel2index_hash_fun
parameter_list|(
name|Edgel
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|edgel2index_equal_fun
parameter_list|(
name|Edgel
modifier|*
name|e1
parameter_list|,
name|Edgel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|gimp_edgel_track_mark
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|edgel
parameter_list|,
name|long
name|size_limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|gimp_edgel_region_area
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|start_edgel
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edgel set */
end_comment

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_edgelset_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_add
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_init_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_smooth_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|mask_size
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_compute_curvature
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_build_graph
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_next8
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Edgel
modifier|*
name|it
parameter_list|,
name|Edgel
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|G_DEFINE_TYPE_WITH_CODE
argument_list|(
argument|GimpLineArt
argument_list|,
argument|gimp_line_art
argument_list|,
argument|GIMP_TYPE_OBJECT
argument_list|,
argument|G_ADD_PRIVATE (GimpLineArt)
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|guint
name|gimp_line_art_signals
index|[
name|LAST_SIGNAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_class_init (GimpLineArtClass * klass)
name|gimp_line_art_class_init
parameter_list|(
name|GimpLineArtClass
modifier|*
name|klass
parameter_list|)
block|{
name|GObjectClass
modifier|*
name|object_class
init|=
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|gimp_line_art_signals
index|[
name|COMPUTING_START
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"computing-start"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpLineArtClass
argument_list|,
name|computing_start
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_line_art_signals
index|[
name|COMPUTING_END
index|]
operator|=
name|g_signal_new
argument_list|(
literal|"computing-end"
argument_list|,
name|G_TYPE_FROM_CLASS
argument_list|(
name|klass
argument_list|)
argument_list|,
name|G_SIGNAL_RUN_FIRST
argument_list|,
name|G_STRUCT_OFFSET
argument_list|(
name|GimpLineArtClass
argument_list|,
name|computing_end
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gimp_marshal_VOID__VOID
argument_list|,
name|G_TYPE_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|object_class
operator|->
name|finalize
operator|=
name|gimp_line_art_finalize
expr_stmt|;
name|object_class
operator|->
name|set_property
operator|=
name|gimp_line_art_set_property
expr_stmt|;
name|object_class
operator|->
name|get_property
operator|=
name|gimp_line_art_get_property
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_SELECT_TRANSPARENT
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"select-transparent"
argument_list|,
name|_
argument_list|(
literal|"Select transparent pixels instead of gray ones"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select transparent pixels instead of gray ones"
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_CONSTRUCT
operator||
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_THRESHOLD
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"threshold"
argument_list|,
name|_
argument_list|(
literal|"Line art detection threshold"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Threshold to detect contour (higher values will include more pixels)"
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.92
argument_list|,
name|G_PARAM_CONSTRUCT
operator||
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_MAX_GROW
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"max-grow"
argument_list|,
name|_
argument_list|(
literal|"Maximum growing size"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Maximum number of pixels grown under the line art"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|3
argument_list|,
name|G_PARAM_CONSTRUCT
operator||
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_SPLINE_MAX_LEN
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"spline-max-length"
argument_list|,
name|_
argument_list|(
literal|"Maximum curved closing length"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Maximum curved length (in pixels) to close the line art"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
literal|100
argument_list|,
name|G_PARAM_CONSTRUCT
operator||
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_SEGMENT_MAX_LEN
argument_list|,
name|g_param_spec_int
argument_list|(
literal|"segment-max-length"
argument_list|,
name|_
argument_list|(
literal|"Maximum straight closing length"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Maximum straight length (in pixels) to close the line art"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
literal|100
argument_list|,
name|G_PARAM_CONSTRUCT
operator||
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_init (GimpLineArt * line_art)
name|gimp_line_art_init
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
name|line_art
operator|->
name|priv
operator|=
name|gimp_line_art_get_instance_private
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_finalize (GObject * object)
name|gimp_line_art_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpLineArt
modifier|*
name|line_art
init|=
name|GIMP_LINE_ART
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|frozen
operator|=
name|FALSE
expr_stmt|;
name|gimp_line_art_set_input
argument_list|(
name|line_art
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_set_property (GObject * object,guint property_id,const GValue * value,GParamSpec * pspec)
name|gimp_line_art_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpLineArt
modifier|*
name|line_art
init|=
name|GIMP_LINE_ART
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_SELECT_TRANSPARENT
case|:
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|select_transparent
operator|!=
name|g_value_get_boolean
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|select_transparent
operator|=
name|g_value_get_boolean
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_MAX_GROW
case|:
name|line_art
operator|->
name|priv
operator|->
name|max_grow
operator|=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_THRESHOLD
case|:
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|threshold
operator|!=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|threshold
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SPLINE_MAX_LEN
case|:
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
operator|!=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
operator|=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|max_len_bound
condition|)
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
operator|=
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SEGMENT_MAX_LEN
case|:
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
operator|!=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
operator|=
name|g_value_get_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|max_len_bound
condition|)
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
operator|=
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_get_property (GObject * object,guint property_id,GValue * value,GParamSpec * pspec)
name|gimp_line_art_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpLineArt
modifier|*
name|line_art
init|=
name|GIMP_LINE_ART
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_SELECT_TRANSPARENT
case|:
name|g_value_set_boolean
argument_list|(
name|value
argument_list|,
name|line_art
operator|->
name|priv
operator|->
name|select_transparent
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_MAX_GROW
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|line_art
operator|->
name|priv
operator|->
name|max_grow
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_THRESHOLD
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|line_art
operator|->
name|priv
operator|->
name|threshold
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SPLINE_MAX_LEN
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SEGMENT_MAX_LEN
case|:
name|g_value_set_int
argument_list|(
name|value
argument_list|,
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Public functions */
end_comment

begin_function
name|GimpLineArt
modifier|*
DECL|function|gimp_line_art_new (void)
name|gimp_line_art_new
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|g_object_new
argument_list|(
name|GIMP_TYPE_LINE_ART
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_line_art_bind_gap_length (GimpLineArt * line_art,gboolean bound)
name|gimp_line_art_bind_gap_length
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|,
name|gboolean
name|bound
parameter_list|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|max_len_bound
operator|=
name|bound
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_line_art_set_input (GimpLineArt * line_art,GimpPickable * pickable)
name|gimp_line_art_set_input
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|,
name|GimpPickable
modifier|*
name|pickable
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|pickable
operator|==
name|NULL
operator|||
name|GIMP_IS_VIEWABLE
argument_list|(
name|pickable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pickable
operator|!=
name|line_art
operator|->
name|priv
operator|->
name|input
condition|)
block|{
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|input
condition|)
name|g_signal_handlers_disconnect_by_data
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|input
operator|=
name|pickable
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
if|if
condition|(
name|pickable
condition|)
block|{
name|g_signal_connect
argument_list|(
name|pickable
argument_list|,
literal|"invalidate-preview"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_line_art_input_invalidate_preview
argument_list|)
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|GimpPickable
modifier|*
DECL|function|gimp_line_art_get_input (GimpLineArt * line_art)
name|gimp_line_art_get_input
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
return|return
name|line_art
operator|->
name|priv
operator|->
name|input
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_line_art_freeze (GimpLineArt * line_art)
name|gimp_line_art_freeze
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
operator|!
name|line_art
operator|->
name|priv
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|frozen
operator|=
name|TRUE
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|compute_after_thaw
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_line_art_thaw (GimpLineArt * line_art)
name|gimp_line_art_thaw
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|frozen
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|compute_after_thaw
condition|)
block|{
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|compute_after_thaw
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GeglBuffer
modifier|*
DECL|function|gimp_line_art_get (GimpLineArt * line_art,gfloat ** distmap)
name|gimp_line_art_get
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|,
name|gfloat
modifier|*
modifier|*
name|distmap
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|async
condition|)
block|{
name|gimp_waitable_wait
argument_list|(
name|GIMP_WAITABLE
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|line_art
operator|->
name|priv
operator|->
name|closed
condition|)
block|{
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|async
condition|)
name|gimp_waitable_wait
argument_list|(
name|GIMP_WAITABLE
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_return_val_if_fail
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|closed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|distmap
condition|)
operator|*
name|distmap
operator|=
name|line_art
operator|->
name|priv
operator|->
name|distmap
expr_stmt|;
return|return
name|line_art
operator|->
name|priv
operator|->
name|closed
return|;
block|}
end_function

begin_comment
comment|/* Functions for asynchronous computation. */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_compute (GimpLineArt * line_art)
name|gimp_line_art_compute
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|frozen
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|compute_after_thaw
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|async
condition|)
block|{
comment|/* we cancel the async, but don't wait for it to finish, since        * it might take a while to respond.  instead gimp_line_art_compute_cb()        * bails if the async has been canceled, to avoid accessing the line art.        */
name|g_signal_emit
argument_list|(
name|line_art
argument_list|,
name|gimp_line_art_signals
index|[
name|COMPUTING_END
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_cancelable_cancel
argument_list|(
name|GIMP_CANCELABLE
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|)
argument_list|)
expr_stmt|;
name|g_clear_object
argument_list|(
operator|&
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|idle_id
condition|)
block|{
name|g_source_remove
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|idle_id
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|idle_id
operator|=
literal|0
expr_stmt|;
block|}
name|g_clear_object
argument_list|(
operator|&
name|line_art
operator|->
name|priv
operator|->
name|closed
argument_list|)
expr_stmt|;
name|g_clear_pointer
argument_list|(
operator|&
name|line_art
operator|->
name|priv
operator|->
name|distmap
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_art
operator|->
name|priv
operator|->
name|input
condition|)
block|{
comment|/* gimp_line_art_prepare_async() will flush the pickable, which        * may trigger this signal handler, and will leak a line art (as        * line_art->priv->async has not been set yet).        */
name|g_signal_handlers_block_by_func
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_line_art_input_invalidate_preview
argument_list|)
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|async
operator|=
name|gimp_line_art_prepare_async
argument_list|(
name|line_art
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_signal_emit
argument_list|(
name|line_art
argument_list|,
name|gimp_line_art_signals
index|[
name|COMPUTING_START
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_signal_handlers_unblock_by_func
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_line_art_input_invalidate_preview
argument_list|)
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
name|gimp_async_add_callback_for_object
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|,
operator|(
name|GimpAsyncCallback
operator|)
name|gimp_line_art_compute_cb
argument_list|,
name|line_art
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_compute_cb (GimpAsync * async,GimpLineArt * line_art)
name|gimp_line_art_compute_cb
parameter_list|(
name|GimpAsync
modifier|*
name|async
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
return|return;
if|if
condition|(
name|gimp_async_is_finished
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|LineArtResult
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|gimp_async_get_result
argument_list|(
name|async
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|closed
operator|=
name|g_object_ref
argument_list|(
name|result
operator|->
name|closed
argument_list|)
expr_stmt|;
name|line_art
operator|->
name|priv
operator|->
name|distmap
operator|=
name|result
operator|->
name|distmap
expr_stmt|;
name|result
operator|->
name|distmap
operator|=
name|NULL
expr_stmt|;
name|g_signal_emit
argument_list|(
name|line_art
argument_list|,
name|gimp_line_art_signals
index|[
name|COMPUTING_END
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|g_clear_object
argument_list|(
operator|&
name|line_art
operator|->
name|priv
operator|->
name|async
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GimpAsync
modifier|*
DECL|function|gimp_line_art_prepare_async (GimpLineArt * line_art,gint priority)
name|gimp_line_art_prepare_async
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|,
name|gint
name|priority
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|GimpAsync
modifier|*
name|async
decl_stmt|;
name|LineArtData
modifier|*
name|data
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_PICKABLE
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_pickable_flush
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_gegl_buffer_dup
argument_list|(
name|gimp_pickable_get_buffer
argument_list|(
name|line_art
operator|->
name|priv
operator|->
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|line_art_data_new
argument_list|(
name|buffer
argument_list|,
name|line_art
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|async
operator|=
name|gimp_parallel_run_async_full
argument_list|(
name|priority
argument_list|,
operator|(
name|GimpParallelRunAsyncFunc
operator|)
name|gimp_line_art_prepare_async_func
argument_list|,
name|data
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|line_art_data_free
argument_list|)
expr_stmt|;
return|return
name|async
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_prepare_async_func (GimpAsync * async,LineArtData * data)
name|gimp_line_art_prepare_async_func
parameter_list|(
name|GimpAsync
modifier|*
name|async
parameter_list|,
name|LineArtData
modifier|*
name|data
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|closed
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|distmap
init|=
name|NULL
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gboolean
name|select_transparent
init|=
name|FALSE
decl_stmt|;
name|has_alpha
operator|=
name|babl_format_has_alpha
argument_list|(
name|gegl_buffer_get_format
argument_list|(
name|data
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|select_transparent
condition|)
block|{
comment|/*  don't select transparent regions if there are no fully            *  transparent pixels.            */
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|data
operator|->
name|buffer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|babl_format
argument_list|(
literal|"A u8"
argument_list|)
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|p
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
name|line_art_data_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|select_transparent
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|select_transparent
condition|)
break|break;
block|}
if|if
condition|(
name|select_transparent
condition|)
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For smart selection, we generate a binarized image with close    * regions, then run a composite selection with no threshold on    * this intermediate buffer.    */
name|GIMP_TIMER_START
argument_list|()
expr_stmt|;
name|closed
operator|=
name|gimp_line_art_close
argument_list|(
name|data
operator|->
name|buffer
argument_list|,
name|select_transparent
argument_list|,
name|data
operator|->
name|threshold
argument_list|,
name|data
operator|->
name|spline_max_len
argument_list|,
name|data
operator|->
name|segment_max_len
argument_list|,
comment|/*minimal_lineart_area,*/
literal|5
argument_list|,
comment|/*normal_estimate_mask_size,*/
literal|5
argument_list|,
comment|/*end_point_rate,*/
literal|0.85
argument_list|,
comment|/*spline_max_angle,*/
literal|90.0
argument_list|,
comment|/*end_point_connectivity,*/
literal|2
argument_list|,
comment|/*spline_roundness,*/
literal|1.0
argument_list|,
comment|/*allow_self_intersections,*/
name|TRUE
argument_list|,
comment|/*created_regions_significant_area,*/
literal|4
argument_list|,
comment|/*created_regions_minimum_area,*/
literal|100
argument_list|,
comment|/*small_segments_from_spline_sources,*/
name|TRUE
argument_list|,
operator|&
name|distmap
argument_list|,
name|async
argument_list|)
expr_stmt|;
name|GIMP_TIMER_END
argument_list|(
literal|"close line-art"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_finish_full
argument_list|(
name|async
argument_list|,
name|line_art_result_new
argument_list|(
name|closed
argument_list|,
name|distmap
argument_list|)
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|line_art_result_free
argument_list|)
expr_stmt|;
block|}
name|line_art_data_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|LineArtData
modifier|*
DECL|function|line_art_data_new (GeglBuffer * buffer,GimpLineArt * line_art)
name|line_art_data_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
name|LineArtData
modifier|*
name|data
init|=
name|g_slice_new
argument_list|(
name|LineArtData
argument_list|)
decl_stmt|;
name|data
operator|->
name|buffer
operator|=
name|g_object_ref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|data
operator|->
name|select_transparent
operator|=
name|line_art
operator|->
name|priv
operator|->
name|select_transparent
expr_stmt|;
name|data
operator|->
name|threshold
operator|=
name|line_art
operator|->
name|priv
operator|->
name|threshold
expr_stmt|;
name|data
operator|->
name|spline_max_len
operator|=
name|line_art
operator|->
name|priv
operator|->
name|spline_max_len
expr_stmt|;
name|data
operator|->
name|segment_max_len
operator|=
name|line_art
operator|->
name|priv
operator|->
name|segment_max_len
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|line_art_data_free (LineArtData * data)
name|line_art_data_free
parameter_list|(
name|LineArtData
modifier|*
name|data
parameter_list|)
block|{
name|g_object_unref
argument_list|(
name|data
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|LineArtData
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|LineArtResult
modifier|*
DECL|function|line_art_result_new (GeglBuffer * closed,gfloat * distmap)
name|line_art_result_new
parameter_list|(
name|GeglBuffer
modifier|*
name|closed
parameter_list|,
name|gfloat
modifier|*
name|distmap
parameter_list|)
block|{
name|LineArtResult
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|g_slice_new
argument_list|(
name|LineArtResult
argument_list|)
expr_stmt|;
name|data
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|data
operator|->
name|distmap
operator|=
name|distmap
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|line_art_result_free (LineArtResult * data)
name|line_art_result_free
parameter_list|(
name|LineArtResult
modifier|*
name|data
parameter_list|)
block|{
name|g_object_unref
argument_list|(
name|data
operator|->
name|closed
argument_list|)
expr_stmt|;
name|g_clear_pointer
argument_list|(
operator|&
name|data
operator|->
name|distmap
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|LineArtResult
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_line_art_idle (GimpLineArt * line_art)
name|gimp_line_art_idle
parameter_list|(
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|idle_id
operator|=
literal|0
expr_stmt|;
name|gimp_line_art_compute
argument_list|(
name|line_art
argument_list|)
expr_stmt|;
return|return
name|G_SOURCE_REMOVE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_input_invalidate_preview (GimpViewable * viewable,GimpLineArt * line_art)
name|gimp_line_art_input_invalidate_preview
parameter_list|(
name|GimpViewable
modifier|*
name|viewable
parameter_list|,
name|GimpLineArt
modifier|*
name|line_art
parameter_list|)
block|{
if|if
condition|(
operator|!
name|line_art
operator|->
name|priv
operator|->
name|idle_id
condition|)
block|{
name|line_art
operator|->
name|priv
operator|->
name|idle_id
operator|=
name|g_idle_add_full
argument_list|(
name|GIMP_PRIORITY_VIEWABLE_IDLE
argument_list|,
operator|(
name|GSourceFunc
operator|)
name|gimp_line_art_idle
argument_list|,
name|line_art
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All actual computation functions. */
end_comment

begin_comment
comment|/**  * gimp_line_art_close:  * @buffer: the input #GeglBuffer.  * @select_transparent: whether we binarize the alpha channel or the  *                      luminosity.  * @stroke_threshold: [0-1] threshold value for detecting stroke pixels  *                    (higher values will detect more stroke pixels).  * @spline_max_length: the maximum length for creating splines between  *                     end points.  * @segment_max_length: the maximum length for creating segments  *                      between end points. Unlike splines, segments  *                      are straight lines.  * @minimal_lineart_area: the minimum size in number pixels for area to  *                        be considered as line art.  * @normal_estimate_mask_size:  * @end_point_rate: threshold to estimate if a curvature is an end-point  *                  in [0-1] range value.  * @spline_max_angle: the maximum angle between end point normals for  *                    creating splines between them.  * @end_point_connectivity:  * @spline_roundness:  * @allow_self_intersections: whether to allow created splines and  *                            segments to intersect.  * @created_regions_significant_area:  * @created_regions_minimum_area:  * @small_segments_from_spline_sources:  * @closed_distmap: a distance map of the closed line art pixels.  * @async: the #GimpAsync associated with the computation  *  * Creates a binarized version of the strokes of @buffer, detected either  * with luminosity (light means background) or alpha values depending on  * @select_transparent. This binary version of the strokes will have closed  * regions allowing adequate selection of "nearly closed regions".  * This algorithm is meant for digital painting (and in particular on the  * sketch-only step), and therefore will likely produce unexpected results on  * other types of input.  *  * The algorithm is the first step from the research paper "A Fast and  * Efficient Semi-guided Algorithm for Flat Coloring Line-arts", by SÃ©bastian  * Fourey, David TschumperlÃ©, David Revoy.  * https://hal.archives-ouvertes.fr/hal-01891876  *  * Returns: a new #GeglBuffer of format "Y u8" representing the  *          binarized @line_art. If @lineart_distmap is not #NULL, a  *          newly allocated float buffer is returned, which can be used  *          for overflowing created masks later.  */
end_comment

begin_function
specifier|static
name|GeglBuffer
modifier|*
DECL|function|gimp_line_art_close (GeglBuffer * buffer,gboolean select_transparent,gdouble stroke_threshold,gint spline_max_length,gint segment_max_length,gint minimal_lineart_area,gint normal_estimate_mask_size,gfloat end_point_rate,gfloat spline_max_angle,gint end_point_connectivity,gfloat spline_roundness,gboolean allow_self_intersections,gint created_regions_significant_area,gint created_regions_minimum_area,gboolean small_segments_from_spline_sources,gfloat ** closed_distmap,GimpAsync * async)
name|gimp_line_art_close
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gboolean
name|select_transparent
parameter_list|,
name|gdouble
name|stroke_threshold
parameter_list|,
name|gint
name|spline_max_length
parameter_list|,
name|gint
name|segment_max_length
parameter_list|,
name|gint
name|minimal_lineart_area
parameter_list|,
name|gint
name|normal_estimate_mask_size
parameter_list|,
name|gfloat
name|end_point_rate
parameter_list|,
name|gfloat
name|spline_max_angle
parameter_list|,
name|gint
name|end_point_connectivity
parameter_list|,
name|gfloat
name|spline_roundness
parameter_list|,
name|gboolean
name|allow_self_intersections
parameter_list|,
name|gint
name|created_regions_significant_area
parameter_list|,
name|gint
name|created_regions_minimum_area
parameter_list|,
name|gboolean
name|small_segments_from_spline_sources
parameter_list|,
name|gfloat
modifier|*
modifier|*
name|closed_distmap
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
specifier|const
name|Babl
modifier|*
name|gray_format
decl_stmt|;
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|GeglBuffer
modifier|*
name|closed
init|=
name|NULL
decl_stmt|;
name|GeglBuffer
modifier|*
name|strokes
init|=
name|NULL
decl_stmt|;
name|guchar
name|max_value
init|=
literal|0
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|select_transparent
condition|)
comment|/* Keep alpha channel as gray levels */
name|gray_format
operator|=
name|babl_format
argument_list|(
literal|"A u8"
argument_list|)
expr_stmt|;
else|else
comment|/* Keep luminance */
name|gray_format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
comment|/* Transform the line art from any format to gray. */
name|strokes
operator|=
name|gegl_buffer_new
argument_list|(
name|gegl_buffer_get_extent
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gray_format
argument_list|)
expr_stmt|;
name|gimp_gegl_buffer_copy
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
name|strokes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_buffer_set_format
argument_list|(
name|strokes
argument_list|,
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_transparent
condition|)
block|{
comment|/* Compute the biggest value */
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|strokes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|data
init|=
operator|(
name|guchar
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end1
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|data
operator|>
name|max_value
condition|)
name|max_value
operator|=
operator|*
name|data
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Make the image binary: 1 is stroke, 0 background */
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|strokes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READWRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|data
init|=
operator|(
name|guchar
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end1
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|select_transparent
condition|)
comment|/* Negate the value. */
operator|*
name|data
operator|=
name|max_value
operator|-
operator|*
name|data
expr_stmt|;
comment|/* Apply a threshold. */
if|if
condition|(
operator|*
name|data
operator|>
call|(
name|guchar
call|)
argument_list|(
literal|255.0f
operator|*
operator|(
literal|1.0f
operator|-
name|stroke_threshold
operator|)
argument_list|)
condition|)
operator|*
name|data
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|data
operator|=
literal|0
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
comment|/* Denoise (remove small connected components) */
name|gimp_lineart_denoise
argument_list|(
name|strokes
argument_list|,
name|minimal_lineart_area
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end1
goto|;
name|closed
operator|=
name|g_object_ref
argument_list|(
name|strokes
argument_list|)
expr_stmt|;
if|if
condition|(
name|spline_max_length
operator|>
literal|0
operator|||
name|segment_max_length
operator|>
literal|0
condition|)
block|{
name|GArray
modifier|*
name|keypoints
init|=
name|NULL
decl_stmt|;
name|GHashTable
modifier|*
name|visited
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|radii
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|normals
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|curvatures
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|smoothed_curvatures
init|=
name|NULL
decl_stmt|;
name|gfloat
name|threshold
decl_stmt|;
name|gfloat
name|clamped_threshold
decl_stmt|;
name|GList
modifier|*
name|fill_pixels
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|iter
decl_stmt|;
name|normals
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
operator|*
literal|2
argument_list|)
expr_stmt|;
name|curvatures
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|smoothed_curvatures
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* Estimate normals& curvature */
name|gimp_lineart_compute_normals_curvatures
argument_list|(
name|strokes
argument_list|,
name|normals
argument_list|,
name|curvatures
argument_list|,
name|smoothed_curvatures
argument_list|,
name|normal_estimate_mask_size
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end2
goto|;
name|radii
operator|=
name|gimp_lineart_estimate_strokes_radii
argument_list|(
name|strokes
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end2
goto|;
name|threshold
operator|=
literal|1.0f
operator|-
name|end_point_rate
expr_stmt|;
name|clamped_threshold
operator|=
name|MAX
argument_list|(
literal|0.25f
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|j
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end2
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|smoothed_curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
operator|>=
operator|(
name|threshold
operator|/
name|MAX
argument_list|(
literal|1.0f
argument_list|,
name|radii
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
argument_list|)
operator|)
operator|||
name|curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
operator|>=
name|clamped_threshold
condition|)
name|curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
operator|=
literal|1.0
expr_stmt|;
else|else
name|curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
name|g_clear_pointer
argument_list|(
operator|&
name|radii
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|keypoints
operator|=
name|gimp_lineart_curvature_extremums
argument_list|(
name|curvatures
argument_list|,
name|smoothed_curvatures
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end2
goto|;
name|visited
operator|=
name|g_hash_table_new_full
argument_list|(
operator|(
name|GHashFunc
operator|)
name|visited_hash_fun
argument_list|,
operator|(
name|GEqualFunc
operator|)
name|visited_equal_fun
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_free
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spline_max_length
operator|>
literal|0
condition|)
block|{
name|GList
modifier|*
name|candidates
decl_stmt|;
name|SplineCandidate
modifier|*
name|candidate
decl_stmt|;
name|candidates
operator|=
name|gimp_lineart_find_spline_candidates
argument_list|(
name|keypoints
argument_list|,
name|normals
argument_list|,
name|width
argument_list|,
name|spline_max_length
argument_list|,
name|spline_max_angle
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end3
goto|;
name|g_object_unref
argument_list|(
name|closed
argument_list|)
expr_stmt|;
name|closed
operator|=
name|gimp_gegl_buffer_dup
argument_list|(
name|strokes
argument_list|)
expr_stmt|;
comment|/* Draw splines */
while|while
condition|(
name|candidates
condition|)
block|{
name|Pixel
modifier|*
name|p1
decl_stmt|;
name|Pixel
modifier|*
name|p2
decl_stmt|;
name|gboolean
name|inserted
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end3
goto|;
block|}
name|p1
operator|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|candidate
operator|=
operator|(
name|SplineCandidate
operator|*
operator|)
name|candidates
operator|->
name|data
expr_stmt|;
name|p1
operator|->
name|x
operator|=
name|candidate
operator|->
name|p1
operator|.
name|x
expr_stmt|;
name|p1
operator|->
name|y
operator|=
name|candidate
operator|->
name|p1
operator|.
name|y
expr_stmt|;
name|p2
operator|->
name|x
operator|=
name|candidate
operator|->
name|p2
operator|.
name|x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|candidate
operator|->
name|p2
operator|.
name|y
expr_stmt|;
name|g_free
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|g_list_delete_link
argument_list|(
name|candidates
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
operator|||
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
operator|&&
operator|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
operator|||
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
condition|)
block|{
name|GArray
modifier|*
name|discrete_curve
decl_stmt|;
name|GimpVector2
name|vect1
init|=
name|pair2normal
argument_list|(
operator|*
name|p1
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|GimpVector2
name|vect2
init|=
name|pair2normal
argument_list|(
operator|*
name|p2
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|gfloat
name|distance
init|=
name|gimp_vector2_length_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
operator|*
name|p1
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|transitions
decl_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect1
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect1
argument_list|,
name|spline_roundness
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect2
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect2
argument_list|,
name|spline_roundness
argument_list|)
expr_stmt|;
name|discrete_curve
operator|=
name|gimp_lineart_discrete_spline
argument_list|(
operator|*
name|p1
argument_list|,
name|vect1
argument_list|,
operator|*
name|p2
argument_list|,
name|vect2
argument_list|)
expr_stmt|;
name|transitions
operator|=
name|allow_self_intersections
condition|?
name|gimp_number_of_transitions
argument_list|(
name|discrete_curve
argument_list|,
name|strokes
argument_list|)
else|:
name|gimp_number_of_transitions
argument_list|(
name|discrete_curve
argument_list|,
name|closed
argument_list|)
expr_stmt|;
if|if
condition|(
name|transitions
operator|==
literal|2
operator|&&
name|gimp_line_art_allow_closure
argument_list|(
name|closed
argument_list|,
name|discrete_curve
argument_list|,
operator|&
name|fill_pixels
argument_list|,
name|created_regions_significant_area
argument_list|,
name|created_regions_minimum_area
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|discrete_curve
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|discrete_curve
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|closed
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|closed
argument_list|)
condition|)
block|{
name|guchar
name|val
init|=
literal|2
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|closed
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|discrete_curve
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
block|{
name|g_free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
block|}
name|end3
label|:
name|g_list_free_full
argument_list|(
name|candidates
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end2
goto|;
block|}
name|g_clear_object
argument_list|(
operator|&
name|strokes
argument_list|)
expr_stmt|;
comment|/* Draw straight line segments */
if|if
condition|(
name|segment_max_length
operator|>
literal|0
condition|)
block|{
name|Pixel
modifier|*
name|point
decl_stmt|;
name|point
operator|=
operator|(
name|Pixel
operator|*
operator|)
name|keypoints
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keypoints
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
modifier|*
name|p
decl_stmt|;
name|gboolean
name|inserted
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end2
goto|;
block|}
name|p
operator|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|point
expr_stmt|;
if|if
condition|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
operator|||
operator|(
name|small_segments_from_spline_sources
operator|&&
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
condition|)
block|{
name|GArray
modifier|*
name|segment
init|=
name|gimp_lineart_line_segment_until_hit
argument_list|(
name|closed
argument_list|,
operator|*
name|point
argument_list|,
name|pair2normal
argument_list|(
operator|*
name|point
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
argument_list|,
name|segment_max_length
argument_list|)
decl_stmt|;
if|if
condition|(
name|segment
operator|->
name|len
operator|&&
name|gimp_line_art_allow_closure
argument_list|(
name|closed
argument_list|,
name|segment
argument_list|,
operator|&
name|fill_pixels
argument_list|,
name|created_regions_significant_area
argument_list|,
name|created_regions_minimum_area
argument_list|)
condition|)
block|{
name|gint
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|segment
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|segment
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|guchar
name|val
init|=
literal|2
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|closed
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|segment
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|point
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|iter
operator|=
name|fill_pixels
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|iter
operator|->
name|data
decl_stmt|;
name|gint
name|fill_max
init|=
name|created_regions_significant_area
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end2
goto|;
block|}
comment|/* XXX A best approach would be to generalize            * gimp_drawable_bucket_fill() to work on any buffer (the code            * is already mostly there) rather than reimplementing a naive            * bucket fill.            * This is mostly a quick'n dirty first implementation which I            * will improve later.            */
name|gimp_line_art_simple_fill
argument_list|(
name|closed
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|y
argument_list|,
operator|&
name|fill_max
argument_list|)
expr_stmt|;
block|}
name|end2
label|:
name|g_list_free_full
argument_list|(
name|fill_pixels
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|normals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|curvatures
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|smoothed_curvatures
argument_list|)
expr_stmt|;
name|g_clear_pointer
argument_list|(
operator|&
name|radii
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|keypoints
condition|)
name|g_array_free
argument_list|(
name|keypoints
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_clear_pointer
argument_list|(
operator|&
name|visited
argument_list|,
name|g_hash_table_destroy
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end1
goto|;
block|}
else|else
block|{
name|g_clear_object
argument_list|(
operator|&
name|strokes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closed_distmap
condition|)
block|{
name|GeglNode
modifier|*
name|graph
decl_stmt|;
name|GeglNode
modifier|*
name|input
decl_stmt|;
name|GeglNode
modifier|*
name|op
decl_stmt|;
comment|/* Flooding needs a distance map for closed line art. */
operator|*
name|closed_distmap
operator|=
name|g_new
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|graph
operator|=
name|gegl_node_new
argument_list|()
expr_stmt|;
name|input
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:buffer-source"
argument_list|,
literal|"buffer"
argument_list|,
name|closed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:distance-transform"
argument_list|,
literal|"metric"
argument_list|,
name|GEGL_DISTANCE_METRIC_EUCLIDEAN
argument_list|,
literal|"normalize"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|input
argument_list|,
literal|"output"
argument_list|,
name|op
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|gegl_node_blit
argument_list|(
name|op
argument_list|,
literal|1.0
argument_list|,
name|gegl_buffer_get_extent
argument_list|(
name|closed
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|*
name|closed_distmap
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_BLIT_DEFAULT
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|graph
argument_list|)
expr_stmt|;
block|}
name|end1
label|:
name|g_clear_object
argument_list|(
operator|&
name|strokes
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
name|g_clear_object
argument_list|(
operator|&
name|closed
argument_list|)
expr_stmt|;
return|return
name|closed
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_lineart_denoise (GeglBuffer * buffer,int minimum_area,GimpAsync * async)
name|gimp_lineart_denoise
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|minimum_area
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
comment|/* Keep connected regions with significant area. */
name|GArray
modifier|*
name|region
decl_stmt|;
name|GQueue
modifier|*
name|q
init|=
name|g_queue_new
argument_list|()
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gboolean
modifier|*
name|visited
init|=
name|g_new0
argument_list|(
name|gboolean
argument_list|,
name|width
operator|*
name|height
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|region
operator|=
name|g_array_sized_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
operator|*
argument_list|)
argument_list|,
name|minimum_area
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|guchar
name|has_stroke
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gint
name|regionSize
init|=
literal|0
decl_stmt|;
name|p
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|Pixel
modifier|*
name|p
decl_stmt|;
name|gint
name|p2x
decl_stmt|;
name|gint
name|p2y
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|p
operator|=
operator|(
name|Pixel
operator|*
operator|)
name|g_queue_pop_head
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
operator|++
name|regionSize
expr_stmt|;
if|if
condition|(
name|regionSize
operator|<
name|minimum_area
condition|)
name|g_array_append_val
argument_list|(
name|region
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regionSize
operator|<
name|minimum_area
condition|)
block|{
name|Pixel
modifier|*
name|pixel
init|=
operator|(
name|Pixel
operator|*
operator|)
name|region
operator|->
name|data
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|region
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|guchar
name|val
init|=
literal|0
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|pixel
operator|->
name|x
argument_list|,
name|pixel
operator|->
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|pixel
operator|++
expr_stmt|;
block|}
block|}
name|g_array_remove_range
argument_list|(
name|region
argument_list|,
literal|0
argument_list|,
name|region
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|end
label|:
name|g_array_free
argument_list|(
name|region
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_queue_free_full
argument_list|(
name|q
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_lineart_compute_normals_curvatures (GeglBuffer * mask,gfloat * normals,gfloat * curvatures,gfloat * smoothed_curvatures,int normal_estimate_mask_size,GimpAsync * async)
name|gimp_lineart_compute_normals_curvatures
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gfloat
modifier|*
name|smoothed_curvatures
parameter_list|,
name|int
name|normal_estimate_mask_size
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|gfloat
modifier|*
name|edgels_curvatures
init|=
name|NULL
decl_stmt|;
name|gfloat
modifier|*
name|smoothed_curvature
decl_stmt|;
name|GArray
modifier|*
name|es
init|=
name|NULL
decl_stmt|;
name|Edgel
modifier|*
modifier|*
name|e
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|es
operator|=
name|gimp_edgelset_new
argument_list|(
name|mask
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|e
operator|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|es
operator|->
name|data
expr_stmt|;
name|gimp_edgelset_smooth_normals
argument_list|(
name|es
argument_list|,
name|normal_estimate_mask_size
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|gimp_edgelset_compute_curvature
argument_list|(
name|es
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end
goto|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
specifier|const
name|float
name|curvature
init|=
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
operator|>
literal|0.0f
operator|)
condition|?
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
else|:
literal|0.0f
decl_stmt|;
specifier|const
name|float
name|w
init|=
name|MAX
argument_list|(
literal|1e-8f
argument_list|,
name|curvature
operator|*
name|curvature
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|normals
index|[
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
operator|+=
name|w
operator|*
operator|(
operator|*
name|e
operator|)
operator|->
name|x_normal
expr_stmt|;
name|normals
index|[
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|+=
name|w
operator|*
operator|(
operator|*
name|e
operator|)
operator|->
name|y_normal
expr_stmt|;
name|curvatures
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
index|]
operator|=
name|MAX
argument_list|(
name|curvature
argument_list|,
name|curvatures
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
index|]
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|float
name|_angle
init|=
name|atan2f
argument_list|(
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|,
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|)
decl_stmt|;
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
operator|=
name|cosf
argument_list|(
name|_angle
argument_list|)
expr_stmt|;
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|sinf
argument_list|(
name|_angle
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Smooth curvatures on edgels, then take maximum on each pixel. */
name|edgels_curvatures
operator|=
name|gimp_lineart_get_smooth_curvatures
argument_list|(
name|es
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|smoothed_curvature
operator|=
name|edgels_curvatures
expr_stmt|;
name|e
operator|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|es
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|gfloat
modifier|*
name|pixel_curvature
init|=
operator|&
name|smoothed_curvatures
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|pixel_curvature
operator|<
operator|*
name|smoothed_curvature
condition|)
operator|*
name|pixel_curvature
operator|=
operator|*
name|smoothed_curvature
expr_stmt|;
operator|++
name|smoothed_curvature
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
name|end
label|:
name|g_free
argument_list|(
name|edgels_curvatures
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
condition|)
name|g_array_free
argument_list|(
name|es
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gfloat
modifier|*
DECL|function|gimp_lineart_get_smooth_curvatures (GArray * edgelset,GimpAsync * async)
name|gimp_lineart_get_smooth_curvatures
parameter_list|(
name|GArray
modifier|*
name|edgelset
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|Edgel
modifier|*
modifier|*
name|e
decl_stmt|;
name|gfloat
modifier|*
name|smoothed_curvatures
init|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|edgelset
operator|->
name|len
argument_list|)
decl_stmt|;
name|gfloat
name|weights
index|[
literal|9
index|]
decl_stmt|;
name|gfloat
name|smoothed_curvature
decl_stmt|;
name|gfloat
name|weights_sum
decl_stmt|;
name|gint
name|idx
init|=
literal|0
decl_stmt|;
name|weights
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|8
condition|;
operator|++
name|i
control|)
name|weights
index|[
name|i
index|]
operator|=
name|expf
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
literal|30.0f
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|edgelset
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|Edgel
modifier|*
name|edgel_before
init|=
name|g_array_index
argument_list|(
name|edgelset
argument_list|,
name|Edgel
operator|*
argument_list|,
operator|(
operator|*
name|e
operator|)
operator|->
name|previous
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|edgel_after
init|=
name|g_array_index
argument_list|(
name|edgelset
argument_list|,
name|Edgel
operator|*
argument_list|,
operator|(
operator|*
name|e
operator|)
operator|->
name|next
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|5
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|smoothed_curvatures
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|smoothed_curvature
operator|=
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
expr_stmt|;
name|weights_sum
operator|=
name|weights
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|edgel_after
operator|!=
name|edgel_before
operator|)
condition|)
block|{
name|smoothed_curvature
operator|+=
name|weights
index|[
name|i
index|]
operator|*
name|edgel_before
operator|->
name|curvature
expr_stmt|;
name|smoothed_curvature
operator|+=
name|weights
index|[
name|i
index|]
operator|*
name|edgel_after
operator|->
name|curvature
expr_stmt|;
name|edgel_before
operator|=
name|g_array_index
argument_list|(
name|edgelset
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_before
operator|->
name|previous
argument_list|)
expr_stmt|;
name|edgel_after
operator|=
name|g_array_index
argument_list|(
name|edgelset
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_after
operator|->
name|next
argument_list|)
expr_stmt|;
name|weights_sum
operator|+=
literal|2
operator|*
name|weights
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|smoothed_curvature
operator|/=
name|weights_sum
expr_stmt|;
name|smoothed_curvatures
index|[
name|idx
operator|++
index|]
operator|=
name|smoothed_curvature
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
return|return
name|smoothed_curvatures
return|;
block|}
end_function

begin_comment
comment|/**  * Keep one pixel per connected component of curvature extremums.  */
end_comment

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_curvature_extremums (gfloat * curvatures,gfloat * smoothed_curvatures,gint width,gint height,GimpAsync * async)
name|gimp_lineart_curvature_extremums
parameter_list|(
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gfloat
modifier|*
name|smoothed_curvatures
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|gboolean
modifier|*
name|visited
init|=
name|g_new0
argument_list|(
name|gboolean
argument_list|,
name|width
operator|*
name|height
argument_list|)
decl_stmt|;
name|GQueue
modifier|*
name|q
init|=
name|g_queue_new
argument_list|()
decl_stmt|;
name|GArray
modifier|*
name|max_positions
decl_stmt|;
name|max_positions
operator|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|curvatures
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|)
operator|&&
operator|!
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|Pixel
name|max_smoothed_curvature_pixel
decl_stmt|;
name|Pixel
name|max_raw_curvature_pixel
decl_stmt|;
name|gfloat
name|max_smoothed_curvature
decl_stmt|;
name|gfloat
name|max_raw_curvature
decl_stmt|;
name|max_smoothed_curvature_pixel
operator|=
name|gimp_vector2_new
argument_list|(
operator|-
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|max_smoothed_curvature
operator|=
literal|0.0f
expr_stmt|;
name|max_raw_curvature_pixel
operator|=
name|gimp_vector2_new
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|max_raw_curvature
operator|=
name|curvatures
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
expr_stmt|;
name|p
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|gfloat
name|sc
decl_stmt|;
name|gfloat
name|c
decl_stmt|;
name|gint
name|p2x
decl_stmt|;
name|gint
name|p2y
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|p
operator|=
operator|(
name|Pixel
operator|*
operator|)
name|g_queue_pop_head
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sc
operator|=
name|smoothed_curvatures
index|[
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|->
name|y
operator|*
name|width
index|]
expr_stmt|;
name|c
operator|=
name|curvatures
index|[
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|->
name|y
operator|*
name|width
index|]
expr_stmt|;
name|curvatures
index|[
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|->
name|y
operator|*
name|width
index|]
operator|=
literal|0.0f
expr_stmt|;
name|p2x
operator|=
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
operator|(
name|gint
operator|)
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|>
name|max_smoothed_curvature
condition|)
block|{
name|max_smoothed_curvature_pixel
operator|=
operator|*
name|p
expr_stmt|;
name|max_smoothed_curvature
operator|=
name|sc
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
name|max_raw_curvature
condition|)
block|{
name|max_raw_curvature_pixel
operator|=
operator|*
name|p
expr_stmt|;
name|max_raw_curvature
operator|=
name|c
expr_stmt|;
block|}
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_smoothed_curvature
operator|>
literal|0.0f
condition|)
block|{
name|curvatures
index|[
operator|(
name|gint
operator|)
name|max_smoothed_curvature_pixel
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|max_smoothed_curvature_pixel
operator|.
name|y
operator|*
name|width
index|]
operator|=
name|max_smoothed_curvature
expr_stmt|;
name|g_array_append_val
argument_list|(
name|max_positions
argument_list|,
name|max_smoothed_curvature_pixel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curvatures
index|[
operator|(
name|gint
operator|)
name|max_raw_curvature_pixel
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|max_raw_curvature_pixel
operator|.
name|y
operator|*
name|width
index|]
operator|=
name|max_raw_curvature
expr_stmt|;
name|g_array_append_val
argument_list|(
name|max_positions
argument_list|,
name|max_raw_curvature_pixel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|end
label|:
name|g_queue_free_full
argument_list|(
name|q
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|g_array_free
argument_list|(
name|max_positions
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|max_positions
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|max_positions
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimp_spline_candidate_cmp (const SplineCandidate * a,const SplineCandidate * b,gpointer user_data)
name|gimp_spline_candidate_cmp
parameter_list|(
specifier|const
name|SplineCandidate
modifier|*
name|a
parameter_list|,
specifier|const
name|SplineCandidate
modifier|*
name|b
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
comment|/* This comparison actually returns the opposite of common comparison    * functions on purpose, as we want the first element on the list to    * be the "bigger".    */
if|if
condition|(
name|a
operator|->
name|quality
operator|<
name|b
operator|->
name|quality
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|quality
operator|>
name|b
operator|->
name|quality
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|gimp_lineart_find_spline_candidates (GArray * max_positions,gfloat * normals,gint width,gint distance_threshold,gfloat max_angle_deg,GimpAsync * async)
name|gimp_lineart_find_spline_candidates
parameter_list|(
name|GArray
modifier|*
name|max_positions
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|distance_threshold
parameter_list|,
name|gfloat
name|max_angle_deg
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|GList
modifier|*
name|candidates
init|=
name|NULL
decl_stmt|;
specifier|const
name|float
name|CosMin
init|=
name|cosf
argument_list|(
name|M_PI
operator|*
operator|(
name|max_angle_deg
operator|/
literal|180.0
operator|)
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_positions
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p1
init|=
name|g_array_index
argument_list|(
name|max_positions
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gint
name|j
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
name|g_list_free_full
argument_list|(
name|candidates
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|max_positions
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|max_positions
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
specifier|const
name|float
name|distance
init|=
name|gimp_vector2_length_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|<=
name|distance_threshold
condition|)
block|{
name|GimpVector2
name|normalP1
decl_stmt|;
name|GimpVector2
name|normalP2
decl_stmt|;
name|GimpVector2
name|p1f
decl_stmt|;
name|GimpVector2
name|p2f
decl_stmt|;
name|GimpVector2
name|p1p2
decl_stmt|;
name|float
name|cosN
decl_stmt|;
name|float
name|qualityA
decl_stmt|;
name|float
name|qualityB
decl_stmt|;
name|float
name|qualityC
decl_stmt|;
name|float
name|quality
decl_stmt|;
name|normalP1
operator|=
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p1
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p1
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p1
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p1
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|normalP2
operator|=
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|p1f
operator|=
name|gimp_vector2_new
argument_list|(
name|p1
operator|.
name|x
argument_list|,
name|p1
operator|.
name|y
argument_list|)
expr_stmt|;
name|p2f
operator|=
name|gimp_vector2_new
argument_list|(
name|p2
operator|.
name|x
argument_list|,
name|p2
operator|.
name|y
argument_list|)
expr_stmt|;
name|p1p2
operator|=
name|gimp_vector2_sub_val
argument_list|(
name|p2f
argument_list|,
name|p1f
argument_list|)
expr_stmt|;
name|cosN
operator|=
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP1
argument_list|,
operator|(
name|gimp_vector2_neg_val
argument_list|(
name|normalP2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|qualityA
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
literal|1
operator|-
name|distance
operator|/
name|distance_threshold
argument_list|)
expr_stmt|;
name|qualityB
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
call|(
name|float
call|)
argument_list|(
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP1
argument_list|,
name|p1p2
argument_list|)
operator|-
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP2
argument_list|,
name|p1p2
argument_list|)
argument_list|)
operator|/
name|distance
argument_list|)
expr_stmt|;
name|qualityC
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
name|cosN
operator|-
name|CosMin
argument_list|)
expr_stmt|;
name|quality
operator|=
name|qualityA
operator|*
name|qualityB
operator|*
name|qualityC
expr_stmt|;
if|if
condition|(
name|quality
operator|>
literal|0
condition|)
block|{
name|SplineCandidate
modifier|*
name|candidate
init|=
name|g_new
argument_list|(
name|SplineCandidate
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|candidate
operator|->
name|p1
operator|=
name|p1
expr_stmt|;
name|candidate
operator|->
name|p2
operator|=
name|p2
expr_stmt|;
name|candidate
operator|->
name|quality
operator|=
name|quality
expr_stmt|;
name|candidates
operator|=
name|g_list_insert_sorted_with_data
argument_list|(
name|candidates
argument_list|,
name|candidate
argument_list|,
operator|(
name|GCompareDataFunc
operator|)
name|gimp_spline_candidate_cmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|candidates
return|;
block|}
end_function

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_discrete_spline (Pixel p0,GimpVector2 n0,Pixel p1,GimpVector2 n1)
name|gimp_lineart_discrete_spline
parameter_list|(
name|Pixel
name|p0
parameter_list|,
name|GimpVector2
name|n0
parameter_list|,
name|Pixel
name|p1
parameter_list|,
name|GimpVector2
name|n1
parameter_list|)
block|{
name|GArray
modifier|*
name|points
init|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|double
name|a0
init|=
literal|2
operator|*
name|p0
operator|.
name|x
operator|-
literal|2
operator|*
name|p1
operator|.
name|x
operator|+
name|n0
operator|.
name|x
operator|-
name|n1
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|b0
init|=
operator|-
literal|3
operator|*
name|p0
operator|.
name|x
operator|+
literal|3
operator|*
name|p1
operator|.
name|x
operator|-
literal|2
operator|*
name|n0
operator|.
name|x
operator|+
name|n1
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|c0
init|=
name|n0
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|d0
init|=
name|p0
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|a1
init|=
literal|2
operator|*
name|p0
operator|.
name|y
operator|-
literal|2
operator|*
name|p1
operator|.
name|y
operator|+
name|n0
operator|.
name|y
operator|-
name|n1
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|b1
init|=
operator|-
literal|3
operator|*
name|p0
operator|.
name|y
operator|+
literal|3
operator|*
name|p1
operator|.
name|y
operator|-
literal|2
operator|*
name|n0
operator|.
name|y
operator|+
name|n1
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|c1
init|=
name|n0
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|d1
init|=
name|p0
operator|.
name|y
decl_stmt|;
name|double
name|t
init|=
literal|0.0
decl_stmt|;
specifier|const
name|double
name|dtMin
init|=
literal|1.0
operator|/
name|MAX
argument_list|(
name|fabs
argument_list|(
name|p0
operator|.
name|x
operator|-
name|p1
operator|.
name|x
argument_list|)
argument_list|,
name|fabs
argument_list|(
name|p0
operator|.
name|y
operator|-
name|p1
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|Pixel
name|point
init|=
name|gimp_vector2_new
argument_list|(
operator|(
name|gint
operator|)
name|round
argument_list|(
name|d0
argument_list|)
argument_list|,
operator|(
name|gint
operator|)
name|round
argument_list|(
name|d1
argument_list|)
argument_list|)
decl_stmt|;
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|point
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<=
literal|1.0
condition|)
block|{
specifier|const
name|double
name|t2
init|=
name|t
operator|*
name|t
decl_stmt|;
specifier|const
name|double
name|t3
init|=
name|t
operator|*
name|t2
decl_stmt|;
name|double
name|dx
decl_stmt|;
name|double
name|dy
decl_stmt|;
name|Pixel
name|p
init|=
name|gimp_vector2_new
argument_list|(
operator|(
name|gint
operator|)
name|round
argument_list|(
name|a0
operator|*
name|t3
operator|+
name|b0
operator|*
name|t2
operator|+
name|c0
operator|*
name|t
operator|+
name|d0
argument_list|)
argument_list|,
operator|(
name|gint
operator|)
name|round
argument_list|(
name|a1
operator|*
name|t3
operator|+
name|b1
operator|*
name|t2
operator|+
name|c1
operator|*
name|t
operator|+
name|d1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* create gimp_vector2_neq () ? */
if|if
condition|(
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|x
operator|!=
name|p
operator|.
name|x
operator|||
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|y
operator|!=
name|p
operator|.
name|y
condition|)
block|{
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|dx
operator|=
name|fabs
argument_list|(
literal|3
operator|*
name|a0
operator|*
name|t
operator|*
name|t
operator|+
literal|2
operator|*
name|b0
operator|*
name|t
operator|+
name|c0
argument_list|)
operator|+
literal|1e-8
expr_stmt|;
name|dy
operator|=
name|fabs
argument_list|(
literal|3
operator|*
name|a1
operator|*
name|t
operator|*
name|t
operator|+
literal|2
operator|*
name|b1
operator|*
name|t
operator|+
name|c1
argument_list|)
operator|+
literal|1e-8
expr_stmt|;
name|t
operator|+=
name|MIN
argument_list|(
name|dtMin
argument_list|,
literal|0.75
operator|/
name|MAX
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|x
operator|!=
name|p1
operator|.
name|x
operator|||
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|y
operator|!=
name|p1
operator|.
name|y
condition|)
block|{
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
return|return
name|points
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimp_number_of_transitions (GArray * pixels,GeglBuffer * buffer)
name|gimp_number_of_transitions
parameter_list|(
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pixels
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|Pixel
name|it
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|guchar
name|value
decl_stmt|;
name|gboolean
name|previous
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|previous
operator|=
operator|(
name|gboolean
operator|)
name|value
expr_stmt|;
comment|/* Starts at the second element. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|it
operator|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|result
operator|+=
operator|(
operator|(
name|gboolean
operator|)
name|value
operator|!=
name|previous
operator|)
expr_stmt|;
name|previous
operator|=
operator|(
name|gboolean
operator|)
name|value
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_line_art_allow_closure:  * @mask: the current state of line art closure.  * @pixels: the pixels of a candidate closure (spline or segment).  * @fill_pixels: #GList of unsignificant pixels to bucket fill.  * @significant_size: number of pixels for area to be considered  *                    "significant".  * @minimum_size: number of pixels for area to be allowed.  *  * Checks whether adding the set of points @pixels to @mask will create  * 4-connected background regions whose size (i.e. number of pixels)  * will be below @minimum_size. If it creates such small areas, the  * function will refuse this candidate spline/segment, with the  * exception of very small areas under @significant_size. These  * micro-area are considered "unsignificant" and accepted (because they  * can be created in some conditions, for instance when created curves  * cross or start from a same endpoint), and one pixel for each  * micro-area will be added to @fill_pixels to be later filled along  * with the candidate pixels.  *  * Returns: #TRUE if @pixels should be added to @mask, #FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|gimp_line_art_allow_closure (GeglBuffer * mask,GArray * pixels,GList ** fill_pixels,int significant_size,int minimum_size)
name|gimp_line_art_allow_closure
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GList
modifier|*
modifier|*
name|fill_pixels
parameter_list|,
name|int
name|significant_size
parameter_list|,
name|int
name|minimum_size
parameter_list|)
block|{
comment|/* A theorem from the paper is that a zone with more than    * `2 * (@minimum_size - 1)` edgels (border pixels) will have more    * than @minimum_size pixels.    * Since we are following the edges of the area, we can therefore stop    * earlier if we reach this number of edgels.    */
specifier|const
name|glong
name|max_edgel_count
init|=
literal|2
operator|*
name|minimum_size
decl_stmt|;
name|Pixel
modifier|*
name|p
init|=
operator|(
name|Pixel
operator|*
operator|)
name|pixels
operator|->
name|data
decl_stmt|;
name|GList
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Mark pixels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|x
operator|>=
literal|0
operator|&&
name|p
operator|->
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|->
name|y
operator|>=
literal|0
operator|&&
name|p
operator|->
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|->
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|direction
init|=
literal|0
init|;
name|direction
operator|<
literal|4
condition|;
operator|++
name|direction
control|)
block|{
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
operator|&&
name|border_in_direction
argument_list|(
name|mask
argument_list|,
name|p
argument_list|,
name|direction
argument_list|)
condition|)
block|{
name|Edgel
name|e
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|glong
name|count
decl_stmt|;
name|glong
name|area
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|gboolean
call|)
argument_list|(
name|val
operator|&
operator|(
literal|4
operator|<<
name|direction
operator|)
argument_list|)
condition|)
continue|continue;
name|gimp_edgel_init
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|x
operator|=
name|p
operator|.
name|x
expr_stmt|;
name|e
operator|.
name|y
operator|=
name|p
operator|.
name|y
expr_stmt|;
name|e
operator|.
name|direction
operator|=
name|direction
expr_stmt|;
name|count
operator|=
name|gimp_edgel_track_mark
argument_list|(
name|mask
argument_list|,
name|e
argument_list|,
name|max_edgel_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|count
operator|<=
name|max_edgel_count
operator|)
condition|)
block|{
name|area
operator|=
name|gimp_edgel_region_area
argument_list|(
name|mask
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|area
operator|>=
name|significant_size
operator|&&
name|area
operator|<
name|minimum_size
condition|)
block|{
name|gint
name|j
decl_stmt|;
comment|/* Remove marks */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pixels
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|p2
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p2
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p2
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p2
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_list_free_full
argument_list|(
name|fp
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|area
operator|>
literal|0
operator|&&
name|area
operator|<
name|significant_size
condition|)
block|{
name|Pixel
modifier|*
name|np
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|np
operator|->
name|x
operator|=
name|direction
operator|==
name|XPlusDirection
condition|?
name|p
operator|.
name|x
operator|+
literal|1
else|:
operator|(
name|direction
operator|==
name|XMinusDirection
condition|?
name|p
operator|.
name|x
operator|-
literal|1
else|:
name|p
operator|.
name|x
operator|)
expr_stmt|;
name|np
operator|->
name|y
operator|=
name|direction
operator|==
name|YPlusDirection
condition|?
name|p
operator|.
name|y
operator|+
literal|1
else|:
operator|(
name|direction
operator|==
name|YMinusDirection
condition|?
name|p
operator|.
name|y
operator|-
literal|1
else|:
name|p
operator|.
name|y
operator|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|x
operator|>=
literal|0
operator|&&
name|np
operator|->
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|np
operator|->
name|y
operator|>=
literal|0
operator|&&
name|np
operator|->
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
name|fp
operator|=
name|g_list_prepend
argument_list|(
name|fp
argument_list|,
name|np
argument_list|)
expr_stmt|;
else|else
name|g_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
operator|*
name|fill_pixels
operator|=
name|g_list_concat
argument_list|(
operator|*
name|fill_pixels
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Remove marks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_line_segment_until_hit (const GeglBuffer * mask,Pixel start,GimpVector2 direction,int size)
name|gimp_lineart_line_segment_until_hit
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|start
parameter_list|,
name|GimpVector2
name|direction
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
init|=
operator|(
name|GeglBuffer
operator|*
operator|)
name|mask
decl_stmt|;
name|gboolean
name|out
init|=
name|FALSE
decl_stmt|;
name|GArray
modifier|*
name|points
init|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tmax
decl_stmt|;
name|GimpVector2
name|p0
init|=
name|gimp_vector2_new
argument_list|(
name|start
operator|.
name|x
argument_list|,
name|start
operator|.
name|y
argument_list|)
decl_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|direction
argument_list|,
operator|(
name|gdouble
operator|)
name|size
argument_list|)
expr_stmt|;
name|direction
operator|.
name|x
operator|=
name|round
argument_list|(
name|direction
operator|.
name|x
argument_list|)
expr_stmt|;
name|direction
operator|.
name|y
operator|=
name|round
argument_list|(
name|direction
operator|.
name|y
argument_list|)
expr_stmt|;
name|tmax
operator|=
name|MAX
argument_list|(
name|abs
argument_list|(
operator|(
name|int
operator|)
name|direction
operator|.
name|x
argument_list|)
argument_list|,
name|abs
argument_list|(
operator|(
name|int
operator|)
name|direction
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<=
name|tmax
condition|;
operator|++
name|t
control|)
block|{
name|GimpVector2
name|v
init|=
name|gimp_vector2_add_val
argument_list|(
name|p0
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|direction
argument_list|,
operator|(
name|float
operator|)
name|t
operator|/
name|tmax
argument_list|)
argument_list|)
decl_stmt|;
name|Pixel
name|p
decl_stmt|;
name|p
operator|.
name|x
operator|=
operator|(
name|gint
operator|)
name|round
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
name|p
operator|.
name|y
operator|=
operator|(
name|gint
operator|)
name|round
argument_list|(
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|&&
name|val
condition|)
block|{
return|return
name|points
return|;
block|}
name|out
operator|=
operator|!
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out
condition|)
block|{
return|return
name|points
return|;
block|}
else|else
block|{
name|g_array_free
argument_list|(
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
return|;
block|}
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gfloat
modifier|*
DECL|function|gimp_lineart_estimate_strokes_radii (GeglBuffer * mask,GimpAsync * async)
name|gimp_lineart_estimate_strokes_radii
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|gfloat
modifier|*
name|dist
decl_stmt|;
name|gfloat
modifier|*
name|thickness
decl_stmt|;
name|GeglNode
modifier|*
name|graph
decl_stmt|;
name|GeglNode
modifier|*
name|input
decl_stmt|;
name|GeglNode
modifier|*
name|op
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
decl_stmt|;
comment|/* Compute a distance map for the line art. */
name|dist
operator|=
name|g_new
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|graph
operator|=
name|gegl_node_new
argument_list|()
expr_stmt|;
name|input
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:buffer-source"
argument_list|,
literal|"buffer"
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:distance-transform"
argument_list|,
literal|"metric"
argument_list|,
name|GEGL_DISTANCE_METRIC_EUCLIDEAN
argument_list|,
literal|"normalize"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|input
argument_list|,
literal|"output"
argument_list|,
name|op
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|gegl_node_blit
argument_list|(
name|op
argument_list|,
literal|1.0
argument_list|,
name|gegl_buffer_get_extent
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|dist
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_BLIT_DEFAULT
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|thickness
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|mask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|m
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|startx
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|x
decl_stmt|;
name|gint
name|starty
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|y
decl_stmt|;
name|gint
name|endy
init|=
name|starty
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|height
decl_stmt|;
name|gint
name|endx
init|=
name|startx
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|width
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|y
operator|=
name|starty
init|;
name|y
operator|<
name|endy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|startx
init|;
name|x
operator|<
name|endx
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|&&
name|dist
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|==
literal|1.0
condition|)
block|{
name|gint
name|dx
init|=
name|x
decl_stmt|;
name|gint
name|dy
init|=
name|y
decl_stmt|;
name|gfloat
name|d
init|=
literal|1.0
decl_stmt|;
name|gfloat
name|nd
decl_stmt|;
name|gboolean
name|neighbour_thicker
init|=
name|TRUE
decl_stmt|;
while|while
condition|(
name|neighbour_thicker
condition|)
block|{
name|gint
name|px
init|=
name|dx
operator|-
literal|1
decl_stmt|;
name|gint
name|py
init|=
name|dy
operator|-
literal|1
decl_stmt|;
name|gint
name|nx
init|=
name|dx
operator|+
literal|1
decl_stmt|;
name|gint
name|ny
init|=
name|dy
operator|+
literal|1
decl_stmt|;
name|neighbour_thicker
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|px
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nd
operator|=
name|dist
index|[
name|px
operator|+
name|dy
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|px
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|py
operator|>=
literal|0
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|px
operator|+
name|py
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|px
expr_stmt|;
name|dy
operator|=
name|py
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ny
operator|<
name|height
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|px
operator|+
name|ny
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|px
expr_stmt|;
name|dy
operator|=
name|ny
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|nx
operator|<
name|width
condition|)
block|{
if|if
condition|(
operator|(
name|nd
operator|=
name|dist
index|[
name|nx
operator|+
name|dy
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|nx
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|py
operator|>=
literal|0
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|nx
operator|+
name|py
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|nx
expr_stmt|;
name|dy
operator|=
name|py
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ny
operator|<
name|height
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|nx
operator|+
name|ny
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dx
operator|=
name|nx
expr_stmt|;
name|dy
operator|=
name|ny
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|py
operator|>
literal|0
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|dx
operator|+
name|py
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dy
operator|=
name|py
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ny
operator|<
name|height
operator|&&
operator|(
name|nd
operator|=
name|dist
index|[
name|dx
operator|+
name|ny
operator|*
name|width
index|]
operator|)
operator|>
name|d
condition|)
block|{
name|d
operator|=
name|nd
expr_stmt|;
name|dy
operator|=
name|ny
expr_stmt|;
name|neighbour_thicker
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
name|thickness
index|[
operator|(
name|gint
operator|)
name|x
operator|+
operator|(
name|gint
operator|)
name|y
operator|*
name|width
index|]
operator|=
name|d
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
block|}
block|}
name|end
label|:
name|g_free
argument_list|(
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
name|g_clear_pointer
argument_list|(
operator|&
name|thickness
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
return|return
name|thickness
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_line_art_simple_fill (GeglBuffer * buffer,gint x,gint y,gint * counter)
name|gimp_line_art_simple_fill
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
modifier|*
name|counter
parameter_list|)
block|{
name|guchar
name|val
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
operator|||
name|counter
operator|<=
literal|0
condition|)
return|return;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
operator|(
operator|*
name|counter
operator|)
operator|--
expr_stmt|;
name|gimp_line_art_simple_fill
argument_list|(
name|buffer
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|gimp_line_art_simple_fill
argument_list|(
name|buffer
argument_list|,
name|x
operator|-
literal|1
argument_list|,
name|y
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|gimp_line_art_simple_fill
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|gimp_line_art_simple_fill
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|visited_hash_fun (Pixel * key)
name|visited_hash_fun
parameter_list|(
name|Pixel
modifier|*
name|key
parameter_list|)
block|{
comment|/* Cantor pairing function. */
return|return
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|)
operator|*
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
name|key
operator|->
name|y
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|visited_equal_fun (Pixel * e1,Pixel * e2)
name|visited_equal_fun
parameter_list|(
name|Pixel
modifier|*
name|e1
parameter_list|,
name|Pixel
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|border_in_direction (GeglBuffer * mask,Pixel p,int direction)
name|border_in_direction
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|p
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|gint
name|px
init|=
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
name|DeltaX
index|[
name|direction
index|]
decl_stmt|;
name|gint
name|py
init|=
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|+
name|DeltaY
index|[
name|direction
index|]
decl_stmt|;
if|if
condition|(
name|px
operator|>=
literal|0
operator|&&
name|px
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|py
operator|>=
literal|0
operator|&&
name|py
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
name|px
argument_list|,
name|py
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
return|return
operator|!
operator|(
operator|(
name|gboolean
operator|)
name|val
operator|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|GimpVector2
DECL|function|pair2normal (Pixel p,gfloat * normals,gint width)
name|pair2normal
parameter_list|(
name|Pixel
name|p
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|)
block|{
return|return
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Edgel functions */
end_comment

begin_function
specifier|static
name|Edgel
modifier|*
DECL|function|gimp_edgel_new (int x,int y,Direction direction)
name|gimp_edgel_new
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|)
block|{
name|Edgel
modifier|*
name|edgel
init|=
name|g_new
argument_list|(
name|Edgel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|edgel
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|edgel
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|edgel
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|gimp_edgel_init
argument_list|(
name|edgel
argument_list|)
expr_stmt|;
return|return
name|edgel
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgel_init (Edgel * edgel)
name|gimp_edgel_init
parameter_list|(
name|Edgel
modifier|*
name|edgel
parameter_list|)
block|{
name|edgel
operator|->
name|x_normal
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|y_normal
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|curvature
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|next
operator|=
name|edgel
operator|->
name|previous
operator|=
name|G_MAXUINT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgel_clear (Edgel ** edgel)
name|gimp_edgel_clear
parameter_list|(
name|Edgel
modifier|*
modifier|*
name|edgel
parameter_list|)
block|{
name|g_clear_pointer
argument_list|(
name|edgel
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|gimp_edgel_cmp (const Edgel * e1,const Edgel * e2)
name|gimp_edgel_cmp
parameter_list|(
specifier|const
name|Edgel
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edgel
modifier|*
name|e2
parameter_list|)
block|{
name|gimp_assert
argument_list|(
name|e1
operator|&&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|)
operator|&&
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|)
operator|&&
operator|(
name|e1
operator|->
name|direction
operator|==
name|e2
operator|->
name|direction
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|e1
operator|->
name|y
operator|<
name|e2
operator|->
name|y
operator|)
operator|||
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|x
operator|<
name|e2
operator|->
name|x
operator|)
operator|||
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|direction
operator|<
name|e2
operator|->
name|direction
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|edgel2index_hash_fun (Edgel * key)
name|edgel2index_hash_fun
parameter_list|(
name|Edgel
modifier|*
name|key
parameter_list|)
block|{
comment|/* Cantor pairing function.    * Was not sure how to use the direction though. :-/    */
return|return
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|)
operator|*
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
name|key
operator|->
name|y
operator|*
name|key
operator|->
name|direction
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|edgel2index_equal_fun (Edgel * e1,Edgel * e2)
name|edgel2index_equal_fun
parameter_list|(
name|Edgel
modifier|*
name|e1
parameter_list|,
name|Edgel
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|direction
operator|==
name|e2
operator|->
name|direction
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @mask;  * @edgel:  * @size_limit:  *  * Track a border, marking inner pixels with a bit corresponding to the  * edgel traversed (4<< direction) for direction in {0,1,2,3}.  * Stop tracking after @size_limit edgels have been visited.  *  * Returns: Number of visited edgels, or -1 if an already visited edgel  *          has been encountered.  */
end_comment

begin_function
specifier|static
name|glong
DECL|function|gimp_edgel_track_mark (GeglBuffer * mask,Edgel edgel,long size_limit)
name|gimp_edgel_track_mark
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|edgel
parameter_list|,
name|long
name|size_limit
parameter_list|)
block|{
name|Edgel
name|start
init|=
name|edgel
decl_stmt|;
name|long
name|count
init|=
literal|1
decl_stmt|;
do|do
block|{
name|guchar
name|val
decl_stmt|;
name|gimp_edgelset_next8
argument_list|(
name|mask
argument_list|,
operator|&
name|edgel
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
name|edgel
operator|.
name|x
argument_list|,
name|edgel
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|2
condition|)
block|{
comment|/* Only mark pixels of the spline/segment */
if|if
condition|(
name|val
operator|&
operator|(
literal|4
operator|<<
name|edgel
operator|.
name|direction
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Mark edgel in pixel (1 == In Mask, 2 == Spline/Segment) */
name|val
operator||=
operator|(
literal|4
operator|<<
name|edgel
operator|.
name|direction
operator|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|edgel
operator|.
name|x
argument_list|,
name|edgel
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|count
expr_stmt|;
block|}
do|while
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
literal|0
operator|&&
name|count
operator|<=
name|size_limit
condition|)
do|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_edgel_region_area:  * @mask: current state of closed line art buffer.  * @start_edgel: edgel to follow.  *  * Follows a line border, starting from @start_edgel to compute the area  * enclosed by this border.  * Unfortunately this may return a negative area when the line does not  * close a zone. In this case, there is an uncertaincy on the size of  * the created zone, and we should consider it a big size.  *  * Returns: the area enclosed by the followed line, or a negative value  * if the zone is not closed (hence actual area unknown).  */
end_comment

begin_function
specifier|static
name|glong
DECL|function|gimp_edgel_region_area (const GeglBuffer * mask,Edgel start_edgel)
name|gimp_edgel_region_area
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|start_edgel
parameter_list|)
block|{
name|Edgel
name|edgel
init|=
name|start_edgel
decl_stmt|;
name|glong
name|area
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|edgel
operator|.
name|direction
operator|==
name|XPlusDirection
condition|)
name|area
operator|-=
name|edgel
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|edgel
operator|.
name|direction
operator|==
name|XMinusDirection
condition|)
name|area
operator|+=
name|edgel
operator|.
name|x
operator|-
literal|1
expr_stmt|;
name|gimp_edgelset_next8
argument_list|(
name|mask
argument_list|,
operator|&
name|edgel
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start_edgel
argument_list|)
operator|!=
literal|0
condition|)
do|;
return|return
name|area
return|;
block|}
end_function

begin_comment
comment|/* Edgel sets */
end_comment

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_edgelset_new (GeglBuffer * buffer,GimpAsync * async)
name|gimp_edgelset_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|GArray
modifier|*
name|set
decl_stmt|;
name|GHashTable
modifier|*
name|edgel2index
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|set
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Edgel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|g_array_set_clear_func
argument_list|(
name|set
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|gimp_edgel_clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|1
operator|||
name|height
operator|<=
literal|1
condition|)
return|return
name|set
return|;
name|edgel2index
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|edgel2index_hash_fun
argument_list|,
operator|(
name|GEqualFunc
operator|)
name|edgel2index_equal_fun
argument_list|)
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|p
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|prevy
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|1
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|nexty
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|2
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|prevx
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|3
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|nextx
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|4
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|startx
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|x
decl_stmt|;
name|gint
name|starty
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|y
decl_stmt|;
name|gint
name|endy
init|=
name|starty
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|height
decl_stmt|;
name|gint
name|endx
init|=
name|startx
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|width
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|gi
argument_list|)
expr_stmt|;
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|y
operator|=
name|starty
init|;
name|y
operator|<
name|endy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|startx
init|;
name|x
operator|<
name|endx
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|prevy
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|YMinusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|nexty
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|YPlusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|prevx
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|XMinusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|nextx
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|XPlusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
block|}
name|prevy
operator|++
expr_stmt|;
name|nexty
operator|++
expr_stmt|;
name|prevx
operator|++
expr_stmt|;
name|nextx
operator|++
expr_stmt|;
block|}
block|}
name|gimp_edgelset_build_graph
argument_list|(
name|set
argument_list|,
name|buffer
argument_list|,
name|edgel2index
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|gimp_edgelset_init_normals
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|end
label|:
name|g_hash_table_destroy
argument_list|(
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_async_is_stopped
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|g_array_free
argument_list|(
name|set
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|set
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_add (GArray * set,int x,int y,Direction direction,GHashTable * edgel2index)
name|gimp_edgelset_add
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
block|{
name|Edgel
modifier|*
name|edgel
init|=
name|gimp_edgel_new
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|direction
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|position
init|=
name|set
operator|->
name|len
decl_stmt|;
name|g_array_append_val
argument_list|(
name|set
argument_list|,
name|edgel
argument_list|)
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|edgel2index
argument_list|,
name|edgel
argument_list|,
name|GUINT_TO_POINTER
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_init_normals (GArray * set)
name|gimp_edgelset_init_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
block|{
name|Edgel
modifier|*
modifier|*
name|e
init|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|set
operator|->
name|data
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|GimpVector2
name|n
init|=
name|Direction2Normal
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|direction
index|]
decl_stmt|;
operator|(
operator|*
name|e
operator|)
operator|->
name|x_normal
operator|=
name|n
operator|.
name|x
expr_stmt|;
operator|(
operator|*
name|e
operator|)
operator|->
name|y_normal
operator|=
name|n
operator|.
name|y
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_smooth_normals (GArray * set,int mask_size,GimpAsync * async)
name|gimp_edgelset_smooth_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|mask_size
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
specifier|const
name|gfloat
name|sigma
init|=
name|mask_size
operator|*
literal|0.775
decl_stmt|;
specifier|const
name|gfloat
name|den
init|=
literal|2
operator|*
name|sigma
operator|*
name|sigma
decl_stmt|;
name|gfloat
name|weights
index|[
literal|65
index|]
decl_stmt|;
name|GimpVector2
name|smoothed_normal
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimp_assert
argument_list|(
name|mask_size
operator|<=
literal|65
argument_list|)
expr_stmt|;
name|weights
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|mask_size
condition|;
operator|++
name|i
control|)
name|weights
index|[
name|i
index|]
operator|=
name|expf
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
name|den
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|edgel_before
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|previous
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|edgel_after
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|next
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|mask_size
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
return|return;
block|}
name|smoothed_normal
operator|=
name|Direction2Normal
index|[
name|it
operator|->
name|direction
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|edgel_after
operator|!=
name|edgel_before
operator|)
condition|)
block|{
name|smoothed_normal
operator|=
name|gimp_vector2_add_val
argument_list|(
name|smoothed_normal
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|Direction2Normal
index|[
name|edgel_before
operator|->
name|direction
index|]
argument_list|,
name|weights
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|smoothed_normal
operator|=
name|gimp_vector2_add_val
argument_list|(
name|smoothed_normal
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|Direction2Normal
index|[
name|edgel_after
operator|->
name|direction
index|]
argument_list|,
name|weights
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|edgel_before
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_before
operator|->
name|previous
argument_list|)
expr_stmt|;
name|edgel_after
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_after
operator|->
name|next
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|gimp_vector2_normalize
argument_list|(
operator|&
name|smoothed_normal
argument_list|)
expr_stmt|;
name|it
operator|->
name|x_normal
operator|=
name|smoothed_normal
operator|.
name|x
expr_stmt|;
name|it
operator|->
name|y_normal
operator|=
name|smoothed_normal
operator|.
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_compute_curvature (GArray * set,GimpAsync * async)
name|gimp_edgelset_compute_curvature
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|previous
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|previous
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|next
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|next
argument_list|)
decl_stmt|;
name|GimpVector2
name|n_prev
init|=
name|gimp_vector2_new
argument_list|(
name|previous
operator|->
name|x_normal
argument_list|,
name|previous
operator|->
name|y_normal
argument_list|)
decl_stmt|;
name|GimpVector2
name|n_next
init|=
name|gimp_vector2_new
argument_list|(
name|next
operator|->
name|x_normal
argument_list|,
name|next
operator|->
name|y_normal
argument_list|)
decl_stmt|;
name|GimpVector2
name|diff
init|=
name|gimp_vector2_mul_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
name|n_next
argument_list|,
name|n_prev
argument_list|)
argument_list|,
literal|0.5
argument_list|)
decl_stmt|;
specifier|const
name|float
name|c
init|=
name|gimp_vector2_length_val
argument_list|(
name|diff
argument_list|)
decl_stmt|;
specifier|const
name|float
name|crossp
init|=
name|n_prev
operator|.
name|x
operator|*
name|n_next
operator|.
name|y
operator|-
name|n_prev
operator|.
name|y
operator|*
name|n_next
operator|.
name|x
decl_stmt|;
name|it
operator|->
name|curvature
operator|=
operator|(
name|crossp
operator|>
literal|0.0f
operator|)
condition|?
name|c
else|:
operator|-
name|c
expr_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_build_graph (GArray * set,GeglBuffer * buffer,GHashTable * edgel2index,GimpAsync * async)
name|gimp_edgelset_build_graph
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|,
name|GimpAsync
modifier|*
name|async
parameter_list|)
block|{
name|Edgel
name|edgel
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|neighbor
decl_stmt|;
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|guint
name|neighbor_pos
decl_stmt|;
if|if
condition|(
name|gimp_async_is_canceled
argument_list|(
name|async
argument_list|)
condition|)
block|{
name|gimp_async_abort
argument_list|(
name|async
argument_list|)
expr_stmt|;
return|return;
block|}
name|gimp_edgelset_next8
argument_list|(
name|buffer
argument_list|,
name|it
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
name|gimp_assert
argument_list|(
name|g_hash_table_contains
argument_list|(
name|edgel2index
argument_list|,
operator|&
name|edgel
argument_list|)
argument_list|)
expr_stmt|;
name|neighbor_pos
operator|=
name|GPOINTER_TO_UINT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|edgel2index
argument_list|,
operator|&
name|edgel
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|next
operator|=
name|neighbor_pos
expr_stmt|;
name|neighbor
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|neighbor_pos
argument_list|)
expr_stmt|;
name|neighbor
operator|->
name|previous
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_next8 (const GeglBuffer * buffer,Edgel * it,Edgel * n)
name|gimp_edgelset_next8
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Edgel
modifier|*
name|it
parameter_list|,
name|Edgel
modifier|*
name|n
parameter_list|)
block|{
name|guint8
name|pixels
index|[
literal|9
index|]
decl_stmt|;
name|n
operator|->
name|x
operator|=
name|it
operator|->
name|x
expr_stmt|;
name|n
operator|->
name|y
operator|=
name|it
operator|->
name|y
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|it
operator|->
name|direction
expr_stmt|;
name|gegl_buffer_get
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|n
operator|->
name|x
operator|-
literal|1
argument_list|,
name|n
operator|->
name|y
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|NULL
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|direction
condition|)
block|{
case|case
name|XPlusDirection
case|:
if|if
condition|(
name|pixels
index|[
literal|8
index|]
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|YMinusDirection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixels
index|[
literal|7
index|]
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|YPlusDirection
expr_stmt|;
block|}
break|break;
case|case
name|YMinusDirection
case|:
if|if
condition|(
name|pixels
index|[
literal|2
index|]
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|XMinusDirection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixels
index|[
literal|5
index|]
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|XPlusDirection
expr_stmt|;
block|}
break|break;
case|case
name|XMinusDirection
case|:
if|if
condition|(
name|pixels
index|[
literal|0
index|]
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|YPlusDirection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixels
index|[
literal|1
index|]
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|YMinusDirection
expr_stmt|;
block|}
break|break;
case|case
name|YPlusDirection
case|:
if|if
condition|(
name|pixels
index|[
literal|6
index|]
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|XPlusDirection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixels
index|[
literal|3
index|]
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|XMinusDirection
expr_stmt|;
block|}
break|break;
default|default:
name|g_return_if_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

