begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Copyright (C) 2017 SÃ©bastien Fourey& David TchumperlÃ©  * Copyright (C) 2018 Jehan  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
DECL|macro|GEGL_ITERATOR2_API
define|#
directive|define
name|GEGL_ITERATOR2_API
end_define

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"core-types.h"
end_include

begin_include
include|#
directive|include
file|"gimplineart.h"
end_include

begin_decl_stmt
DECL|variable|DeltaX
specifier|static
name|int
name|DeltaX
index|[
literal|4
index|]
init|=
block|{
operator|+
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|DeltaY
specifier|static
name|int
name|DeltaY
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|+
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|Direction2Normal
specifier|static
specifier|const
name|GimpVector2
name|Direction2Normal
index|[
literal|4
index|]
init|=
block|{
block|{
literal|1.0f
block|,
literal|0.0f
block|}
block|,
block|{
operator|-
literal|1.0f
block|,
literal|0.0f
block|}
block|,
block|{
literal|0.0f
block|,
literal|1.0f
block|}
block|,
block|{
literal|0.0f
block|,
operator|-
literal|1.0f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|enum|_Direction
typedef|typedef
enum|enum
name|_Direction
block|{
DECL|enumerator|XPlusDirection
name|XPlusDirection
init|=
literal|0
block|,
DECL|enumerator|XMinusDirection
name|XMinusDirection
init|=
literal|1
block|,
DECL|enumerator|YPlusDirection
name|YPlusDirection
init|=
literal|2
block|,
DECL|enumerator|YMinusDirection
name|YMinusDirection
init|=
literal|3
DECL|typedef|Direction
block|}
name|Direction
typedef|;
end_typedef

begin_typedef
DECL|typedef|Pixel
typedef|typedef
name|GimpVector2
name|Pixel
typedef|;
end_typedef

begin_typedef
DECL|struct|_SplineCandidate
typedef|typedef
struct|struct
name|_SplineCandidate
block|{
DECL|member|p1
name|Pixel
name|p1
decl_stmt|;
DECL|member|p2
name|Pixel
name|p2
decl_stmt|;
DECL|member|quality
name|float
name|quality
decl_stmt|;
DECL|typedef|SplineCandidate
block|}
name|SplineCandidate
typedef|;
end_typedef

begin_typedef
DECL|struct|_Edgel
typedef|typedef
struct|struct
name|_Edgel
block|{
DECL|member|x
DECL|member|y
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
DECL|member|direction
name|Direction
name|direction
decl_stmt|;
DECL|member|x_normal
name|gfloat
name|x_normal
decl_stmt|;
DECL|member|y_normal
name|gfloat
name|y_normal
decl_stmt|;
DECL|member|curvature
name|gfloat
name|curvature
decl_stmt|;
DECL|member|next
DECL|member|previous
name|guint
name|next
decl_stmt|,
name|previous
decl_stmt|;
DECL|typedef|Edgel
block|}
name|Edgel
typedef|;
end_typedef

begin_function_decl
specifier|static
name|GeglBuffer
modifier|*
name|gimp_lineart_get_labels
parameter_list|(
name|GeglBuffer
modifier|*
name|line_art
parameter_list|,
name|gboolean
name|is_high_connectivity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_lineart_erode
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_lineart_denoise
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_lineart_compute_normals_curvatures
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|int
name|normal_estimate_mask_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_curvature_extremums
parameter_list|(
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gint
name|curvatures_width
parameter_list|,
name|gint
name|curvatures_height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|gimp_spline_candidate_cmp
parameter_list|(
specifier|const
name|SplineCandidate
modifier|*
name|a
parameter_list|,
specifier|const
name|SplineCandidate
modifier|*
name|b
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GList
modifier|*
name|gimp_lineart_find_spline_candidates
parameter_list|(
name|GArray
modifier|*
name|max_positions
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|distance_threshold
parameter_list|,
name|gfloat
name|max_angle_deg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_discrete_spline
parameter_list|(
name|Pixel
name|p0
parameter_list|,
name|GimpVector2
name|n0
parameter_list|,
name|Pixel
name|p1
parameter_list|,
name|GimpVector2
name|n1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|gimp_number_of_transitions
parameter_list|(
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gboolean
name|border_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_lineart_curve_creates_region
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GArray
modifier|*
name|pixels
parameter_list|,
name|int
name|lower_size_limit
parameter_list|,
name|int
name|upper_size_limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_lineart_line_segment_until_hit
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Pixel
name|start
parameter_list|,
name|GimpVector2
name|direction
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gfloat
name|gimp_lineart_estimate_stroke_width
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Some callback-type functions. */
end_comment

begin_function_decl
specifier|static
name|guint
name|visited_hash_fun
parameter_list|(
name|Pixel
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|visited_equal_fun
parameter_list|(
name|Pixel
modifier|*
name|e1
parameter_list|,
name|Pixel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|float_compare
parameter_list|(
name|gconstpointer
name|p1
parameter_list|,
name|gconstpointer
name|p2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gboolean
name|border_in_direction
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|p
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|GimpVector2
name|pair2normal
parameter_list|(
name|Pixel
name|p
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edgel */
end_comment

begin_function_decl
specifier|static
name|Edgel
modifier|*
name|gimp_edgel_new
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgel_init
parameter_list|(
name|Edgel
modifier|*
name|edgel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgel_clear
parameter_list|(
name|Edgel
modifier|*
modifier|*
name|edgel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gimp_edgel_cmp
parameter_list|(
specifier|const
name|Edgel
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edgel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|edgel2index_hash_fun
parameter_list|(
name|Edgel
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|edgel2index_equal_fun
parameter_list|(
name|Edgel
modifier|*
name|e1
parameter_list|,
name|Edgel
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|gimp_edgel_track_mark
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|edgel
parameter_list|,
name|long
name|size_limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|gimp_edgel_region_area
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|starting_edgel
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edgel set */
end_comment

begin_function_decl
specifier|static
name|GArray
modifier|*
name|gimp_edgelset_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_add
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_init_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_smooth_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|mask_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_compute_curvature
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_build_graph
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_edgelset_next8
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Edgel
modifier|*
name|it
parameter_list|,
name|Edgel
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Public functions */
end_comment

begin_comment
comment|/**  * gimp_lineart_close:  * @line_art: the input #GeglBuffer  * @select_transparent: whether we binarize the alpha channel or the  *                      luminosity.  * @stroke_threshold: [0-1] threshold value for detecting stroke pixels  *                    (higher values will detect more stroke pixels).  * @erosion:  * @minimal_lineart_area:  * @normal_estimate_mask_size:  * @end_point_rate: [0-1] range value.  * @spline_max_length:  * @spline_max_angle:  * @end_point_connectivity:  * @spline_roundness:  * @allow_self_intersections:  * @created_regions_significant_area:  * @created_regions_minimum_area:  * @small_segments_from_spline_sources:  * @segments_max_length:  *  * Creates a binarized version of the strokes of @line_art, detected either  * with luminosity (light means background) or alpha values depending on  * @select_transparent. This binary version of the strokes will have closed  * regions allowing adequate selection of "nearly closed regions".  * This algorithm is meant for digital painting (and in particular on the  * sketch-only step), and therefore will likely produce unexpected results on  * other types of input.  *  * The algorithm is the first step from the research paper "A Fast and  * Efficient Semi-guided Algorithm for Flat Coloring Line-arts", by SÃ©bastian  * Fourey, David TschumperlÃ©, David Revoy.  *  * Returns: a new #GeglBuffer of format "Y u8" representing the  *          binarized @line_art. A value of  */
end_comment

begin_function
name|GeglBuffer
modifier|*
DECL|function|gimp_lineart_close (GeglBuffer * line_art,gboolean select_transparent,gfloat stroke_threshold,gint erosion,gint minimal_lineart_area,gint normal_estimate_mask_size,gfloat end_point_rate,gint spline_max_length,gfloat spline_max_angle,gint end_point_connectivity,gfloat spline_roundness,gboolean allow_self_intersections,gint created_regions_significant_area,gint created_regions_minimum_area,gboolean small_segments_from_spline_sources,gint segments_max_length)
name|gimp_lineart_close
parameter_list|(
name|GeglBuffer
modifier|*
name|line_art
parameter_list|,
name|gboolean
name|select_transparent
parameter_list|,
name|gfloat
name|stroke_threshold
parameter_list|,
name|gint
name|erosion
parameter_list|,
name|gint
name|minimal_lineart_area
parameter_list|,
name|gint
name|normal_estimate_mask_size
parameter_list|,
name|gfloat
name|end_point_rate
parameter_list|,
name|gint
name|spline_max_length
parameter_list|,
name|gfloat
name|spline_max_angle
parameter_list|,
name|gint
name|end_point_connectivity
parameter_list|,
name|gfloat
name|spline_roundness
parameter_list|,
name|gboolean
name|allow_self_intersections
parameter_list|,
name|gint
name|created_regions_significant_area
parameter_list|,
name|gint
name|created_regions_minimum_area
parameter_list|,
name|gboolean
name|small_segments_from_spline_sources
parameter_list|,
name|gint
name|segments_max_length
parameter_list|)
block|{
specifier|const
name|Babl
modifier|*
name|gray_format
decl_stmt|;
name|gfloat
modifier|*
name|normals
decl_stmt|;
name|gfloat
modifier|*
name|curvatures
decl_stmt|;
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|GeglBuffer
modifier|*
name|closed
decl_stmt|;
name|GeglBuffer
modifier|*
name|strokes
decl_stmt|;
name|GHashTable
modifier|*
name|visited
decl_stmt|;
name|GArray
modifier|*
name|keypoints
decl_stmt|;
name|Pixel
modifier|*
name|point
decl_stmt|;
name|GList
modifier|*
name|candidates
decl_stmt|;
name|SplineCandidate
modifier|*
name|candidate
decl_stmt|;
name|guchar
name|max_value
init|=
literal|0
decl_stmt|;
name|gfloat
name|threshold
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|line_art
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|line_art
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|normals
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
operator|*
literal|2
argument_list|)
expr_stmt|;
name|curvatures
operator|=
name|g_new0
argument_list|(
name|gfloat
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_transparent
condition|)
comment|/* Keep alpha channel as gray levels */
name|gray_format
operator|=
name|babl_format
argument_list|(
literal|"A u8"
argument_list|)
expr_stmt|;
else|else
comment|/* Keep luminance */
name|gray_format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
comment|/* Transform the line art from any format to gray. */
name|strokes
operator|=
name|gegl_buffer_new
argument_list|(
name|gegl_buffer_get_extent
argument_list|(
name|line_art
argument_list|)
argument_list|,
name|gray_format
argument_list|)
expr_stmt|;
name|gegl_buffer_copy
argument_list|(
name|line_art
argument_list|,
name|NULL
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
name|strokes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_buffer_set_format
argument_list|(
name|strokes
argument_list|,
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_transparent
condition|)
block|{
comment|/* Compute the biggest value */
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|strokes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|data
init|=
operator|(
name|guchar
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|data
operator|>
name|max_value
condition|)
name|max_value
operator|=
operator|*
name|data
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Make the image binary: 1 is stroke, 0 background */
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|strokes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READWRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|data
init|=
operator|(
name|guchar
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|select_transparent
condition|)
comment|/* Negate the value. */
operator|*
name|data
operator|=
name|max_value
operator|-
operator|*
name|data
expr_stmt|;
comment|/* Apply a threshold. */
if|if
condition|(
operator|*
name|data
operator|>
call|(
name|guchar
call|)
argument_list|(
literal|255.0f
operator|*
operator|(
literal|1.0f
operator|-
name|stroke_threshold
operator|)
argument_list|)
condition|)
operator|*
name|data
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|data
operator|=
literal|0
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|erosion
operator|>
literal|0
condition|)
block|{
name|gimp_lineart_erode
argument_list|(
name|strokes
argument_list|,
name|erosion
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|erosion
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|gfloat
name|stroke_width
init|=
name|gimp_lineart_estimate_stroke_width
argument_list|(
name|strokes
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|erode_size
init|=
operator|(
name|gint
operator|)
name|roundf
argument_list|(
name|stroke_width
operator|/
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|erode_size
condition|)
name|gimp_lineart_erode
argument_list|(
name|strokes
argument_list|,
literal|2
operator|*
name|erode_size
argument_list|)
expr_stmt|;
block|}
comment|/* Denoise (remove small connected components) */
name|gimp_lineart_denoise
argument_list|(
name|strokes
argument_list|,
name|minimal_lineart_area
argument_list|)
expr_stmt|;
comment|/* Estimate normals& curvature */
name|gimp_lineart_compute_normals_curvatures
argument_list|(
name|strokes
argument_list|,
name|normals
argument_list|,
name|curvatures
argument_list|,
name|normal_estimate_mask_size
argument_list|)
expr_stmt|;
name|threshold
operator|=
literal|1.0f
operator|-
name|end_point_rate
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
block|{
name|gfloat
name|v
init|=
name|curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
decl_stmt|;
name|curvatures
index|[
name|i
operator|+
name|j
operator|*
name|width
index|]
operator|=
name|v
operator|>=
name|threshold
condition|?
name|v
operator|-
name|threshold
else|:
operator|(
name|v
operator|<=
operator|-
name|threshold
condition|?
name|v
operator|+
name|threshold
else|:
literal|0.0f
operator|)
expr_stmt|;
block|}
block|}
name|keypoints
operator|=
name|gimp_lineart_curvature_extremums
argument_list|(
name|curvatures
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|gimp_lineart_find_spline_candidates
argument_list|(
name|keypoints
argument_list|,
name|normals
argument_list|,
name|width
argument_list|,
name|spline_max_length
argument_list|,
name|spline_max_angle
argument_list|)
expr_stmt|;
name|closed
operator|=
name|gegl_buffer_dup
argument_list|(
name|strokes
argument_list|)
expr_stmt|;
comment|/* Draw splines */
name|visited
operator|=
name|g_hash_table_new_full
argument_list|(
operator|(
name|GHashFunc
operator|)
name|visited_hash_fun
argument_list|,
operator|(
name|GEqualFunc
operator|)
name|visited_equal_fun
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_free
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|candidates
condition|)
block|{
name|Pixel
modifier|*
name|p1
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gboolean
name|inserted
init|=
name|FALSE
decl_stmt|;
name|candidate
operator|=
operator|(
name|SplineCandidate
operator|*
operator|)
name|candidates
operator|->
name|data
expr_stmt|;
name|p1
operator|->
name|x
operator|=
name|candidate
operator|->
name|p1
operator|.
name|x
expr_stmt|;
name|p1
operator|->
name|y
operator|=
name|candidate
operator|->
name|p1
operator|.
name|y
expr_stmt|;
name|p2
operator|->
name|x
operator|=
name|candidate
operator|->
name|p2
operator|.
name|x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|candidate
operator|->
name|p2
operator|.
name|y
expr_stmt|;
name|g_free
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|g_list_delete_link
argument_list|(
name|candidates
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
operator|||
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
operator|&&
operator|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
operator|||
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
condition|)
block|{
name|GArray
modifier|*
name|discrete_curve
decl_stmt|;
name|GimpVector2
name|vect1
init|=
name|pair2normal
argument_list|(
operator|*
name|p1
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|GimpVector2
name|vect2
init|=
name|pair2normal
argument_list|(
operator|*
name|p2
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|gfloat
name|distance
init|=
name|gimp_vector2_length_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
operator|*
name|p1
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
decl_stmt|;
name|gint
name|transitions
decl_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect1
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect1
argument_list|,
name|spline_roundness
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect2
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|vect2
argument_list|,
name|spline_roundness
argument_list|)
expr_stmt|;
name|discrete_curve
operator|=
name|gimp_lineart_discrete_spline
argument_list|(
operator|*
name|p1
argument_list|,
name|vect1
argument_list|,
operator|*
name|p2
argument_list|,
name|vect2
argument_list|)
expr_stmt|;
name|transitions
operator|=
name|allow_self_intersections
condition|?
name|gimp_number_of_transitions
argument_list|(
name|discrete_curve
argument_list|,
name|strokes
argument_list|,
name|FALSE
argument_list|)
else|:
name|gimp_number_of_transitions
argument_list|(
name|discrete_curve
argument_list|,
name|closed
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|transitions
operator|==
literal|2
operator|&&
operator|!
name|gimp_lineart_curve_creates_region
argument_list|(
name|closed
argument_list|,
name|discrete_curve
argument_list|,
name|created_regions_significant_area
argument_list|,
name|created_regions_minimum_area
operator|-
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|discrete_curve
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|discrete_curve
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|closed
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|closed
argument_list|)
condition|)
block|{
name|guchar
name|val
init|=
literal|1
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|closed
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p2
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|discrete_curve
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
block|{
name|g_free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Draw straight line segments */
name|point
operator|=
operator|(
name|Pixel
operator|*
operator|)
name|keypoints
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keypoints
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gboolean
name|inserted
init|=
name|FALSE
decl_stmt|;
operator|*
name|p
operator|=
operator|*
name|point
expr_stmt|;
if|if
condition|(
operator|!
name|g_hash_table_contains
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
operator|||
operator|(
name|small_segments_from_spline_sources
operator|&&
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
argument_list|)
operator|<
name|end_point_connectivity
operator|)
condition|)
block|{
name|GArray
modifier|*
name|segment
init|=
name|gimp_lineart_line_segment_until_hit
argument_list|(
name|closed
argument_list|,
operator|*
name|point
argument_list|,
name|pair2normal
argument_list|(
operator|*
name|point
argument_list|,
name|normals
argument_list|,
name|width
argument_list|)
argument_list|,
name|segments_max_length
argument_list|)
decl_stmt|;
if|if
condition|(
name|segment
operator|->
name|len
operator|&&
operator|!
name|gimp_lineart_curve_creates_region
argument_list|(
name|closed
argument_list|,
name|segment
argument_list|,
name|created_regions_significant_area
argument_list|,
name|created_regions_minimum_area
operator|-
literal|1
argument_list|)
condition|)
block|{
name|gint
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|segment
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|segment
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|guchar
name|val
init|=
literal|1
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|closed
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|g_hash_table_replace
argument_list|(
name|visited
argument_list|,
name|p
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|GPOINTER_TO_INT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|visited
argument_list|,
name|p
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|segment
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|point
operator|++
expr_stmt|;
block|}
name|g_hash_table_destroy
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|g_array_free
argument_list|(
name|keypoints
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|strokes
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|normals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|curvatures
argument_list|)
expr_stmt|;
name|g_list_free_full
argument_list|(
name|candidates
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
return|return
name|closed
return|;
block|}
end_function

begin_comment
comment|/* Private functions */
end_comment

begin_function
specifier|static
name|GeglBuffer
modifier|*
DECL|function|gimp_lineart_get_labels (GeglBuffer * line_art,gboolean is_high_connectivity)
name|gimp_lineart_get_labels
parameter_list|(
name|GeglBuffer
modifier|*
name|line_art
parameter_list|,
name|gboolean
name|is_high_connectivity
parameter_list|)
block|{
comment|/*    * Converted from CImg.get_label() code, with tolerance = 0 (used to    * determine if two neighboring pixels belong to the same region).    * The algorithm of connected components computation has been primarily done    * by A. Meijster, according to the publication: 'W.H. Hesselink, A.    * Meijster, C. Bron, "Concurrent Determination of Connected Components.",    * In: Science of Computer Programming 41 (2001), pp. 173--194'.    * The submitted code has then been modified to fit CImg first, then GIMP.     */
name|guint32
modifier|*
name|data
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|line_art
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|line_art
argument_list|)
decl_stmt|;
name|guint32
name|counter
init|=
literal|0
decl_stmt|;
name|guint32
name|p
init|=
literal|0
decl_stmt|;
comment|/* Create neighborhood tables. */
name|int
name|dx
index|[
literal|4
index|]
decl_stmt|,
name|dy
index|[
literal|4
index|]
decl_stmt|;
name|dx
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|dy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dx
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dy
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_high_connectivity
condition|)
block|{
name|dx
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|dy
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|dx
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|dy
index|[
literal|3
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|data
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|babl_format_get_bytes_per_pixel
argument_list|(
name|babl_format_n
argument_list|(
name|babl_type
argument_list|(
literal|"u32"
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* Init label numbers. */
for|for
control|(
name|guint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|width
operator|*
name|height
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* For each neighbour-direction, label. */
for|for
control|(
name|unsigned
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
operator|(
name|is_high_connectivity
condition|?
literal|4
else|:
literal|2
operator|)
condition|;
operator|++
name|n
control|)
block|{
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
specifier|const
name|gint
name|_dx
init|=
name|dx
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|gint
name|_dy
init|=
name|dy
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|gint
name|y0
init|=
operator|(
name|_dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|_dy
else|:
literal|0
decl_stmt|;
specifier|const
name|gint
name|it_width
init|=
name|width
operator|-
name|_dx
operator|+
literal|1
decl_stmt|;
specifier|const
name|gint
name|it_height
init|=
operator|(
name|_dy
operator|<
literal|0
operator|)
condition|?
name|height
operator|-
name|y0
operator|+
literal|1
else|:
name|height
operator|-
name|_dy
operator|-
name|y0
operator|+
literal|1
decl_stmt|;
specifier|const
name|glong
name|offset
init|=
name|_dy
operator|*
name|width
operator|+
name|_dx
decl_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|line_art
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|y0
argument_list|,
name|it_width
argument_list|,
name|it_height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|babl_format
argument_list|(
literal|"Y u32"
argument_list|)
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|line_art
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|_dx
argument_list|,
name|y0
operator|+
name|_dy
argument_list|,
name|it_width
argument_list|,
name|it_height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|babl_format
argument_list|(
literal|"Y u32"
argument_list|)
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|GeglRectangle
modifier|*
name|roi
init|=
operator|&
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
decl_stmt|;
name|guint32
modifier|*
name|pixel
init|=
operator|(
name|guint32
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|guint32
modifier|*
name|neighbour
init|=
operator|(
name|guint32
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|1
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|gint
name|x
init|=
name|roi
operator|->
name|x
decl_stmt|;
name|gint
name|y
init|=
name|roi
operator|->
name|y
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|pixel
operator|==
name|neighbour
condition|)
block|{
specifier|const
name|glong
name|p
init|=
name|width
operator|*
name|y
decl_stmt|;
specifier|const
name|guint32
name|q
init|=
name|p
operator|+
name|offset
decl_stmt|;
name|guint32
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MAX
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|,
name|j
operator|=
name|MIN
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
init|;
name|i
operator|!=
name|j
operator|&&
name|data
index|[
name|i
index|]
operator|!=
name|i
condition|;
control|)
block|{
name|i
operator|=
operator|(
name|guint32
operator|)
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
comment|/* Swap i and j. */
name|guint32
name|temp
init|=
name|i
decl_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|data
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
for|for
control|(
name|guint32
name|_p
init|=
operator|(
name|guint32
operator|)
name|p
init|;
name|_p
operator|!=
name|j
condition|;
control|)
block|{
specifier|const
name|guint32
name|h
init|=
operator|(
name|guint32
operator|)
name|data
index|[
name|_p
index|]
decl_stmt|;
name|data
index|[
name|_p
index|]
operator|=
operator|(
name|guint32
operator|)
name|j
expr_stmt|;
name|_p
operator|=
name|h
expr_stmt|;
block|}
for|for
control|(
name|guint32
name|_q
init|=
operator|(
name|guint32
operator|)
name|q
init|;
name|_q
operator|!=
name|j
condition|;
control|)
block|{
specifier|const
name|guint32
name|h
init|=
operator|(
name|guint32
operator|)
name|data
index|[
name|_q
index|]
decl_stmt|;
name|data
index|[
name|_q
index|]
operator|=
operator|(
name|guint32
operator|)
name|j
expr_stmt|;
name|_q
operator|=
name|h
expr_stmt|;
block|}
block|}
name|pixel
operator|++
expr_stmt|;
name|neighbour
operator|++
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|-
name|roi
operator|->
name|x
operator|>=
name|roi
operator|->
name|width
condition|)
block|{
name|x
operator|=
name|roi
operator|->
name|x
expr_stmt|;
name|y
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Resolve equivalences. */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|guint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|width
operator|*
name|height
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|data
index|[
name|i
index|]
operator|==
name|p
condition|?
name|counter
operator|++
else|:
name|data
index|[
name|data
index|[
name|i
index|]
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|gegl_buffer_linear_new_from_data
argument_list|(
name|data
argument_list|,
name|babl_format_n
argument_list|(
name|babl_type
argument_list|(
literal|"u32"
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gegl_buffer_get_extent
argument_list|(
name|line_art
argument_list|)
argument_list|,
literal|0
argument_list|,
name|g_free
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_lineart_erode (GeglBuffer * buffer,gint s)
name|gimp_lineart_erode
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
name|s
parameter_list|)
block|{
comment|/* Erode image by a rectangular structuring element of specified    * size.    */
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
specifier|const
name|gint
name|_s2
init|=
name|s
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
specifier|const
name|gint
name|_s1
init|=
name|s
operator|-
name|_s2
decl_stmt|;
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
if|if
condition|(
name|s
operator|<=
literal|1
condition|)
return|return;
name|format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|width
operator|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|height
operator|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|1
condition|)
block|{
comment|/* Erosion along X-axis. */
specifier|const
name|gint
name|s1
init|=
name|_s1
operator|>
name|width
condition|?
name|width
else|:
name|_s1
decl_stmt|;
specifier|const
name|gint
name|s2
init|=
name|_s2
operator|>
name|width
condition|?
name|width
else|:
name|_s2
decl_stmt|;
name|gint
name|y
decl_stmt|;
name|buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|width
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
name|guchar
name|cur
decl_stmt|;
name|gint
name|xs
init|=
name|width
decl_stmt|;
name|gint
name|xd
init|=
literal|0
decl_stmt|;
name|gboolean
name|is_first
init|=
name|TRUE
decl_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|MIN
argument_list|(
name|s2
argument_list|,
name|width
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|val
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|x
operator|==
literal|0
condition|)
block|{
name|cur
operator|=
operator|*
name|val
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|val
operator|<=
name|cur
condition|)
block|{
name|xs
operator|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|x
operator|+
name|k
operator|+
literal|1
expr_stmt|;
name|cur
operator|=
operator|*
name|val
expr_stmt|;
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
name|val
operator|++
expr_stmt|;
block|}
block|}
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|++
expr_stmt|;
if|if
condition|(
name|xs
operator|>=
name|width
operator|-
literal|1
condition|)
block|{
name|guchar
name|se
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|width
operator|-
literal|1
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|se
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|cur
operator|=
name|MIN
argument_list|(
name|cur
argument_list|,
name|se
argument_list|)
expr_stmt|;
name|gegl_buffer_set_color_from_pixel
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|cur
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gint
name|_width
init|=
name|MIN
argument_list|(
name|width
operator|-
name|xs
operator|-
literal|1
argument_list|,
name|s1
argument_list|)
decl_stmt|;
name|gint
name|p
init|=
name|s1
decl_stmt|;
name|_width
operator|=
name|MIN
argument_list|(
name|_width
argument_list|,
name|width
operator|-
name|xd
argument_list|)
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|xs
argument_list|,
name|y
argument_list|,
name|_width
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|val
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|val
operator|<=
name|cur
condition|)
block|{
name|cur
operator|=
operator|*
name|val
expr_stmt|;
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|++
expr_stmt|;
name|xs
operator|++
expr_stmt|;
name|val
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|p
operator|>
literal|0
condition|)
block|{
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|++
expr_stmt|;
operator|--
name|p
expr_stmt|;
block|}
for|for
control|(
name|int
name|p
init|=
name|width
operator|-
name|s
operator|-
literal|1
init|;
name|p
operator|>
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|xs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|xs
operator|++
expr_stmt|;
if|if
condition|(
name|is_first
condition|)
block|{
name|guchar
name|nval
decl_stmt|;
name|gint
name|nxs
init|=
name|xs
operator|-
literal|1
decl_stmt|;
name|cur
operator|=
name|val
expr_stmt|;
for|for
control|(
name|int
name|q
init|=
name|s
operator|-
literal|2
init|;
name|q
operator|>
literal|0
condition|;
operator|--
name|q
control|)
block|{
name|nxs
operator|--
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|nxs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|nval
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
name|cur
condition|)
name|cur
operator|=
name|nval
expr_stmt|;
block|}
name|nxs
operator|--
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|nxs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|nval
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
name|cur
condition|)
block|{
name|cur
operator|=
name|nval
expr_stmt|;
name|is_first
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|<=
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
else|else
block|{
name|guchar
name|tmp
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|xs
operator|-
name|s
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|tmp
condition|)
name|is_first
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|++
expr_stmt|;
block|}
name|xd
operator|=
name|width
operator|-
literal|1
expr_stmt|;
name|xs
operator|=
name|width
operator|-
literal|1
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|xs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|cur
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|xs
operator|--
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
name|s1
init|;
name|p
operator|>
literal|0
operator|&&
name|xs
operator|>=
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|xs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|xs
operator|--
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
block|}
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|--
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
name|s2
operator|-
literal|1
init|;
name|p
operator|>
literal|0
operator|&&
name|xd
operator|>=
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|xs
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|>
literal|0
condition|)
name|xs
operator|--
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
name|buf
index|[
name|xd
index|]
operator|=
name|cur
expr_stmt|;
name|xd
operator|--
expr_stmt|;
block|}
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
literal|1
condition|)
block|{
comment|/* Erosion along Y-axis. */
specifier|const
name|gint
name|s1
init|=
name|_s1
operator|>
name|height
condition|?
name|height
else|:
name|_s1
decl_stmt|;
specifier|const
name|gint
name|s2
init|=
name|_s2
operator|>
name|height
condition|?
name|height
else|:
name|_s2
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|height
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|guchar
name|cur
decl_stmt|;
name|gint
name|ys
init|=
literal|0
decl_stmt|;
name|gint
name|yd
init|=
literal|0
decl_stmt|;
name|gboolean
name|is_first
init|=
name|TRUE
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|cur
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|ys
operator|++
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
name|s2
operator|-
literal|1
init|;
name|p
operator|>
literal|0
operator|&&
name|ys
operator|<
name|height
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|ys
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|<=
name|cur
condition|)
block|{
name|cur
operator|=
name|val
expr_stmt|;
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|buf
index|[
name|yd
index|]
operator|=
name|cur
expr_stmt|;
name|yd
operator|++
expr_stmt|;
if|if
condition|(
name|ys
operator|>=
name|height
operator|-
literal|1
condition|)
block|{
name|guchar
name|se
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|height
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|se
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|cur
operator|=
name|MIN
argument_list|(
name|cur
argument_list|,
name|se
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
operator|&
name|cur
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|p
init|=
name|s1
init|;
name|p
operator|>
literal|0
operator|&&
name|yd
operator|<
name|height
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ys
operator|<
name|height
operator|-
literal|1
condition|)
name|ys
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|<=
name|cur
condition|)
block|{
name|cur
operator|=
name|val
expr_stmt|;
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
name|buf
index|[
name|yd
index|]
operator|=
name|cur
expr_stmt|;
name|yd
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|p
init|=
name|height
operator|-
name|s
operator|-
literal|1
init|;
name|p
operator|>
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|ys
operator|++
expr_stmt|;
if|if
condition|(
name|is_first
condition|)
block|{
name|guchar
name|nval
decl_stmt|;
name|gint
name|nys
init|=
name|ys
operator|-
literal|1
decl_stmt|;
name|cur
operator|=
name|val
expr_stmt|;
for|for
control|(
name|int
name|q
init|=
name|s
operator|-
literal|2
init|;
name|q
operator|>
literal|0
condition|;
operator|--
name|q
control|)
block|{
name|nys
operator|--
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|nys
argument_list|,
name|NULL
argument_list|,
operator|&
name|nval
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
name|cur
condition|)
name|cur
operator|=
name|nval
expr_stmt|;
block|}
name|nys
operator|--
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|nys
argument_list|,
name|NULL
argument_list|,
operator|&
name|nval
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
name|cur
condition|)
block|{
name|cur
operator|=
name|nval
expr_stmt|;
name|is_first
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|<=
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
else|else
block|{
name|guchar
name|tmp
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
operator|-
name|s
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|tmp
condition|)
name|is_first
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|buf
index|[
name|yd
index|]
operator|=
name|cur
expr_stmt|;
name|yd
operator|++
expr_stmt|;
block|}
name|yd
operator|=
name|height
operator|-
literal|1
expr_stmt|;
name|ys
operator|=
name|height
operator|-
literal|1
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|cur
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|ys
operator|--
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
name|s1
init|;
name|p
operator|>
literal|0
operator|&&
name|ys
operator|>=
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|ys
operator|--
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
block|}
name|buf
index|[
name|yd
index|]
operator|=
name|cur
expr_stmt|;
name|yd
operator|--
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
name|s2
operator|-
literal|1
init|;
name|p
operator|>
literal|0
operator|&&
name|yd
operator|>=
literal|0
condition|;
operator|--
name|p
control|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|ys
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ys
operator|>
literal|0
condition|)
name|ys
operator|--
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|cur
condition|)
name|cur
operator|=
name|val
expr_stmt|;
name|buf
index|[
name|yd
index|]
operator|=
name|cur
expr_stmt|;
name|yd
operator|--
expr_stmt|;
block|}
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_lineart_denoise (GeglBuffer * buffer,int minimum_area)
name|gimp_lineart_denoise
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|minimum_area
parameter_list|)
block|{
comment|/* Keep connected regions with significant area. */
name|GArray
modifier|*
name|region
decl_stmt|;
name|GQueue
modifier|*
name|q
init|=
name|g_queue_new
argument_list|()
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gboolean
modifier|*
name|visited
init|=
name|g_new0
argument_list|(
name|gboolean
argument_list|,
name|width
operator|*
name|height
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|region
operator|=
name|g_array_sized_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
operator|*
argument_list|)
argument_list|,
name|minimum_area
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|guchar
name|has_stroke
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gint
name|regionSize
init|=
literal|0
decl_stmt|;
name|p
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|Pixel
modifier|*
name|p
init|=
operator|(
name|Pixel
operator|*
operator|)
name|g_queue_pop_head
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|gint
name|p2x
decl_stmt|;
name|gint
name|p2y
decl_stmt|;
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
condition|)
block|{
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_stroke
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
operator|++
name|regionSize
expr_stmt|;
if|if
condition|(
name|regionSize
operator|<
name|minimum_area
condition|)
name|g_array_append_val
argument_list|(
name|region
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regionSize
operator|<
name|minimum_area
condition|)
block|{
name|Pixel
modifier|*
name|pixel
init|=
operator|(
name|Pixel
operator|*
operator|)
name|region
operator|->
name|data
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|region
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|guchar
name|val
init|=
literal|0
decl_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|pixel
operator|->
name|x
argument_list|,
name|pixel
operator|->
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|pixel
operator|++
expr_stmt|;
block|}
block|}
name|g_array_remove_range
argument_list|(
name|region
argument_list|,
literal|0
argument_list|,
name|region
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|g_array_free
argument_list|(
name|region
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_queue_free_full
argument_list|(
name|q
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_lineart_compute_normals_curvatures (GeglBuffer * mask,gfloat * normals,gfloat * curvatures,int normal_estimate_mask_size)
name|gimp_lineart_compute_normals_curvatures
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|int
name|normal_estimate_mask_size
parameter_list|)
block|{
name|GArray
modifier|*
name|es
init|=
name|gimp_edgelset_new
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
modifier|*
name|e
init|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|es
operator|->
name|data
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|gimp_edgelset_smooth_normals
argument_list|(
name|es
argument_list|,
name|normal_estimate_mask_size
argument_list|)
expr_stmt|;
name|gimp_edgelset_compute_curvature
argument_list|(
name|es
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
specifier|const
name|float
name|w
init|=
name|MAX
argument_list|(
literal|1e-8f
argument_list|,
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
operator|*
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
argument_list|)
decl_stmt|;
name|normals
index|[
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
operator|+=
name|w
operator|*
operator|(
operator|*
name|e
operator|)
operator|->
name|x_normal
expr_stmt|;
name|normals
index|[
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|+=
name|w
operator|*
operator|(
operator|*
name|e
operator|)
operator|->
name|y_normal
expr_stmt|;
name|curvatures
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
index|]
operator|=
name|MAX
argument_list|(
operator|(
operator|*
name|e
operator|)
operator|->
name|curvature
argument_list|,
name|curvatures
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|x
operator|+
operator|(
operator|*
name|e
operator|)
operator|->
name|y
operator|*
name|width
index|]
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|;
operator|++
name|y
control|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|float
name|_angle
init|=
name|atan2f
argument_list|(
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|,
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|)
decl_stmt|;
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
operator|=
name|cosf
argument_list|(
name|_angle
argument_list|)
expr_stmt|;
name|normals
index|[
operator|(
name|x
operator|+
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|sinf
argument_list|(
name|_angle
argument_list|)
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|es
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Keep one pixel per connected component of curvature extremums.  */
end_comment

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_curvature_extremums (gfloat * curvatures,gint width,gint height)
name|gimp_lineart_curvature_extremums
parameter_list|(
name|gfloat
modifier|*
name|curvatures
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gboolean
modifier|*
name|visited
init|=
name|g_new0
argument_list|(
name|gboolean
argument_list|,
name|width
operator|*
name|height
argument_list|)
decl_stmt|;
name|GQueue
modifier|*
name|q
init|=
name|g_queue_new
argument_list|()
decl_stmt|;
name|GArray
modifier|*
name|max_positions
decl_stmt|;
name|max_positions
operator|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|curvatures
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|)
operator|&&
operator|!
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|Pixel
name|max_curvature_pixel
init|=
name|gimp_vector2_new
argument_list|(
operator|-
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|)
decl_stmt|;
name|gfloat
name|max_curvature
init|=
literal|0.0f
decl_stmt|;
name|p
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|visited
index|[
name|x
operator|+
name|y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|gfloat
name|c
decl_stmt|;
name|gint
name|p2x
decl_stmt|;
name|gint
name|p2y
decl_stmt|;
name|p
operator|=
operator|(
name|Pixel
operator|*
operator|)
name|g_queue_pop_head
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|c
operator|=
name|curvatures
index|[
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|->
name|y
operator|*
name|width
index|]
expr_stmt|;
name|curvatures
index|[
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|->
name|y
operator|*
name|width
index|]
operator|=
literal|0.0f
expr_stmt|;
name|p2x
operator|=
operator|(
name|gint
operator|)
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
operator|(
name|gint
operator|)
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|p2x
operator|=
name|p
operator|->
name|x
operator|+
literal|1
expr_stmt|;
name|p2y
operator|=
name|p
operator|->
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p2x
operator|>=
literal|0
operator|&&
name|p2x
operator|<
name|width
operator|&&
name|p2y
operator|>=
literal|0
operator|&&
name|p2y
operator|<
name|height
operator|&&
name|curvatures
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|>
literal|0.0
operator|&&
operator|!
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
condition|)
block|{
name|Pixel
modifier|*
name|p2
init|=
name|g_new
argument_list|(
name|Pixel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|p2
operator|->
name|x
operator|=
name|p2x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|p2y
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|visited
index|[
name|p2x
operator|+
name|p2y
operator|*
name|width
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
name|max_curvature
condition|)
block|{
name|max_curvature_pixel
operator|=
operator|*
name|p
expr_stmt|;
name|max_curvature
operator|=
name|c
expr_stmt|;
block|}
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|curvatures
index|[
operator|(
name|gint
operator|)
name|max_curvature_pixel
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|max_curvature_pixel
operator|.
name|y
operator|*
name|width
index|]
operator|=
name|max_curvature
expr_stmt|;
name|g_array_append_val
argument_list|(
name|max_positions
argument_list|,
name|max_curvature_pixel
argument_list|)
expr_stmt|;
block|}
block|}
name|g_queue_free_full
argument_list|(
name|q
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|max_positions
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimp_spline_candidate_cmp (const SplineCandidate * a,const SplineCandidate * b,gpointer user_data)
name|gimp_spline_candidate_cmp
parameter_list|(
specifier|const
name|SplineCandidate
modifier|*
name|a
parameter_list|,
specifier|const
name|SplineCandidate
modifier|*
name|b
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
comment|/* This comparison actually returns the opposite of common comparison    * functions on purpose, as we want the first element on the list to    * be the "bigger".    */
if|if
condition|(
name|a
operator|->
name|quality
operator|<
name|b
operator|->
name|quality
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|quality
operator|>
name|b
operator|->
name|quality
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|gimp_lineart_find_spline_candidates (GArray * max_positions,gfloat * normals,gint width,gint distance_threshold,gfloat max_angle_deg)
name|gimp_lineart_find_spline_candidates
parameter_list|(
name|GArray
modifier|*
name|max_positions
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|distance_threshold
parameter_list|,
name|gfloat
name|max_angle_deg
parameter_list|)
block|{
name|GList
modifier|*
name|candidates
init|=
name|NULL
decl_stmt|;
specifier|const
name|float
name|CosMin
init|=
name|cosf
argument_list|(
name|M_PI
operator|*
operator|(
name|max_angle_deg
operator|/
literal|180.0
operator|)
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_positions
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p1
init|=
name|g_array_index
argument_list|(
name|max_positions
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gint
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|max_positions
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|max_positions
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
specifier|const
name|float
name|distance
init|=
name|gimp_vector2_length_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|<=
name|distance_threshold
condition|)
block|{
name|GimpVector2
name|normalP1
decl_stmt|;
name|GimpVector2
name|normalP2
decl_stmt|;
name|GimpVector2
name|p1f
decl_stmt|;
name|GimpVector2
name|p2f
decl_stmt|;
name|GimpVector2
name|p1p2
decl_stmt|;
name|float
name|cosN
decl_stmt|;
name|float
name|qualityA
decl_stmt|;
name|float
name|qualityB
decl_stmt|;
name|float
name|qualityC
decl_stmt|;
name|float
name|quality
decl_stmt|;
name|normalP1
operator|=
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p1
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p1
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p1
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p1
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|normalP2
operator|=
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|p1f
operator|=
name|gimp_vector2_new
argument_list|(
name|p1
operator|.
name|x
argument_list|,
name|p1
operator|.
name|y
argument_list|)
expr_stmt|;
name|p2f
operator|=
name|gimp_vector2_new
argument_list|(
name|p2
operator|.
name|x
argument_list|,
name|p2
operator|.
name|y
argument_list|)
expr_stmt|;
name|p1p2
operator|=
name|gimp_vector2_sub_val
argument_list|(
name|p2f
argument_list|,
name|p1f
argument_list|)
expr_stmt|;
name|cosN
operator|=
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP1
argument_list|,
operator|(
name|gimp_vector2_neg_val
argument_list|(
name|normalP2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|qualityA
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
literal|1
operator|-
name|distance
operator|/
name|distance_threshold
argument_list|)
expr_stmt|;
name|qualityB
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
call|(
name|float
call|)
argument_list|(
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP1
argument_list|,
name|p1p2
argument_list|)
operator|-
name|gimp_vector2_inner_product_val
argument_list|(
name|normalP2
argument_list|,
name|p1p2
argument_list|)
argument_list|)
operator|/
name|distance
argument_list|)
expr_stmt|;
name|qualityC
operator|=
name|MAX
argument_list|(
literal|0.0f
argument_list|,
name|cosN
operator|-
name|CosMin
argument_list|)
expr_stmt|;
name|quality
operator|=
name|qualityA
operator|*
name|qualityB
operator|*
name|qualityC
expr_stmt|;
if|if
condition|(
name|quality
operator|>
literal|0
condition|)
block|{
name|SplineCandidate
modifier|*
name|candidate
init|=
name|g_new
argument_list|(
name|SplineCandidate
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|candidate
operator|->
name|p1
operator|=
name|p1
expr_stmt|;
name|candidate
operator|->
name|p2
operator|=
name|p2
expr_stmt|;
name|candidate
operator|->
name|quality
operator|=
name|quality
expr_stmt|;
name|candidates
operator|=
name|g_list_insert_sorted_with_data
argument_list|(
name|candidates
argument_list|,
name|candidate
argument_list|,
operator|(
name|GCompareDataFunc
operator|)
name|gimp_spline_candidate_cmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|candidates
return|;
block|}
end_function

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_discrete_spline (Pixel p0,GimpVector2 n0,Pixel p1,GimpVector2 n1)
name|gimp_lineart_discrete_spline
parameter_list|(
name|Pixel
name|p0
parameter_list|,
name|GimpVector2
name|n0
parameter_list|,
name|Pixel
name|p1
parameter_list|,
name|GimpVector2
name|n1
parameter_list|)
block|{
name|GArray
modifier|*
name|points
init|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|double
name|a0
init|=
literal|2
operator|*
name|p0
operator|.
name|x
operator|-
literal|2
operator|*
name|p1
operator|.
name|x
operator|+
name|n0
operator|.
name|x
operator|-
name|n1
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|b0
init|=
operator|-
literal|3
operator|*
name|p0
operator|.
name|x
operator|+
literal|3
operator|*
name|p1
operator|.
name|x
operator|-
literal|2
operator|*
name|n0
operator|.
name|x
operator|+
name|n1
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|c0
init|=
name|n0
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|d0
init|=
name|p0
operator|.
name|x
decl_stmt|;
specifier|const
name|double
name|a1
init|=
literal|2
operator|*
name|p0
operator|.
name|y
operator|-
literal|2
operator|*
name|p1
operator|.
name|y
operator|+
name|n0
operator|.
name|y
operator|-
name|n1
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|b1
init|=
operator|-
literal|3
operator|*
name|p0
operator|.
name|y
operator|+
literal|3
operator|*
name|p1
operator|.
name|y
operator|-
literal|2
operator|*
name|n0
operator|.
name|y
operator|+
name|n1
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|c1
init|=
name|n0
operator|.
name|y
decl_stmt|;
specifier|const
name|double
name|d1
init|=
name|p0
operator|.
name|y
decl_stmt|;
name|double
name|t
init|=
literal|0.0
decl_stmt|;
specifier|const
name|double
name|dtMin
init|=
literal|1.0
operator|/
name|MAX
argument_list|(
name|fabs
argument_list|(
name|p0
operator|.
name|x
operator|-
name|p1
operator|.
name|x
argument_list|)
argument_list|,
name|fabs
argument_list|(
name|p0
operator|.
name|y
operator|-
name|p1
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|Pixel
name|point
init|=
name|gimp_vector2_new
argument_list|(
operator|(
name|gint
operator|)
name|round
argument_list|(
name|d0
argument_list|)
argument_list|,
operator|(
name|gint
operator|)
name|round
argument_list|(
name|d1
argument_list|)
argument_list|)
decl_stmt|;
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|point
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<=
literal|1.0
condition|)
block|{
specifier|const
name|double
name|t2
init|=
name|t
operator|*
name|t
decl_stmt|;
specifier|const
name|double
name|t3
init|=
name|t
operator|*
name|t2
decl_stmt|;
name|double
name|dx
decl_stmt|;
name|double
name|dy
decl_stmt|;
name|Pixel
name|p
init|=
name|gimp_vector2_new
argument_list|(
operator|(
name|gint
operator|)
name|round
argument_list|(
name|a0
operator|*
name|t3
operator|+
name|b0
operator|*
name|t2
operator|+
name|c0
operator|*
name|t
operator|+
name|d0
argument_list|)
argument_list|,
operator|(
name|gint
operator|)
name|round
argument_list|(
name|a1
operator|*
name|t3
operator|+
name|b1
operator|*
name|t2
operator|+
name|c1
operator|*
name|t
operator|+
name|d1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* create gimp_vector2_neq () ? */
if|if
condition|(
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|x
operator|!=
name|p
operator|.
name|x
operator|||
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|y
operator|!=
name|p
operator|.
name|y
condition|)
block|{
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|dx
operator|=
name|fabs
argument_list|(
literal|3
operator|*
name|a0
operator|*
name|t
operator|*
name|t
operator|+
literal|2
operator|*
name|b0
operator|*
name|t
operator|+
name|c0
argument_list|)
operator|+
literal|1e-8
expr_stmt|;
name|dy
operator|=
name|fabs
argument_list|(
literal|3
operator|*
name|a1
operator|*
name|t
operator|*
name|t
operator|+
literal|2
operator|*
name|b1
operator|*
name|t
operator|+
name|c1
argument_list|)
operator|+
literal|1e-8
expr_stmt|;
name|t
operator|+=
name|MIN
argument_list|(
name|dtMin
argument_list|,
literal|0.75
operator|/
name|MAX
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|x
operator|!=
name|p1
operator|.
name|x
operator|||
name|g_array_index
argument_list|(
name|points
argument_list|,
name|Pixel
argument_list|,
name|points
operator|->
name|len
operator|-
literal|1
argument_list|)
operator|.
name|y
operator|!=
name|p1
operator|.
name|y
condition|)
block|{
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
return|return
name|points
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimp_number_of_transitions (GArray * pixels,GeglBuffer * buffer,gboolean border_value)
name|gimp_number_of_transitions
parameter_list|(
name|GArray
modifier|*
name|pixels
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gboolean
name|border_value
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pixels
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|Pixel
name|it
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|guchar
name|value
decl_stmt|;
name|gboolean
name|previous
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|previous
operator|=
operator|(
name|gboolean
operator|)
name|value
expr_stmt|;
comment|/* Starts at the second element. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|gboolean
name|val
decl_stmt|;
name|it
operator|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|x
operator|>=
literal|0
operator|&&
name|it
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
operator|&&
name|it
operator|.
name|y
operator|>=
literal|0
operator|&&
name|it
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|guchar
name|value
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|it
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|gboolean
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|border_value
expr_stmt|;
block|}
name|result
operator|+=
operator|(
name|val
operator|!=
name|previous
operator|)
expr_stmt|;
name|previous
operator|=
name|val
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Check whether a set of points will create a 4-connected background  * region whose size (i.e. number of pixels) falls within a given interval.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|gimp_lineart_curve_creates_region (GeglBuffer * mask,GArray * pixels,int lower_size_limit,int upper_size_limit)
name|gimp_lineart_curve_creates_region
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|GArray
modifier|*
name|pixels
parameter_list|,
name|int
name|lower_size_limit
parameter_list|,
name|int
name|upper_size_limit
parameter_list|)
block|{
specifier|const
name|glong
name|max_edgel_count
init|=
literal|2
operator|*
operator|(
name|upper_size_limit
operator|+
literal|1
operator|)
decl_stmt|;
name|Pixel
modifier|*
name|p
init|=
operator|(
name|Pixel
operator|*
operator|)
name|pixels
operator|->
name|data
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Mark pixels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|x
operator|>=
literal|0
operator|&&
name|p
operator|->
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|->
name|y
operator|>=
literal|0
operator|&&
name|p
operator|->
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|->
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|->
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|direction
init|=
literal|0
init|;
name|direction
operator|<
literal|4
condition|;
operator|++
name|direction
control|)
block|{
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
operator|&&
name|border_in_direction
argument_list|(
name|mask
argument_list|,
name|p
argument_list|,
name|direction
argument_list|)
condition|)
block|{
name|Edgel
name|e
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|glong
name|count
decl_stmt|;
name|glong
name|area
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|gboolean
call|)
argument_list|(
name|val
operator|&
operator|(
literal|4
operator|<<
name|direction
operator|)
argument_list|)
condition|)
continue|continue;
name|gimp_edgel_init
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|x
operator|=
name|p
operator|.
name|x
expr_stmt|;
name|e
operator|.
name|y
operator|=
name|p
operator|.
name|y
expr_stmt|;
name|e
operator|.
name|direction
operator|=
name|direction
expr_stmt|;
name|count
operator|=
name|gimp_edgel_track_mark
argument_list|(
name|mask
argument_list|,
name|e
argument_list|,
name|max_edgel_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|count
operator|<=
name|max_edgel_count
operator|)
operator|&&
operator|(
operator|(
name|area
operator|=
operator|-
literal|1
operator|*
name|gimp_edgel_region_area
argument_list|(
name|mask
argument_list|,
name|e
argument_list|)
operator|)
operator|>=
name|lower_size_limit
operator|)
operator|&&
operator|(
name|area
operator|<=
name|upper_size_limit
operator|)
condition|)
block|{
name|gint
name|j
decl_stmt|;
comment|/* Remove marks */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pixels
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|Pixel
name|p2
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|p2
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p2
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p2
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p2
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p2
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p2
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
block|}
block|}
block|}
comment|/* Remove marks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pixels
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Pixel
name|p
init|=
name|g_array_index
argument_list|(
name|pixels
argument_list|,
name|Pixel
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
argument_list|,
operator|(
name|gint
operator|)
name|p
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_lineart_line_segment_until_hit (const GeglBuffer * mask,Pixel start,GimpVector2 direction,int size)
name|gimp_lineart_line_segment_until_hit
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|start
parameter_list|,
name|GimpVector2
name|direction
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
init|=
operator|(
name|GeglBuffer
operator|*
operator|)
name|mask
decl_stmt|;
name|gboolean
name|out
init|=
name|FALSE
decl_stmt|;
name|GArray
modifier|*
name|points
init|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tmax
decl_stmt|;
name|GimpVector2
name|p0
init|=
name|gimp_vector2_new
argument_list|(
name|start
operator|.
name|x
argument_list|,
name|start
operator|.
name|y
argument_list|)
decl_stmt|;
name|gimp_vector2_mul
argument_list|(
operator|&
name|direction
argument_list|,
operator|(
name|gdouble
operator|)
name|size
argument_list|)
expr_stmt|;
name|direction
operator|.
name|x
operator|=
name|round
argument_list|(
name|direction
operator|.
name|x
argument_list|)
expr_stmt|;
name|direction
operator|.
name|y
operator|=
name|round
argument_list|(
name|direction
operator|.
name|y
argument_list|)
expr_stmt|;
name|tmax
operator|=
name|MAX
argument_list|(
name|abs
argument_list|(
operator|(
name|int
operator|)
name|direction
operator|.
name|x
argument_list|)
argument_list|,
name|abs
argument_list|(
operator|(
name|int
operator|)
name|direction
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<=
name|tmax
condition|;
operator|++
name|t
control|)
block|{
name|GimpVector2
name|v
init|=
name|gimp_vector2_add_val
argument_list|(
name|p0
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|direction
argument_list|,
operator|(
name|float
operator|)
name|t
operator|/
name|tmax
argument_list|)
argument_list|)
decl_stmt|;
name|Pixel
name|p
decl_stmt|;
name|p
operator|.
name|x
operator|=
operator|(
name|gint
operator|)
name|round
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
name|p
operator|.
name|y
operator|=
operator|(
name|gint
operator|)
name|round
argument_list|(
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|>=
literal|0
operator|&&
name|p
operator|.
name|x
operator|<
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
operator|&&
name|p
operator|.
name|y
operator|>=
literal|0
operator|&&
name|p
operator|.
name|y
operator|<
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|buffer
argument_list|,
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|&&
name|val
condition|)
block|{
return|return
name|points
return|;
block|}
name|out
operator|=
operator|!
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out
condition|)
block|{
return|return
name|points
return|;
block|}
else|else
block|{
name|g_array_free
argument_list|(
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
return|;
block|}
name|g_array_append_val
argument_list|(
name|points
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Pixel
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gfloat
DECL|function|gimp_lineart_estimate_stroke_width (GeglBuffer * mask)
name|gimp_lineart_estimate_stroke_width
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|)
block|{
comment|/* Return the median distance maximum per connected component. */
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|GeglBuffer
modifier|*
name|distmap
decl_stmt|;
name|GeglBuffer
modifier|*
name|labels
decl_stmt|;
name|GeglNode
modifier|*
name|graph
decl_stmt|;
name|GeglNode
modifier|*
name|input
decl_stmt|;
name|GeglNode
modifier|*
name|op
decl_stmt|;
name|GeglNode
modifier|*
name|sink
decl_stmt|;
name|guint32
name|label_max
init|=
literal|0
decl_stmt|;
name|GArray
modifier|*
name|dmax
decl_stmt|;
name|gfloat
modifier|*
name|dmax_data
decl_stmt|;
name|gfloat
name|res
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Compute a distance map for the line art. */
name|graph
operator|=
name|gegl_node_new
argument_list|()
expr_stmt|;
name|input
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:buffer-source"
argument_list|,
literal|"buffer"
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:distance-transform"
argument_list|,
literal|"metric"
argument_list|,
name|GEGL_DISTANCE_METRIC_EUCLIDEAN
argument_list|,
literal|"normalize"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sink
operator|=
name|gegl_node_new_child
argument_list|(
name|graph
argument_list|,
literal|"operation"
argument_list|,
literal|"gegl:buffer-sink"
argument_list|,
literal|"buffer"
argument_list|,
operator|&
name|distmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|input
argument_list|,
literal|"output"
argument_list|,
name|op
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|gegl_node_connect_to
argument_list|(
name|op
argument_list|,
literal|"output"
argument_list|,
name|sink
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|gegl_node_process
argument_list|(
name|sink
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|labels
operator|=
name|gimp_lineart_get_labels
argument_list|(
name|mask
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Check biggest label. */
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|labels
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint32
modifier|*
name|data
init|=
operator|(
name|guint32
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
name|label_max
operator|=
name|MAX
argument_list|(
operator|*
name|data
argument_list|,
name|label_max
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label_max
operator|==
literal|0
condition|)
block|{
name|g_object_unref
argument_list|(
name|labels
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|distmap
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
comment|/* Make sure that stroke pixels are label 0. */
name|label_max
operator|++
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|mask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|labels
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|babl_format_n
argument_list|(
name|babl_type
argument_list|(
literal|"u32"
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEGL_ACCESS_WRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|m
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|guint32
modifier|*
name|l
init|=
operator|(
name|guint32
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|1
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|m
condition|)
operator|*
name|l
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|l
operator|==
literal|0
condition|)
operator|*
name|l
operator|=
name|label_max
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
comment|/* Create an array of max distance per label */
name|dmax
operator|=
name|g_array_sized_new
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|,
name|label_max
argument_list|)
expr_stmt|;
name|g_array_set_size
argument_list|(
name|dmax
argument_list|,
name|label_max
argument_list|)
expr_stmt|;
name|dmax_data
operator|=
operator|(
name|gfloat
operator|*
operator|)
name|dmax
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|dmax_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
operator|*
name|label_max
argument_list|)
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|mask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|labels
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_WRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|distmap
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_WRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|m
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|guint32
modifier|*
name|l
init|=
operator|(
name|guint32
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|1
index|]
operator|.
name|data
decl_stmt|;
name|gfloat
modifier|*
name|d
init|=
operator|(
name|gfloat
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|2
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gi
operator|->
name|length
condition|;
name|k
operator|++
control|)
block|{
name|gimp_assert
argument_list|(
operator|*
name|m
operator|==
literal|0
operator|||
operator|*
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|&&
operator|*
name|d
operator|>
name|dmax_data
index|[
operator|*
name|l
operator|-
literal|1
index|]
condition|)
name|dmax_data
index|[
operator|*
name|l
operator|-
literal|1
index|]
operator|=
operator|*
name|d
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
comment|/* Sort and crop labels with distance 0. */
name|g_array_sort
argument_list|(
name|dmax
argument_list|,
name|float_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|label_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dmax_data
index|[
name|i
index|]
operator|!=
literal|0.0
condition|)
break|break;
block|}
name|res
operator|=
name|dmax_data
index|[
name|i
operator|+
operator|(
name|label_max
operator|-
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
name|g_array_unref
argument_list|(
name|dmax
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|labels
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|distmap
argument_list|)
expr_stmt|;
return|return
literal|2.0
operator|*
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|visited_hash_fun (Pixel * key)
name|visited_hash_fun
parameter_list|(
name|Pixel
modifier|*
name|key
parameter_list|)
block|{
comment|/* Cantor pairing function. */
return|return
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|)
operator|*
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
name|key
operator|->
name|y
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|visited_equal_fun (Pixel * e1,Pixel * e2)
name|visited_equal_fun
parameter_list|(
name|Pixel
modifier|*
name|e1
parameter_list|,
name|Pixel
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|float_compare (gconstpointer p1,gconstpointer p2)
name|float_compare
parameter_list|(
name|gconstpointer
name|p1
parameter_list|,
name|gconstpointer
name|p2
parameter_list|)
block|{
specifier|const
name|gfloat
modifier|*
name|i1
init|=
operator|(
name|gfloat
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|gfloat
modifier|*
name|i2
init|=
operator|(
name|gfloat
operator|*
operator|)
name|p2
decl_stmt|;
return|return
operator|(
operator|*
name|i1
operator|>
operator|*
name|i2
operator|)
condition|?
literal|1
else|:
operator|(
operator|*
name|i1
operator|<
operator|*
name|i2
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|border_in_direction (GeglBuffer * mask,Pixel p,int direction)
name|border_in_direction
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Pixel
name|p
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|gint
name|px
init|=
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
name|DeltaX
index|[
name|direction
index|]
decl_stmt|;
name|gint
name|py
init|=
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|+
name|DeltaY
index|[
name|direction
index|]
decl_stmt|;
if|if
condition|(
name|px
operator|>=
literal|0
operator|&&
name|px
operator|<
name|gegl_buffer_get_width
argument_list|(
name|mask
argument_list|)
operator|&&
name|py
operator|>=
literal|0
operator|&&
name|py
operator|<
name|gegl_buffer_get_height
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
name|px
argument_list|,
name|py
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
return|return
operator|!
operator|(
operator|(
name|gboolean
operator|)
name|val
operator|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|GimpVector2
DECL|function|pair2normal (Pixel p,gfloat * normals,gint width)
name|pair2normal
parameter_list|(
name|Pixel
name|p
parameter_list|,
name|gfloat
modifier|*
name|normals
parameter_list|,
name|gint
name|width
parameter_list|)
block|{
return|return
name|gimp_vector2_new
argument_list|(
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
index|]
argument_list|,
name|normals
index|[
operator|(
operator|(
name|gint
operator|)
name|p
operator|.
name|x
operator|+
operator|(
name|gint
operator|)
name|p
operator|.
name|y
operator|*
name|width
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Edgel functions */
end_comment

begin_function
specifier|static
name|Edgel
modifier|*
DECL|function|gimp_edgel_new (int x,int y,Direction direction)
name|gimp_edgel_new
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|)
block|{
name|Edgel
modifier|*
name|edgel
init|=
name|g_new
argument_list|(
name|Edgel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|edgel
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|edgel
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|edgel
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|gimp_edgel_init
argument_list|(
name|edgel
argument_list|)
expr_stmt|;
return|return
name|edgel
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgel_init (Edgel * edgel)
name|gimp_edgel_init
parameter_list|(
name|Edgel
modifier|*
name|edgel
parameter_list|)
block|{
name|edgel
operator|->
name|x_normal
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|y_normal
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|curvature
operator|=
literal|0
expr_stmt|;
name|edgel
operator|->
name|next
operator|=
name|edgel
operator|->
name|previous
operator|=
name|G_MAXUINT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgel_clear (Edgel ** edgel)
name|gimp_edgel_clear
parameter_list|(
name|Edgel
modifier|*
modifier|*
name|edgel
parameter_list|)
block|{
name|g_clear_pointer
argument_list|(
name|edgel
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|gimp_edgel_cmp (const Edgel * e1,const Edgel * e2)
name|gimp_edgel_cmp
parameter_list|(
specifier|const
name|Edgel
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edgel
modifier|*
name|e2
parameter_list|)
block|{
name|gimp_assert
argument_list|(
name|e1
operator|&&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|)
operator|&&
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|)
operator|&&
operator|(
name|e1
operator|->
name|direction
operator|==
name|e2
operator|->
name|direction
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|e1
operator|->
name|y
operator|<
name|e2
operator|->
name|y
operator|)
operator|||
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|x
operator|<
name|e2
operator|->
name|x
operator|)
operator|||
operator|(
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|direction
operator|<
name|e2
operator|->
name|direction
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|edgel2index_hash_fun (Edgel * key)
name|edgel2index_hash_fun
parameter_list|(
name|Edgel
modifier|*
name|key
parameter_list|)
block|{
comment|/* Cantor pairing function.    * Was not sure how to use the direction though. :-/    */
return|return
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|)
operator|*
operator|(
name|key
operator|->
name|x
operator|+
name|key
operator|->
name|y
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
name|key
operator|->
name|y
operator|*
name|key
operator|->
name|direction
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|edgel2index_equal_fun (Edgel * e1,Edgel * e2)
name|edgel2index_equal_fun
parameter_list|(
name|Edgel
modifier|*
name|e1
parameter_list|,
name|Edgel
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|e1
operator|->
name|x
operator|==
name|e2
operator|->
name|x
operator|&&
name|e1
operator|->
name|y
operator|==
name|e2
operator|->
name|y
operator|&&
name|e1
operator|->
name|direction
operator|==
name|e2
operator|->
name|direction
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @mask;  * @edgel:  * @size_limit:  *  * Track a border, marking inner pixels with a bit corresponding to the  * edgel traversed (4<< direction) for direction in {0,1,2,3}.  * Stop tracking after @size_limit edgels have been visited.  *  * Returns: Number of visited edgels, or -1 if an already visited edgel  *          has been encountered.  */
end_comment

begin_function
specifier|static
name|glong
DECL|function|gimp_edgel_track_mark (GeglBuffer * mask,Edgel edgel,long size_limit)
name|gimp_edgel_track_mark
parameter_list|(
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|edgel
parameter_list|,
name|long
name|size_limit
parameter_list|)
block|{
name|Edgel
name|start
init|=
name|edgel
decl_stmt|;
name|long
name|count
init|=
literal|1
decl_stmt|;
do|do
block|{
name|guchar
name|val
decl_stmt|;
name|gimp_edgelset_next8
argument_list|(
name|mask
argument_list|,
operator|&
name|edgel
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
name|gegl_buffer_sample
argument_list|(
name|mask
argument_list|,
name|edgel
operator|.
name|x
argument_list|,
name|edgel
operator|.
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|2
condition|)
block|{
comment|/* Only mark pixels of the spline/segment */
if|if
condition|(
name|val
operator|&
operator|(
literal|4
operator|<<
name|edgel
operator|.
name|direction
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Mark edgel in pixel (1 == In Mask, 2 == Spline/Segment) */
name|val
operator||=
operator|(
literal|4
operator|<<
name|edgel
operator|.
name|direction
operator|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|mask
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|edgel
operator|.
name|x
argument_list|,
name|edgel
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|count
expr_stmt|;
block|}
do|while
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
literal|0
operator|&&
name|count
operator|<=
name|size_limit
condition|)
do|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|glong
DECL|function|gimp_edgel_region_area (const GeglBuffer * mask,Edgel start_edgel)
name|gimp_edgel_region_area
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|mask
parameter_list|,
name|Edgel
name|start_edgel
parameter_list|)
block|{
name|Edgel
name|edgel
init|=
name|start_edgel
decl_stmt|;
name|long
name|area
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|edgel
operator|.
name|direction
operator|==
name|XPlusDirection
condition|)
name|area
operator|+=
name|edgel
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|edgel
operator|.
name|direction
operator|==
name|XMinusDirection
condition|)
name|area
operator|-=
name|edgel
operator|.
name|x
operator|-
literal|1
expr_stmt|;
name|gimp_edgelset_next8
argument_list|(
name|mask
argument_list|,
operator|&
name|edgel
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gimp_edgel_cmp
argument_list|(
operator|&
name|edgel
argument_list|,
operator|&
name|start_edgel
argument_list|)
operator|!=
literal|0
condition|)
do|;
return|return
name|area
return|;
block|}
end_function

begin_comment
comment|/* Edgel sets */
end_comment

begin_function
specifier|static
name|GArray
modifier|*
DECL|function|gimp_edgelset_new (GeglBuffer * buffer)
name|gimp_edgelset_new
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|GeglBufferIterator
modifier|*
name|gi
decl_stmt|;
name|GArray
modifier|*
name|set
decl_stmt|;
name|GHashTable
modifier|*
name|edgel2index
decl_stmt|;
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|set
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|Edgel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|g_array_set_clear_func
argument_list|(
name|set
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|gimp_edgel_clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|1
operator|||
name|height
operator|<=
literal|1
condition|)
return|return
name|set
return|;
name|edgel2index
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|edgel2index_hash_fun
argument_list|,
operator|(
name|GEqualFunc
operator|)
name|edgel2index_equal_fun
argument_list|)
expr_stmt|;
name|gi
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|gegl_buffer_iterator_add
argument_list|(
name|gi
argument_list|,
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|gi
argument_list|)
condition|)
block|{
name|guint8
modifier|*
name|p
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|prevy
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|1
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|nexty
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|2
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|prevx
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|3
index|]
operator|.
name|data
decl_stmt|;
name|guint8
modifier|*
name|nextx
init|=
operator|(
name|guint8
operator|*
operator|)
name|gi
operator|->
name|items
index|[
literal|4
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|startx
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|x
decl_stmt|;
name|gint
name|starty
init|=
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|y
decl_stmt|;
name|gint
name|endy
init|=
name|starty
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|height
decl_stmt|;
name|gint
name|endx
init|=
name|startx
operator|+
name|gi
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|roi
operator|.
name|width
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|starty
init|;
name|y
operator|<
name|endy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|startx
init|;
name|x
operator|<
name|endx
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|y
operator|==
literal|0
operator|||
operator|!
operator|*
name|prevy
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|YMinusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|height
operator|-
literal|1
operator|||
operator|!
operator|*
name|nexty
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|YPlusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
operator|!
operator|*
name|prevx
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|XMinusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|width
operator|-
literal|1
operator|||
operator|!
operator|*
name|nextx
condition|)
name|gimp_edgelset_add
argument_list|(
name|set
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|XPlusDirection
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
block|}
name|prevy
operator|++
expr_stmt|;
name|nexty
operator|++
expr_stmt|;
name|prevx
operator|++
expr_stmt|;
name|nextx
operator|++
expr_stmt|;
block|}
block|}
name|gimp_edgelset_build_graph
argument_list|(
name|set
argument_list|,
name|buffer
argument_list|,
name|edgel2index
argument_list|)
expr_stmt|;
name|g_hash_table_destroy
argument_list|(
name|edgel2index
argument_list|)
expr_stmt|;
name|gimp_edgelset_init_normals
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_add (GArray * set,int x,int y,Direction direction,GHashTable * edgel2index)
name|gimp_edgelset_add
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|Direction
name|direction
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
block|{
name|Edgel
modifier|*
name|edgel
init|=
name|gimp_edgel_new
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|direction
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|position
init|=
name|set
operator|->
name|len
decl_stmt|;
name|g_array_append_val
argument_list|(
name|set
argument_list|,
name|edgel
argument_list|)
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|edgel2index
argument_list|,
name|edgel
argument_list|,
name|GUINT_TO_POINTER
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_init_normals (GArray * set)
name|gimp_edgelset_init_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
block|{
name|Edgel
modifier|*
modifier|*
name|e
init|=
operator|(
name|Edgel
operator|*
operator|*
operator|)
name|set
operator|->
name|data
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|GimpVector2
name|n
init|=
name|Direction2Normal
index|[
operator|(
operator|*
name|e
operator|)
operator|->
name|direction
index|]
decl_stmt|;
operator|(
operator|*
name|e
operator|)
operator|->
name|x_normal
operator|=
name|n
operator|.
name|x
expr_stmt|;
operator|(
operator|*
name|e
operator|)
operator|->
name|y_normal
operator|=
name|n
operator|.
name|y
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_smooth_normals (GArray * set,int mask_size)
name|gimp_edgelset_smooth_normals
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|int
name|mask_size
parameter_list|)
block|{
specifier|const
name|gfloat
name|sigma
init|=
name|mask_size
operator|*
literal|0.775
decl_stmt|;
specifier|const
name|gfloat
name|den
init|=
literal|2
operator|*
name|sigma
operator|*
name|sigma
decl_stmt|;
name|gfloat
name|weights
index|[
literal|65
index|]
decl_stmt|;
name|GimpVector2
name|smoothed_normal
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gimp_assert
argument_list|(
name|mask_size
operator|<=
literal|65
argument_list|)
expr_stmt|;
name|weights
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|mask_size
condition|;
operator|++
name|i
control|)
name|weights
index|[
name|i
index|]
operator|=
name|expf
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
name|den
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|edgel_before
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|previous
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|edgel_after
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|next
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|mask_size
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|smoothed_normal
operator|=
name|Direction2Normal
index|[
name|it
operator|->
name|direction
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|edgel_after
operator|!=
name|edgel_before
operator|)
condition|)
block|{
name|smoothed_normal
operator|=
name|gimp_vector2_add_val
argument_list|(
name|smoothed_normal
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|Direction2Normal
index|[
name|edgel_before
operator|->
name|direction
index|]
argument_list|,
name|weights
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|smoothed_normal
operator|=
name|gimp_vector2_add_val
argument_list|(
name|smoothed_normal
argument_list|,
name|gimp_vector2_mul_val
argument_list|(
name|Direction2Normal
index|[
name|edgel_after
operator|->
name|direction
index|]
argument_list|,
name|weights
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|edgel_before
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_before
operator|->
name|previous
argument_list|)
expr_stmt|;
name|edgel_after
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|edgel_after
operator|->
name|next
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|gimp_vector2_normalize
argument_list|(
operator|&
name|smoothed_normal
argument_list|)
expr_stmt|;
name|it
operator|->
name|x_normal
operator|=
name|smoothed_normal
operator|.
name|x
expr_stmt|;
name|it
operator|->
name|y_normal
operator|=
name|smoothed_normal
operator|.
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_compute_curvature (GArray * set)
name|gimp_edgelset_compute_curvature
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|previous
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|previous
argument_list|)
decl_stmt|;
name|Edgel
modifier|*
name|next
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|it
operator|->
name|next
argument_list|)
decl_stmt|;
name|GimpVector2
name|n_prev
init|=
name|gimp_vector2_new
argument_list|(
name|previous
operator|->
name|x_normal
argument_list|,
name|previous
operator|->
name|y_normal
argument_list|)
decl_stmt|;
name|GimpVector2
name|n_next
init|=
name|gimp_vector2_new
argument_list|(
name|next
operator|->
name|x_normal
argument_list|,
name|next
operator|->
name|y_normal
argument_list|)
decl_stmt|;
name|GimpVector2
name|diff
init|=
name|gimp_vector2_mul_val
argument_list|(
name|gimp_vector2_sub_val
argument_list|(
name|n_next
argument_list|,
name|n_prev
argument_list|)
argument_list|,
literal|0.5
argument_list|)
decl_stmt|;
specifier|const
name|float
name|c
init|=
name|gimp_vector2_length_val
argument_list|(
name|diff
argument_list|)
decl_stmt|;
specifier|const
name|float
name|crossp
init|=
name|n_prev
operator|.
name|x
operator|*
name|n_next
operator|.
name|y
operator|-
name|n_prev
operator|.
name|y
operator|*
name|n_next
operator|.
name|x
decl_stmt|;
name|it
operator|->
name|curvature
operator|=
operator|(
name|crossp
operator|>
literal|0.0f
operator|)
condition|?
name|c
else|:
literal|0.0f
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_build_graph (GArray * set,GeglBuffer * buffer,GHashTable * edgel2index)
name|gimp_edgelset_build_graph
parameter_list|(
name|GArray
modifier|*
name|set
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|GHashTable
modifier|*
name|edgel2index
parameter_list|)
block|{
name|Edgel
name|edgel
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Edgel
modifier|*
name|neighbor
decl_stmt|;
name|Edgel
modifier|*
name|it
init|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|guint
name|neighbor_pos
decl_stmt|;
name|gimp_edgelset_next8
argument_list|(
name|buffer
argument_list|,
name|it
argument_list|,
operator|&
name|edgel
argument_list|)
expr_stmt|;
name|gimp_assert
argument_list|(
name|g_hash_table_contains
argument_list|(
name|edgel2index
argument_list|,
operator|&
name|edgel
argument_list|)
argument_list|)
expr_stmt|;
name|neighbor_pos
operator|=
name|GPOINTER_TO_UINT
argument_list|(
name|g_hash_table_lookup
argument_list|(
name|edgel2index
argument_list|,
operator|&
name|edgel
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|next
operator|=
name|neighbor_pos
expr_stmt|;
name|neighbor
operator|=
name|g_array_index
argument_list|(
name|set
argument_list|,
name|Edgel
operator|*
argument_list|,
name|neighbor_pos
argument_list|)
expr_stmt|;
name|neighbor
operator|->
name|previous
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_edgelset_next8 (const GeglBuffer * buffer,Edgel * it,Edgel * n)
name|gimp_edgelset_next8
parameter_list|(
specifier|const
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|Edgel
modifier|*
name|it
parameter_list|,
name|Edgel
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|int
name|lx
init|=
name|gegl_buffer_get_width
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|ly
init|=
name|gegl_buffer_get_height
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|)
operator|-
literal|1
decl_stmt|;
name|guchar
name|has_stroke
decl_stmt|;
name|n
operator|->
name|x
operator|=
name|it
operator|->
name|x
expr_stmt|;
name|n
operator|->
name|y
operator|=
name|it
operator|->
name|y
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|it
operator|->
name|direction
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|direction
condition|)
block|{
case|case
name|XPlusDirection
case|:
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|+
literal|1
argument_list|,
name|n
operator|->
name|y
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|x
operator|!=
name|lx
operator|)
operator|&&
operator|(
name|n
operator|->
name|y
operator|!=
name|ly
operator|)
operator|&&
name|has_stroke
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|YMinusDirection
expr_stmt|;
block|}
else|else
block|{
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
argument_list|,
name|n
operator|->
name|y
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|y
operator|!=
name|ly
operator|)
operator|&&
name|has_stroke
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|YPlusDirection
expr_stmt|;
block|}
block|}
break|break;
case|case
name|YMinusDirection
case|:
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|+
literal|1
argument_list|,
name|n
operator|->
name|y
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|x
operator|!=
name|lx
operator|)
operator|&&
name|n
operator|->
name|y
operator|&&
name|has_stroke
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|XMinusDirection
expr_stmt|;
block|}
else|else
block|{
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|+
literal|1
argument_list|,
name|n
operator|->
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|x
operator|!=
name|lx
operator|)
operator|&&
name|has_stroke
condition|)
block|{
operator|++
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|XPlusDirection
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XMinusDirection
case|:
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|-
literal|1
argument_list|,
name|n
operator|->
name|y
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|x
operator|&&
name|n
operator|->
name|y
operator|&&
name|has_stroke
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|YPlusDirection
expr_stmt|;
block|}
else|else
block|{
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
argument_list|,
name|n
operator|->
name|y
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|y
operator|&&
name|has_stroke
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|YMinusDirection
expr_stmt|;
block|}
block|}
break|break;
case|case
name|YPlusDirection
case|:
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|-
literal|1
argument_list|,
name|n
operator|->
name|y
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|x
operator|&&
operator|(
name|n
operator|->
name|y
operator|!=
name|ly
operator|)
operator|&&
name|has_stroke
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
operator|++
operator|(
name|n
operator|->
name|y
operator|)
expr_stmt|;
name|n
operator|->
name|direction
operator|=
name|XPlusDirection
expr_stmt|;
block|}
else|else
block|{
name|gegl_buffer_sample
argument_list|(
operator|(
name|GeglBuffer
operator|*
operator|)
name|buffer
argument_list|,
name|n
operator|->
name|x
operator|-
literal|1
argument_list|,
name|n
operator|->
name|y
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_stroke
argument_list|,
name|NULL
argument_list|,
name|GEGL_SAMPLER_NEAREST
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|x
operator|&&
name|has_stroke
condition|)
block|{
operator|--
operator|(
name|n
operator|->
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|direction
operator|=
name|XMinusDirection
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gimp_assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

