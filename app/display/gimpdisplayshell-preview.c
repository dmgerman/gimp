begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpwidgets/gimpwidgets.h"
end_include

begin_include
include|#
directive|include
file|"display-types.h"
end_include

begin_include
include|#
directive|include
file|"tools/tools-types.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"tools/gimpperspectivetool.h"
end_include

begin_include
include|#
directive|include
file|"tools/gimptransformtool.h"
end_include

begin_include
include|#
directive|include
file|"tools/tool_manager.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell-appearance.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell-preview.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell-transform.h"
end_include

begin_define
DECL|macro|INT_MULT (a,b,t)
define|#
directive|define
name|INT_MULT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) + 0x80, ((((t)>> 8) + (t))>> 8))
end_define

begin_define
DECL|macro|INT_MULT3 (a,b,c,t)
define|#
directive|define
name|INT_MULT3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) * (c) + 0x7F5B, \                             ((((t)>> 7) + (t))>> 16))
end_define

begin_define
DECL|macro|MAX_SUB_COLS
define|#
directive|define
name|MAX_SUB_COLS
value|6
end_define

begin_comment
DECL|macro|MAX_SUB_COLS
comment|/* number of columns and  */
end_comment

begin_define
DECL|macro|MAX_SUB_ROWS
define|#
directive|define
name|MAX_SUB_ROWS
value|6
end_define

begin_comment
DECL|macro|MAX_SUB_ROWS
comment|/* rows to use in perspective preview subdivision */
end_comment

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_display_shell_draw_quad
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_display_shell_draw_tri
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_display_shell_draw_tri_row
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_display_shell_draw_tri_row_mask
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_display_shell_trace_tri_edge
parameter_list|(
name|gint
modifier|*
name|dest
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  public functions  */
end_comment

begin_comment
comment|/**  * gimp_display_shell_preview_transform:  * @shell: the #GimpDisplayShell  *  * If the active tool as reported by tool_manager_get_active() is a  * #GimpTransformTool and the tool has a valid drawable, and the tool  * has use_grid true (which, incidentally, is not the same thing as  * the preview type), and the area of the transformed preview is  * convex, then proceed with drawing the preview.  *  * The preview area is divided into 1 or more quadrilaterals, and  * drawn with gimp_display_shell_draw_quad(), which in turn breaks it  * down into 2 triangles, and draws row by row. If the tool is the  * Perspective tool, then more small quadrilaterals are used to  * compensate for the little rectangles not being the same size. In  * other words, all the transform tools are affine transformations  * except perspective, so approximate it with a few subdivisions.  **/
end_comment

begin_function
name|void
DECL|function|gimp_display_shell_preview_transform (GimpDisplayShell * shell,cairo_t * cr)
name|gimp_display_shell_preview_transform
parameter_list|(
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
decl_stmt|;
name|GimpTransformTool
modifier|*
name|tr_tool
decl_stmt|;
name|gdouble
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|,
name|z4
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|mask_x1
decl_stmt|,
name|mask_y1
decl_stmt|;
name|gint
name|mask_x2
decl_stmt|,
name|mask_y2
decl_stmt|;
name|gint
name|mask_offx
decl_stmt|,
name|mask_offy
decl_stmt|;
name|gint
name|columns
decl_stmt|,
name|rows
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|,
name|sub
decl_stmt|;
comment|/* x and y get filled with the screen coordinates of each corner of     * each quadrilateral subdivision of the transformed area. u and v     * are the corresponding points in the mask     */
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gint
name|x
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|,
name|y
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gfloat
name|u
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|,
name|v
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|opacity
init|=
literal|255
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DISPLAY_SHELL
argument_list|(
name|shell
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_display_shell_get_show_transform
argument_list|(
name|shell
argument_list|)
operator|||
operator|!
name|shell
operator|->
name|canvas
condition|)
return|return;
name|tool
operator|=
name|tool_manager_get_active
argument_list|(
name|shell
operator|->
name|display
operator|->
name|gimp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GIMP_IS_TRANSFORM_TOOL
argument_list|(
name|tool
argument_list|)
operator|||
operator|!
name|GIMP_IS_DRAWABLE
argument_list|(
name|tool
operator|->
name|drawable
argument_list|)
condition|)
return|return;
name|tr_tool
operator|=
name|GIMP_TRANSFORM_TOOL
argument_list|(
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tr_tool
operator|->
name|use_grid
condition|)
return|return;
name|z1
operator|=
operator|(
operator|(
name|tr_tool
operator|->
name|tx2
operator|-
name|tr_tool
operator|->
name|tx1
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty4
operator|-
name|tr_tool
operator|->
name|ty1
operator|)
operator|-
operator|(
name|tr_tool
operator|->
name|tx4
operator|-
name|tr_tool
operator|->
name|tx1
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty2
operator|-
name|tr_tool
operator|->
name|ty1
operator|)
operator|)
expr_stmt|;
name|z2
operator|=
operator|(
operator|(
name|tr_tool
operator|->
name|tx4
operator|-
name|tr_tool
operator|->
name|tx1
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty3
operator|-
name|tr_tool
operator|->
name|ty1
operator|)
operator|-
operator|(
name|tr_tool
operator|->
name|tx3
operator|-
name|tr_tool
operator|->
name|tx1
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty4
operator|-
name|tr_tool
operator|->
name|ty1
operator|)
operator|)
expr_stmt|;
name|z3
operator|=
operator|(
operator|(
name|tr_tool
operator|->
name|tx4
operator|-
name|tr_tool
operator|->
name|tx2
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty3
operator|-
name|tr_tool
operator|->
name|ty2
operator|)
operator|-
operator|(
name|tr_tool
operator|->
name|tx3
operator|-
name|tr_tool
operator|->
name|tx2
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty4
operator|-
name|tr_tool
operator|->
name|ty2
operator|)
operator|)
expr_stmt|;
name|z4
operator|=
operator|(
operator|(
name|tr_tool
operator|->
name|tx3
operator|-
name|tr_tool
operator|->
name|tx2
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty1
operator|-
name|tr_tool
operator|->
name|ty2
operator|)
operator|-
operator|(
name|tr_tool
operator|->
name|tx1
operator|-
name|tr_tool
operator|->
name|tx2
operator|)
operator|*
operator|(
name|tr_tool
operator|->
name|ty3
operator|-
name|tr_tool
operator|->
name|ty2
operator|)
operator|)
expr_stmt|;
comment|/* only draw convex polygons */
if|if
condition|(
operator|!
operator|(
operator|(
name|z1
operator|*
name|z2
operator|>
literal|0
operator|)
operator|&&
operator|(
name|z3
operator|*
name|z4
operator|>
literal|0
operator|)
operator|)
condition|)
return|return;
comment|/* take opacity from the tool options */
block|{
name|gdouble
name|value
decl_stmt|;
name|g_object_get
argument_list|(
name|gimp_tool_get_options
argument_list|(
name|tool
argument_list|)
argument_list|,
literal|"preview-opacity"
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|opacity
operator|=
name|value
operator|*
literal|255.999
expr_stmt|;
block|}
name|mask
operator|=
name|NULL
expr_stmt|;
name|mask_offx
operator|=
name|mask_offy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gimp_item_mask_bounds
argument_list|(
name|GIMP_ITEM
argument_list|(
name|tool
operator|->
name|drawable
argument_list|)
argument_list|,
operator|&
name|mask_x1
argument_list|,
operator|&
name|mask_y1
argument_list|,
operator|&
name|mask_x2
argument_list|,
operator|&
name|mask_y2
argument_list|)
condition|)
block|{
name|mask
operator|=
name|gimp_image_get_mask
argument_list|(
name|gimp_display_get_image
argument_list|(
name|shell
operator|->
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|tool
operator|->
name|drawable
argument_list|)
argument_list|,
operator|&
name|mask_offx
argument_list|,
operator|&
name|mask_offy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GIMP_IS_PERSPECTIVE_TOOL
argument_list|(
name|tr_tool
argument_list|)
condition|)
block|{
comment|/* approximate perspective transform by subdivision        *        * increase number of columns/rows to increase precision        */
name|columns
operator|=
name|MAX_SUB_COLS
expr_stmt|;
name|rows
operator|=
name|MAX_SUB_ROWS
expr_stmt|;
block|}
else|else
block|{
comment|/*  for affine transforms subdivision has no effect        */
name|columns
operator|=
literal|1
expr_stmt|;
name|rows
operator|=
literal|1
expr_stmt|;
block|}
name|dx
operator|=
operator|(
name|tr_tool
operator|->
name|x2
operator|-
name|tr_tool
operator|->
name|x1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|columns
operator|)
expr_stmt|;
name|dy
operator|=
operator|(
name|tr_tool
operator|->
name|y2
operator|-
name|tr_tool
operator|->
name|y1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|rows
operator|)
expr_stmt|;
name|du
operator|=
operator|(
name|mask_x2
operator|-
name|mask_x1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|columns
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|mask_y2
operator|-
name|mask_y1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|rows
operator|)
expr_stmt|;
DECL|macro|CALC_VERTEX (col,row,sub,index)
define|#
directive|define
name|CALC_VERTEX
parameter_list|(
name|col
parameter_list|,
name|row
parameter_list|,
name|sub
parameter_list|,
name|index
parameter_list|)
define|\
value|{                                                             \     gdouble tx1, ty1;                                           \     gdouble tx2, ty2;                                           \                                                                 \     u[sub][index] = tr_tool->x1 + (dx * (col + (index& 1)));   \     v[sub][index] = tr_tool->y1 + (dy * (row + (index>> 1)));  \                                                                 \     gimp_matrix3_transform_point (&tr_tool->transform,          \                                   u[sub][index], v[sub][index], \&tx1,&ty1);                  \                                                                 \     gimp_display_shell_transform_xy_f (shell,                   \                                        tx1, ty1,                \&tx2,&ty2);             \     x[sub][index] = (gint) tx2;                                 \     y[sub][index] = (gint) ty2;                                 \                                                                 \     u[sub][index] = mask_x1 + (du * (col + (index& 1)));       \     v[sub][index] = mask_y1 + (dv * (row + (index>> 1)));      \   }
DECL|macro|COPY_VERTEX (subdest,idest,subsrc,isrc)
define|#
directive|define
name|COPY_VERTEX
parameter_list|(
name|subdest
parameter_list|,
name|idest
parameter_list|,
name|subsrc
parameter_list|,
name|isrc
parameter_list|)
define|\
value|x[subdest][idest] = x[subsrc][isrc];            \   y[subdest][idest] = y[subsrc][isrc];            \   u[subdest][idest] = u[subsrc][isrc];            \   v[subdest][idest] = v[subsrc][isrc];
comment|/*    * upper left corner subdivision: calculate all vertices    */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/*    * top row subdivisions: calculate only right side vertices    */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|j
argument_list|,
literal|2
argument_list|,
name|j
operator|-
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * left column subdivisions: calculate only bottom side vertices    */
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|sub
operator|=
name|columns
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
operator|,
name|sub
operator|+=
name|columns
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * the rest: calculate only the bottom-right vertex    */
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|sub
operator|=
name|columns
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|sub
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
operator|,
name|sub
operator|++
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|,
name|sub
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|2
argument_list|,
name|sub
operator|-
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|k
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|CALC_VERTEX
undef|#
directive|undef
name|COPY_VERTEX
name|k
operator|=
name|columns
operator|*
name|rows
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|gimp_display_shell_draw_quad
argument_list|(
name|tool
operator|->
name|drawable
argument_list|,
name|cr
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|y
index|[
name|j
index|]
argument_list|,
name|u
index|[
name|j
index|]
argument_list|,
name|v
index|[
name|j
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_comment
comment|/**  * gimp_display_shell_draw_quad:  * @texture:   the #GimpDrawable to be previewed  * @cr:        the #cairo_t to draw to  * @mask:      a #GimpChannel  * @opacity:   the opacity of the preview  *  * Take a quadrilateral, divide it into two triangles, and draw those  * with gimp_display_shell_draw_tri().  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_display_shell_draw_quad (GimpDrawable * texture,cairo_t * cr,GimpChannel * mask,gint mask_offx,gint mask_offy,gint * x,gint * y,gfloat * u,gfloat * v,guchar opacity)
name|gimp_display_shell_draw_quad
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|gint
name|x2
index|[
literal|3
index|]
decl_stmt|,
name|y2
index|[
literal|3
index|]
decl_stmt|;
name|gfloat
name|u2
index|[
literal|3
index|]
decl_stmt|,
name|v2
index|[
literal|3
index|]
decl_stmt|;
name|gint
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
comment|/* screen bounds of the quad        */
name|gdouble
name|clip_x1
decl_stmt|,
name|clip_y1
decl_stmt|,
name|clip_x2
decl_stmt|,
name|clip_y2
decl_stmt|;
name|gint
name|c
decl_stmt|;
name|x2
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|3
index|]
expr_stmt|;
name|y2
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|3
index|]
expr_stmt|;
name|u2
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|3
index|]
expr_stmt|;
name|v2
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|x2
index|[
literal|1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y2
index|[
literal|1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
name|u2
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|2
index|]
expr_stmt|;
name|v2
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|x2
index|[
literal|2
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|y2
index|[
literal|2
index|]
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
name|u2
index|[
literal|2
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|v2
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
comment|/* Allocate a box around the quad to compute preview data into     * and fill it with the original window contents.     */
name|cairo_clip_extents
argument_list|(
name|cr
argument_list|,
operator|&
name|clip_x1
argument_list|,
operator|&
name|clip_y1
argument_list|,
operator|&
name|clip_x2
argument_list|,
operator|&
name|clip_y2
argument_list|)
expr_stmt|;
comment|/* find bounds of quad in order to only grab as much of dest as needed */
name|minx
operator|=
name|maxx
operator|=
name|x
index|[
literal|0
index|]
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|y
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|c
index|]
operator|<
name|minx
condition|)
name|minx
operator|=
name|x
index|[
name|c
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|x
index|[
name|c
index|]
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|x
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|y
index|[
name|c
index|]
operator|<
name|miny
condition|)
name|miny
operator|=
name|y
index|[
name|c
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|y
index|[
name|c
index|]
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|y
index|[
name|c
index|]
expr_stmt|;
block|}
if|if
condition|(
name|minx
operator|<
name|clip_x1
condition|)
name|minx
operator|=
name|clip_x1
expr_stmt|;
if|if
condition|(
name|miny
operator|<
name|clip_y1
condition|)
name|miny
operator|=
name|clip_y1
expr_stmt|;
if|if
condition|(
name|maxx
operator|>
name|clip_x2
condition|)
name|maxx
operator|=
name|clip_x2
expr_stmt|;
if|if
condition|(
name|maxy
operator|>
name|clip_y2
condition|)
name|maxy
operator|=
name|clip_y2
expr_stmt|;
if|if
condition|(
name|minx
operator|<=
name|maxx
operator|&&
name|miny
operator|<=
name|maxy
condition|)
block|{
name|cairo_surface_t
modifier|*
name|area
decl_stmt|;
name|area
operator|=
name|cairo_image_surface_create
argument_list|(
name|CAIRO_FORMAT_ARGB32
argument_list|,
name|maxx
operator|-
name|minx
operator|+
literal|1
argument_list|,
name|maxy
operator|-
name|miny
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_display_shell_draw_tri
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|gimp_display_shell_draw_tri
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|cairo_surface_destroy
argument_list|(
name|area
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_display_shell_draw_tri:  * @texture:   the thing being transformed  * @cr:        the #cairo_t to draw to  * @area:      has prefetched pixel data of dest  * @area_offx: x coordinate of area in dest  * @area_offy: y coordinate of area in dest  * @x:         Array of the three x coords of triangle  * @y:         Array of the three y coords of triangle  *  * This draws a triangle onto dest by breaking it down into pixel rows, and  * then calling gimp_display_shell_draw_tri_row() and  * gimp_display_shell_draw_tri_row_mask() to do the actual pixel changing.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_display_shell_draw_tri (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,GimpChannel * mask,gint mask_offx,gint mask_offy,gint * x,gint * y,gfloat * u,gfloat * v,guchar opacity)
name|gimp_display_shell_draw_tri
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
comment|/* texture coords */
name|gfloat
modifier|*
name|v
parameter_list|,
comment|/* 0.0 ... tex width, height */
name|guchar
name|opacity
parameter_list|)
block|{
name|gdouble
name|clip_x1
decl_stmt|,
name|clip_y1
decl_stmt|,
name|clip_x2
decl_stmt|,
name|clip_y2
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|ry
decl_stmt|;
name|gint
modifier|*
name|l_edge
decl_stmt|,
modifier|*
name|r_edge
decl_stmt|;
comment|/* arrays holding x-coords of edge pixels */
name|gint
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* temp pointers into l_edge and r_edge  */
name|gfloat
name|dul
decl_stmt|,
name|dvl
decl_stmt|,
name|dur
decl_stmt|,
name|dvr
decl_stmt|;
comment|/* left and right texture coord deltas  */
name|gfloat
name|u_l
decl_stmt|,
name|v_l
decl_stmt|,
name|u_r
decl_stmt|,
name|v_r
decl_stmt|;
comment|/* left and right texture coord pairs  */
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|!=
name|NULL
operator|&&
name|y
operator|!=
name|NULL
operator|&&
name|u
operator|!=
name|NULL
operator|&&
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|left
operator|=
name|right
operator|=
name|NULL
expr_stmt|;
name|dul
operator|=
name|dvl
operator|=
name|dur
operator|=
name|dvr
operator|=
literal|0
expr_stmt|;
name|u_l
operator|=
name|v_l
operator|=
name|u_r
operator|=
name|v_r
operator|=
literal|0
expr_stmt|;
name|cairo_clip_extents
argument_list|(
name|cr
argument_list|,
operator|&
name|clip_x1
argument_list|,
operator|&
name|clip_y1
argument_list|,
operator|&
name|clip_x2
argument_list|,
operator|&
name|clip_y2
argument_list|)
expr_stmt|;
comment|/* sort vertices in order of y-coordinate */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|y
index|[
name|k
index|]
operator|<
name|y
index|[
name|j
index|]
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|y
index|[
name|k
index|]
expr_stmt|;
name|y
index|[
name|k
index|]
operator|=
name|y
index|[
name|j
index|]
expr_stmt|;
name|y
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x
index|[
name|k
index|]
expr_stmt|;
name|x
index|[
name|k
index|]
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
name|x
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u
index|[
name|k
index|]
expr_stmt|;
name|u
index|[
name|k
index|]
operator|=
name|u
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|j
index|]
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v
index|[
name|k
index|]
expr_stmt|;
name|v
index|[
name|k
index|]
operator|=
name|v
index|[
name|j
index|]
expr_stmt|;
name|v
index|[
name|j
index|]
operator|=
name|ftmp
expr_stmt|;
block|}
if|if
condition|(
name|y
index|[
literal|2
index|]
operator|==
name|y
index|[
literal|0
index|]
condition|)
return|return;
name|l_edge
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|r_edge
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* draw the triangle */
name|gimp_display_shell_trace_tri_edge
argument_list|(
name|l_edge
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|left
operator|=
name|l_edge
expr_stmt|;
name|dul
operator|=
operator|(
name|u
index|[
literal|2
index|]
operator|-
name|u
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dvl
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|-
name|v
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|u_l
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|v_l
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|y
index|[
literal|0
index|]
operator|!=
name|y
index|[
literal|1
index|]
condition|)
block|{
name|gimp_display_shell_trace_tri_edge
argument_list|(
name|r_edge
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|r_edge
expr_stmt|;
name|dur
operator|=
operator|(
name|u
index|[
literal|1
index|]
operator|-
name|u
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|1
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dvr
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|-
name|v
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|1
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|u_r
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|v_r
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|0
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|1
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_display_shell_draw_tri_row_mask
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
else|else
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|0
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|1
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_display_shell_draw_tri_row
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y
index|[
literal|1
index|]
operator|!=
name|y
index|[
literal|2
index|]
condition|)
block|{
name|gimp_display_shell_trace_tri_edge
argument_list|(
name|r_edge
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|r_edge
expr_stmt|;
name|dur
operator|=
operator|(
name|u
index|[
literal|2
index|]
operator|-
name|u
index|[
literal|1
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|dvr
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|-
name|v
index|[
literal|1
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|u_r
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|v_r
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|1
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|2
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_display_shell_draw_tri_row_mask
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
else|else
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|1
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|2
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_display_shell_draw_tri_row
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_edge
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|r_edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_display_shell_draw_tri_row:  * @texture: the thing being transformed  * @cr:      the #cairo_t to draw to  * @area:    has prefetched pixel data of dest  *  * Called from gimp_display_shell_draw_tri(), this draws a single row of a  * triangle onto dest when there is not a mask. The run (x1,y) to (x2,y) in  * dest corresponds to the run (u1,v1) to (u2,v2) in texture.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_display_shell_draw_tri_row (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,gint x1,gfloat u1,gfloat v1,gint x2,gfloat u2,gfloat v2,gint y,guchar opacity)
name|gimp_display_shell_draw_tri_row
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|TileManager
modifier|*
name|tiles
decl_stmt|;
comment|/* used to get the source texture colors   */
name|guchar
modifier|*
name|pptr
decl_stmt|;
comment|/* points into the pixels of a row of area */
name|gfloat
name|u
decl_stmt|,
name|v
decl_stmt|;
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint
name|offset
decl_stmt|;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|cairo_image_surface_get_format
argument_list|(
name|area
argument_list|)
operator|==
name|CAIRO_FORMAT_ARGB32
argument_list|)
expr_stmt|;
comment|/* make sure the pixel run goes in the positive direction */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u2
expr_stmt|;
name|u2
operator|=
name|u1
expr_stmt|;
name|u1
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|ftmp
expr_stmt|;
block|}
name|u
operator|=
name|u1
expr_stmt|;
name|v
operator|=
name|v1
expr_stmt|;
name|du
operator|=
operator|(
name|u2
operator|-
name|u1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|v2
operator|-
name|v1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
comment|/* don't calculate unseen pixels */
if|if
condition|(
name|x1
operator|<
name|area_offx
condition|)
block|{
name|u
operator|+=
name|du
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|v
operator|+=
name|dv
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|x1
operator|=
name|area_offx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|x2
operator|<
name|area_offx
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|x2
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
name|x2
operator|=
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
if|if
condition|(
operator|!
name|dx
condition|)
return|return;
name|pptr
operator|=
operator|(
name|cairo_image_surface_get_data
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|y
operator|-
name|area_offy
operator|)
operator|*
name|cairo_image_surface_get_stride
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|x1
operator|-
name|area_offx
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|tiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|texture
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|texture
argument_list|)
condition|)
block|{
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGB_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|cairo_surface_mark_dirty
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|cairo_set_source_surface
argument_list|(
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|)
expr_stmt|;
name|cairo_rectangle
argument_list|(
name|cr
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cairo_fill
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_display_shell_draw_tri_row_mask:  *  * Called from gimp_display_shell_draw_tri(), this draws a single row of a  * triangle onto dest, when there is a mask.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_display_shell_draw_tri_row_mask (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,GimpChannel * mask,gint mask_offx,gint mask_offy,gint x1,gfloat u1,gfloat v1,gint x2,gfloat u2,gfloat v2,gint y,guchar opacity)
name|gimp_display_shell_draw_tri_row_mask
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|TileManager
modifier|*
name|tiles
decl_stmt|,
modifier|*
name|masktiles
decl_stmt|;
comment|/* used to get the source texture colors */
name|guchar
modifier|*
name|pptr
decl_stmt|;
comment|/* points into the pixels of area        */
name|gfloat
name|u
decl_stmt|,
name|v
decl_stmt|;
name|gfloat
name|mu
decl_stmt|,
name|mv
decl_stmt|;
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|maskval
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint
name|offset
decl_stmt|;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|cairo_image_surface_get_format
argument_list|(
name|area
argument_list|)
operator|==
name|CAIRO_FORMAT_ARGB32
argument_list|)
expr_stmt|;
comment|/* make sure the pixel run goes in the positive direction */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u2
expr_stmt|;
name|u2
operator|=
name|u1
expr_stmt|;
name|u1
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|ftmp
expr_stmt|;
block|}
name|u
operator|=
name|u1
expr_stmt|;
name|v
operator|=
name|v1
expr_stmt|;
name|du
operator|=
operator|(
name|u2
operator|-
name|u1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|v2
operator|-
name|v1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
comment|/* don't calculate unseen pixels */
if|if
condition|(
name|x1
operator|<
name|area_offx
condition|)
block|{
name|u
operator|+=
name|du
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|v
operator|+=
name|dv
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|x1
operator|=
name|area_offx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|x2
operator|<
name|area_offx
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|x2
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
name|x2
operator|=
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
if|if
condition|(
operator|!
name|dx
condition|)
return|return;
name|mu
operator|=
name|u
operator|+
name|mask_offx
expr_stmt|;
name|mv
operator|=
name|v
operator|+
name|mask_offy
expr_stmt|;
name|pptr
operator|=
operator|(
name|cairo_image_surface_get_data
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|y
operator|-
name|area_offy
operator|)
operator|*
name|cairo_image_surface_get_stride
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|x1
operator|-
name|area_offx
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|tiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|masktiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|texture
argument_list|)
condition|)
block|{
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGB_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|cairo_surface_mark_dirty
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|cairo_set_source_surface
argument_list|(
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|)
expr_stmt|;
name|cairo_rectangle
argument_list|(
name|cr
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cairo_fill
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_display_shell_trace_tri_edge:  * @dest: x coordinates are placed in this array  *  * Find the x coordinates for a line that runs from (x1,y1) to (x2,y2),  * corresponding to the y coordinates y1 to y2-1. So  * dest must be large enough to hold y2-y1 values.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_display_shell_trace_tri_edge (gint * dest,gint x1,gint y1,gint x2,gint y2)
name|gimp_display_shell_trace_tri_edge
parameter_list|(
name|gint
modifier|*
name|dest
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
specifier|const
name|gint
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|gint
name|xdir
decl_stmt|;
name|gint
name|errorterm
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
modifier|*
name|dptr
decl_stmt|;
if|if
condition|(
name|dy
operator|<=
literal|0
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|errorterm
operator|=
literal|0
expr_stmt|;
name|dptr
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|x2
operator|<
name|x1
condition|)
block|{
name|dx
operator|=
name|x1
operator|-
name|x2
expr_stmt|;
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|xdir
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|errorterm
operator|+=
name|dx
expr_stmt|;
while|while
condition|(
name|errorterm
operator|>
name|dy
condition|)
block|{
name|x1
operator|+=
name|xdir
expr_stmt|;
name|errorterm
operator|-=
name|dy
expr_stmt|;
block|}
name|dptr
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dy
operator|>=
name|dx
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|errorterm
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|errorterm
operator|>
name|dy
condition|)
block|{
name|x1
operator|+=
name|xdir
expr_stmt|;
name|errorterm
operator|-=
name|dy
expr_stmt|;
block|}
name|dptr
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* dy == dx */
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|x1
operator|+=
name|xdir
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

