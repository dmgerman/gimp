begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * gimpcanvastransformpreview.c  * Copyright (C) 2011 Michael Natterer<mitch@gimp.org>  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpwidgets/gimpwidgets.h"
end_include

begin_include
include|#
directive|include
file|"display/display-types.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp-transform-utils.h"
end_include

begin_include
include|#
directive|include
file|"gimpcanvas.h"
end_include

begin_include
include|#
directive|include
file|"gimpcanvastransformpreview.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell.h"
end_include

begin_include
include|#
directive|include
file|"gimpdisplayshell-transform.h"
end_include

begin_define
DECL|macro|INT_MULT (a,b,t)
define|#
directive|define
name|INT_MULT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) + 0x80, ((((t)>> 8) + (t))>> 8))
end_define

begin_define
DECL|macro|INT_MULT3 (a,b,c,t)
define|#
directive|define
name|INT_MULT3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) * (c) + 0x7F5B, \                            ((((t)>> 7) + (t))>> 16))
end_define

begin_define
DECL|macro|MIN4 (a,b,c,d)
define|#
directive|define
name|MIN4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MIN(MIN(a,b),MIN(c,d))
end_define

begin_define
DECL|macro|MAX4 (a,b,c,d)
define|#
directive|define
name|MAX4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|MAX(MAX(a,b),MAX(c,d))
end_define

begin_define
DECL|macro|MAX_SUB_COLS
define|#
directive|define
name|MAX_SUB_COLS
value|6
end_define

begin_comment
DECL|macro|MAX_SUB_COLS
comment|/* number of columns and  */
end_comment

begin_define
DECL|macro|MAX_SUB_ROWS
define|#
directive|define
name|MAX_SUB_ROWS
value|6
end_define

begin_comment
DECL|macro|MAX_SUB_ROWS
comment|/* rows to use in perspective preview subdivision */
end_comment

begin_enum
enum|enum
DECL|enum|__anon2bd5e2af0103
block|{
DECL|enumerator|PROP_0
name|PROP_0
block|,
DECL|enumerator|PROP_DRAWABLE
name|PROP_DRAWABLE
block|,
DECL|enumerator|PROP_TRANSFORM
name|PROP_TRANSFORM
block|,
DECL|enumerator|PROP_X1
name|PROP_X1
block|,
DECL|enumerator|PROP_Y1
name|PROP_Y1
block|,
DECL|enumerator|PROP_X2
name|PROP_X2
block|,
DECL|enumerator|PROP_Y2
name|PROP_Y2
block|,
DECL|enumerator|PROP_PERSPECTIVE
name|PROP_PERSPECTIVE
block|,
DECL|enumerator|PROP_OPACITY
name|PROP_OPACITY
block|}
enum|;
end_enum

begin_typedef
DECL|typedef|GimpCanvasTransformPreviewPrivate
typedef|typedef
name|struct
name|_GimpCanvasTransformPreviewPrivate
name|GimpCanvasTransformPreviewPrivate
typedef|;
end_typedef

begin_struct
DECL|struct|_GimpCanvasTransformPreviewPrivate
struct|struct
name|_GimpCanvasTransformPreviewPrivate
block|{
DECL|member|drawable
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
DECL|member|transform
name|GimpMatrix3
name|transform
decl_stmt|;
DECL|member|x1
DECL|member|y1
name|gdouble
name|x1
decl_stmt|,
name|y1
decl_stmt|;
DECL|member|x2
DECL|member|y2
name|gdouble
name|x2
decl_stmt|,
name|y2
decl_stmt|;
DECL|member|perspective
name|gboolean
name|perspective
decl_stmt|;
DECL|member|opacity
name|gdouble
name|opacity
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|GET_PRIVATE (transform_preview)
define|#
directive|define
name|GET_PRIVATE
parameter_list|(
name|transform_preview
parameter_list|)
define|\
value|G_TYPE_INSTANCE_GET_PRIVATE (transform_preview, \                                      GIMP_TYPE_CANVAS_TRANSFORM_PREVIEW, \                                      GimpCanvasTransformPreviewPrivate)
end_define

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_draw
parameter_list|(
name|GimpCanvasItem
modifier|*
name|item
parameter_list|,
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cairo_region_t
modifier|*
name|gimp_canvas_transform_preview_get_extents
parameter_list|(
name|GimpCanvasItem
modifier|*
name|item
parameter_list|,
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_draw_quad
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_draw_tri
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_draw_tri_row
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_draw_tri_row_mask
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_canvas_transform_preview_trace_tri_edge
parameter_list|(
name|gint
modifier|*
name|dest
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_TYPE (GimpCanvasTransformPreview,gimp_canvas_transform_preview,GIMP_TYPE_CANVAS_ITEM)
name|G_DEFINE_TYPE
argument_list|(
argument|GimpCanvasTransformPreview
argument_list|,
argument|gimp_canvas_transform_preview
argument_list|,
argument|GIMP_TYPE_CANVAS_ITEM
argument_list|)
end_macro

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_canvas_transform_preview_parent_class
end_define

begin_function
specifier|static
name|void
name|gimp_canvas_transform_preview_class_init
parameter_list|(
name|GimpCanvasTransformPreviewClass
modifier|*
name|klass
parameter_list|)
block|{
name|GObjectClass
modifier|*
name|object_class
init|=
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpCanvasItemClass
modifier|*
name|item_class
init|=
name|GIMP_CANVAS_ITEM_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|object_class
operator|->
name|set_property
operator|=
name|gimp_canvas_transform_preview_set_property
expr_stmt|;
name|object_class
operator|->
name|get_property
operator|=
name|gimp_canvas_transform_preview_get_property
expr_stmt|;
name|item_class
operator|->
name|draw
operator|=
name|gimp_canvas_transform_preview_draw
expr_stmt|;
name|item_class
operator|->
name|get_extents
operator|=
name|gimp_canvas_transform_preview_get_extents
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_DRAWABLE
argument_list|,
name|g_param_spec_object
argument_list|(
literal|"drawable"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_TYPE_DRAWABLE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_TRANSFORM
argument_list|,
name|gimp_param_spec_matrix3
argument_list|(
literal|"transform"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_X1
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"x1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_Y1
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"y1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_X2
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"x2"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_Y2
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"y2"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
literal|0.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_PERSPECTIVE
argument_list|,
name|g_param_spec_boolean
argument_list|(
literal|"perspective"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_class_install_property
argument_list|(
name|object_class
argument_list|,
name|PROP_OPACITY
argument_list|,
name|g_param_spec_double
argument_list|(
literal|"opacity"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|GIMP_PARAM_READWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|g_type_class_add_private
argument_list|(
name|klass
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpCanvasTransformPreviewPrivate
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_init (GimpCanvasTransformPreview * transform_preview)
name|gimp_canvas_transform_preview_init
parameter_list|(
name|GimpCanvasTransformPreview
modifier|*
name|transform_preview
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_set_property (GObject * object,guint property_id,const GValue * value,GParamSpec * pspec)
name|gimp_canvas_transform_preview_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpCanvasTransformPreviewPrivate
modifier|*
name|private
init|=
name|GET_PRIVATE
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_DRAWABLE
case|:
name|private
operator|->
name|drawable
operator|=
name|g_value_get_object
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* don't ref */
break|break;
case|case
name|PROP_TRANSFORM
case|:
block|{
name|GimpMatrix3
modifier|*
name|transform
init|=
name|g_value_get_boxed
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|transform
condition|)
name|private
operator|->
name|transform
operator|=
operator|*
name|transform
expr_stmt|;
else|else
name|gimp_matrix3_identity
argument_list|(
operator|&
name|private
operator|->
name|transform
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_X1
case|:
name|private
operator|->
name|x1
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_Y1
case|:
name|private
operator|->
name|y1
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_X2
case|:
name|private
operator|->
name|x2
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_Y2
case|:
name|private
operator|->
name|y2
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PERSPECTIVE
case|:
name|private
operator|->
name|perspective
operator|=
name|g_value_get_boolean
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|private
operator|->
name|opacity
operator|=
name|g_value_get_double
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_get_property (GObject * object,guint property_id,GValue * value,GParamSpec * pspec)
name|gimp_canvas_transform_preview_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{
name|GimpCanvasTransformPreviewPrivate
modifier|*
name|private
init|=
name|GET_PRIVATE
argument_list|(
name|object
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|property_id
condition|)
block|{
case|case
name|PROP_DRAWABLE
case|:
name|g_value_set_object
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|drawable
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TRANSFORM
case|:
name|g_value_set_boxed
argument_list|(
name|value
argument_list|,
operator|&
name|private
operator|->
name|transform
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PERSPECTIVE
case|:
name|g_value_set_boolean
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|perspective
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_X1
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|x1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_Y1
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_X2
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|x2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_Y2
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|y2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|g_value_set_double
argument_list|(
name|value
argument_list|,
name|private
operator|->
name|opacity
argument_list|)
expr_stmt|;
break|break;
default|default:
name|G_OBJECT_WARN_INVALID_PROPERTY_ID
argument_list|(
name|object
argument_list|,
name|property_id
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_canvas_transform_preview_transform (GimpCanvasItem * item,GimpDisplayShell * shell,GdkRectangle * extents)
name|gimp_canvas_transform_preview_transform
parameter_list|(
name|GimpCanvasItem
modifier|*
name|item
parameter_list|,
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|,
name|GdkRectangle
modifier|*
name|extents
parameter_list|)
block|{
name|GimpCanvasTransformPreviewPrivate
modifier|*
name|private
init|=
name|GET_PRIVATE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|gdouble
name|tx1
decl_stmt|,
name|ty1
decl_stmt|;
name|gdouble
name|tx2
decl_stmt|,
name|ty2
decl_stmt|;
name|gdouble
name|tx3
decl_stmt|,
name|ty3
decl_stmt|;
name|gdouble
name|tx4
decl_stmt|,
name|ty4
decl_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|private
operator|->
name|transform
argument_list|,
name|private
operator|->
name|x1
argument_list|,
name|private
operator|->
name|y1
argument_list|,
operator|&
name|tx1
argument_list|,
operator|&
name|ty1
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|private
operator|->
name|transform
argument_list|,
name|private
operator|->
name|x2
argument_list|,
name|private
operator|->
name|y1
argument_list|,
operator|&
name|tx2
argument_list|,
operator|&
name|ty2
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|private
operator|->
name|transform
argument_list|,
name|private
operator|->
name|x1
argument_list|,
name|private
operator|->
name|y2
argument_list|,
operator|&
name|tx3
argument_list|,
operator|&
name|ty3
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|private
operator|->
name|transform
argument_list|,
name|private
operator|->
name|x2
argument_list|,
name|private
operator|->
name|y2
argument_list|,
operator|&
name|tx4
argument_list|,
operator|&
name|ty4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_transform_polygon_is_convex
argument_list|(
name|tx1
argument_list|,
name|ty1
argument_list|,
name|tx2
argument_list|,
name|ty2
argument_list|,
name|tx3
argument_list|,
name|ty3
argument_list|,
name|tx4
argument_list|,
name|ty4
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|extents
condition|)
block|{
name|gdouble
name|dx1
decl_stmt|,
name|dy1
decl_stmt|;
name|gdouble
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
name|gdouble
name|dx3
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|dx4
decl_stmt|,
name|dy4
decl_stmt|;
name|gimp_display_shell_transform_xy_f
argument_list|(
name|shell
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
operator|&
name|dx1
argument_list|,
operator|&
name|dy1
argument_list|)
expr_stmt|;
name|gimp_display_shell_transform_xy_f
argument_list|(
name|shell
argument_list|,
name|tx2
argument_list|,
name|ty2
argument_list|,
operator|&
name|dx2
argument_list|,
operator|&
name|dy2
argument_list|)
expr_stmt|;
name|gimp_display_shell_transform_xy_f
argument_list|(
name|shell
argument_list|,
name|tx3
argument_list|,
name|ty3
argument_list|,
operator|&
name|dx3
argument_list|,
operator|&
name|dy3
argument_list|)
expr_stmt|;
name|gimp_display_shell_transform_xy_f
argument_list|(
name|shell
argument_list|,
name|tx4
argument_list|,
name|ty4
argument_list|,
operator|&
name|dx4
argument_list|,
operator|&
name|dy4
argument_list|)
expr_stmt|;
name|extents
operator|->
name|x
operator|=
operator|(
name|gint
operator|)
name|floor
argument_list|(
name|MIN4
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|,
name|dx3
argument_list|,
name|dx4
argument_list|)
argument_list|)
expr_stmt|;
name|extents
operator|->
name|y
operator|=
operator|(
name|gint
operator|)
name|floor
argument_list|(
name|MIN4
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|,
name|dy3
argument_list|,
name|dy4
argument_list|)
argument_list|)
expr_stmt|;
name|extents
operator|->
name|width
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX4
argument_list|(
name|dx1
argument_list|,
name|dx2
argument_list|,
name|dx3
argument_list|,
name|dx4
argument_list|)
argument_list|)
expr_stmt|;
name|extents
operator|->
name|height
operator|=
operator|(
name|gint
operator|)
name|ceil
argument_list|(
name|MAX4
argument_list|(
name|dy1
argument_list|,
name|dy2
argument_list|,
name|dy3
argument_list|,
name|dy4
argument_list|)
argument_list|)
expr_stmt|;
name|extents
operator|->
name|width
operator|-=
name|extents
operator|->
name|x
expr_stmt|;
name|extents
operator|->
name|height
operator|-=
name|extents
operator|->
name|y
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_draw (GimpCanvasItem * item,GimpDisplayShell * shell,cairo_t * cr)
name|gimp_canvas_transform_preview_draw
parameter_list|(
name|GimpCanvasItem
modifier|*
name|item
parameter_list|,
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
block|{
name|GimpCanvasTransformPreviewPrivate
modifier|*
name|private
init|=
name|GET_PRIVATE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|gint
name|mask_x1
decl_stmt|,
name|mask_y1
decl_stmt|;
name|gint
name|mask_x2
decl_stmt|,
name|mask_y2
decl_stmt|;
name|gint
name|mask_offx
decl_stmt|,
name|mask_offy
decl_stmt|;
name|gint
name|columns
decl_stmt|,
name|rows
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|,
name|sub
decl_stmt|;
comment|/* x and y get filled with the screen coordinates of each corner of     * each quadrilateral subdivision of the transformed area. u and v     * are the corresponding points in the mask     */
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gint
name|x
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|y
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gfloat
name|u
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|gfloat
name|v
index|[
name|MAX_SUB_COLS
operator|*
name|MAX_SUB_ROWS
index|]
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|opacity
decl_stmt|;
name|opacity
operator|=
name|private
operator|->
name|opacity
operator|*
literal|255.999
expr_stmt|;
comment|/* only draw convex polygons */
if|if
condition|(
operator|!
name|gimp_canvas_transform_preview_transform
argument_list|(
name|item
argument_list|,
name|shell
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
name|mask
operator|=
name|NULL
expr_stmt|;
name|mask_offx
operator|=
literal|0
expr_stmt|;
name|mask_offy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gimp_item_mask_bounds
argument_list|(
name|GIMP_ITEM
argument_list|(
name|private
operator|->
name|drawable
argument_list|)
argument_list|,
operator|&
name|mask_x1
argument_list|,
operator|&
name|mask_y1
argument_list|,
operator|&
name|mask_x2
argument_list|,
operator|&
name|mask_y2
argument_list|)
condition|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|gimp_item_get_image
argument_list|(
name|GIMP_ITEM
argument_list|(
name|private
operator|->
name|drawable
argument_list|)
argument_list|)
decl_stmt|;
name|mask
operator|=
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|private
operator|->
name|drawable
argument_list|)
argument_list|,
operator|&
name|mask_offx
argument_list|,
operator|&
name|mask_offy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|private
operator|->
name|perspective
condition|)
block|{
comment|/* approximate perspective transform by subdivision        *        * increase number of columns/rows to increase precision        */
name|columns
operator|=
name|MAX_SUB_COLS
expr_stmt|;
name|rows
operator|=
name|MAX_SUB_ROWS
expr_stmt|;
block|}
else|else
block|{
comment|/*  for affine transforms subdivision has no effect        */
name|columns
operator|=
literal|1
expr_stmt|;
name|rows
operator|=
literal|1
expr_stmt|;
block|}
name|dx
operator|=
operator|(
name|private
operator|->
name|x2
operator|-
name|private
operator|->
name|x1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|columns
operator|)
expr_stmt|;
name|dy
operator|=
operator|(
name|private
operator|->
name|y2
operator|-
name|private
operator|->
name|y1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|rows
operator|)
expr_stmt|;
name|du
operator|=
operator|(
name|mask_x2
operator|-
name|mask_x1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|columns
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|mask_y2
operator|-
name|mask_y1
operator|)
operator|/
operator|(
operator|(
name|gfloat
operator|)
name|rows
operator|)
expr_stmt|;
DECL|macro|CALC_VERTEX (col,row,sub,index)
define|#
directive|define
name|CALC_VERTEX
parameter_list|(
name|col
parameter_list|,
name|row
parameter_list|,
name|sub
parameter_list|,
name|index
parameter_list|)
define|\
value|{                                                             \     gdouble tx1, ty1;                                           \     gdouble tx2, ty2;                                           \                                                                 \     u[sub][index] = private->x1 + (dx * (col + (index& 1)));   \     v[sub][index] = private->y1 + (dy * (row + (index>> 1)));  \                                                                 \     gimp_matrix3_transform_point (&private->transform,          \                                   u[sub][index], v[sub][index], \&tx1,&ty1);                  \                                                                 \     gimp_display_shell_transform_xy_f (shell,                   \                                        tx1, ty1,                \&tx2,&ty2);             \     x[sub][index] = (gint) tx2;                                 \     y[sub][index] = (gint) ty2;                                 \                                                                 \     u[sub][index] = mask_x1 + (du * (col + (index& 1)));       \     v[sub][index] = mask_y1 + (dv * (row + (index>> 1)));      \   }
DECL|macro|COPY_VERTEX (subdest,idest,subsrc,isrc)
define|#
directive|define
name|COPY_VERTEX
parameter_list|(
name|subdest
parameter_list|,
name|idest
parameter_list|,
name|subsrc
parameter_list|,
name|isrc
parameter_list|)
define|\
value|x[subdest][idest] = x[subsrc][isrc];            \   y[subdest][idest] = y[subsrc][isrc];            \   u[subdest][idest] = u[subsrc][isrc];            \   v[subdest][idest] = v[subsrc][isrc];
comment|/*    * upper left corner subdivision: calculate all vertices    */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/*    * top row subdivisions: calculate only right side vertices    */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|j
argument_list|,
literal|2
argument_list|,
name|j
operator|-
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * left column subdivisions: calculate only bottom side vertices    */
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|sub
operator|=
name|columns
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
operator|,
name|sub
operator|+=
name|columns
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
literal|0
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * the rest: calculate only the bottom-right vertex    */
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|sub
operator|=
name|columns
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|sub
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
operator|,
name|sub
operator|++
control|)
block|{
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|,
name|sub
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|,
name|sub
operator|-
name|columns
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|COPY_VERTEX
argument_list|(
name|sub
argument_list|,
literal|2
argument_list|,
name|sub
operator|-
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CALC_VERTEX
argument_list|(
name|k
argument_list|,
name|j
argument_list|,
name|sub
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|CALC_VERTEX
undef|#
directive|undef
name|COPY_VERTEX
name|k
operator|=
name|columns
operator|*
name|rows
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|gimp_canvas_transform_preview_draw_quad
argument_list|(
name|private
operator|->
name|drawable
argument_list|,
name|cr
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|y
index|[
name|j
index|]
argument_list|,
name|u
index|[
name|j
index|]
argument_list|,
name|v
index|[
name|j
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cairo_region_t
modifier|*
DECL|function|gimp_canvas_transform_preview_get_extents (GimpCanvasItem * item,GimpDisplayShell * shell)
name|gimp_canvas_transform_preview_get_extents
parameter_list|(
name|GimpCanvasItem
modifier|*
name|item
parameter_list|,
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|)
block|{
name|GdkRectangle
name|rectangle
decl_stmt|;
if|if
condition|(
name|gimp_canvas_transform_preview_transform
argument_list|(
name|item
argument_list|,
name|shell
argument_list|,
operator|&
name|rectangle
argument_list|)
condition|)
return|return
name|cairo_region_create_rectangle
argument_list|(
operator|(
name|cairo_rectangle_int_t
operator|*
operator|)
operator|&
name|rectangle
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GimpCanvasItem
modifier|*
DECL|function|gimp_canvas_transform_preview_new (GimpDisplayShell * shell,GimpDrawable * drawable,const GimpMatrix3 * transform,gdouble x1,gdouble y1,gdouble x2,gdouble y2,gboolean perspective,gdouble opacity)
name|gimp_canvas_transform_preview_new
parameter_list|(
name|GimpDisplayShell
modifier|*
name|shell
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
specifier|const
name|GimpMatrix3
modifier|*
name|transform
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|gboolean
name|perspective
parameter_list|,
name|gdouble
name|opacity
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DISPLAY_SHELL
argument_list|(
name|shell
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|transform
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|g_object_new
argument_list|(
name|GIMP_TYPE_CANVAS_TRANSFORM_PREVIEW
argument_list|,
literal|"shell"
argument_list|,
name|shell
argument_list|,
literal|"drawable"
argument_list|,
name|drawable
argument_list|,
literal|"transform"
argument_list|,
name|transform
argument_list|,
literal|"x1"
argument_list|,
name|x1
argument_list|,
literal|"y1"
argument_list|,
name|y1
argument_list|,
literal|"x2"
argument_list|,
name|x2
argument_list|,
literal|"y2"
argument_list|,
name|y2
argument_list|,
literal|"perspective"
argument_list|,
name|perspective
argument_list|,
literal|"opacity"
argument_list|,
name|CLAMP
argument_list|(
name|opacity
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_comment
comment|/**  * gimp_canvas_transform_preview_draw_quad:  * @texture:   the #GimpDrawable to be previewed  * @cr:        the #cairo_t to draw to  * @mask:      a #GimpChannel  * @opacity:   the opacity of the preview  *  * Take a quadrilateral, divide it into two triangles, and draw those  * with gimp_canvas_transform_preview_draw_tri().  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_draw_quad (GimpDrawable * texture,cairo_t * cr,GimpChannel * mask,gint mask_offx,gint mask_offy,gint * x,gint * y,gfloat * u,gfloat * v,guchar opacity)
name|gimp_canvas_transform_preview_draw_quad
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
name|gfloat
modifier|*
name|v
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|gint
name|x2
index|[
literal|3
index|]
decl_stmt|,
name|y2
index|[
literal|3
index|]
decl_stmt|;
name|gfloat
name|u2
index|[
literal|3
index|]
decl_stmt|,
name|v2
index|[
literal|3
index|]
decl_stmt|;
name|gint
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
comment|/* screen bounds of the quad        */
name|gdouble
name|clip_x1
decl_stmt|,
name|clip_y1
decl_stmt|,
name|clip_x2
decl_stmt|,
name|clip_y2
decl_stmt|;
name|gint
name|c
decl_stmt|;
name|x2
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|3
index|]
expr_stmt|;
name|y2
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|3
index|]
expr_stmt|;
name|u2
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|3
index|]
expr_stmt|;
name|v2
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|x2
index|[
literal|1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y2
index|[
literal|1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
name|u2
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|2
index|]
expr_stmt|;
name|v2
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|x2
index|[
literal|2
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|y2
index|[
literal|2
index|]
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
name|u2
index|[
literal|2
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|v2
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
comment|/* Allocate a box around the quad to compute preview data into     * and fill it with the original window contents.     */
name|cairo_clip_extents
argument_list|(
name|cr
argument_list|,
operator|&
name|clip_x1
argument_list|,
operator|&
name|clip_y1
argument_list|,
operator|&
name|clip_x2
argument_list|,
operator|&
name|clip_y2
argument_list|)
expr_stmt|;
comment|/* find bounds of quad in order to only grab as much of dest as needed */
name|minx
operator|=
name|maxx
operator|=
name|x
index|[
literal|0
index|]
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|y
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|c
index|]
operator|<
name|minx
condition|)
name|minx
operator|=
name|x
index|[
name|c
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|x
index|[
name|c
index|]
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|x
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|y
index|[
name|c
index|]
operator|<
name|miny
condition|)
name|miny
operator|=
name|y
index|[
name|c
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|y
index|[
name|c
index|]
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|y
index|[
name|c
index|]
expr_stmt|;
block|}
if|if
condition|(
name|minx
operator|<
name|clip_x1
condition|)
name|minx
operator|=
name|clip_x1
expr_stmt|;
if|if
condition|(
name|miny
operator|<
name|clip_y1
condition|)
name|miny
operator|=
name|clip_y1
expr_stmt|;
if|if
condition|(
name|maxx
operator|>
name|clip_x2
condition|)
name|maxx
operator|=
name|clip_x2
expr_stmt|;
if|if
condition|(
name|maxy
operator|>
name|clip_y2
condition|)
name|maxy
operator|=
name|clip_y2
expr_stmt|;
if|if
condition|(
name|minx
operator|<=
name|maxx
operator|&&
name|miny
operator|<=
name|maxy
condition|)
block|{
name|cairo_surface_t
modifier|*
name|area
decl_stmt|;
name|area
operator|=
name|cairo_image_surface_create
argument_list|(
name|CAIRO_FORMAT_ARGB32
argument_list|,
name|maxx
operator|-
name|minx
operator|+
literal|1
argument_list|,
name|maxy
operator|-
name|miny
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_canvas_transform_preview_draw_tri
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|gimp_canvas_transform_preview_draw_tri
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|cairo_surface_destroy
argument_list|(
name|area
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_canvas_transform_preview_draw_tri:  * @texture:   the thing being transformed  * @cr:        the #cairo_t to draw to  * @area:      has prefetched pixel data of dest  * @area_offx: x coordinate of area in dest  * @area_offy: y coordinate of area in dest  * @x:         Array of the three x coords of triangle  * @y:         Array of the three y coords of triangle  *  * This draws a triangle onto dest by breaking it down into pixel  * rows, and then calling gimp_canvas_transform_preview_draw_tri_row()  * and gimp_canvas_transform_preview_draw_tri_row_mask() to do the  * actual pixel changing.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_draw_tri (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,GimpChannel * mask,gint mask_offx,gint mask_offy,gint * x,gint * y,gfloat * u,gfloat * v,guchar opacity)
name|gimp_canvas_transform_preview_draw_tri
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gfloat
modifier|*
name|u
parameter_list|,
comment|/* texture coords */
name|gfloat
modifier|*
name|v
parameter_list|,
comment|/* 0.0 ... tex width, height */
name|guchar
name|opacity
parameter_list|)
block|{
name|gdouble
name|clip_x1
decl_stmt|,
name|clip_y1
decl_stmt|,
name|clip_x2
decl_stmt|,
name|clip_y2
decl_stmt|;
name|gint
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|ry
decl_stmt|;
name|gint
modifier|*
name|l_edge
decl_stmt|,
modifier|*
name|r_edge
decl_stmt|;
comment|/* arrays holding x-coords of edge pixels */
name|gint
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* temp pointers into l_edge and r_edge  */
name|gfloat
name|dul
decl_stmt|,
name|dvl
decl_stmt|,
name|dur
decl_stmt|,
name|dvr
decl_stmt|;
comment|/* left and right texture coord deltas  */
name|gfloat
name|u_l
decl_stmt|,
name|v_l
decl_stmt|,
name|u_r
decl_stmt|,
name|v_r
decl_stmt|;
comment|/* left and right texture coord pairs  */
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|!=
name|NULL
operator|&&
name|y
operator|!=
name|NULL
operator|&&
name|u
operator|!=
name|NULL
operator|&&
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|left
operator|=
name|right
operator|=
name|NULL
expr_stmt|;
name|dul
operator|=
name|dvl
operator|=
name|dur
operator|=
name|dvr
operator|=
literal|0
expr_stmt|;
name|u_l
operator|=
name|v_l
operator|=
name|u_r
operator|=
name|v_r
operator|=
literal|0
expr_stmt|;
name|cairo_clip_extents
argument_list|(
name|cr
argument_list|,
operator|&
name|clip_x1
argument_list|,
operator|&
name|clip_y1
argument_list|,
operator|&
name|clip_x2
argument_list|,
operator|&
name|clip_y2
argument_list|)
expr_stmt|;
comment|/* sort vertices in order of y-coordinate */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|y
index|[
name|k
index|]
operator|<
name|y
index|[
name|j
index|]
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|y
index|[
name|k
index|]
expr_stmt|;
name|y
index|[
name|k
index|]
operator|=
name|y
index|[
name|j
index|]
expr_stmt|;
name|y
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x
index|[
name|k
index|]
expr_stmt|;
name|x
index|[
name|k
index|]
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
name|x
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u
index|[
name|k
index|]
expr_stmt|;
name|u
index|[
name|k
index|]
operator|=
name|u
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|j
index|]
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v
index|[
name|k
index|]
expr_stmt|;
name|v
index|[
name|k
index|]
operator|=
name|v
index|[
name|j
index|]
expr_stmt|;
name|v
index|[
name|j
index|]
operator|=
name|ftmp
expr_stmt|;
block|}
if|if
condition|(
name|y
index|[
literal|2
index|]
operator|==
name|y
index|[
literal|0
index|]
condition|)
return|return;
name|l_edge
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|r_edge
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* draw the triangle */
name|gimp_canvas_transform_preview_trace_tri_edge
argument_list|(
name|l_edge
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|left
operator|=
name|l_edge
expr_stmt|;
name|dul
operator|=
operator|(
name|u
index|[
literal|2
index|]
operator|-
name|u
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dvl
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|-
name|v
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|u_l
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|v_l
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|y
index|[
literal|0
index|]
operator|!=
name|y
index|[
literal|1
index|]
condition|)
block|{
name|gimp_canvas_transform_preview_trace_tri_edge
argument_list|(
name|r_edge
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|r_edge
expr_stmt|;
name|dur
operator|=
operator|(
name|u
index|[
literal|1
index|]
operator|-
name|u
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|1
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dvr
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|-
name|v
index|[
literal|0
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|1
index|]
operator|-
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|u_r
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|v_r
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|0
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|1
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_canvas_transform_preview_draw_tri_row_mask
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
else|else
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|0
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|1
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_canvas_transform_preview_draw_tri_row
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y
index|[
literal|1
index|]
operator|!=
name|y
index|[
literal|2
index|]
condition|)
block|{
name|gimp_canvas_transform_preview_trace_tri_edge
argument_list|(
name|r_edge
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|r_edge
expr_stmt|;
name|dur
operator|=
operator|(
name|u
index|[
literal|2
index|]
operator|-
name|u
index|[
literal|1
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|dvr
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|-
name|v
index|[
literal|1
index|]
operator|)
operator|/
operator|(
name|y
index|[
literal|2
index|]
operator|-
name|y
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|u_r
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|v_r
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|1
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|2
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_canvas_transform_preview_draw_tri_row_mask
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
name|mask
argument_list|,
name|mask_offx
argument_list|,
name|mask_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
else|else
for|for
control|(
name|ry
operator|=
name|y
index|[
literal|1
index|]
init|;
name|ry
operator|<
name|y
index|[
literal|2
index|]
condition|;
name|ry
operator|++
control|)
block|{
if|if
condition|(
name|ry
operator|>=
name|clip_y1
operator|&&
name|ry
operator|<
name|clip_y2
condition|)
name|gimp_canvas_transform_preview_draw_tri_row
argument_list|(
name|texture
argument_list|,
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|,
operator|*
name|left
argument_list|,
name|u_l
argument_list|,
name|v_l
argument_list|,
operator|*
name|right
argument_list|,
name|u_r
argument_list|,
name|v_r
argument_list|,
name|ry
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
name|u_l
operator|+=
name|dul
expr_stmt|;
name|v_l
operator|+=
name|dvl
expr_stmt|;
name|u_r
operator|+=
name|dur
expr_stmt|;
name|v_r
operator|+=
name|dvr
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_edge
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|r_edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_canvas_transform_preview_draw_tri_row:  * @texture: the thing being transformed  * @cr:      the #cairo_t to draw to  * @area:    has prefetched pixel data of dest  *  * Called from gimp_canvas_transform_preview_draw_tri(), this draws a  * single row of a triangle onto dest when there is not a mask. The  * run (x1,y) to (x2,y) in dest corresponds to the run (u1,v1) to  * (u2,v2) in texture.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_draw_tri_row (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,gint x1,gfloat u1,gfloat v1,gint x2,gfloat u2,gfloat v2,gint y,guchar opacity)
name|gimp_canvas_transform_preview_draw_tri_row
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|TileManager
modifier|*
name|tiles
decl_stmt|;
comment|/* used to get the source texture colors   */
name|guchar
modifier|*
name|pptr
decl_stmt|;
comment|/* points into the pixels of a row of area */
name|gfloat
name|u
decl_stmt|,
name|v
decl_stmt|;
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint
name|offset
decl_stmt|;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|cairo_image_surface_get_format
argument_list|(
name|area
argument_list|)
operator|==
name|CAIRO_FORMAT_ARGB32
argument_list|)
expr_stmt|;
comment|/* make sure the pixel run goes in the positive direction */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u2
expr_stmt|;
name|u2
operator|=
name|u1
expr_stmt|;
name|u1
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|ftmp
expr_stmt|;
block|}
name|u
operator|=
name|u1
expr_stmt|;
name|v
operator|=
name|v1
expr_stmt|;
name|du
operator|=
operator|(
name|u2
operator|-
name|u1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|v2
operator|-
name|v1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
comment|/* don't calculate unseen pixels */
if|if
condition|(
name|x1
operator|<
name|area_offx
condition|)
block|{
name|u
operator|+=
name|du
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|v
operator|+=
name|dv
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|x1
operator|=
name|area_offx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|x2
operator|<
name|area_offx
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|x2
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
name|x2
operator|=
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
if|if
condition|(
operator|!
name|dx
condition|)
return|return;
name|pptr
operator|=
operator|(
name|cairo_image_surface_get_data
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|y
operator|-
name|area_offy
operator|)
operator|*
name|cairo_image_surface_get_stride
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|x1
operator|-
name|area_offx
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|tiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|texture
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|texture
argument_list|)
condition|)
block|{
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGB_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|cairo_surface_mark_dirty
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|cairo_set_source_surface
argument_list|(
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|)
expr_stmt|;
name|cairo_rectangle
argument_list|(
name|cr
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cairo_fill
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_canvas_transform_preview_draw_tri_row_mask:  *  * Called from gimp_canvas_transform_preview_draw_tri(), this draws a  * single row of a triangle onto dest, when there is a mask.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_draw_tri_row_mask (GimpDrawable * texture,cairo_t * cr,cairo_surface_t * area,gint area_offx,gint area_offy,GimpChannel * mask,gint mask_offx,gint mask_offy,gint x1,gfloat u1,gfloat v1,gint x2,gfloat u2,gfloat v2,gint y,guchar opacity)
name|gimp_canvas_transform_preview_draw_tri_row_mask
parameter_list|(
name|GimpDrawable
modifier|*
name|texture
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|cairo_surface_t
modifier|*
name|area
parameter_list|,
name|gint
name|area_offx
parameter_list|,
name|gint
name|area_offy
parameter_list|,
name|GimpChannel
modifier|*
name|mask
parameter_list|,
name|gint
name|mask_offx
parameter_list|,
name|gint
name|mask_offy
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gfloat
name|u1
parameter_list|,
name|gfloat
name|v1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gfloat
name|u2
parameter_list|,
name|gfloat
name|v2
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
name|opacity
parameter_list|)
block|{
name|TileManager
modifier|*
name|tiles
decl_stmt|,
modifier|*
name|masktiles
decl_stmt|;
comment|/* used to get the source texture colors */
name|guchar
modifier|*
name|pptr
decl_stmt|;
comment|/* points into the pixels of area        */
name|gfloat
name|u
decl_stmt|,
name|v
decl_stmt|;
name|gfloat
name|mu
decl_stmt|,
name|mv
decl_stmt|;
name|gfloat
name|du
decl_stmt|,
name|dv
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|maskval
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint
name|offset
decl_stmt|;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_DRAWABLE
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_CHANNEL
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|area
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|cairo_image_surface_get_format
argument_list|(
name|area
argument_list|)
operator|==
name|CAIRO_FORMAT_ARGB32
argument_list|)
expr_stmt|;
comment|/* make sure the pixel run goes in the positive direction */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|gint
name|tmp
decl_stmt|;
name|gfloat
name|ftmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
name|ftmp
operator|=
name|u2
expr_stmt|;
name|u2
operator|=
name|u1
expr_stmt|;
name|u1
operator|=
name|ftmp
expr_stmt|;
name|ftmp
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|ftmp
expr_stmt|;
block|}
name|u
operator|=
name|u1
expr_stmt|;
name|v
operator|=
name|v1
expr_stmt|;
name|du
operator|=
operator|(
name|u2
operator|-
name|u1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|dv
operator|=
operator|(
name|v2
operator|-
name|v1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
comment|/* don't calculate unseen pixels */
if|if
condition|(
name|x1
operator|<
name|area_offx
condition|)
block|{
name|u
operator|+=
name|du
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|v
operator|+=
name|dv
operator|*
operator|(
name|area_offx
operator|-
name|x1
operator|)
expr_stmt|;
name|x1
operator|=
name|area_offx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|x2
operator|<
name|area_offx
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|x2
operator|>
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
condition|)
block|{
name|x2
operator|=
name|area_offx
operator|+
name|cairo_image_surface_get_width
argument_list|(
name|area
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
if|if
condition|(
operator|!
name|dx
condition|)
return|return;
name|mu
operator|=
name|u
operator|+
name|mask_offx
expr_stmt|;
name|mv
operator|=
name|v
operator|+
name|mask_offy
expr_stmt|;
name|pptr
operator|=
operator|(
name|cairo_image_surface_get_data
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|y
operator|-
name|area_offy
operator|)
operator|*
name|cairo_image_surface_get_stride
argument_list|(
name|area
argument_list|)
operator|+
operator|(
name|x1
operator|-
name|area_offx
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|tiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|masktiles
operator|=
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|texture
argument_list|)
condition|)
block|{
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|cmap
operator|=
name|gimp_drawable_get_colormap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
operator|+
name|pixel
index|[
literal|0
index|]
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|0
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|1
index|]
argument_list|,
name|cmap
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGB_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
while|while
condition|(
name|dx
operator|--
condition|)
block|{
specifier|register
name|gulong
name|tmp
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|tiles
argument_list|,
operator|(
name|gint
operator|)
name|u
argument_list|,
operator|(
name|gint
operator|)
name|v
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|masktiles
argument_list|,
operator|(
name|gint
operator|)
name|mu
argument_list|,
operator|(
name|gint
operator|)
name|mv
argument_list|,
operator|&
name|maskval
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|INT_MULT3
argument_list|(
name|opacity
argument_list|,
name|maskval
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GIMP_CAIRO_ARGB32_SET_PIXEL
argument_list|(
name|pptr
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|u
operator|+=
name|du
expr_stmt|;
name|v
operator|+=
name|dv
expr_stmt|;
name|mu
operator|+=
name|du
expr_stmt|;
name|mv
operator|+=
name|dv
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|cairo_surface_mark_dirty
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|cairo_set_source_surface
argument_list|(
name|cr
argument_list|,
name|area
argument_list|,
name|area_offx
argument_list|,
name|area_offy
argument_list|)
expr_stmt|;
name|cairo_rectangle
argument_list|(
name|cr
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cairo_fill
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_canvas_transform_preview_trace_tri_edge:  * @dest: x coordinates are placed in this array  *  * Find the x coordinates for a line that runs from (x1,y1) to  * (x2,y2), corresponding to the y coordinates y1 to y2-1. So dest  * must be large enough to hold y2-y1 values.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_canvas_transform_preview_trace_tri_edge (gint * dest,gint x1,gint y1,gint x2,gint y2)
name|gimp_canvas_transform_preview_trace_tri_edge
parameter_list|(
name|gint
modifier|*
name|dest
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
specifier|const
name|gint
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
name|gint
name|dx
decl_stmt|;
name|gint
name|xdir
decl_stmt|;
name|gint
name|errorterm
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
modifier|*
name|dptr
decl_stmt|;
if|if
condition|(
name|dy
operator|<=
literal|0
condition|)
return|return;
name|g_return_if_fail
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|errorterm
operator|=
literal|0
expr_stmt|;
name|dptr
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|x2
operator|<
name|x1
condition|)
block|{
name|dx
operator|=
name|x1
operator|-
name|x2
expr_stmt|;
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|xdir
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|errorterm
operator|+=
name|dx
expr_stmt|;
while|while
condition|(
name|errorterm
operator|>
name|dy
condition|)
block|{
name|x1
operator|+=
name|xdir
expr_stmt|;
name|errorterm
operator|-=
name|dy
expr_stmt|;
block|}
name|dptr
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dy
operator|>=
name|dx
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|errorterm
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|errorterm
operator|>
name|dy
condition|)
block|{
name|x1
operator|+=
name|xdir
expr_stmt|;
name|errorterm
operator|-=
name|dy
expr_stmt|;
block|}
name|dptr
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* dy == dx */
block|{
name|b
operator|=
name|dy
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
block|{
operator|*
name|dptr
operator|=
name|x1
expr_stmt|;
name|x1
operator|+=
name|xdir
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

