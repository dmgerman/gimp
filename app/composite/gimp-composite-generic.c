begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  *  */
end_comment

begin_comment
comment|/*  * This file is supposed to contain the generic (read: C) implementation  * of the pixel fiddling paint-functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<cairo.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"base/base-types.h"
end_include

begin_include
include|#
directive|include
file|"gimp-composite.h"
end_include

begin_include
include|#
directive|include
file|"gimp-composite-generic.h"
end_include

begin_define
DECL|macro|OPAQUE_OPACITY
define|#
directive|define
name|OPAQUE_OPACITY
value|255
end_define

begin_define
DECL|macro|TRANSPARENT_OPACITY
define|#
directive|define
name|TRANSPARENT_OPACITY
value|0
end_define

begin_define
DECL|macro|RANDOM_TABLE_SIZE
define|#
directive|define
name|RANDOM_TABLE_SIZE
value|4096
end_define

begin_define
DECL|macro|INT_MULT (a,b,t)
define|#
directive|define
name|INT_MULT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) + 0x80, ((((t)>> 8) + (t))>> 8))
end_define

begin_comment
comment|/* A drawable has an alphachannel if contains either 4 or 2 bytes data  * aka GRAYA and RGBA and thus the macro below works. This will have  * to change if we support bigger formats. We'll do it so for now because  * masking is always cheaper than passing parameters over the stack.      */
end_comment

begin_comment
comment|/* FIXME: Move to a global place */
end_comment

begin_define
DECL|macro|HAS_ALPHA (bytes)
define|#
directive|define
name|HAS_ALPHA
parameter_list|(
name|bytes
parameter_list|)
value|(~bytes& 1)
end_define

begin_decl_stmt
DECL|variable|add_lut
specifier|static
name|guchar
name|add_lut
index|[
literal|511
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|random_table
specifier|static
name|gint32
name|random_table
index|[
name|RANDOM_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|burn_lut
specifier|static
name|guchar
name|burn_lut
index|[
literal|256
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  * Pixel format type conversion  *  * XXX This implementation will not work for>8 bit colours.  * XXX This implementation is totally wrong.  */
end_comment

begin_comment
comment|/**  * gimp_composite_convert_any_any_any_generic:  * @ctx:  *  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_convert_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_convert_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|D
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|unsigned
name|char
modifier|*
name|A
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|int
name|bpp_A
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|int
name|bpp_D
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|n_pixels
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bpp_A
condition|;
name|j
operator|++
control|)
block|{
name|D
index|[
name|j
index|]
operator|=
name|A
index|[
name|j
index|]
expr_stmt|;
block|}
name|D
index|[
name|j
index|]
operator|=
name|GIMP_COMPOSITE_ALPHA_OPAQUE
expr_stmt|;
name|A
operator|+=
name|bpp_A
expr_stmt|;
name|D
operator|+=
name|bpp_D
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_color_any_any_any_generic:  * @dest:  * @color:  * @w:  * @bytes:  *  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_color_any_any_any_generic (guchar * dest,const guchar * color,guint w,guint bytes)
name|gimp_composite_color_any_any_any_generic
parameter_list|(
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|color
parameter_list|,
name|guint
name|w
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
comment|/* dest % bytes and color % bytes must be 0 or we will crash      when bytes = 2 or 4.      Is this safe to assume?  Lets find out.      This is 4-7X as fast as the simple version.    */
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|guchar
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
else|#
directive|else
name|guchar
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|guint32
modifier|*
name|longd
decl_stmt|,
name|longc
decl_stmt|;
name|guint16
modifier|*
name|shortd
decl_stmt|,
name|shortc
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
name|memset
argument_list|(
name|dest
argument_list|,
operator|*
name|color
argument_list|,
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
operator|+=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|shortc
operator|=
operator|(
operator|(
name|guint16
operator|*
operator|)
name|color
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|shortd
operator|=
operator|(
name|guint16
operator|*
operator|)
name|dest
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
operator|*
name|shortd
operator|=
name|shortc
expr_stmt|;
name|shortd
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sparc || __sparc__ */
break|break;
case|case
literal|3
case|:
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
name|c2
operator|=
name|color
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|c2
expr_stmt|;
name|dest
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
name|c2
operator|=
name|color
index|[
literal|2
index|]
expr_stmt|;
name|c3
operator|=
name|color
index|[
literal|3
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|c2
expr_stmt|;
name|dest
index|[
literal|3
index|]
operator|=
name|c3
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
else|#
directive|else
name|longc
operator|=
operator|(
operator|(
name|guint32
operator|*
operator|)
name|color
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|longd
operator|=
operator|(
name|guint32
operator|*
operator|)
name|dest
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
operator|*
name|longd
operator|=
name|longc
expr_stmt|;
name|longd
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sparc || __sparc__ */
break|break;
default|default:
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_blend_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a blend operation between sources ctx->A and ctx->B, using  * the generalised algorithm: D = A * (255 -&beta;) + B *&beta;  *  * The result is left in ctx->D  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_blend_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_blend_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guchar
name|blend
init|=
name|ctx
operator|->
name|blend
operator|.
name|blend
decl_stmt|;
name|guint
name|bytes
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|w
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|b
decl_stmt|;
specifier|const
name|guchar
name|blend2
init|=
operator|(
literal|255
operator|-
name|blend
operator|)
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|src1
index|[
name|b
index|]
operator|*
name|blend2
operator|+
name|src2
index|[
name|b
index|]
operator|*
name|blend
operator|)
operator|/
literal|255
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void gimp_composite_shade_generic (const guchar *src, guchar *dest, const guchar *col, guchar blend, guint w, guint bytes, guint has_alpha) {   const guchar blend2 = (255 - blend);   const guint alpha = (has_alpha) ? bytes - 1 : bytes;   guint b;    while (w--)     {       for (b = 0; b< alpha; b++)         dest[b] = (src[b] * blend2 + col[b] * blend) / 255;        if (has_alpha)         dest[alpha] = src[alpha];
comment|/* alpha channel */
end_comment

begin_endif
unit|src += bytes;       dest += bytes;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * gimp_composite_darken_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a darken operation between sources ctx->A and ctx->B, using  * the generalised algorithm:  * D_r = min(A_r, B_r);  * D_g = min(A_g, B_g);  * D_b = min(A_b, B_b);  * D_a = min(A_a, B_a);  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_darken_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_darken_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|s1
decl_stmt|,
name|s2
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|s1
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|s2
operator|=
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|s1
operator|<
name|s2
operator|)
condition|?
name|s1
else|:
name|s2
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_lighten_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a lighten operation between sources ctx->A and ctx->B, using the  * generalised algorithm:  * D_r = max(A_r, B_r);  * D_g = max(A_g, B_g);  * D_b = max(A_b, B_b);  * D_a = min(A_a, B_a);  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_lighten_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_lighten_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|s1
decl_stmt|,
name|s2
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|s1
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|s2
operator|=
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|s1
operator|<
name|s2
operator|)
condition|?
name|s2
else|:
name|s1
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_hue_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a conversion to hue only of the source ctx->A using  * the hue of ctx->B.  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_hue_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_hue_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|gint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|gint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|bytes1
operator|>
literal|2
condition|)
block|{
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
comment|/*  Composition should have no effect if saturation is zero.            *  otherwise, black would be painted red (see bug #123296).            */
if|if
condition|(
name|g2
condition|)
name|r1
operator|=
name|r2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_saturation_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a conversion to saturation only of the source ctx->A using  * the saturation level of ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_saturation_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_saturation_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|gint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|gint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|bytes1
operator|>
literal|2
condition|)
block|{
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
name|g1
operator|=
name|g2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_value_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a conversion to value only of the source ctx->A using  * the value of ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_value_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_value_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|gint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|gint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|bytes1
operator|>
literal|2
condition|)
block|{
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
name|b1
operator|=
name|b2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_color_only_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a conversion to of the source ctx->A using  * the hue and saturation values of ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_color_only_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_color_only_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|gint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|gint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|bytes1
operator|>
literal|2
condition|)
block|{
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsl_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsl_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
comment|/*  transfer hue and saturation to the source pixel  */
name|r1
operator|=
name|r2
expr_stmt|;
name|g1
operator|=
name|g2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsl_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_behind_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform a behind operation to between the pixel sources ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_behind_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_behind_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
condition|?
name|BEHIND_INTEN
else|:
name|NO_COMBINATION
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_multiply_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] multiply operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_multiply_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_multiply_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_divide_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] divide operation between the pixel sources ctx->A  * and ctx->B.  ctx->A is the numerator, ctx->B the denominator.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_divide_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_divide_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|result
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|result
operator|=
operator|(
operator|(
name|src1
index|[
name|b
index|]
operator|*
literal|256
operator|)
operator|/
operator|(
literal|1
operator|+
name|src2
index|[
name|b
index|]
operator|)
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|MIN
argument_list|(
name|result
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_screen_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] screen operation between the pixel sources  * ctx->A and ctx->B, using the generalised algorithm:  *  * D = 255 - (255 - A) * (255 - B)  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_screen_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_screen_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
literal|255
operator|-
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
operator|(
literal|255
operator|-
name|src2
index|[
name|b
index|]
operator|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_overlay_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] overlay operation between the pixel sources  * ctx->A and ctx->B, using the generalised algorithm:  *  * D =  A * (A + (2 * B) * (255 - A))  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_overlay_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_overlay_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|,
name|tmpM
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
operator|+
name|INT_MULT
argument_list|(
literal|2
operator|*
name|src2
index|[
name|b
index|]
argument_list|,
literal|255
operator|-
name|src1
index|[
name|b
index|]
argument_list|,
name|tmpM
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_dodge_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] dodge operation between the pixel sources  * ctx->A and ctx->B, using the generalised algorithm:  *  * D = saturation of 255 or (A * 256) / (256 - B)  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_dodge_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_dodge_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|tmp
operator|=
name|src1
index|[
name|b
index|]
operator|<<
literal|8
expr_stmt|;
name|tmp
operator|/=
literal|256
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|MIN
argument_list|(
name|tmp
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_burn_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] dodge operation between the pixel sources  * ctx->A and ctx->B, using the generalised algorithm:  *  * D = saturation of 255 or depletion of 0, of ((255 - A) * 256) / (B + 1)  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_burn_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_burn_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|burn_lut
index|[
name|src1
index|[
name|b
index|]
index|]
index|[
name|src2
index|[
name|b
index|]
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_hardlight_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] hardlight operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_hardlight_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_hardlight_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|src2
index|[
name|b
index|]
operator|>
literal|128
condition|)
block|{
name|tmp
operator|=
operator|(
operator|(
name|gint
operator|)
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
operator|*
operator|(
operator|(
name|gint
operator|)
literal|255
operator|-
operator|(
operator|(
name|src2
index|[
name|b
index|]
operator|-
literal|128
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|MIN
argument_list|(
literal|255
operator|-
operator|(
name|tmp
operator|>>
literal|8
operator|)
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|(
name|gint
operator|)
name|src1
index|[
name|b
index|]
operator|*
operator|(
operator|(
name|gint
operator|)
name|src2
index|[
name|b
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|MIN
argument_list|(
name|tmp
operator|>>
literal|8
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_softlight_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] softlight operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_softlight_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_softlight_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmpS
decl_stmt|,
name|tmpM
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
comment|/* Mix multiply and screen */
name|tmpM
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmpM
argument_list|)
expr_stmt|;
name|tmpS
operator|=
literal|255
operator|-
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
operator|(
literal|255
operator|-
name|src2
index|[
name|b
index|]
operator|)
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
name|tmpM
argument_list|,
name|tmp2
argument_list|)
operator|+
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|tmpS
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_grain_extract_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] grain-extract operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_grain_extract_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_grain_extract_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
operator|+
literal|128
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|diff
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_grain_merge_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] grain-merge operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_grain_merge_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_grain_merge_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|sum
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
comment|/* Add, re-center and clip. */
name|sum
operator|=
name|src1
index|[
name|b
index|]
operator|+
name|src2
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_addition_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] addition operation of the pixel sources ctx->A  * and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_addition_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_addition_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|A
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|B
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|D
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|D
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|A
index|[
name|alpha
index|]
argument_list|,
name|B
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|D
index|[
name|alpha
index|]
operator|=
name|B
index|[
name|alpha
index|]
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_subtract_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] subtract operation of the pixel source  * ctx-B from ctx->A.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_subtract_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_subtract_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|diff
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_difference_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] difference operation between the pixel sources  * ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_difference_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_difference_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|diff
operator|<
literal|0
operator|)
condition|?
operator|-
name|diff
else|:
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_dissolve_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] alpha dissolve operation between the pixel  * sources ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_dissolve_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_dissolve_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|GRand
modifier|*
name|gr
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|combined_opacity
decl_stmt|;
name|gint
name|db
decl_stmt|;
name|gint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|gint
name|opacity
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|opacity
decl_stmt|;
name|gint
name|sb
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
name|gint
name|x
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|x
decl_stmt|;
name|gint
name|y
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|y
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|mask
init|=
name|ctx
operator|->
name|M
decl_stmt|;
name|gint32
name|rand_val
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guchar
modifier|*
name|src
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guint
name|has_alpha
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
comment|/*    * if destination does not have an alpha channel, add one to it.    */
if|if
condition|(
operator|!
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
condition|)
block|{
name|ctx
operator|->
name|pixelformat_D
operator|=
name|gimp_composite_pixel_alpha
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
expr_stmt|;
block|}
name|db
operator|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
expr_stmt|;
name|gr
operator|=
name|g_rand_new_with_seed
argument_list|(
name|random_table
index|[
name|y
operator|%
name|RANDOM_TABLE_SIZE
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|x
condition|;
name|b
operator|++
control|)
name|g_rand_int
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|db
operator|-
literal|1
expr_stmt|;
comment|/*    * XXX NB: The mask is assumed to be a linear array of bytes, no    * accounting for the mask being of a particular pixel format.    */
while|while
condition|(
name|length
operator|--
condition|)
block|{
comment|/*  preserve the intensity values  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src
index|[
name|b
index|]
expr_stmt|;
comment|/*  dissolve if random value is>= opacity  */
name|rand_val
operator|=
name|g_rand_int_range
argument_list|(
name|gr
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|has_alpha
condition|)
name|combined_opacity
operator|=
name|opacity
operator|*
name|src
index|[
name|alpha
index|]
operator|*
operator|(
operator|*
name|mask
operator|)
operator|/
operator|(
literal|255
operator|*
literal|255
operator|)
expr_stmt|;
else|else
name|combined_opacity
operator|=
name|opacity
operator|*
operator|(
operator|*
name|mask
operator|)
operator|/
literal|255
expr_stmt|;
name|mask
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|has_alpha
condition|)
name|combined_opacity
operator|=
name|opacity
operator|*
name|src
index|[
name|alpha
index|]
operator|/
literal|255
expr_stmt|;
else|else
name|combined_opacity
operator|=
name|opacity
expr_stmt|;
block|}
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|rand_val
operator|>=
name|combined_opacity
operator|)
condition|?
name|TRANSPARENT_OPACITY
else|:
name|OPAQUE_OPACITY
expr_stmt|;
name|dest
operator|+=
name|db
expr_stmt|;
name|src
operator|+=
name|sb
expr_stmt|;
block|}
name|g_rand_free
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
condition|?
name|COMBINE_INTEN_A_INTEN_A
else|:
name|COMBINE_INTEN_INTEN_A
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_replace_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] replace operation of the pixel  * source ctx->A with the ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_replace_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_replace_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
name|REPLACE_INTEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_swap_any_any_any_generic:  * @ctx: The compositing context.  *  * Swap the contents of ctx->A and ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_swap_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_swap_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|guchar
modifier|*
name|src
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
operator|*
name|bytes1
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|guchar
name|tmp
init|=
operator|*
name|dest
decl_stmt|;
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
name|tmp
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|dest
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_normal_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] over operation of the pixel  * source ctx->B on ctx->A.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_normal_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_normal_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_erase_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] "erase" operation of the pixel  * source ctx->A using the alpha information in ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_anti_erase_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] "anti-erase" operation of the pixel  * source ctx->A using the alpha information in ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_anti_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_anti_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|ANTI_ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_color_erase_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] "color-erase" operation of the pixel  * source ctx->A using the alpha information in ctx->B.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_color_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_color_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|COLOR_ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_composite_scale_any_any_any_generic:  * @ctx: The compositing context.  *  * Perform an RGB[A] scale operation of the pixel source ctx->A using  * the scale coefficient on the compositing context, @ctx.  *  **/
end_comment

begin_function
name|void
DECL|function|gimp_composite_scale_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_scale_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_V8
operator|)
condition|?
literal|1
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_VA8
operator|)
condition|?
literal|2
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_RGB8
operator|)
condition|?
literal|3
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_RGBA8
operator|)
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
name|length
operator|=
name|ctx
operator|->
name|n_pixels
operator|*
name|bytes1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|(
name|guchar
operator|)
name|INT_MULT
argument_list|(
operator|*
name|src1
argument_list|,
name|ctx
operator|->
name|scale
operator|.
name|scale
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|src1
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_composite_generic_init:  *  * Initialise the generic set of compositing functions.  *  * Returns: boolean indicating that the initialisation was successful.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_composite_generic_init (void)
name|gimp_composite_generic_init
parameter_list|(
name|void
parameter_list|)
block|{
name|GRand
modifier|*
name|gr
decl_stmt|;
name|guint
name|i
decl_stmt|;
name|gint
name|a
decl_stmt|,
name|b
decl_stmt|;
DECL|macro|RANDOM_SEED
define|#
directive|define
name|RANDOM_SEED
value|314159265
comment|/*  generate a table of random seeds  */
name|gr
operator|=
name|g_rand_new_with_seed
argument_list|(
name|RANDOM_SEED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RANDOM_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|random_table
index|[
name|i
index|]
operator|=
name|g_rand_int
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|g_rand_free
argument_list|(
name|gr
argument_list|)
expr_stmt|;
comment|/*  generate a table for burn compositing */
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
literal|256
condition|;
name|a
operator|++
control|)
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|256
condition|;
name|b
operator|++
control|)
block|{
comment|/* FIXME: Is the burn effect supposed to be dependant on the sign          * of this temporary variable?          */
name|gint
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
literal|255
operator|-
name|a
operator|)
operator|<<
literal|8
expr_stmt|;
name|tmp
operator|/=
name|b
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
operator|(
literal|255
operator|-
name|tmp
operator|)
expr_stmt|;
name|burn_lut
index|[
name|a
index|]
index|[
name|b
index|]
operator|=
name|CLAMP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
comment|/*  generate a table for saturate add */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|256
init|;
name|i
operator|<=
literal|510
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

