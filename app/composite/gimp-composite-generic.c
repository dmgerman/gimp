begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * -*- mode: c tab-width: 2; c-basic-indent: 2; indent-tabs-mode: nil -*-  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  */
end_comment

begin_comment
comment|/*  * This file is supposed to contain the generic (read: C) implementation  * of the pixelfiddeling paint-functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"base/base-types.h"
end_include

begin_include
include|#
directive|include
file|"gimp-composite.h"
end_include

begin_define
DECL|macro|OPAQUE_OPACITY
define|#
directive|define
name|OPAQUE_OPACITY
value|255
end_define

begin_define
DECL|macro|TRANSPARENT_OPACITY
define|#
directive|define
name|TRANSPARENT_OPACITY
value|0
end_define

begin_define
DECL|macro|INT_MULT (a,b,t)
define|#
directive|define
name|INT_MULT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) + 0x80, ((((t)>> 8) + (t))>> 8))
end_define

begin_comment
comment|/* This version of INT_MULT3 is very fast, but suffers from some    slight roundoff errors.  It returns the correct result 99.987    percent of the time */
end_comment

begin_define
DECL|macro|INT_MULT3 (a,b,c,t)
define|#
directive|define
name|INT_MULT3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
value|((t) = (a) * (b) * (c)+ 0x7F5B, ((((t)>> 7) + (t))>> 16))
end_define

begin_comment
comment|/*   This version of INT_MULT3 always gives the correct result, but runs at   approximatly one third the speed. */
end_comment

begin_comment
comment|/*  #define INT_MULT3(a,b,c,t) (((a) * (b) * (c)+ 32512) / 65025.0)  */
end_comment

begin_define
DECL|macro|INT_BLEND (a,b,alpha,tmp)
define|#
directive|define
name|INT_BLEND
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|alpha
parameter_list|,
name|tmp
parameter_list|)
value|(INT_MULT((a)-(b), alpha, tmp) + (b))
end_define

begin_define
DECL|macro|RANDOM_TABLE_SIZE
define|#
directive|define
name|RANDOM_TABLE_SIZE
value|4096
end_define

begin_comment
comment|/* A drawable has an alphachannel if contains either 4 or 2 bytes data  * aka GRAYA and RGBA and thus the macro below works. This will have  * to change if we support bigger formats. We'll do it so for now because  * masking is always cheaper than passing parameters over the stack.      */
end_comment

begin_comment
comment|/* FIXME: Move to a global place */
end_comment

begin_define
DECL|macro|HAS_ALPHA (bytes)
define|#
directive|define
name|HAS_ALPHA
parameter_list|(
name|bytes
parameter_list|)
value|(~bytes& 1)
end_define

begin_decl_stmt
DECL|variable|add_lut
specifier|static
name|guchar
name|add_lut
index|[
literal|511
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|random_table
specifier|static
name|gint32
name|random_table
index|[
name|RANDOM_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  * Pixel format type conversion  *  * XXX This implementation will not work for>8 bit colours.  * XXX This implementation is totally wrong.  */
end_comment

begin_function
name|void
DECL|function|gimp_composite_convert_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_convert_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|D
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|char
modifier|*
name|A
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|int
name|bpp_A
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|int
name|bpp_D
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|n_pixels
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bpp_A
condition|;
name|j
operator|++
control|)
block|{
name|D
index|[
name|j
index|]
operator|=
name|A
index|[
name|j
index|]
expr_stmt|;
block|}
name|D
index|[
name|j
index|]
operator|=
name|GIMP_COMPOSITE_ALPHA_OPAQUE
expr_stmt|;
name|A
operator|+=
name|bpp_A
expr_stmt|;
name|D
operator|+=
name|bpp_D
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_color_any_any_any_generic (guchar * dest,const guchar * color,guint w,guint bytes)
name|gimp_composite_color_any_any_any_generic
parameter_list|(
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|color
parameter_list|,
name|guint
name|w
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
comment|/* dest % bytes and color % bytes must be 0 or we will crash       when bytes = 2 or 4.      Is this safe to assume?  Lets find out.      This is 4-7X as fast as the simple version.    */
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|guchar
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
else|#
directive|else
name|guchar
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|guint32
modifier|*
name|longd
decl_stmt|,
name|longc
decl_stmt|;
name|guint16
modifier|*
name|shortd
decl_stmt|,
name|shortc
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
name|memset
argument_list|(
name|dest
argument_list|,
operator|*
name|color
argument_list|,
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
operator|+=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|shortc
operator|=
operator|(
operator|(
name|guint16
operator|*
operator|)
name|color
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|shortd
operator|=
operator|(
name|guint16
operator|*
operator|)
name|dest
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
operator|*
name|shortd
operator|=
name|shortc
expr_stmt|;
name|shortd
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sparc || __sparc__ */
break|break;
case|case
literal|3
case|:
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
name|c2
operator|=
name|color
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|c2
expr_stmt|;
name|dest
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|c0
operator|=
name|color
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|color
index|[
literal|1
index|]
expr_stmt|;
name|c2
operator|=
name|color
index|[
literal|2
index|]
expr_stmt|;
name|c3
operator|=
name|color
index|[
literal|3
index|]
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|c0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|c2
expr_stmt|;
name|dest
index|[
literal|3
index|]
operator|=
name|c3
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
else|#
directive|else
name|longc
operator|=
operator|(
operator|(
name|guint32
operator|*
operator|)
name|color
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|longd
operator|=
operator|(
name|guint32
operator|*
operator|)
name|dest
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
operator|*
name|longd
operator|=
name|longc
expr_stmt|;
name|longd
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sparc || __sparc__ */
break|break;
default|default:
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|color
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_blend_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_blend_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guchar
name|blend
init|=
name|ctx
operator|->
name|blend
operator|.
name|blend
decl_stmt|;
name|guint
name|bytes
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|w
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|b
decl_stmt|;
specifier|const
name|guchar
name|blend2
init|=
operator|(
literal|255
operator|-
name|blend
operator|)
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|src1
index|[
name|b
index|]
operator|*
name|blend2
operator|+
name|src2
index|[
name|b
index|]
operator|*
name|blend
operator|)
operator|/
literal|255
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void gimp_composite_shade_generic (const guchar *src, guchar *dest, const guchar *col, guchar blend, guint w, guint bytes, guint has_alpha) {   const guchar blend2 = (255 - blend);   const guint alpha = (has_alpha) ? bytes - 1 : bytes;   guint b;    while (w--)     {       for (b = 0; b< alpha; b++)         dest[b] = (src[b] * blend2 + col[b] * blend) / 255;        if (has_alpha)         dest[alpha] = src[alpha];
comment|/* alpha channel */
end_comment

begin_endif
unit|src += bytes;       dest += bytes;     } }
endif|#
directive|endif
end_endif

begin_function
name|void
DECL|function|gimp_composite_darken_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_darken_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|s1
decl_stmt|,
name|s2
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|s1
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|s2
operator|=
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|s1
operator|<
name|s2
operator|)
condition|?
name|s1
else|:
name|s2
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_lighten_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_lighten_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|s1
decl_stmt|,
name|s2
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|s1
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|s2
operator|=
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|s1
operator|<
name|s2
operator|)
condition|?
name|s2
else|:
name|s1
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_hue_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_hue_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|guint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|guint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
name|r1
operator|=
name|r2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_saturation_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_saturation_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|guint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|guint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
name|g1
operator|=
name|g2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_value_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_value_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|guint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|guint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hsv_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
name|b1
operator|=
name|b2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hsv_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_color_only_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_color_only_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
name|guint
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|guint
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|;
comment|/*  assumes inputs are only 4 byte RGBA pixels  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|r1
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|g1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|r2
operator|=
name|src2
index|[
literal|0
index|]
expr_stmt|;
name|g2
operator|=
name|src2
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|src2
index|[
literal|2
index|]
expr_stmt|;
name|gimp_rgb_to_hls_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|gimp_rgb_to_hls_int
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|g2
argument_list|,
operator|&
name|b2
argument_list|)
expr_stmt|;
comment|/*  transfer hue and saturation to the source pixel  */
name|r1
operator|=
name|r2
expr_stmt|;
name|b1
operator|=
name|b2
expr_stmt|;
comment|/*  set the destination  */
name|gimp_hls_to_rgb_int
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|g1
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|r1
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|g1
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|b1
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
literal|3
index|]
argument_list|,
name|src2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
literal|3
index|]
operator|=
name|src2
index|[
literal|3
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_multiply_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_multiply_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_divide_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_divide_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|result
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|result
operator|=
operator|(
operator|(
name|src1
index|[
name|b
index|]
operator|*
literal|256
operator|)
operator|/
operator|(
literal|1
operator|+
name|src2
index|[
name|b
index|]
operator|)
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|MIN
argument_list|(
name|result
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_screen_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_screen_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
literal|255
operator|-
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
operator|(
literal|255
operator|-
name|src2
index|[
name|b
index|]
operator|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_overlay_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_overlay_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
operator|+
name|INT_MULT
argument_list|(
literal|2
operator|*
name|src2
index|[
name|b
index|]
argument_list|,
literal|255
operator|-
name|src1
index|[
name|b
index|]
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_dodge_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_dodge_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|tmp
operator|=
name|src1
index|[
name|b
index|]
operator|<<
literal|8
expr_stmt|;
name|tmp
operator|/=
literal|256
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_burn_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_burn_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
comment|/* FIXME: Is the burn effect supposed to be dependant on the sign of this    * temporary variable? */
name|gint
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|tmp
operator|=
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|tmp
operator|/=
name|src2
index|[
name|b
index|]
operator|+
literal|1
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
literal|255
operator|-
name|tmp
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_hardlight_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_hardlight_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmp
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|src2
index|[
name|b
index|]
operator|>
literal|128
condition|)
block|{
name|tmp
operator|=
operator|(
operator|(
name|gint
operator|)
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
operator|*
operator|(
operator|(
name|gint
operator|)
literal|255
operator|-
operator|(
operator|(
name|src2
index|[
name|b
index|]
operator|-
literal|128
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
literal|255
operator|-
operator|(
name|tmp
operator|>>
literal|8
operator|)
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|(
name|gint
operator|)
name|src1
index|[
name|b
index|]
operator|*
operator|(
operator|(
name|gint
operator|)
name|src2
index|[
name|b
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|tmp
operator|>>
literal|8
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_softlight_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_softlight_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|,
name|tmpS
decl_stmt|,
name|tmpM
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
comment|/* Mix multiply and screen */
name|tmpM
operator|=
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|src2
index|[
name|b
index|]
argument_list|,
name|tmpM
argument_list|)
expr_stmt|;
name|tmpS
operator|=
literal|255
operator|-
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
operator|(
literal|255
operator|-
name|src2
index|[
name|b
index|]
operator|)
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|b
index|]
operator|)
argument_list|,
name|tmpM
argument_list|,
name|tmp2
argument_list|)
operator|+
name|INT_MULT
argument_list|(
name|src1
index|[
name|b
index|]
argument_list|,
name|tmpS
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_grain_extract_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_grain_extract_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
operator|+
literal|128
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|diff
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_grain_merge_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_grain_merge_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|sum
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
comment|/* Add, re-center and clip. */
name|sum
operator|=
name|src1
index|[
name|b
index|]
operator|+
name|src2
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_addition_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_addition_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|A
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|B
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|D
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|D
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|A
index|[
name|alpha
index|]
argument_list|,
name|B
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|D
index|[
name|alpha
index|]
operator|=
name|B
index|[
name|alpha
index|]
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|D
index|[
name|b
index|]
operator|=
name|add_lut
index|[
name|A
index|[
name|b
index|]
operator|+
name|B
index|[
name|b
index|]
index|]
expr_stmt|;
name|A
operator|+=
name|bytes1
expr_stmt|;
name|B
operator|+=
name|bytes2
expr_stmt|;
name|D
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_subtract_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_subtract_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|diff
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_difference_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_difference_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|guint
name|bytes2
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha1
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
operator|(
name|has_alpha1
operator|||
name|has_alpha2
operator|)
condition|?
name|MAX
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
operator|-
literal|1
else|:
name|bytes1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|diff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|src1
index|[
name|b
index|]
operator|-
name|src2
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|diff
operator|<
literal|0
operator|)
condition|?
operator|-
name|diff
else|:
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|has_alpha1
operator|&&
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|MIN
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_alpha2
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_dissolve_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_dissolve_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|GRand
modifier|*
name|gr
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|combined_opacity
decl_stmt|;
name|gint
name|db
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
name|gint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|gint
name|opacity
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|opacity
decl_stmt|;
name|gint
name|sb
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
name|gint
name|x
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|x
decl_stmt|;
name|gint
name|y
init|=
name|ctx
operator|->
name|dissolve
operator|.
name|y
decl_stmt|;
name|guchar
modifier|*
name|mask
init|=
name|ctx
operator|->
name|M
decl_stmt|;
name|gint32
name|rand_val
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guchar
modifier|*
name|src
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guint
name|has_alpha
init|=
name|gimp_composite_pixel_alpha
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
decl_stmt|;
comment|/*    * if destination does not have an alpha channel, add one to it.    */
if|if
condition|(
operator|!
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
condition|)
block|{
name|ctx
operator|->
name|pixelformat_D
operator|=
name|gimp_composite_pixel_alpha
index|[
name|ctx
operator|->
name|pixelformat_D
index|]
expr_stmt|;
block|}
name|gr
operator|=
name|g_rand_new_with_seed
argument_list|(
name|random_table
index|[
name|y
operator|%
name|RANDOM_TABLE_SIZE
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|x
condition|;
name|b
operator|++
control|)
name|g_rand_int
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|db
operator|-
literal|1
expr_stmt|;
comment|/*    * XXX NB: The mask is assumed to be a linear array of bytes, no    * accounting for the mask being of a particular pixel format.    */
while|while
condition|(
name|length
operator|--
condition|)
block|{
comment|/*  preserve the intensity values  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src
index|[
name|b
index|]
expr_stmt|;
comment|/*  dissolve if random value is>= opacity  */
name|rand_val
operator|=
name|g_rand_int_range
argument_list|(
name|gr
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|has_alpha
condition|)
name|combined_opacity
operator|=
name|opacity
operator|*
name|src
index|[
name|alpha
index|]
operator|*
operator|(
operator|*
name|mask
operator|)
operator|/
operator|(
literal|255
operator|*
literal|255
operator|)
expr_stmt|;
else|else
name|combined_opacity
operator|=
name|opacity
operator|*
operator|(
operator|*
name|mask
operator|)
operator|/
literal|255
expr_stmt|;
name|mask
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|has_alpha
condition|)
name|combined_opacity
operator|=
name|opacity
operator|*
name|src
index|[
name|alpha
index|]
operator|/
literal|255
expr_stmt|;
else|else
name|combined_opacity
operator|=
name|opacity
expr_stmt|;
block|}
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|rand_val
operator|>=
name|combined_opacity
operator|)
condition|?
literal|0
else|:
name|OPAQUE_OPACITY
expr_stmt|;
name|dest
operator|+=
name|db
expr_stmt|;
name|src
operator|+=
name|sb
expr_stmt|;
block|}
name|g_rand_free
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
condition|?
name|COMBINE_INTEN_A_INTEN_A
else|:
name|COMBINE_INTEN_INTEN_A
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_replace_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_replace_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
name|REPLACE_INTEN
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_swap_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_swap_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|guint
name|length
decl_stmt|;
name|guchar
modifier|*
name|src
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|guint
name|bytes1
init|=
name|gimp_composite_pixel_bpp
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
decl_stmt|;
name|length
operator|=
name|ctx
operator|->
name|n_pixels
operator|*
name|bytes1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|src
operator|=
operator|*
name|src
operator|^
operator|*
name|dest
expr_stmt|;
operator|*
name|dest
operator|=
operator|*
name|dest
operator|^
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
operator|*
name|src
operator|^
operator|*
name|dest
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|dest
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_normal_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_normal_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_anti_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_anti_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|ANTI_ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_color_erase_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_color_erase_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|D
operator|=
name|ctx
operator|->
name|B
expr_stmt|;
name|ctx
operator|->
name|combine
operator|=
operator|(
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_A
index|]
operator|&&
name|gimp_composite_pixel_alphap
index|[
name|ctx
operator|->
name|pixelformat_B
index|]
operator|)
condition|?
name|COLOR_ERASE_INTEN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_scale_any_any_any_generic (GimpCompositeContext * ctx)
name|gimp_composite_scale_any_any_any_generic
parameter_list|(
name|GimpCompositeContext
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|ctx
operator|->
name|D
decl_stmt|;
name|guint
name|length
init|=
name|ctx
operator|->
name|n_pixels
decl_stmt|;
name|guint
name|bytes1
init|=
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_V8
operator|)
condition|?
literal|1
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_VA8
operator|)
condition|?
literal|2
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_RGB8
operator|)
condition|?
literal|3
else|:
operator|(
name|ctx
operator|->
name|pixelformat_A
operator|==
name|GIMP_PIXELFORMAT_RGBA8
operator|)
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
name|length
operator|=
name|ctx
operator|->
name|n_pixels
operator|*
name|bytes1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|(
name|guchar
operator|)
name|INT_MULT
argument_list|(
operator|*
name|src1
argument_list|,
name|ctx
operator|->
name|scale
operator|.
name|scale
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|src1
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_composite_generic_init (void)
name|gimp_composite_generic_init
parameter_list|(
name|void
parameter_list|)
block|{
name|GRand
modifier|*
name|gr
decl_stmt|;
name|guint
name|i
decl_stmt|;
DECL|macro|RANDOM_SEED
define|#
directive|define
name|RANDOM_SEED
value|314159265
comment|/*  generate a table of random seeds  */
name|gr
operator|=
name|g_rand_new_with_seed
argument_list|(
name|RANDOM_SEED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RANDOM_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|random_table
index|[
name|i
index|]
operator|=
name|g_rand_int
argument_list|(
name|gr
argument_list|)
expr_stmt|;
name|g_rand_free
argument_list|(
name|gr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|256
init|;
name|i
operator|<=
literal|510
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
end_function

end_unit

