begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This tool is based on a paper from SIGGRAPH '95  * thanks to Professor D. Forsyth for prompting us to implement this tool  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"channel_pvt.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"iscissors.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"temp_buf.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|M_PI
end_ifndef

begin_define
DECL|macro|M_PI
define|#
directive|define
name|M_PI
value|3.14159265358979323846
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* M_PI */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|M_PI_4
end_ifndef

begin_define
DECL|macro|M_PI_4
define|#
directive|define
name|M_PI_4
value|0.78539816339744830962
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* M_PI_4 */
end_comment

begin_comment
comment|/*  local structures  */
end_comment

begin_typedef
DECL|typedef|IScissorsOptions
typedef|typedef
name|struct
name|_IScissorsOptions
name|IScissorsOptions
typedef|;
end_typedef

begin_struct
DECL|struct|_IScissorsOptions
struct|struct
name|_IScissorsOptions
block|{
DECL|member|antialias
name|int
name|antialias
decl_stmt|;
DECL|member|feather
name|int
name|feather
decl_stmt|;
DECL|member|feather_radius
name|double
name|feather_radius
decl_stmt|;
DECL|member|resolution
name|double
name|resolution
decl_stmt|;
DECL|member|threshold
name|double
name|threshold
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|Kink
typedef|typedef
name|struct
name|_kink
name|Kink
typedef|;
end_typedef

begin_struct
DECL|struct|_kink
struct|struct
name|_kink
block|{
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  coordinates  */
DECL|member|is_a_kink
name|int
name|is_a_kink
decl_stmt|;
comment|/*  is this a kink?  */
DECL|member|normal
name|double
name|normal
index|[
literal|2
index|]
decl_stmt|;
comment|/*  normal vector to kink  */
DECL|member|kinkiness
name|double
name|kinkiness
decl_stmt|;
comment|/*  kinkiness measure  */
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|Point
typedef|typedef
name|struct
name|_point
name|Point
typedef|;
end_typedef

begin_struct
DECL|struct|_point
struct|struct
name|_point
block|{
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  coordinates  */
DECL|member|dir
name|int
name|dir
decl_stmt|;
comment|/*  direction  */
DECL|member|kink
name|int
name|kink
decl_stmt|;
comment|/*  is it a kink?  */
DECL|member|stable
name|int
name|stable
decl_stmt|;
comment|/*  is the point in a stable locale?  */
DECL|member|dx
DECL|member|dy
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
comment|/*  moving coordinates  */
DECL|member|normal
name|double
name|normal
index|[
literal|2
index|]
decl_stmt|;
comment|/*  normal vector to kink  */
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|Iscissors
typedef|typedef
name|struct
name|_iscissors
name|Iscissors
typedef|;
end_typedef

begin_struct
DECL|struct|_iscissors
struct|struct
name|_iscissors
block|{
DECL|member|core
name|DrawCore
modifier|*
name|core
decl_stmt|;
comment|/*  Core select object               */
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  upper left hand coordinate       */
DECL|member|ix
DECL|member|iy
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
comment|/*  initial coordinates              */
DECL|member|nx
DECL|member|ny
name|int
name|nx
decl_stmt|,
name|ny
decl_stmt|;
comment|/*  new coordinates                  */
DECL|member|state
name|int
name|state
decl_stmt|;
comment|/*  state of iscissors               */
DECL|member|num_segs
name|int
name|num_segs
decl_stmt|;
comment|/*  number of points in the polygon  */
DECL|member|num_pts
name|int
name|num_pts
decl_stmt|;
comment|/*  number of kinks in list          */
DECL|member|num_kinks
name|int
name|num_kinks
decl_stmt|;
comment|/*  number of kinks in list          */
DECL|member|mask
name|Channel
modifier|*
name|mask
decl_stmt|;
comment|/*  selection mask                   */
DECL|member|kinks
name|Kink
modifier|*
name|kinks
decl_stmt|;
comment|/*  kinks in the object outline      */
DECL|member|edge_buf
name|TempBuf
modifier|*
name|edge_buf
decl_stmt|;
comment|/*  edge map buffer                  */
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|BezierMatrix
typedef|typedef
name|double
name|BezierMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_typedef
DECL|typedef|CRMatrix
typedef|typedef
name|double
name|CRMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_comment
comment|/**********************************************/
end_comment

begin_comment
comment|/*  Intelligent scissors selection apparatus  */
end_comment

begin_define
DECL|macro|IMAGE_COORDS
define|#
directive|define
name|IMAGE_COORDS
value|1
end_define

begin_define
DECL|macro|AA_IMAGE_COORDS
define|#
directive|define
name|AA_IMAGE_COORDS
value|2
end_define

begin_define
DECL|macro|SCREEN_COORDS
define|#
directive|define
name|SCREEN_COORDS
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE2
define|#
directive|define
name|SUPERSAMPLE2
value|9
end_define

begin_define
DECL|macro|FREE_SELECT_MODE
define|#
directive|define
name|FREE_SELECT_MODE
value|0
end_define

begin_define
DECL|macro|BOUNDARY_MODE
define|#
directive|define
name|BOUNDARY_MODE
value|1
end_define

begin_define
DECL|macro|POINT_WIDTH
define|#
directive|define
name|POINT_WIDTH
value|8
end_define

begin_define
DECL|macro|POINT_HALFWIDTH
define|#
directive|define
name|POINT_HALFWIDTH
value|4
end_define

begin_define
DECL|macro|DEFAULT_MAX_INC
define|#
directive|define
name|DEFAULT_MAX_INC
value|1024
end_define

begin_define
DECL|macro|EDGE_WIDTH
define|#
directive|define
name|EDGE_WIDTH
value|1
end_define

begin_define
DECL|macro|LOCALIZE_RADIUS
define|#
directive|define
name|LOCALIZE_RADIUS
value|24
end_define

begin_define
DECL|macro|BLOCK_WIDTH
define|#
directive|define
name|BLOCK_WIDTH
value|64
end_define

begin_define
DECL|macro|BLOCK_HEIGHT
define|#
directive|define
name|BLOCK_HEIGHT
value|64
end_define

begin_define
DECL|macro|CONV_WIDTH
define|#
directive|define
name|CONV_WIDTH
value|BLOCK_WIDTH
end_define

begin_define
DECL|macro|CONV_HEIGHT
define|#
directive|define
name|CONV_HEIGHT
value|BLOCK_HEIGHT
end_define

begin_define
DECL|macro|HORIZONTAL
define|#
directive|define
name|HORIZONTAL
value|0
end_define

begin_define
DECL|macro|VERTICAL
define|#
directive|define
name|VERTICAL
value|1
end_define

begin_define
DECL|macro|SUBDIVIDE
define|#
directive|define
name|SUBDIVIDE
value|1000
end_define

begin_define
DECL|macro|EDGE_STRENGTH
define|#
directive|define
name|EDGE_STRENGTH
value|255
end_define

begin_define
DECL|macro|EPSILON
define|#
directive|define
name|EPSILON
value|0.00001
end_define

begin_define
DECL|macro|NO
define|#
directive|define
name|NO
value|0
end_define

begin_define
DECL|macro|YES
define|#
directive|define
name|YES
value|1
end_define

begin_comment
comment|/*  functional defines  */
end_comment

begin_define
DECL|macro|SQR (x)
define|#
directive|define
name|SQR
parameter_list|(
name|x
parameter_list|)
value|((x) * (x))
end_define

begin_define
DECL|macro|BILINEAR (jk,j1k,jk1,j1k1,dx,dy)
define|#
directive|define
name|BILINEAR
parameter_list|(
name|jk
parameter_list|,
name|j1k
parameter_list|,
name|jk1
parameter_list|,
name|j1k1
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|((1-dy) * ((1-dx)*jk + dx*j1k) + \       dy  * ((1-dx)*jk1 + dx*j1k1))
end_define

begin_comment
comment|/*  static variables  */
end_comment

begin_decl_stmt
DECL|variable|last_tool
specifier|static
name|Tool
modifier|*
name|last_tool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The global array of XSegments for drawing the polygon...  */
end_comment

begin_decl_stmt
DECL|variable|segs
specifier|static
name|GdkSegment
modifier|*
name|segs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_segs
specifier|static
name|int
name|max_segs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pts
specifier|static
name|Point
modifier|*
name|pts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_pts
specifier|static
name|int
name|max_pts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  boundary resolution variables  */
end_comment

begin_decl_stmt
DECL|variable|resolution
specifier|static
name|int
name|resolution
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|resolution
comment|/* in pixels */
end_comment

begin_decl_stmt
DECL|variable|threshold
specifier|static
name|int
name|threshold
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|threshold
comment|/* in intensity */
end_comment

begin_decl_stmt
DECL|variable|elasticity
specifier|static
name|double
name|elasticity
init|=
literal|0.30
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|elasticity
comment|/* between 0.0 -> 1.0 */
end_comment

begin_decl_stmt
DECL|variable|kink_thres
specifier|static
name|double
name|kink_thres
init|=
literal|0.33
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|kink_thres
comment|/* between 0.0 -> 1.0 */
end_comment

begin_decl_stmt
DECL|variable|std_dev
specifier|static
name|double
name|std_dev
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|std_dev
comment|/* in pixels */
end_comment

begin_decl_stmt
DECL|variable|miss_thres
specifier|static
name|int
name|miss_thres
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|miss_thres
comment|/* in intensity */
end_comment

begin_comment
comment|/*  edge map blocks variables  */
end_comment

begin_decl_stmt
DECL|variable|edge_map_blocks
specifier|static
name|TempBuf
modifier|*
modifier|*
name|edge_map_blocks
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|horz_blocks
specifier|static
name|int
name|horz_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vert_blocks
specifier|static
name|int
name|vert_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  convolution and basis matrixes  */
end_comment

begin_decl_stmt
DECL|variable|conv1
specifier|static
name|unsigned
name|char
name|conv1
index|[
name|CONV_WIDTH
operator|*
name|CONV_HEIGHT
operator|*
name|MAX_CHANNELS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|conv2
specifier|static
name|unsigned
name|char
name|conv2
index|[
name|CONV_WIDTH
operator|*
name|CONV_HEIGHT
operator|*
name|MAX_CHANNELS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grad
specifier|static
name|unsigned
name|char
name|grad
index|[
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
operator|*
operator|(
name|CONV_HEIGHT
operator|+
literal|2
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|CR_basis
specifier|static
name|CRMatrix
name|CR_basis
init|=
block|{
block|{
operator|-
literal|0.5
block|,
literal|1.5
block|,
operator|-
literal|1.5
block|,
literal|0.5
block|}
block|,
block|{
literal|1.0
block|,
operator|-
literal|2.5
block|,
literal|2.0
block|,
operator|-
literal|0.5
block|}
block|,
block|{
operator|-
literal|0.5
block|,
literal|0.0
block|,
literal|0.5
block|,
literal|0.0
block|}
block|,
block|{
literal|0.0
block|,
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|CR_bezier_basis
specifier|static
name|CRMatrix
name|CR_bezier_basis
init|=
block|{
block|{
literal|0.0
block|,
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
operator|-
literal|0.16667
block|,
literal|1.0
block|,
literal|0.16667
block|,
literal|0.0
block|}
block|,
block|{
literal|0.0
block|,
literal|0.16667
block|,
literal|1.0
block|,
operator|-
literal|0.16667
block|}
block|,
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|1.0
block|,
literal|0.0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|iscissors_options
specifier|static
name|IScissorsOptions
modifier|*
name|iscissors_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|selection_to_bezier
parameter_list|(
name|GtkWidget
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_reset
parameter_list|(
name|Iscissors
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_draw_CR
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|Iscissors
modifier|*
parameter_list|,
name|Point
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CR_compose
parameter_list|(
name|CRMatrix
parameter_list|,
name|CRMatrix
parameter_list|,
name|CRMatrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_segment
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_point
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  boundary localization routines  */
end_comment

begin_function_decl
specifier|static
name|void
name|normalize
parameter_list|(
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|dotprod
parameter_list|(
name|double
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Kink
modifier|*
name|get_kink
parameter_list|(
name|Kink
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_next_kink
parameter_list|(
name|Kink
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|find_distance
parameter_list|(
name|Kink
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|go_distance
parameter_list|(
name|Kink
modifier|*
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|,
name|double
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|travel_length
parameter_list|(
name|Kink
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_edge_xy
parameter_list|(
name|TempBuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shape_of_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_kinks
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initial_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|edge_map_from_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|orient_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|localize_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_process_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezierify_boundary
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  edge map buffer utility functions  */
end_comment

begin_function_decl
specifier|static
name|TempBuf
modifier|*
name|calculate_edge_map
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|construct_edge_map
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|TempBuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  edge map blocks utility functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_edge_map_blocks
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_edge_map_blocks
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_edge_map_blocks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  gaussian& 1st derivative  */
end_comment

begin_function_decl
specifier|static
name|void
name|gaussian_deriv
parameter_list|(
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_curve
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|double
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_curve_d
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|double
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Catmull-Rom boundary conversion  */
end_comment

begin_function_decl
specifier|static
name|void
name|CR_convert
parameter_list|(
name|Iscissors
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CR_convert_points
parameter_list|(
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CR_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|CR_insert_in_list
parameter_list|(
name|GSList
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************/
end_comment

begin_comment
comment|/*  Selection options dialog--for all selection tools  */
end_comment

begin_comment
comment|/*******************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|selection_toggle_update (GtkWidget * w,gpointer data)
name|selection_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|w
argument_list|)
operator|->
name|active
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|selection_scale_update (GtkAdjustment * adjustment,double * scale_val)
name|selection_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|double
modifier|*
name|scale_val
parameter_list|)
block|{
operator|*
name|scale_val
operator|=
name|adjustment
operator|->
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|selection_to_bezier (GtkWidget * w,gpointer none)
name|selection_to_bezier
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|none
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
if|if
condition|(
name|last_tool
condition|)
block|{
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|last_tool
operator|->
name|private
expr_stmt|;
name|last_tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|bezierify_boundary
argument_list|(
name|last_tool
argument_list|)
expr_stmt|;
name|tools_select
argument_list|(
name|BEZIER_SELECT
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|IScissorsOptions
modifier|*
DECL|function|iscissors_selection_options (void)
name|iscissors_selection_options
parameter_list|(
name|void
parameter_list|)
block|{
name|IScissorsOptions
modifier|*
name|options
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|antialias_toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|feather_toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|feather_scale
decl_stmt|;
name|GtkObject
modifier|*
name|feather_scale_data
decl_stmt|;
name|GtkWidget
modifier|*
name|resolution_scale
decl_stmt|;
name|GtkObject
modifier|*
name|resolution_scale_data
decl_stmt|;
name|GtkWidget
modifier|*
name|elasticity_scale
decl_stmt|;
name|GtkObject
modifier|*
name|elasticity_scale_data
decl_stmt|;
name|GtkWidget
modifier|*
name|threshold_scale
decl_stmt|;
name|GtkWidget
modifier|*
name|convert_button
decl_stmt|;
name|GtkObject
modifier|*
name|threshold_scale_data
decl_stmt|;
comment|/*  the new options structure  */
name|options
operator|=
operator|(
name|IScissorsOptions
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IScissorsOptions
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|->
name|antialias
operator|=
literal|1
expr_stmt|;
name|options
operator|->
name|feather
operator|=
literal|0
expr_stmt|;
name|options
operator|->
name|feather_radius
operator|=
literal|10.0
expr_stmt|;
name|options
operator|->
name|resolution
operator|=
literal|40.0
expr_stmt|;
name|options
operator|->
name|threshold
operator|=
literal|15.0
expr_stmt|;
comment|/*  the main vbox  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  the main label  */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Intelligent Scissors Options"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/*  the antialias toggle button  */
name|antialias_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Antialiasing"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|antialias_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|antialias_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|antialias
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|antialias_toggle
argument_list|)
expr_stmt|;
comment|/*  the feather toggle button  */
name|feather_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Feather"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|feather_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|feather_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|feather
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|feather_toggle
argument_list|)
expr_stmt|;
comment|/*  the feather radius scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Feather Radius"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|feather_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|10.0
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|feather_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|feather_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|feather_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|feather_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|feather_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|feather_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_scale_update
argument_list|,
operator|&
name|options
operator|->
name|feather_radius
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|feather_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the resolution scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Curve Resolution"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|resolution_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|4.0
argument_list|,
literal|1.0
argument_list|,
literal|200.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|resolution_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|resolution_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|resolution_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|resolution_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|resolution_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|resolution_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_scale_update
argument_list|,
operator|&
name|options
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|resolution_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the threshold scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Edge Detect Thresh."
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|threshold_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|15.0
argument_list|,
literal|1.0
argument_list|,
literal|255.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|threshold_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|threshold_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|threshold_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|threshold_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|threshold_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|threshold_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_scale_update
argument_list|,
operator|&
name|options
operator|->
name|threshold
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|threshold_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*the elasticity scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Elasticity."
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|elasticity_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|.01
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.05
argument_list|,
literal|0.05
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|elasticity_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|elasticity_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|elasticity_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|elasticity_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|elasticity_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|elasticity_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_scale_update
argument_list|,
operator|&
name|elasticity
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|elasticity_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the convert to bezier button  */
name|convert_button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Convert to Bezier Curve"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|convert_button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|convert_button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|selection_to_bezier
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|convert_button
argument_list|)
expr_stmt|;
comment|/*  Register this selection options widget with the main tools options dialog  */
name|tools_register_options
argument_list|(
name|ISCISSORS
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_iscissors ()
name|tools_new_iscissors
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|Iscissors
modifier|*
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|iscissors_options
condition|)
name|iscissors_options
operator|=
name|iscissors_selection_options
argument_list|()
expr_stmt|;
name|tool
operator|=
operator|(
name|Tool
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Iscissors
argument_list|)
argument_list|)
expr_stmt|;
name|private
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|iscissors_draw
argument_list|)
expr_stmt|;
name|private
operator|->
name|edge_buf
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|kinks
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|ISCISSORS
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|0
expr_stmt|;
comment|/*  Allow scrolling  */
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|private
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|iscissors_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|iscissors_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|iscissors_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|rect_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|iscissors_control
expr_stmt|;
name|tool
operator|->
name|auto_snap_to
operator|=
literal|0
expr_stmt|;
name|last_tool
operator|=
name|tool
expr_stmt|;
name|iscissors_reset
argument_list|(
name|private
argument_list|)
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_iscissors (Tool * tool)
name|tools_free_iscissors
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|iscissors
operator|->
name|core
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Local functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|iscissors_button_press (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|iscissors_button_press
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|int
name|replace
decl_stmt|,
name|op
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|last_tool
operator|=
name|tool
expr_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
comment|/*message_box ("Intelligent Scissors is currently not enabled\nfor use with   the tile-based GIMP\non anything but yosh's computer.",   NULL, NULL);*/
comment|/*  return;*/
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp_ptr
operator|!=
name|tool
operator|->
name|gdisp_ptr
condition|)
block|{
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|FREE_SELECT_MODE
case|:
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|last_tool
operator|=
name|NULL
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
operator|(
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskTranslate
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|layer_is_floating_sel
argument_list|(
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|)
operator|)
operator|&&
name|gdisplay_mask_value
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|)
operator|>
name|HALF_WAY
condition|)
block|{
comment|/*  Have to blank out the edge blocks since they might change  */
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskToLayerTranslate
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  If the edge map blocks haven't been allocated, do so now  */
if|if
condition|(
operator|!
name|edge_map_blocks
condition|)
name|allocate_edge_map_blocks
argument_list|(
name|BLOCK_WIDTH
argument_list|,
name|BLOCK_HEIGHT
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|num_segs
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|bevent
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|bevent
operator|->
name|y
expr_stmt|;
name|add_segment
argument_list|(
operator|&
operator|(
name|iscissors
operator|->
name|num_segs
operator|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUNDARY_MODE
case|:
if|if
condition|(
comment|/*channel_value (iscissors->mask, iscissors->x, iscissors->y)*/
name|TRUE
condition|)
block|{
name|replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|ADD
expr_stmt|;
name|replace
operator|=
literal|1
expr_stmt|;
block|}
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
comment|/*  If we're antialiased, then recompute the 	   *  mask... 	   */
if|if
condition|(
name|iscissors_options
operator|->
name|antialias
condition|)
name|CR_convert
argument_list|(
name|iscissors
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors_options
operator|->
name|feather
condition|)
name|channel_feather
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|iscissors_options
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|iscissors
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|iscissors_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*return;*/
name|last_tool
operator|=
name|tool
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/*  First take care of the case where the user "cancels" the action  */
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_BUTTON3_MASK
operator|)
condition|)
block|{
comment|/*  Progress to the next stage of intelligent selection  */
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|FREE_SELECT_MODE
case|:
comment|/*  Add one additional segment  */
name|add_segment
argument_list|(
operator|&
operator|(
name|iscissors
operator|->
name|num_segs
operator|)
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|x1
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|num_segs
operator|>=
literal|3
condition|)
block|{
comment|/*  Find the boundary  */
name|find_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Set the new state  */
name|iscissors
operator|->
name|state
operator|=
name|BOUNDARY_MODE
expr_stmt|;
comment|/*  Start the draw core up again  */
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|BOUNDARY_MODE
case|:
name|iscissors
operator|->
name|state
operator|=
name|FREE_SELECT_MODE
expr_stmt|;
break|break;
block|}
block|}
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|iscissors_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
return|return;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|FREE_SELECT_MODE
case|:
name|x
operator|=
name|mevent
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|mevent
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|add_segment
argument_list|(
operator|&
operator|(
name|iscissors
operator|->
name|num_segs
operator|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
name|gdk_draw_segments
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|segs
operator|+
operator|(
name|iscissors
operator|->
name|num_segs
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUNDARY_MODE
case|:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_draw (Tool * tool)
name|iscissors_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|int
name|indices
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|FREE_SELECT_MODE
case|:
name|gdk_draw_segments
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|segs
argument_list|,
name|iscissors
operator|->
name|num_segs
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUNDARY_MODE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|<
literal|3
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|3
operator|)
else|:
operator|(
name|i
operator|-
literal|3
operator|)
expr_stmt|;
name|indices
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|<
literal|2
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|2
operator|)
else|:
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
name|indices
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|<
literal|1
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|1
operator|)
else|:
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|indices
index|[
literal|3
index|]
operator|=
name|i
expr_stmt|;
name|iscissors_draw_CR
argument_list|(
name|gdisp
argument_list|,
name|iscissors
argument_list|,
name|pts
argument_list|,
name|indices
argument_list|,
name|SCREEN_COORDS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_draw_CR (GDisplay * gdisp,Iscissors * iscissors,Point * pts,int * indices,int draw_type)
name|iscissors_draw_CR
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|Point
modifier|*
name|pts
parameter_list|,
name|int
modifier|*
name|indices
parameter_list|,
name|int
name|draw_type
parameter_list|)
block|{
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
specifier|static
name|GdkPoint
name|gdk_points
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|npoints
init|=
literal|256
decl_stmt|;
name|CRMatrix
name|geometry
decl_stmt|;
name|CRMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|CRMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|draw_type
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dy
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dx
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dy
operator|*
name|SUPERSAMPLE
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|gdisplay_transform_coords_f
argument_list|(
name|gdisp
argument_list|,
operator|(
name|int
operator|)
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dx
argument_list|,
operator|(
name|int
operator|)
name|pts
index|[
name|indices
index|[
name|i
index|]
index|]
operator|.
name|dy
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
comment|/*g_print("%f %f\n", x, y);*/
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|SUBDIVIDE
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward differencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|CR_compose
argument_list|(
name|CR_basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|CR_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|lastx
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|lasty
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUBDIVIDE
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then draw it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
comment|/* add the point to the point buffer */
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|newx
argument_list|,
name|newy
argument_list|,
operator|&
name|tx
argument_list|,
operator|&
name|ty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|x
operator|=
name|tx
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|y
operator|=
name|ty
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* if the point buffer is full put it to the screen and zero it out */
if|if
condition|(
name|index
operator|>=
name|npoints
condition|)
block|{
switch|switch
condition|(
name|draw_type
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
case|case
name|AA_IMAGE_COORDS
case|:
name|CR_convert_points
argument_list|(
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|gdk_draw_points
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* if there are points in the buffer, then put them on the screen */
if|if
condition|(
name|index
condition|)
switch|switch
condition|(
name|draw_type
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
case|case
name|AA_IMAGE_COORDS
case|:
name|CR_convert_points
argument_list|(
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|gdk_draw_points
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_control (Tool * tool,int action,gpointer gdisp_ptr)
name|iscissors_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|int
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_reset (Iscissors * iscissors)
name|iscissors_reset
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|)
block|{
comment|/*  Reset the edge map blocks structure  */
name|free_edge_map_blocks
argument_list|()
expr_stmt|;
comment|/*  free edge buffer  */
if|if
condition|(
name|iscissors
operator|->
name|edge_buf
condition|)
name|temp_buf_free
argument_list|(
name|iscissors
operator|->
name|edge_buf
argument_list|)
expr_stmt|;
comment|/*  free mask  */
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
comment|/*  Free kinks  */
if|if
condition|(
name|iscissors
operator|->
name|kinks
condition|)
name|g_free
argument_list|(
name|iscissors
operator|->
name|kinks
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|FREE_SELECT_MODE
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|edge_buf
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|kinks
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|num_segs
operator|=
literal|0
expr_stmt|;
name|iscissors
operator|->
name|num_pts
operator|=
literal|0
expr_stmt|;
name|iscissors
operator|->
name|num_kinks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|add_segment (int * num_segs,int x,int y)
name|add_segment
parameter_list|(
name|int
modifier|*
name|num_segs
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|num_segs
operator|>=
name|max_segs
condition|)
block|{
name|max_segs
operator|+=
name|DEFAULT_MAX_INC
expr_stmt|;
name|segs
operator|=
operator|(
name|GdkSegment
operator|*
operator|)
name|g_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|segs
argument_list|,
sizeof|sizeof
argument_list|(
name|GdkSegment
argument_list|)
operator|*
name|max_segs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|segs
condition|)
name|fatal_error
argument_list|(
literal|"Unable to reallocate segment array in iscissors."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|num_segs
condition|)
block|{
name|segs
index|[
operator|*
name|num_segs
index|]
operator|.
name|x1
operator|=
name|segs
index|[
operator|*
name|num_segs
operator|-
literal|1
index|]
operator|.
name|x2
expr_stmt|;
name|segs
index|[
operator|*
name|num_segs
index|]
operator|.
name|y1
operator|=
name|segs
index|[
operator|*
name|num_segs
operator|-
literal|1
index|]
operator|.
name|y2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
condition|)
block|{
name|segs
index|[
literal|0
index|]
operator|.
name|x1
operator|=
name|x
expr_stmt|;
name|segs
index|[
literal|0
index|]
operator|.
name|y1
operator|=
name|y
expr_stmt|;
block|}
name|segs
index|[
operator|*
name|num_segs
index|]
operator|.
name|x2
operator|=
name|x
expr_stmt|;
name|segs
index|[
operator|*
name|num_segs
index|]
operator|.
name|y2
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|num_segs
operator|&&
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|num_segs
operator|)
operator|++
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|add_point (int * num_pts,int kink,int x,int y,double * normal)
name|add_point
parameter_list|(
name|int
modifier|*
name|num_pts
parameter_list|,
name|int
name|kink
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|double
modifier|*
name|normal
parameter_list|)
block|{
if|if
condition|(
operator|*
name|num_pts
operator|>=
name|max_pts
condition|)
block|{
name|max_pts
operator|+=
name|DEFAULT_MAX_INC
expr_stmt|;
name|pts
operator|=
operator|(
name|Point
operator|*
operator|)
name|g_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pts
argument_list|,
sizeof|sizeof
argument_list|(
name|Point
argument_list|)
operator|*
name|max_pts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pts
condition|)
name|fatal_error
argument_list|(
literal|"Unable to reallocate points array in iscissors."
argument_list|)
expr_stmt|;
block|}
name|pts
index|[
operator|*
name|num_pts
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|pts
index|[
operator|*
name|num_pts
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|pts
index|[
operator|*
name|num_pts
index|]
operator|.
name|kink
operator|=
name|kink
expr_stmt|;
name|pts
index|[
operator|*
name|num_pts
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|=
name|normal
index|[
literal|0
index|]
expr_stmt|;
name|pts
index|[
operator|*
name|num_pts
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|=
name|normal
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|num_pts
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|CR_compose (CRMatrix a,CRMatrix b,CRMatrix ab)
name|CR_compose
parameter_list|(
name|CRMatrix
name|a
parameter_list|,
name|CRMatrix
name|b
parameter_list|,
name|CRMatrix
name|ab
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ab
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|a
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|b
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|b
index|[
literal|1
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|b
index|[
literal|2
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|3
index|]
operator|*
name|b
index|[
literal|3
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|normalize (double * vec)
name|normalize
parameter_list|(
name|double
modifier|*
name|vec
parameter_list|)
block|{
name|double
name|length
decl_stmt|;
name|length
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|)
operator|+
name|SQR
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|vec
index|[
literal|0
index|]
operator|/=
name|length
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|/=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|dotprod (double * vec1,double * vec2)
name|dotprod
parameter_list|(
name|double
modifier|*
name|vec1
parameter_list|,
name|double
modifier|*
name|vec2
parameter_list|)
block|{
name|double
name|val
decl_stmt|;
name|val
operator|=
name|vec1
index|[
literal|0
index|]
operator|*
name|vec2
index|[
literal|0
index|]
operator|+
name|vec1
index|[
literal|1
index|]
operator|*
name|vec2
index|[
literal|1
index|]
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|Kink
modifier|*
DECL|function|get_kink (Kink * kinks,int index,int num_kinks)
name|get_kink
parameter_list|(
name|Kink
modifier|*
name|kinks
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|num_kinks
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|num_kinks
condition|)
return|return
name|kinks
operator|+
name|index
return|;
elseif|else
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|+=
name|num_kinks
expr_stmt|;
return|return
name|kinks
operator|+
name|index
return|;
block|}
else|else
block|{
while|while
condition|(
name|index
operator|>=
name|num_kinks
condition|)
name|index
operator|-=
name|num_kinks
expr_stmt|;
return|return
name|kinks
operator|+
name|index
return|;
block|}
comment|/* I don't think it ever gets to this point -- Rockwalrus */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|find_next_kink (Kink * kinks,int num_kinks,int this)
name|find_next_kink
parameter_list|(
name|Kink
modifier|*
name|kinks
parameter_list|,
name|int
name|num_kinks
parameter_list|,
name|int
name|this
parameter_list|)
block|{
if|if
condition|(
name|this
operator|>=
name|num_kinks
condition|)
return|return
literal|0
return|;
do|do
block|{
name|this
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|kinks
index|[
name|this
index|]
operator|.
name|is_a_kink
condition|)
do|;
return|return
name|this
return|;
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|find_distance (Kink * kinks,int this,int next)
name|find_distance
parameter_list|(
name|Kink
modifier|*
name|kinks
parameter_list|,
name|int
name|this
parameter_list|,
name|int
name|next
parameter_list|)
block|{
name|double
name|dist
init|=
literal|0.0
decl_stmt|;
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
while|while
condition|(
name|this
operator|!=
name|next
condition|)
block|{
name|dx
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|x
operator|-
name|kinks
index|[
name|this
operator|+
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|y
operator|-
name|kinks
index|[
name|this
operator|+
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|dist
operator|+=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|++
expr_stmt|;
block|}
return|return
name|dist
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|go_distance (Kink * kinks,int this,double dist,double * x,double * y)
name|go_distance
parameter_list|(
name|Kink
modifier|*
name|kinks
parameter_list|,
name|int
name|this
parameter_list|,
name|double
name|dist
parameter_list|,
name|double
modifier|*
name|x
parameter_list|,
name|double
modifier|*
name|y
parameter_list|)
block|{
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|double
name|length
init|=
literal|0.0
decl_stmt|;
name|double
name|t
init|=
literal|2.0
decl_stmt|;
name|dx
operator|=
name|dy
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|dist
operator|==
literal|0.0
condition|)
block|{
operator|*
name|x
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|x
expr_stmt|;
operator|*
name|y
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|y
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|dist
operator|>
literal|0.0
condition|)
block|{
name|dx
operator|=
name|kinks
index|[
name|this
operator|+
literal|1
index|]
operator|.
name|x
operator|-
name|kinks
index|[
name|this
index|]
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|kinks
index|[
name|this
operator|+
literal|1
index|]
operator|.
name|y
operator|-
name|kinks
index|[
name|this
index|]
operator|.
name|y
expr_stmt|;
name|length
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|dist
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|dist
operator|>
literal|0.0
condition|)
name|this
operator|++
expr_stmt|;
block|}
name|t
operator|=
operator|(
name|length
operator|+
name|dist
operator|)
operator|/
name|length
expr_stmt|;
operator|*
name|x
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|x
operator|+
name|t
operator|*
name|dx
expr_stmt|;
operator|*
name|y
operator|=
name|kinks
index|[
name|this
index|]
operator|.
name|y
operator|+
name|t
operator|*
name|dy
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|travel_length (Kink * kinks,int num_kinks,int start,int dir,int dist)
name|travel_length
parameter_list|(
name|Kink
modifier|*
name|kinks
parameter_list|,
name|int
name|num_kinks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|dist
parameter_list|)
block|{
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|Kink
modifier|*
name|k1
decl_stmt|,
modifier|*
name|k2
decl_stmt|;
name|double
name|distance
init|=
name|dist
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|distance
operator|>
literal|0
condition|)
block|{
name|k1
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|start
argument_list|,
name|num_kinks
argument_list|)
expr_stmt|;
name|k2
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|start
operator|+
name|dir
argument_list|,
name|num_kinks
argument_list|)
expr_stmt|;
name|dx
operator|=
name|k2
operator|->
name|x
operator|-
name|k1
operator|->
name|x
expr_stmt|;
name|dy
operator|=
name|k2
operator|->
name|y
operator|-
name|k1
operator|->
name|y
expr_stmt|;
name|distance
operator|-=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|+=
name|dir
expr_stmt|;
name|length
operator|+=
name|dir
expr_stmt|;
block|}
comment|/*  backup one step and return value  */
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|find_edge_xy (TempBuf * edge_buf,int dir,double x,double y,double * edge)
name|find_edge_xy
parameter_list|(
name|TempBuf
modifier|*
name|edge_buf
parameter_list|,
name|int
name|dir
parameter_list|,
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
modifier|*
name|edge
parameter_list|)
block|{
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|int
name|xx
decl_stmt|,
name|yy
decl_stmt|;
name|int
name|rowstride
decl_stmt|,
name|bytes
decl_stmt|;
name|int
name|d11
decl_stmt|,
name|d12
decl_stmt|,
name|d21
decl_stmt|,
name|d22
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bytes
operator|=
name|edge_buf
operator|->
name|bytes
expr_stmt|;
name|rowstride
operator|=
name|bytes
operator|*
name|edge_buf
operator|->
name|width
expr_stmt|;
name|x
operator|-=
name|edge_buf
operator|->
name|x
expr_stmt|;
name|y
operator|-=
name|edge_buf
operator|->
name|y
expr_stmt|;
name|ix
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|+
literal|2
argument_list|)
operator|-
literal|2
expr_stmt|;
name|iy
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|+
literal|2
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/*  If we're scouting out of bounds, return 0  */
if|if
condition|(
name|ix
operator|<
literal|0
operator|||
name|ix
operator|>=
name|edge_buf
operator|->
name|width
operator|||
name|iy
operator|<
literal|0
operator|||
name|iy
operator|>=
name|edge_buf
operator|->
name|height
condition|)
block|{
name|edge
index|[
literal|0
index|]
operator|=
name|EDGE_STRENGTH
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|dx
operator|=
name|x
operator|-
name|ix
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|iy
expr_stmt|;
block|}
else|else
block|{
name|dx
operator|=
literal|1
operator|-
operator|(
name|x
operator|-
name|ix
operator|)
expr_stmt|;
name|dy
operator|=
literal|1
operator|-
operator|(
name|y
operator|-
name|iy
operator|)
expr_stmt|;
block|}
name|data
operator|=
name|temp_buf_data
argument_list|(
name|edge_buf
argument_list|)
operator|+
name|iy
operator|*
name|rowstride
operator|+
name|ix
operator|*
name|bytes
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|xx
operator|=
operator|(
operator|(
name|ix
operator|+
literal|1
operator|)
operator|>=
name|edge_buf
operator|->
name|width
operator|)
condition|?
literal|0
else|:
name|bytes
expr_stmt|;
name|yy
operator|=
operator|(
operator|(
name|iy
operator|+
literal|1
operator|)
operator|>=
name|edge_buf
operator|->
name|height
operator|)
condition|?
literal|0
else|:
name|rowstride
expr_stmt|;
block|}
else|else
block|{
name|xx
operator|=
operator|(
operator|(
name|ix
operator|-
literal|1
operator|)
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
name|bytes
expr_stmt|;
name|yy
operator|=
operator|(
operator|(
name|iy
operator|-
literal|1
operator|)
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
name|rowstride
expr_stmt|;
block|}
name|d11
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|>
name|threshold
operator|)
condition|?
name|data
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
name|d12
operator|=
operator|(
name|data
index|[
name|xx
index|]
operator|>
name|threshold
operator|)
condition|?
name|data
index|[
name|xx
index|]
else|:
literal|0
expr_stmt|;
name|d21
operator|=
operator|(
name|data
index|[
name|yy
index|]
operator|>
name|threshold
operator|)
condition|?
name|data
index|[
name|yy
index|]
else|:
literal|0
expr_stmt|;
name|d22
operator|=
operator|(
name|data
index|[
name|xx
operator|+
name|yy
index|]
operator|>
name|threshold
operator|)
condition|?
name|data
index|[
name|xx
operator|+
name|yy
index|]
else|:
literal|0
expr_stmt|;
name|edge
index|[
name|b
index|]
operator|=
name|BILINEAR
argument_list|(
name|d11
argument_list|,
name|d12
argument_list|,
name|d21
argument_list|,
name|d22
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|edge
index|[
literal|0
index|]
operator|>
literal|0.0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_boundary (Tool * tool)
name|find_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
comment|/*  Find directional changes  */
name|shape_of_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Process the kinks  */
name|process_kinks
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Determine the initial boundary  */
name|initial_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Get the edge map from the boundary extents  */
name|edge_map_from_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Orient the boundary based on edge detection  */
name|orient_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Setup the points array for localization  */
name|reset_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  Localize the boundary based on edge detection    *  and inter-segment elasticity    */
while|while
condition|(
name|localize_boundary
argument_list|(
name|tool
argument_list|)
condition|)
empty_stmt|;
comment|/*  Post process the points array to fit non-edge-seeking    *  boundary points into the scheme of things    */
name|post_process_boundary
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  convert the boundary into a mask  */
name|CR_convert
argument_list|(
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
argument_list|,
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shape_of_boundary (Tool * tool)
name|shape_of_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Kink
modifier|*
name|kinks
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|double
name|vec1
index|[
literal|2
index|]
decl_stmt|,
name|vec2
index|[
literal|2
index|]
decl_stmt|,
name|vec
index|[
literal|2
index|]
decl_stmt|;
name|double
name|std_dev
decl_stmt|;
name|double
name|weight
decl_stmt|;
name|int
name|left
decl_stmt|,
name|right
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  This function determines the kinkiness at each point in the    *  original free-hand curve by finding the dotproduct between    *  the two vectors formed at each point from that point to its    *  immediate neighbors.  A smoothing function is applied to    *  determine the vectors to ameliorate the otherwise excessive    *  jitter associated with original selection.    */
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|iscissors
operator|->
name|num_kinks
operator|=
name|iscissors
operator|->
name|num_segs
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|kinks
condition|)
name|g_free
argument_list|(
name|iscissors
operator|->
name|kinks
argument_list|)
expr_stmt|;
name|kinks
operator|=
name|iscissors
operator|->
name|kinks
operator|=
operator|(
name|Kink
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Kink
argument_list|)
operator|*
operator|(
name|iscissors
operator|->
name|num_kinks
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_kinks
condition|;
name|i
operator|++
control|)
block|{
comment|/* untransform coords */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|x1
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|y1
argument_list|,
operator|&
name|kinks
index|[
name|j
index|]
operator|.
name|x
argument_list|,
operator|&
name|kinks
index|[
name|j
index|]
operator|.
name|y
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*	          kinks[j].x = segs[i].x1;       kinks[j].y = segs[i].y1; */
if|if
condition|(
name|j
condition|)
block|{
if|if
condition|(
operator|(
name|kinks
index|[
name|i
index|]
operator|.
name|x
operator|!=
name|kinks
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|x
operator|)
operator|||
operator|(
name|kinks
index|[
name|j
index|]
operator|.
name|y
operator|!=
name|kinks
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|y
operator|)
condition|)
operator|++
name|j
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
block|}
name|iscissors
operator|->
name|num_kinks
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_kinks
condition|;
name|i
operator|++
control|)
block|{
name|left
operator|=
name|travel_length
argument_list|(
name|kinks
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|,
name|i
argument_list|,
operator|-
literal|1
argument_list|,
name|resolution
argument_list|)
expr_stmt|;
name|right
operator|=
name|travel_length
argument_list|(
name|kinks
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|resolution
argument_list|)
expr_stmt|;
name|std_dev
operator|=
name|sqrt
argument_list|(
operator|-
operator|(
name|SQR
argument_list|(
name|left
argument_list|)
operator|)
operator|/
operator|(
literal|2
operator|*
name|log
argument_list|(
name|EPSILON
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|std_dev
argument_list|)
operator|<
name|EPSILON
condition|)
name|std_dev
operator|=
literal|1.0
expr_stmt|;
name|vec1
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|vec1
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|left
init|;
name|j
operator|<
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|k
operator|->
name|x
operator|-
name|kinks
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
name|k
operator|->
name|y
operator|-
name|kinks
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|normalize
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|weight
operator|=
name|exp
argument_list|(
operator|-
name|SQR
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|/
operator|(
literal|2
operator|*
name|SQR
argument_list|(
name|std_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|vec1
index|[
literal|0
index|]
operator|+=
name|weight
operator|*
name|vec
index|[
literal|0
index|]
expr_stmt|;
name|vec1
index|[
literal|1
index|]
operator|+=
name|weight
operator|*
name|vec
index|[
literal|1
index|]
expr_stmt|;
block|}
name|normalize
argument_list|(
name|vec1
argument_list|)
expr_stmt|;
name|std_dev
operator|=
name|sqrt
argument_list|(
operator|-
operator|(
name|SQR
argument_list|(
name|right
argument_list|)
operator|)
operator|/
operator|(
literal|2
operator|*
name|log
argument_list|(
name|EPSILON
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|std_dev
argument_list|)
operator|<
name|EPSILON
condition|)
name|std_dev
operator|=
literal|1.0
expr_stmt|;
name|vec2
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|vec2
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|right
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|k
operator|->
name|x
operator|-
name|kinks
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
name|k
operator|->
name|y
operator|-
name|kinks
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|normalize
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|weight
operator|=
name|exp
argument_list|(
operator|-
name|SQR
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|/
operator|(
literal|2
operator|*
name|SQR
argument_list|(
name|std_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|vec2
index|[
literal|0
index|]
operator|+=
name|weight
operator|*
name|vec
index|[
literal|0
index|]
expr_stmt|;
name|vec2
index|[
literal|1
index|]
operator|+=
name|weight
operator|*
name|vec
index|[
literal|1
index|]
expr_stmt|;
block|}
name|normalize
argument_list|(
name|vec2
argument_list|)
expr_stmt|;
comment|/*  determine the kinkiness based on the two vectors  */
name|kinks
index|[
name|i
index|]
operator|.
name|kinkiness
operator|=
operator|(
name|M_PI
operator|-
name|acos
argument_list|(
name|dotprod
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|)
argument_list|)
operator|)
operator|/
name|M_PI
expr_stmt|;
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|=
operator|(
name|vec1
index|[
literal|0
index|]
operator|+
name|vec2
index|[
literal|0
index|]
operator|)
operator|/
literal|2.0
expr_stmt|;
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|=
operator|(
name|vec1
index|[
literal|1
index|]
operator|+
name|vec2
index|[
literal|1
index|]
operator|)
operator|/
literal|2.0
expr_stmt|;
comment|/*  if the average vector is zero length...  */
if|if
condition|(
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|<
name|EPSILON
operator|&&
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|<
name|EPSILON
condition|)
block|{
comment|/*  normal = 90 degree rotation of vec1  */
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|=
operator|-
name|vec1
index|[
literal|1
index|]
expr_stmt|;
name|kinks
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|=
name|vec1
index|[
literal|0
index|]
expr_stmt|;
block|}
name|normalize
argument_list|(
name|kinks
index|[
name|i
index|]
operator|.
name|normal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|process_kinks (Tool * tool)
name|process_kinks
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Kink
modifier|*
name|kinks
decl_stmt|,
modifier|*
name|k_left
decl_stmt|,
modifier|*
name|k_right
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|kinks
operator|=
name|iscissors
operator|->
name|kinks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_kinks
condition|;
name|i
operator|++
control|)
block|{
comment|/*FIXME*/
name|kinks
index|[
name|i
index|]
operator|.
name|x
operator|=
name|BOUNDS
argument_list|(
name|kinks
index|[
name|i
index|]
operator|.
name|x
argument_list|,
literal|0
argument_list|,
operator|(
name|drawable_width
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|kinks
index|[
name|i
index|]
operator|.
name|y
operator|=
name|BOUNDS
argument_list|(
name|kinks
index|[
name|i
index|]
operator|.
name|y
argument_list|,
literal|0
argument_list|,
operator|(
name|drawable_height
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/*  get local maximums  */
name|k_left
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|)
expr_stmt|;
name|k_right
operator|=
name|get_kink
argument_list|(
name|kinks
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kinks
index|[
name|i
index|]
operator|.
name|kinkiness
operator|>
name|k_left
operator|->
name|kinkiness
operator|)
operator|&&
operator|(
name|kinks
index|[
name|i
index|]
operator|.
name|kinkiness
operator|>=
name|k_right
operator|->
name|kinkiness
operator|)
operator|&&
operator|(
name|kinks
index|[
name|i
index|]
operator|.
name|kinkiness
operator|>
name|kink_thres
operator|)
condition|)
name|kinks
index|[
name|i
index|]
operator|.
name|is_a_kink
operator|=
literal|1
expr_stmt|;
else|else
name|kinks
index|[
name|i
index|]
operator|.
name|is_a_kink
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|initial_boundary (Tool * tool)
name|initial_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Kink
modifier|*
name|kinks
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|double
name|dist
decl_stmt|;
name|double
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|this
decl_stmt|,
name|next
decl_stmt|,
name|k
decl_stmt|;
name|int
name|num_pts
init|=
literal|0
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|kinks
operator|=
name|iscissors
operator|->
name|kinks
expr_stmt|;
comment|/*  for a connected boundary, set up the last kink as the same    *  x& y coordinates as the first    */
name|kinks
index|[
name|iscissors
operator|->
name|num_kinks
index|]
operator|.
name|x
operator|=
name|kinks
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|kinks
index|[
name|iscissors
operator|->
name|num_kinks
index|]
operator|.
name|y
operator|=
name|kinks
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|kinks
index|[
name|iscissors
operator|->
name|num_kinks
index|]
operator|.
name|is_a_kink
operator|=
literal|1
expr_stmt|;
name|this
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|find_next_kink
argument_list|(
name|kinks
argument_list|,
name|iscissors
operator|->
name|num_kinks
argument_list|,
name|this
argument_list|)
operator|)
condition|)
block|{
comment|/*  Find the distance in pixels from the current to        *  the next kink        */
name|dist
operator|=
name|find_distance
argument_list|(
name|kinks
argument_list|,
name|this
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|>
literal|0.0
condition|)
block|{
comment|/*  Find the number of segments that should be created 	   *  to fill the void 	   */
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|dist
operator|/
name|resolution
argument_list|)
expr_stmt|;
name|res
operator|=
name|dist
operator|/
call|(
name|double
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|add_point
argument_list|(
operator|&
name|num_pts
argument_list|,
literal|1
argument_list|,
name|kinks
index|[
name|this
index|]
operator|.
name|x
argument_list|,
name|kinks
index|[
name|this
index|]
operator|.
name|y
argument_list|,
name|kinks
index|[
name|this
index|]
operator|.
name|normal
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
name|go_distance
argument_list|(
name|kinks
argument_list|,
name|this
argument_list|,
name|res
operator|*
name|i
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|add_point
argument_list|(
operator|&
name|num_pts
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
name|kinks
index|[
name|k
index|]
operator|.
name|normal
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|=
name|next
expr_stmt|;
block|}
name|iscissors
operator|->
name|num_pts
operator|=
name|num_pts
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|edge_map_from_boundary (Tool * tool)
name|edge_map_from_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|unsigned
name|char
name|black
index|[
name|EDGE_WIDTH
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|x
operator|=
name|y
operator|=
name|w
operator|=
name|h
operator|=
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
name|x1
operator|=
name|drawable_width
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|y1
operator|=
name|drawable_height
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  Find the edge map extents  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|BOUNDS
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|-
name|LOCALIZE_RADIUS
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|BOUNDS
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|-
name|LOCALIZE_RADIUS
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|BOUNDS
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|+
name|LOCALIZE_RADIUS
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|BOUNDS
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|+
name|LOCALIZE_RADIUS
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|-=
name|x
expr_stmt|;
name|h
operator|-=
name|y
expr_stmt|;
name|set_edge_map_blocks
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|x1
condition|)
name|x1
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|y1
condition|)
name|y1
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|w
operator|>
name|x2
condition|)
name|x2
operator|=
name|x
operator|+
name|w
expr_stmt|;
if|if
condition|(
name|y
operator|+
name|h
operator|>
name|y2
condition|)
name|y2
operator|=
name|y
operator|+
name|h
expr_stmt|;
block|}
comment|/*  construct the edge map  */
name|iscissors
operator|->
name|edge_buf
operator|=
name|temp_buf_new
argument_list|(
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|EDGE_WIDTH
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|construct_edge_map
argument_list|(
name|tool
argument_list|,
name|iscissors
operator|->
name|edge_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|orient_boundary (Tool * tool)
name|orient_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|int
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|double
name|dx1
decl_stmt|,
name|dy1
decl_stmt|,
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
name|double
name|edge1
index|[
name|EDGE_WIDTH
index|]
decl_stmt|,
name|edge2
index|[
name|EDGE_WIDTH
index|]
decl_stmt|;
name|double
name|max
decl_stmt|;
name|double
name|angle
decl_stmt|;
name|int
name|dir
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|max_dir
decl_stmt|;
name|int
name|max_orient
decl_stmt|;
name|int
name|found
decl_stmt|;
name|max_dir
operator|=
literal|0
expr_stmt|;
name|max_orient
operator|=
literal|0
expr_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
comment|/*  Search for the closest edge  */
name|j
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0.0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|angle
operator|=
name|atan2
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|(
operator|(
name|angle
operator|>
operator|-
literal|3
operator|*
name|M_PI_4
operator|)
operator|&&
operator|(
name|angle
operator|<
name|M_PI_4
operator|)
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|LOCALIZE_RADIUS
operator|&&
operator|!
name|found
condition|)
block|{
name|dx1
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|+
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|*
name|j
expr_stmt|;
name|dy1
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|+
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|*
name|j
expr_stmt|;
name|e1
operator|=
name|find_edge_xy
argument_list|(
name|iscissors
operator|->
name|edge_buf
argument_list|,
name|dir
argument_list|,
name|dx1
argument_list|,
name|dy1
argument_list|,
name|edge1
argument_list|)
expr_stmt|;
name|dx2
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|-
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|*
name|j
expr_stmt|;
name|dy2
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|-
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|*
name|j
expr_stmt|;
name|e2
operator|=
name|find_edge_xy
argument_list|(
name|iscissors
operator|->
name|edge_buf
argument_list|,
operator|-
name|dir
argument_list|,
name|dx2
argument_list|,
name|dy2
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
name|e1
operator|=
name|e2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e1
operator|&&
name|e2
condition|)
block|{
if|if
condition|(
name|edge1
index|[
literal|0
index|]
operator|>
name|edge2
index|[
literal|0
index|]
condition|)
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
else|else
block|{
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
operator|-
name|dir
expr_stmt|;
block|}
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e1
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e2
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
operator|-
name|dir
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|edge1
index|[
literal|0
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|edge1
index|[
literal|0
index|]
expr_stmt|;
name|max_orient
operator|=
literal|1
expr_stmt|;
name|max_dir
operator|=
name|dir
expr_stmt|;
block|}
if|if
condition|(
name|edge2
index|[
literal|0
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|edge2
index|[
literal|0
index|]
expr_stmt|;
name|max_orient
operator|=
operator|-
literal|1
expr_stmt|;
name|max_dir
operator|=
operator|-
name|dir
expr_stmt|;
block|}
block|}
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|max
operator|>
name|miss_thres
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|*=
name|max_orient
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|*=
name|max_orient
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
name|max_dir
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reset_boundary (Tool * tool)
name|reset_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|double
name|edge
index|[
name|EDGE_WIDTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|==
literal|0
condition|)
name|pts
index|[
name|i
index|]
operator|.
name|stable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|find_edge_xy
argument_list|(
name|iscissors
operator|->
name|edge_buf
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|dir
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|edge
argument_list|)
condition|)
name|pts
index|[
name|i
index|]
operator|.
name|stable
operator|=
literal|1
expr_stmt|;
else|else
name|pts
index|[
name|i
index|]
operator|.
name|stable
operator|=
literal|0
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dx
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dy
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|localize_boundary (Tool * tool)
name|localize_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|double
name|max
decl_stmt|;
name|double
name|d_l
decl_stmt|,
name|d_r
decl_stmt|;
name|double
name|edge
index|[
name|EDGE_WIDTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
name|int
name|moved
init|=
literal|0
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  this function lets the boundary crawl in its desired    *  direction, but within limits set by the elasticity    *  variable.  The process is incremental, so this function    *  needs to be repeatedly called until there is no discernable    *  movement    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|pts
index|[
name|i
index|]
operator|.
name|stable
condition|)
block|{
name|x
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|dx
operator|+
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|pts
index|[
name|i
index|]
operator|.
name|dy
operator|+
name|pts
index|[
name|i
index|]
operator|.
name|normal
index|[
literal|1
index|]
expr_stmt|;
name|left
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|iscissors
operator|->
name|num_pts
operator|-
literal|1
else|:
name|i
operator|-
literal|1
expr_stmt|;
name|right
operator|=
operator|(
name|i
operator|==
operator|(
name|iscissors
operator|->
name|num_pts
operator|-
literal|1
operator|)
operator|)
condition|?
literal|0
else|:
name|i
operator|+
literal|1
expr_stmt|;
name|dx
operator|=
name|x
operator|-
name|pts
index|[
name|left
index|]
operator|.
name|dx
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|pts
index|[
name|left
index|]
operator|.
name|dy
expr_stmt|;
name|d_l
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|dx
operator|=
name|x
operator|-
name|pts
index|[
name|right
index|]
operator|.
name|dx
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|pts
index|[
name|right
index|]
operator|.
name|dy
expr_stmt|;
name|d_r
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|dx
operator|=
name|pts
index|[
name|left
index|]
operator|.
name|dx
operator|-
name|pts
index|[
name|right
index|]
operator|.
name|dx
expr_stmt|;
name|dy
operator|=
name|pts
index|[
name|left
index|]
operator|.
name|dy
operator|-
name|pts
index|[
name|right
index|]
operator|.
name|dy
expr_stmt|;
name|max
operator|=
operator|(
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dx
argument_list|)
operator|+
name|SQR
argument_list|(
name|dy
argument_list|)
argument_list|)
operator|/
literal|2.0
operator|)
operator|*
operator|(
literal|1.0
operator|+
name|elasticity
operator|)
expr_stmt|;
comment|/*  If moving the point along it's directional vector 	   *  still satisfies the elasticity constraints (OR) 	   *  the point is a kink (in which case it can violate 	   *  elasticity completely. 	   */
if|if
condition|(
operator|(
operator|(
name|d_l
operator|<
name|max
operator|)
operator|&&
operator|(
name|d_r
operator|<
name|max
operator|)
operator|)
operator|||
name|pts
index|[
name|i
index|]
operator|.
name|kink
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|dx
operator|=
name|x
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dy
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|find_edge_xy
argument_list|(
name|iscissors
operator|->
name|edge_buf
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|dir
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|edge
argument_list|)
condition|)
name|pts
index|[
name|i
index|]
operator|.
name|stable
operator|=
literal|1
expr_stmt|;
else|else
name|moved
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|moved
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|post_process_boundary (Tool * tool)
name|post_process_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|left
decl_stmt|,
name|right
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  Relocate all points which did not manage to seek an edge    *  to the average of their edge-seeking neighbors    *  Also relocate points which failed to reach a stable    *  edge position.  These cases indicate that the point    *  somehow slipped through the cracks and is headed towards    *  lands unknown and most likely undesired.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
comment|/*   iff you uncomment this, change it to use the drawable width&height    pts[i].x = BOUNDS (pts[i].x, 0, (gdisp->gimage->width - 1));       pts[i].y = BOUNDS (pts[i].y, 0, (gdisp->gimage->height - 1));       pts[i].dx = BOUNDS (pts[i].dx, 0, (gdisp->gimage->width - 1));       pts[i].dy = BOUNDS (pts[i].dy, 0, (gdisp->gimage->height - 1)); */
if|if
condition|(
name|pts
index|[
name|i
index|]
operator|.
name|dir
operator|==
literal|0
operator|||
name|pts
index|[
name|i
index|]
operator|.
name|stable
operator|==
literal|0
condition|)
block|{
name|left
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|iscissors
operator|->
name|num_pts
operator|-
literal|1
else|:
name|i
operator|-
literal|1
expr_stmt|;
name|right
operator|=
operator|(
name|i
operator|==
operator|(
name|iscissors
operator|->
name|num_pts
operator|-
literal|1
operator|)
operator|)
condition|?
literal|0
else|:
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pts
index|[
name|left
index|]
operator|.
name|stable
operator|&&
name|pts
index|[
name|right
index|]
operator|.
name|stable
condition|)
block|{
name|pts
index|[
name|i
index|]
operator|.
name|dx
operator|=
operator|(
name|pts
index|[
name|left
index|]
operator|.
name|dx
operator|+
name|pts
index|[
name|right
index|]
operator|.
name|dx
operator|)
operator|/
literal|2.0
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|dy
operator|=
operator|(
name|pts
index|[
name|left
index|]
operator|.
name|dy
operator|+
name|pts
index|[
name|right
index|]
operator|.
name|dy
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
block|}
block|}
comment|/*  connect the boundary  */
name|pts
index|[
name|iscissors
operator|->
name|num_pts
index|]
operator|.
name|dx
operator|=
name|pts
index|[
literal|0
index|]
operator|.
name|dx
expr_stmt|;
name|pts
index|[
name|iscissors
operator|->
name|num_pts
index|]
operator|.
name|dy
operator|=
name|pts
index|[
literal|0
index|]
operator|.
name|dy
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezierify_boundary (Tool * tool)
name|bezierify_boundary
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|CRMatrix
name|geometry
decl_stmt|;
name|CRMatrix
name|bezier_geom
decl_stmt|;
name|BezierPoint
modifier|*
name|bez_pts
decl_stmt|;
name|BezierPoint
modifier|*
name|new_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|last_pt
decl_stmt|;
name|int
name|indices
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|num_pts
operator|<
literal|4
condition|)
block|{
name|message_box
argument_list|(
literal|"Boundary contains< 4 points!  Cannot bezierify."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|bez_pts
operator|=
name|NULL
expr_stmt|;
name|last_pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|<
literal|3
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|3
operator|)
else|:
operator|(
name|i
operator|-
literal|3
operator|)
expr_stmt|;
name|indices
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|<
literal|2
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|2
operator|)
else|:
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
name|indices
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|<
literal|1
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|1
operator|)
else|:
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|indices
index|[
literal|3
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|geometry
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|j
index|]
index|]
operator|.
name|dx
expr_stmt|;
name|geometry
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
name|pts
index|[
name|indices
index|[
name|j
index|]
index|]
operator|.
name|dy
expr_stmt|;
name|geometry
index|[
name|j
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|j
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|CR_compose
argument_list|(
name|CR_bezier_basis
argument_list|,
name|geometry
argument_list|,
name|bezier_geom
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|new_pt
operator|=
operator|(
name|BezierPoint
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_pt
condition|)
name|last_pt
operator|->
name|next
operator|=
name|new_pt
expr_stmt|;
else|else
name|bez_pts
operator|=
name|new_pt
expr_stmt|;
name|new_pt
operator|->
name|type
operator|=
operator|(
name|j
operator|==
literal|0
operator|)
condition|?
name|BEZIER_ANCHOR
else|:
name|BEZIER_CONTROL
expr_stmt|;
name|new_pt
operator|->
name|x
operator|=
name|bezier_geom
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
name|new_pt
operator|->
name|y
operator|=
name|bezier_geom
index|[
name|j
index|]
index|[
literal|1
index|]
expr_stmt|;
name|new_pt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_pt
operator|->
name|prev
operator|=
name|last_pt
expr_stmt|;
name|last_pt
operator|=
name|new_pt
expr_stmt|;
block|}
block|}
comment|/*  final anchor point  */
name|last_pt
operator|->
name|next
operator|=
name|bez_pts
expr_stmt|;
name|bez_pts
operator|->
name|prev
operator|=
name|last_pt
expr_stmt|;
comment|/*  Load this curve into the bezier tool  */
name|bezier_select_load
argument_list|(
name|gdisp
argument_list|,
name|bez_pts
argument_list|,
name|iscissors
operator|->
name|num_pts
operator|*
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|FREE_SELECT_MODE
expr_stmt|;
name|last_tool
operator|=
name|NULL
expr_stmt|;
comment|/*  	iscissors_reset (iscissors); */
block|}
end_function

begin_function
specifier|static
name|TempBuf
modifier|*
DECL|function|calculate_edge_map (GImage * gimage,int x,int y,int w,int h)
name|calculate_edge_map
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|TempBuf
modifier|*
name|edge_map
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|offx
decl_stmt|,
name|offy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|double
name|gradient
decl_stmt|;
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|xx
decl_stmt|,
name|yy
decl_stmt|;
name|unsigned
name|char
modifier|*
name|gr
decl_stmt|,
modifier|*
name|dh
decl_stmt|,
modifier|*
name|dv
decl_stmt|,
modifier|*
name|cm
decl_stmt|;
name|int
name|hmax
decl_stmt|,
name|vmax
decl_stmt|;
name|int
name|b
decl_stmt|;
name|double
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
comment|/*  allocate the new edge map  */
name|edge_map
operator|=
name|temp_buf_new
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|EDGE_WIDTH
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  calculate the extent of the search make a 1 pixel border */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|offx
operator|=
operator|(
name|x
operator|-
name|x1
operator|)
expr_stmt|;
name|offy
operator|=
operator|(
name|y
operator|-
name|y1
operator|)
expr_stmt|;
comment|/*  Set the drawable up as the source pixel region  */
comment|/*srcPR.bytes = drawable_bytes (drawable);   srcPR.w = width;   srcPR.h = height;   srcPR.rowstride = gimage->width * drawable_bytes (drawable);   srcPR.data = drawable_data (drawable) + y1 * srcPR.rowstride + x1 * srcPR.bytes;*/
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  Get the horizontal derivative  */
name|destPR
operator|.
name|data
operator|=
name|conv1
operator|+
name|MAX_CHANNELS
operator|*
operator|(
name|CONV_WIDTH
operator|*
name|offy
operator|+
name|offx
operator|)
expr_stmt|;
name|destPR
operator|.
name|rowstride
operator|=
name|CONV_WIDTH
operator|*
name|MAX_CHANNELS
expr_stmt|;
name|destPR
operator|.
name|tiles
operator|=
name|NULL
expr_stmt|;
name|destPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|destPR
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|destPR
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|destPR
operator|.
name|w
operator|=
name|w
expr_stmt|;
name|destPR
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|destPR
operator|.
name|dirty
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
name|gaussian_deriv
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|HORIZONTAL
argument_list|,
name|std_dev
argument_list|)
expr_stmt|;
comment|/*  Get the vertical derivative  */
name|destPR
operator|.
name|data
operator|=
name|conv2
operator|+
name|MAX_CHANNELS
operator|*
operator|(
name|CONV_WIDTH
operator|*
name|offy
operator|+
name|offx
operator|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
name|gaussian_deriv
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|VERTICAL
argument_list|,
name|std_dev
argument_list|)
expr_stmt|;
comment|/*  fill in the edge map  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|gr
operator|=
name|grad
operator|+
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|dh
operator|=
name|conv1
operator|+
name|destPR
operator|.
name|rowstride
operator|*
name|i
expr_stmt|;
name|dv
operator|=
name|conv2
operator|+
name|destPR
operator|.
name|rowstride
operator|*
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|hmax
operator|=
name|dh
index|[
literal|0
index|]
operator|-
literal|128
expr_stmt|;
name|vmax
operator|=
name|dv
index|[
literal|0
index|]
operator|-
literal|128
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<
name|drawable_bytes
argument_list|(
name|drawable
argument_list|)
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|dh
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|hmax
argument_list|)
condition|)
name|hmax
operator|=
name|dh
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|dv
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|vmax
argument_list|)
condition|)
name|vmax
operator|=
name|dv
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
block|}
comment|/*  store the information in the edge map  */
name|dh
index|[
literal|0
index|]
operator|=
name|hmax
operator|+
literal|128
expr_stmt|;
name|dv
index|[
literal|0
index|]
operator|=
name|vmax
operator|+
literal|128
expr_stmt|;
comment|/*  Find the gradient  */
name|gradient
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|hmax
argument_list|)
operator|+
name|SQR
argument_list|(
name|vmax
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Make the edge gradient map extend one pixel further  */
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|gr
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|gradient
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|(
name|width
operator|-
literal|1
operator|)
condition|)
name|gr
index|[
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|gradient
expr_stmt|;
operator|*
name|gr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|gradient
expr_stmt|;
name|dh
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dv
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
comment|/*  Make the edge gradient map extend one row further  */
name|memcpy
argument_list|(
name|grad
argument_list|,
name|grad
operator|+
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|grad
operator|+
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
operator|*
operator|(
name|CONV_HEIGHT
operator|+
literal|1
operator|)
argument_list|,
name|grad
operator|+
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
operator|*
operator|(
name|CONV_HEIGHT
operator|)
argument_list|,
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|cm
operator|=
name|temp_buf_data
argument_list|(
name|edge_map
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
name|gr
operator|=
name|grad
operator|+
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
operator|*
operator|(
name|i
operator|+
name|offy
operator|+
literal|1
operator|)
operator|+
operator|(
name|offx
operator|+
literal|1
operator|)
expr_stmt|;
name|dh
operator|=
name|conv1
operator|+
name|destPR
operator|.
name|rowstride
operator|*
operator|(
name|i
operator|+
name|offy
operator|)
operator|+
name|srcPR
operator|.
name|bytes
operator|*
name|offx
expr_stmt|;
name|dv
operator|=
name|conv2
operator|+
name|destPR
operator|.
name|rowstride
operator|*
operator|(
name|i
operator|+
name|offy
operator|)
operator|+
name|srcPR
operator|.
name|bytes
operator|*
name|offx
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
block|{
name|dx
operator|=
call|(
name|double
call|)
argument_list|(
name|dh
index|[
literal|0
index|]
operator|-
literal|128
argument_list|)
operator|/
literal|128.0
expr_stmt|;
name|dy
operator|=
call|(
name|double
call|)
argument_list|(
name|dv
index|[
literal|0
index|]
operator|-
literal|128
argument_list|)
operator|/
literal|128.0
expr_stmt|;
name|xx
operator|=
operator|(
name|dx
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|yy
operator|=
operator|(
name|dy
operator|>
literal|0
operator|)
condition|?
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
else|:
operator|-
operator|(
name|CONV_WIDTH
operator|+
literal|2
operator|)
expr_stmt|;
name|dx
operator|=
name|fabs
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|dy
operator|=
name|fabs
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|prev
operator|=
name|BILINEAR
argument_list|(
name|gr
index|[
literal|0
index|]
argument_list|,
name|gr
index|[
operator|-
name|xx
index|]
argument_list|,
name|gr
index|[
operator|-
name|yy
index|]
argument_list|,
name|gr
index|[
operator|-
name|xx
operator|-
name|yy
index|]
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|next
operator|=
name|BILINEAR
argument_list|(
name|gr
index|[
literal|0
index|]
argument_list|,
name|gr
index|[
name|xx
index|]
argument_list|,
name|gr
index|[
name|yy
index|]
argument_list|,
name|gr
index|[
name|xx
operator|+
name|yy
index|]
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
index|[
literal|0
index|]
operator|>=
name|prev
operator|&&
name|gr
index|[
literal|0
index|]
operator|>=
name|next
condition|)
operator|*
name|cm
operator|++
operator|=
name|gr
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|*
name|cm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*cm++ = dh[0];*/
comment|/*cm++ = dv[0];*/
name|dh
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|dv
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|gr
operator|++
expr_stmt|;
block|}
block|}
return|return
name|edge_map
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|construct_edge_map (Tool * tool,TempBuf * edge_buf)
name|construct_edge_map
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|TempBuf
modifier|*
name|edge_buf
parameter_list|)
block|{
name|TempBuf
modifier|*
name|block
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|int
name|offx
decl_stmt|,
name|offy
decl_stmt|;
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|long
name|sboffset
decl_stmt|;
name|long
name|dboffset
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
comment|/*#define ISCISSORS_STILL_DOES_NOT_WORK */
ifdef|#
directive|ifdef
name|ISCISSORS_STILL_DOES_NOT_WORK
name|FILE
modifier|*
name|dump
decl_stmt|;
endif|#
directive|endif
comment|/*  init some variables  */
name|srcPR
operator|.
name|bytes
operator|=
name|edge_buf
operator|->
name|bytes
expr_stmt|;
name|destPR
operator|.
name|rowstride
operator|=
name|edge_buf
operator|->
name|bytes
operator|*
name|edge_buf
operator|->
name|width
expr_stmt|;
name|destPR
operator|.
name|x
operator|=
name|edge_buf
operator|->
name|x
expr_stmt|;
name|destPR
operator|.
name|y
operator|=
name|edge_buf
operator|->
name|y
expr_stmt|;
name|destPR
operator|.
name|h
operator|=
name|edge_buf
operator|->
name|height
expr_stmt|;
name|destPR
operator|.
name|w
operator|=
name|edge_buf
operator|->
name|width
expr_stmt|;
name|destPR
operator|.
name|bytes
operator|=
name|edge_buf
operator|->
name|bytes
expr_stmt|;
name|srcPR
operator|.
name|tiles
operator|=
name|destPR
operator|.
name|tiles
operator|=
name|NULL
expr_stmt|;
name|y
operator|=
name|edge_buf
operator|->
name|y
expr_stmt|;
name|endx
operator|=
name|edge_buf
operator|->
name|x
operator|+
name|edge_buf
operator|->
name|width
expr_stmt|;
name|endy
operator|=
name|edge_buf
operator|->
name|y
operator|+
name|edge_buf
operator|->
name|height
expr_stmt|;
name|row
operator|=
operator|(
name|y
operator|/
name|BLOCK_HEIGHT
operator|)
expr_stmt|;
comment|/*  patch the buffer with the saved portions of the image  */
while|while
condition|(
name|y
operator|<
name|endy
condition|)
block|{
name|x
operator|=
name|edge_buf
operator|->
name|x
expr_stmt|;
name|col
operator|=
operator|(
name|x
operator|/
name|BLOCK_WIDTH
operator|)
expr_stmt|;
comment|/*  calculate y offset into this row of blocks  */
name|offy
operator|=
operator|(
name|y
operator|-
name|row
operator|*
name|BLOCK_HEIGHT
operator|)
expr_stmt|;
name|y2
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|*
name|BLOCK_HEIGHT
expr_stmt|;
if|if
condition|(
name|y2
operator|>
name|endy
condition|)
name|y2
operator|=
name|endy
expr_stmt|;
name|srcPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|endx
condition|)
block|{
name|index
operator|=
name|row
operator|*
name|horz_blocks
operator|+
name|col
expr_stmt|;
name|block
operator|=
name|edge_map_blocks
index|[
name|index
index|]
expr_stmt|;
comment|/*  If the block exists, patch it into buf  */
if|if
condition|(
name|block
condition|)
block|{
name|srcPR
operator|.
name|x
operator|=
name|block
operator|->
name|x
expr_stmt|;
name|srcPR
operator|.
name|y
operator|=
name|block
operator|->
name|y
expr_stmt|;
comment|/* calculate x offset into the block  */
name|offx
operator|=
operator|(
name|x
operator|-
name|col
operator|*
name|BLOCK_WIDTH
operator|)
expr_stmt|;
name|x2
operator|=
operator|(
name|col
operator|+
literal|1
operator|)
operator|*
name|BLOCK_WIDTH
expr_stmt|;
if|if
condition|(
name|x2
operator|>
name|endx
condition|)
name|x2
operator|=
name|endx
expr_stmt|;
name|srcPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x
expr_stmt|;
comment|/* i Am going to special case this thing */
comment|/*  Calculate the offsets into source buffer  */
name|srcPR
operator|.
name|rowstride
operator|=
name|srcPR
operator|.
name|bytes
operator|*
name|block
operator|->
name|width
expr_stmt|;
name|sboffset
operator|=
name|offy
expr_stmt|;
name|sboffset
operator|*=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|sboffset
operator|+=
name|offx
operator|*
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|srcPR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|block
argument_list|)
operator|+
name|sboffset
expr_stmt|;
comment|/*  Calculate offset into destination buffer */
name|dboffset
operator|=
operator|(
operator|(
name|edge_buf
operator|->
name|y
operator|>
name|srcPR
operator|.
name|y
operator|)
condition|?
operator|(
literal|0
operator|)
else|:
operator|(
name|srcPR
operator|.
name|y
operator|-
name|edge_buf
operator|->
name|y
operator|)
operator|)
expr_stmt|;
name|dboffset
operator|*=
name|destPR
operator|.
name|rowstride
expr_stmt|;
name|dboffset
operator|+=
operator|(
operator|(
name|edge_buf
operator|->
name|x
operator|<
name|srcPR
operator|.
name|x
operator|)
condition|?
operator|(
operator|(
name|srcPR
operator|.
name|x
operator|-
name|edge_buf
operator|->
name|x
operator|)
operator|*
name|destPR
operator|.
name|bytes
operator|)
else|:
operator|(
operator|(
name|edge_buf
operator|->
name|x
operator|-
name|srcPR
operator|.
name|x
operator|)
operator|*
name|destPR
operator|.
name|bytes
operator|)
operator|)
expr_stmt|;
name|destPR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|edge_buf
argument_list|)
operator|+
name|dboffset
expr_stmt|;
comment|/* look at this debuggin info. 	   printf("Pixel region dump (Y %d %d) X %d %d\n", y, endy, x, endx); 	   printf("index(%d) X: %d Y: %d ox: %d oy: %d \n", index, x, y, offx, offy); 	   printf("soff: %d  doff: %d\n",sboffset,dboffset); 	   printf("s.x:%d s.y:%d s.w:%d s.h:%d s.rs:%d s.b%d\n",srcPR.x, srcPR.y, srcPR.w, srcPR.h,srcPR.rowstride, srcPR.bytes); 	   printf("d.x:%d d.y:%d d.w:%d d.h:%d d.rs:%d d.b%d\n",destPR.x,destPR.y,destPR.w,destPR.h,destPR.rowstride, destPR.bytes); 	   printf("e.x:%d e.y:%d e.w:%d e.h:%d\n",edge_buf->x,edge_buf->y,edge_buf->width,edge_buf->height); 	   printf("sdata:%d ddata:%d\n",srcPR.data, destPR.data); 	   printf("bdata:%d edata:%d\n", block->data, edge_buf->data); 	   if((dboffset + (srcPR.h*destPR.rowstride))> (edge_buf->height * edge_buf -> width)) printf ("ERROR\n"); 	   */
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
block|}
name|col
operator|++
expr_stmt|;
name|x
operator|=
name|col
operator|*
name|BLOCK_WIDTH
expr_stmt|;
block|}
name|row
operator|++
expr_stmt|;
name|y
operator|=
name|row
operator|*
name|BLOCK_HEIGHT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISCISSORS_STILL_DOES_NOT_WORK
comment|/*  dump the edge buffer for debugging*/
name|dump
operator|=
name|fopen
argument_list|(
literal|"dump"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"P5\n%d %d\n255\n"
argument_list|,
name|edge_buf
operator|->
name|width
argument_list|,
name|edge_buf
operator|->
name|height
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|edge_buf
operator|->
name|data
argument_list|,
name|edge_buf
operator|->
name|width
operator|*
name|edge_buf
operator|->
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|,
name|dump
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|dump
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  edge map blocks utility functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|set_edge_map_blocks (void * gimage_ptr,int x,int y,int w,int h)
name|set_edge_map_blocks
parameter_list|(
name|void
modifier|*
name|gimage_ptr
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|int
name|startx
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|width
operator|=
name|height
operator|=
literal|0
expr_stmt|;
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|gimage_ptr
expr_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|width
operator|=
name|drawable_width
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|height
operator|=
name|drawable_height
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|startx
operator|=
name|x
expr_stmt|;
name|endx
operator|=
name|x
operator|+
name|w
expr_stmt|;
name|endy
operator|=
name|y
operator|+
name|h
expr_stmt|;
name|row
operator|=
name|y
operator|/
name|BLOCK_HEIGHT
expr_stmt|;
while|while
condition|(
name|y
operator|<
name|endy
condition|)
block|{
name|col
operator|=
name|x
operator|/
name|BLOCK_WIDTH
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|endx
condition|)
block|{
name|index
operator|=
name|row
operator|*
name|horz_blocks
operator|+
name|col
expr_stmt|;
comment|/*  If the block doesn't exist, create and initialize it  */
if|if
condition|(
operator|!
name|edge_map_blocks
index|[
name|index
index|]
condition|)
block|{
comment|/*  determine memory efficient width and height of block  */
name|x1
operator|=
name|col
operator|*
name|BLOCK_WIDTH
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x1
operator|+
name|BLOCK_WIDTH
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|y1
operator|=
name|row
operator|*
name|BLOCK_HEIGHT
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y1
operator|+
name|BLOCK_HEIGHT
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
comment|/*  calculate a edge map for the specified portion of the gimage  */
name|edge_map_blocks
index|[
name|index
index|]
operator|=
name|calculate_edge_map
argument_list|(
name|gimage
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|col
operator|++
expr_stmt|;
name|x
operator|=
name|col
operator|*
name|BLOCK_WIDTH
expr_stmt|;
block|}
name|row
operator|++
expr_stmt|;
name|y
operator|=
name|row
operator|*
name|BLOCK_HEIGHT
expr_stmt|;
name|x
operator|=
name|startx
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|allocate_edge_map_blocks (int block_width,int block_height,int image_width,int image_height)
name|allocate_edge_map_blocks
parameter_list|(
name|int
name|block_width
parameter_list|,
name|int
name|block_height
parameter_list|,
name|int
name|image_width
parameter_list|,
name|int
name|image_height
parameter_list|)
block|{
name|int
name|num_blocks
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  calculate the number of rows and cols in the edge map block grid  */
name|horz_blocks
operator|=
operator|(
name|image_width
operator|+
name|block_width
operator|-
literal|1
operator|)
operator|/
name|block_width
expr_stmt|;
name|vert_blocks
operator|=
operator|(
name|image_height
operator|+
name|block_height
operator|-
literal|1
operator|)
operator|/
name|block_height
expr_stmt|;
comment|/*  Allocate the array  */
name|num_blocks
operator|=
name|horz_blocks
operator|*
name|vert_blocks
expr_stmt|;
name|edge_map_blocks
operator|=
operator|(
name|TempBuf
operator|*
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TempBuf
operator|*
argument_list|)
operator|*
name|num_blocks
argument_list|)
expr_stmt|;
comment|/*  Initialize the array  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
name|edge_map_blocks
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|free_edge_map_blocks ()
name|free_edge_map_blocks
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
if|if
condition|(
operator|!
name|edge_map_blocks
condition|)
return|return;
name|num_blocks
operator|=
name|vert_blocks
operator|*
name|horz_blocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|edge_map_blocks
index|[
name|i
index|]
condition|)
block|{
comment|/*	printf("tbf: index %d %d   ",i, num_blocks); 	printf("X:%d ",edge_map_blocks[i]->x); 	printf("Y:%d ",edge_map_blocks[i]->y); 	printf("W:%d ",edge_map_blocks[i]->width); 	printf("H:%d ",edge_map_blocks[i]->height); 	printf("data:%d ",edge_map_blocks[i]->data); 	printf("\n"); */
name|temp_buf_free
argument_list|(
name|edge_map_blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|edge_map_blocks
argument_list|)
expr_stmt|;
name|edge_map_blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************/
end_comment

begin_comment
comment|/*   Functions for gaussian convolutions     */
end_comment

begin_comment
comment|/*********************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gaussian_deriv (PixelRegion * input,PixelRegion * output,int type,double std_dev)
name|gaussian_deriv
parameter_list|(
name|PixelRegion
modifier|*
name|input
parameter_list|,
name|PixelRegion
modifier|*
name|output
parameter_list|,
name|int
name|type
parameter_list|,
name|double
name|std_dev
parameter_list|)
block|{
name|long
name|width
decl_stmt|,
name|height
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|curve_array
index|[
literal|9
index|]
decl_stmt|;
name|int
name|sum_array
index|[
literal|9
index|]
decl_stmt|;
name|int
modifier|*
name|curve
decl_stmt|;
name|int
modifier|*
name|sum
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|initial_p
index|[
name|MAX_CHANNELS
index|]
decl_stmt|,
name|initial_m
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|length
operator|=
literal|3
expr_stmt|;
comment|/*  static for speed  */
name|width
operator|=
name|input
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|input
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|input
operator|->
name|bytes
expr_stmt|;
comment|/*  initialize  */
name|curve
operator|=
name|curve_array
operator|+
name|length
expr_stmt|;
name|sum
operator|=
name|sum_array
operator|+
name|length
expr_stmt|;
name|buf
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|MAXIMUM
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VERTICAL
condition|)
block|{
name|make_curve_d
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
literal|0
index|]
operator|*
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|make_curve
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
expr_stmt|;
block|}
name|src
operator|=
name|input
operator|->
name|data
expr_stmt|;
name|dest
operator|=
name|output
operator|->
name|data
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|sp
operator|=
name|src
expr_stmt|;
name|dp
operator|=
name|dest
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|src
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|initial_p
index|[
name|chan
index|]
operator|=
name|sp
index|[
name|chan
index|]
expr_stmt|;
name|initial_m
index|[
name|chan
index|]
operator|=
name|sp
index|[
operator|(
name|height
operator|-
literal|1
operator|)
operator|*
name|input
operator|->
name|rowstride
operator|+
name|chan
index|]
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|start
operator|=
operator|(
name|row
operator|<
name|length
operator|)
condition|?
operator|-
name|row
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
name|height
operator|<=
operator|(
name|row
operator|+
name|length
operator|)
operator|)
condition|?
operator|(
name|height
operator|-
name|row
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|s
operator|=
name|sp
operator|+
operator|(
name|start
operator|*
name|input
operator|->
name|rowstride
operator|)
operator|+
name|chan
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|val
operator|+=
operator|*
name|s
operator|*
name|curve
index|[
name|i
operator|++
index|]
expr_stmt|;
name|s
operator|+=
name|input
operator|->
name|rowstride
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|val
operator|/
name|total
expr_stmt|;
block|}
name|sp
operator|+=
name|input
operator|->
name|rowstride
expr_stmt|;
block|}
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VERTICAL
condition|)
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|b
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
operator|+
literal|128
expr_stmt|;
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|>
literal|255
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|<
literal|0
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|dp
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|output
operator|->
name|rowstride
expr_stmt|;
block|}
else|else
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|>
literal|255
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|<
literal|0
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|dp
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|output
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|HORIZONTAL
condition|)
block|{
name|make_curve_d
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
literal|0
index|]
operator|*
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|make_curve
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
expr_stmt|;
block|}
name|src
operator|=
name|output
operator|->
name|data
expr_stmt|;
name|dest
operator|=
name|output
operator|->
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|sp
operator|=
name|src
expr_stmt|;
name|dp
operator|=
name|dest
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|src
operator|+=
name|output
operator|->
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|output
operator|->
name|rowstride
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|initial_p
index|[
name|chan
index|]
operator|=
name|sp
index|[
name|chan
index|]
expr_stmt|;
name|initial_m
index|[
name|chan
index|]
operator|=
name|sp
index|[
operator|(
name|width
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|chan
index|]
expr_stmt|;
block|}
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|start
operator|=
operator|(
name|col
operator|<
name|length
operator|)
condition|?
operator|-
name|col
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
name|width
operator|<=
operator|(
name|col
operator|+
name|length
operator|)
operator|)
condition|?
operator|(
name|width
operator|-
name|col
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|s
operator|=
name|sp
operator|+
operator|(
name|start
operator|*
name|bytes
operator|)
operator|+
name|chan
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|val
operator|+=
operator|*
name|s
operator|*
name|curve
index|[
name|i
operator|++
index|]
expr_stmt|;
name|s
operator|+=
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|val
operator|/
name|total
expr_stmt|;
block|}
name|sp
operator|+=
name|bytes
expr_stmt|;
block|}
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|HORIZONTAL
condition|)
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|b
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
operator|+
literal|128
expr_stmt|;
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|>
literal|255
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|<
literal|0
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|dp
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|>
literal|255
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
name|chan
index|]
operator|<
literal|0
condition|)
name|dp
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|dp
index|[
name|chan
index|]
operator|=
name|b
index|[
name|chan
index|]
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The equations: g(r) = exp (- r^2 / (2 * sigma^2))  *                   r = sqrt (x^2 + y ^2)  */
end_comment

begin_function
specifier|static
name|void
DECL|function|make_curve (int * curve,int * sum,double sigma,int length)
name|make_curve
parameter_list|(
name|int
modifier|*
name|curve
parameter_list|,
name|int
modifier|*
name|sum
parameter_list|,
name|double
name|sigma
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|double
name|sigma2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sigma2
operator|=
name|sigma
operator|*
name|sigma
expr_stmt|;
name|curve
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curve
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|exp
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
operator|(
literal|2
operator|*
name|sigma2
operator|)
argument_list|)
operator|*
literal|255
argument_list|)
expr_stmt|;
name|curve
index|[
operator|-
name|i
index|]
operator|=
name|curve
index|[
name|i
index|]
expr_stmt|;
block|}
name|sum
index|[
operator|-
name|length
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|length
operator|+
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
name|sum
index|[
name|i
index|]
operator|=
name|sum
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The equations: d_g(r) = -r * exp (- r^2 / (2 * sigma^2)) / sigma^2  *                   r = sqrt (x^2 + y ^2)  */
end_comment

begin_function
specifier|static
name|void
DECL|function|make_curve_d (int * curve,int * sum,double sigma,int length)
name|make_curve_d
parameter_list|(
name|int
modifier|*
name|curve
parameter_list|,
name|int
modifier|*
name|sum
parameter_list|,
name|double
name|sigma
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|double
name|sigma2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sigma2
operator|=
name|sigma
operator|*
name|sigma
expr_stmt|;
name|curve
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curve
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|i
operator|*
name|exp
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
operator|(
literal|2
operator|*
name|sigma2
operator|)
argument_list|)
operator|/
name|sigma2
operator|)
operator|*
literal|255
argument_list|)
expr_stmt|;
name|curve
index|[
operator|-
name|i
index|]
operator|=
operator|-
name|curve
index|[
name|i
index|]
expr_stmt|;
block|}
name|sum
index|[
operator|-
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sum
index|[
operator|-
name|length
operator|+
name|i
index|]
operator|=
name|sum
index|[
operator|-
name|length
operator|+
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
operator|-
name|length
operator|+
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sum
index|[
name|i
index|]
operator|=
name|sum
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************/
end_comment

begin_comment
comment|/*   Functions for Catmull-Rom area conversion */
end_comment

begin_comment
comment|/***********************************************/
end_comment

begin_decl_stmt
DECL|variable|CR_scanlines
specifier|static
name|GSList
modifier|*
modifier|*
name|CR_scanlines
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|start_convert
specifier|static
name|int
name|start_convert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|width
DECL|variable|height
specifier|static
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lastx
specifier|static
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lasty
specifier|static
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|CR_convert (Iscissors * iscissors,GDisplay * gdisp,int antialias)
name|CR_convert
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|antialias
parameter_list|)
block|{
name|int
name|indices
index|[
literal|4
index|]
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|draw_type
decl_stmt|;
name|int
modifier|*
name|vals
decl_stmt|,
name|val
decl_stmt|;
name|int
name|x
decl_stmt|,
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|PixelRegion
name|maskPR
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
comment|/* destroy previous region */
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
block|{
name|channel_delete
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get the new mask's maximum extents */
if|if
condition|(
name|antialias
condition|)
block|{
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|draw_type
operator|=
name|AA_IMAGE_COORDS
expr_stmt|;
comment|/* allocate value array  */
name|vals
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|width
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
expr_stmt|;
name|draw_type
operator|=
name|IMAGE_COORDS
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new mask */
name|iscissors
operator|->
name|mask
operator|=
name|channel_new_mask
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|ID
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* allocate room for the scanlines */
name|CR_scanlines
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GSList
operator|*
argument_list|)
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* zero out the scanlines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
name|CR_scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* scan convert the curve */
name|start_convert
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iscissors
operator|->
name|num_pts
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|<
literal|3
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|3
operator|)
else|:
operator|(
name|i
operator|-
literal|3
operator|)
expr_stmt|;
name|indices
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|<
literal|2
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|2
operator|)
else|:
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
name|indices
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|<
literal|1
operator|)
condition|?
operator|(
name|iscissors
operator|->
name|num_pts
operator|+
name|i
operator|-
literal|1
operator|)
else|:
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|indices
index|[
literal|3
index|]
operator|=
name|i
expr_stmt|;
name|iscissors_draw_CR
argument_list|(
name|gdisp
argument_list|,
name|iscissors
argument_list|,
name|pts
argument_list|,
name|indices
argument_list|,
name|draw_type
argument_list|)
expr_stmt|;
block|}
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|iscissors
operator|->
name|mask
operator|->
name|drawable
operator|.
name|tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iscissors
operator|->
name|mask
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|iscissors
operator|->
name|mask
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|=
name|CR_scanlines
index|[
name|i
index|]
expr_stmt|;
comment|/*  zero the vals array  */
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
name|i
operator|%
name|SUPERSAMPLE
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|x
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|w
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|w
operator|+
name|x
operator|>
name|width
condition|)
name|w
operator|=
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|antialias
condition|)
name|channel_add_segment
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|i
argument_list|,
name|w
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
name|vals
index|[
name|j
operator|+
name|x
index|]
operator|+=
literal|255
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|SUPERSAMPLE
operator|)
condition|)
block|{
name|b
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|+=
name|SUPERSAMPLE
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SUPERSAMPLE
condition|;
name|x
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
operator|*
name|b
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|/
name|SUPERSAMPLE2
argument_list|)
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|maskPR
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|/
name|SUPERSAMPLE
operator|)
argument_list|,
name|iscissors
operator|->
name|mask
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|CR_scanlines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CR_scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|CR_scanlines
argument_list|)
expr_stmt|;
name|CR_scanlines
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|CR_convert_points (GdkPoint * points,int npoints)
name|CR_convert_points
parameter_list|(
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|start_convert
condition|)
name|start_convert
operator|=
literal|0
expr_stmt|;
else|else
name|CR_convert_line
argument_list|(
name|CR_scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|npoints
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|CR_convert_line
argument_list|(
name|CR_scanlines
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|CR_convert_line (GSList ** scanlines,int x1,int y1,int x2,int y2)
name|CR_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|error
decl_stmt|,
name|inc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|float
name|slope
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y2
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
operator|+
operator|(
literal|0
operator|-
name|y2
operator|)
operator|/
name|slope
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y2
operator|>=
name|height
condition|)
block|{
if|if
condition|(
name|y1
operator|>=
name|height
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y2
operator|=
name|height
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
operator|(
name|height
operator|-
name|y1
operator|)
operator|/
name|slope
expr_stmt|;
name|y2
operator|=
name|height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|scanlines
operator|=
operator|&
name|scanlines
index|[
name|y1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|dx
else|:
name|dx
operator|)
operator|>
operator|(
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
operator|)
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|dx
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|x1
operator|!=
name|x2
condition|)
block|{
name|error
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dx
expr_stmt|;
operator|*
name|scanlines
operator|=
name|CR_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
block|}
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
operator|-
name|dy
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|y1
operator|++
operator|<
name|y2
condition|)
block|{
operator|*
name|scanlines
operator|=
name|CR_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
name|error
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dy
expr_stmt|;
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|CR_insert_in_list (GSList * list,int x)
name|CR_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|GSList
modifier|*
name|orig
init|=
name|list
decl_stmt|;
name|GSList
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
call|(
name|gpointer
call|)
argument_list|(
operator|(
name|long
operator|)
name|x
argument_list|)
argument_list|)
return|;
while|while
condition|(
name|list
condition|)
block|{
name|rest
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|long
operator|)
name|list
operator|->
name|data
condition|)
block|{
name|rest
operator|=
name|g_slist_prepend
argument_list|(
name|rest
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|list
operator|->
name|data
operator|=
call|(
name|gpointer
call|)
argument_list|(
operator|(
name|long
operator|)
name|x
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rest
condition|)
block|{
name|g_slist_append
argument_list|(
name|list
argument_list|,
call|(
name|gpointer
call|)
argument_list|(
operator|(
name|long
operator|)
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|orig
return|;
block|}
end_function

end_unit

