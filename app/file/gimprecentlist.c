begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Recent File Storage,  * see http://freedesktop.org/Standards/recent-file-spec/  *  * This code is taken from libegg and has been adapted to the GIMP needs.  * The original author is James Willcox<jwillcox@cs.indiana.edu>,  * responsible for bugs in this version is Sven Neumann<sven@gimp.org>.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
DECL|macro|_SVID_SOURCE
define|#
directive|define
name|_SVID_SOURCE
end_define

begin_comment
DECL|macro|_SVID_SOURCE
comment|/* need lockf() and F_TLOCK/F_ULOCK */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|G_OS_WIN32
end_ifndef

begin_comment
comment|/* This code doesn't compile on win32 and the use of                      * the freedesktop standard doesn't make much sense                      * there anyway. If someone wants to contribute a win32                      * specific implementation, that would be appreciated.                      */
end_comment

begin_include
include|#
directive|include
file|"config/config-types.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpxmlparser.h"
end_include

begin_include
include|#
directive|include
file|"gimprecentitem.h"
end_include

begin_include
include|#
directive|include
file|"gimprecentlist.h"
end_include

begin_define
DECL|macro|GIMP_RECENT_LIST_FILE_NAME
define|#
directive|define
name|GIMP_RECENT_LIST_FILE_NAME
value|".recently-used"
end_define

begin_define
DECL|macro|GIMP_RECENT_LIST_MAX_ITEMS
define|#
directive|define
name|GIMP_RECENT_LIST_MAX_ITEMS
value|500
end_define

begin_define
DECL|macro|GIMP_RECENT_LIST_GROUP_GIMP
define|#
directive|define
name|GIMP_RECENT_LIST_GROUP_GIMP
value|"gimp"
end_define

begin_define
DECL|macro|GIMP_RECENT_ITEM_LIST_UNREF (list)
define|#
directive|define
name|GIMP_RECENT_ITEM_LIST_UNREF
parameter_list|(
name|list
parameter_list|)
define|\
value|g_list_foreach (list, (GFunc) gimp_recent_item_unref, NULL);  \   g_list_free (list);
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27bc4bc00108
block|{
DECL|member|states
name|GSList
modifier|*
name|states
decl_stmt|;
DECL|member|items
name|GList
modifier|*
name|items
decl_stmt|;
DECL|member|current_item
name|GimpRecentItem
modifier|*
name|current_item
decl_stmt|;
DECL|typedef|ParseInfo
block|}
name|ParseInfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27bc4bc00203
block|{
DECL|enumerator|STATE_START
name|STATE_START
block|,
DECL|enumerator|STATE_RECENT_FILES
name|STATE_RECENT_FILES
block|,
DECL|enumerator|STATE_RECENT_ITEM
name|STATE_RECENT_ITEM
block|,
DECL|enumerator|STATE_URI
name|STATE_URI
block|,
DECL|enumerator|STATE_MIME_TYPE
name|STATE_MIME_TYPE
block|,
DECL|enumerator|STATE_TIMESTAMP
name|STATE_TIMESTAMP
block|,
DECL|enumerator|STATE_PRIVATE
name|STATE_PRIVATE
block|,
DECL|enumerator|STATE_GROUPS
name|STATE_GROUPS
block|,
DECL|enumerator|STATE_GROUP
name|STATE_GROUP
DECL|typedef|ParseState
block|}
name|ParseState
typedef|;
end_typedef

begin_define
DECL|macro|TAG_RECENT_FILES
define|#
directive|define
name|TAG_RECENT_FILES
value|"RecentFiles"
end_define

begin_define
DECL|macro|TAG_RECENT_ITEM
define|#
directive|define
name|TAG_RECENT_ITEM
value|"RecentItem"
end_define

begin_define
DECL|macro|TAG_URI
define|#
directive|define
name|TAG_URI
value|"URI"
end_define

begin_define
DECL|macro|TAG_MIME_TYPE
define|#
directive|define
name|TAG_MIME_TYPE
value|"Mime-Type"
end_define

begin_define
DECL|macro|TAG_TIMESTAMP
define|#
directive|define
name|TAG_TIMESTAMP
value|"Timestamp"
end_define

begin_define
DECL|macro|TAG_PRIVATE
define|#
directive|define
name|TAG_PRIVATE
value|"Private"
end_define

begin_define
DECL|macro|TAG_GROUPS
define|#
directive|define
name|TAG_GROUPS
value|"Groups"
end_define

begin_define
DECL|macro|TAG_GROUP
define|#
directive|define
name|TAG_GROUP
value|"Group"
end_define

begin_function_decl
specifier|static
name|void
name|start_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|text_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|markup_parser
specifier|static
specifier|const
name|GMarkupParser
name|markup_parser
init|=
block|{
name|start_element_handler
block|,
name|end_element_handler
block|,
name|text_handler
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|gimp_recent_list_add_new_groups (GimpRecentItem * item,GimpRecentItem * upd_item)
name|gimp_recent_list_add_new_groups
parameter_list|(
name|GimpRecentItem
modifier|*
name|item
parameter_list|,
name|GimpRecentItem
modifier|*
name|upd_item
parameter_list|)
block|{
specifier|const
name|GList
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|gimp_recent_item_get_groups
argument_list|(
name|upd_item
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|group
init|=
name|tmp
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_recent_item_in_group
argument_list|(
name|item
argument_list|,
name|group
argument_list|)
condition|)
name|gimp_recent_item_add_group
argument_list|(
name|item
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_update_item (GList * items,GimpRecentItem * upd_item)
name|gimp_recent_list_update_item
parameter_list|(
name|GList
modifier|*
name|items
parameter_list|,
name|GimpRecentItem
modifier|*
name|upd_item
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|uri
init|=
name|gimp_recent_item_get_uri
argument_list|(
name|upd_item
argument_list|)
decl_stmt|;
name|GList
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|items
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|GimpRecentItem
modifier|*
name|item
init|=
name|tmp
operator|->
name|data
decl_stmt|;
comment|/*  gnome_vfs_uris_match (gimp_recent_item_get_uri (item), uri)  */
if|if
condition|(
name|strcmp
argument_list|(
name|gimp_recent_item_get_uri
argument_list|(
name|item
argument_list|)
argument_list|,
name|uri
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gimp_recent_item_set_timestamp
argument_list|(
name|item
argument_list|,
operator|(
name|time_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_recent_list_add_new_groups
argument_list|(
name|item
argument_list|,
name|upd_item
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_info_init (ParseInfo * info)
name|parse_info_init
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|states
operator|=
name|g_slist_prepend
argument_list|(
name|NULL
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|STATE_START
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|items
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_info_free (ParseInfo * info)
name|parse_info_free
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_slist_free
argument_list|(
name|info
operator|->
name|states
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|push_state (ParseInfo * info,ParseState state)
name|push_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|,
name|ParseState
name|state
parameter_list|)
block|{
name|info
operator|->
name|states
operator|=
name|g_slist_prepend
argument_list|(
name|info
operator|->
name|states
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|pop_state (ParseInfo * info)
name|pop_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|info
operator|->
name|states
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|states
operator|=
name|g_slist_remove
argument_list|(
name|info
operator|->
name|states
argument_list|,
name|info
operator|->
name|states
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ParseState
DECL|function|peek_state (ParseInfo * info)
name|peek_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|info
operator|->
name|states
operator|!=
name|NULL
argument_list|,
name|STATE_START
argument_list|)
expr_stmt|;
return|return
name|GPOINTER_TO_INT
argument_list|(
name|info
operator|->
name|states
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_define
DECL|macro|ELEMENT_IS (name)
define|#
directive|define
name|ELEMENT_IS
parameter_list|(
name|name
parameter_list|)
value|(strcmp (element_name, (name)) == 0)
end_define

begin_function
specifier|static
name|void
DECL|function|start_element_handler (GMarkupParseContext * context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,gpointer user_data,GError ** error)
name|start_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_RECENT_FILES
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_RECENT_FILES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_RECENT_ITEM
argument_list|)
condition|)
block|{
name|info
operator|->
name|current_item
operator|=
name|gimp_recent_item_new
argument_list|()
expr_stmt|;
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_RECENT_ITEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_URI
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_URI
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_MIME_TYPE
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_MIME_TYPE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_TIMESTAMP
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_TIMESTAMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_PRIVATE
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_PRIVATE
argument_list|)
expr_stmt|;
name|gimp_recent_item_set_private
argument_list|(
name|info
operator|->
name|current_item
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_GROUPS
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_GROUPS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELEMENT_IS
argument_list|(
name|TAG_GROUP
argument_list|)
condition|)
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_GROUP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|end_element_handler (GMarkupParseContext * context,const gchar * element_name,gpointer user_data,GError ** error)
name|end_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|peek_state
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|STATE_RECENT_ITEM
case|:
name|info
operator|->
name|items
operator|=
name|g_list_prepend
argument_list|(
name|info
operator|->
name|items
argument_list|,
name|info
operator|->
name|current_item
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|pop_state
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|text_handler (GMarkupParseContext * context,const gchar * text,gsize text_len,gpointer user_data,GError ** error)
name|text_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|peek_state
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|STATE_START
case|:
case|case
name|STATE_RECENT_FILES
case|:
case|case
name|STATE_RECENT_ITEM
case|:
case|case
name|STATE_PRIVATE
case|:
case|case
name|STATE_GROUPS
case|:
break|break;
case|case
name|STATE_URI
case|:
name|gimp_recent_item_set_uri
argument_list|(
name|info
operator|->
name|current_item
argument_list|,
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_MIME_TYPE
case|:
name|gimp_recent_item_set_mime_type
argument_list|(
name|info
operator|->
name|current_item
argument_list|,
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_TIMESTAMP
case|:
name|gimp_recent_item_set_timestamp
argument_list|(
name|info
operator|->
name|current_item
argument_list|,
operator|(
name|time_t
operator|)
name|atoi
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_GROUP
case|:
name|gimp_recent_item_add_group
argument_list|(
name|info
operator|->
name|current_item
argument_list|,
name|text
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_recent_list_enforce_limit (GList * list,gint limit)
name|gimp_recent_list_enforce_limit
parameter_list|(
name|GList
modifier|*
name|list
parameter_list|,
name|gint
name|limit
parameter_list|)
block|{
name|gint
name|len
decl_stmt|;
name|GList
modifier|*
name|end
decl_stmt|;
comment|/* limit< 0 means unlimited */
if|if
condition|(
name|limit
operator|<=
literal|0
condition|)
return|return;
name|len
operator|=
name|g_list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|limit
condition|)
block|{
name|GList
modifier|*
name|next
decl_stmt|;
name|end
operator|=
name|g_list_nth
argument_list|(
name|list
argument_list|,
name|limit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next
operator|=
name|end
operator|->
name|next
expr_stmt|;
name|end
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|GIMP_RECENT_ITEM_LIST_UNREF
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|gimp_recent_list_read (gint fd)
name|gimp_recent_list_read
parameter_list|(
name|gint
name|fd
parameter_list|)
block|{
name|GimpXmlParser
modifier|*
name|parser
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|ParseInfo
name|info
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|parse_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|parser
operator|=
name|gimp_xml_parser_new
argument_list|(
operator|&
name|markup_parser
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_xml_parser_parse_fd
argument_list|(
name|parser
argument_list|,
name|fd
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|g_printerr
argument_list|(
literal|"%s"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_error_free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|gimp_xml_parser_free
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|list
operator|=
name|info
operator|.
name|items
expr_stmt|;
name|parse_info_free
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
name|g_list_reverse
argument_list|(
name|list
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_write_raw (gint fd,const gchar * content,gssize len)
name|gimp_recent_list_write_raw
parameter_list|(
name|gint
name|fd
parameter_list|,
specifier|const
name|gchar
modifier|*
name|content
parameter_list|,
name|gssize
name|len
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|gssize
name|remaining
init|=
name|len
decl_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|g_warning
argument_list|(
literal|"Couldn't stat XML document."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|off_t
operator|)
name|len
operator|<
name|sbuf
operator|.
name|st_size
condition|)
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|gssize
name|written
init|=
name|write
argument_list|(
name|fd
argument_list|,
name|content
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
return|return
name|FALSE
return|;
name|remaining
operator|-=
name|written
expr_stmt|;
block|}
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_write (gint fd,GList * list)
name|gimp_recent_list_write
parameter_list|(
name|gint
name|fd
parameter_list|,
name|GList
modifier|*
name|list
parameter_list|)
block|{
name|GString
modifier|*
name|string
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
literal|"<?xml version=\"1.0\"?>\n"
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_RECENT_FILES
literal|">\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|GimpRecentItem
modifier|*
name|item
init|=
name|list
operator|->
name|data
decl_stmt|;
specifier|const
name|GList
modifier|*
name|groups
decl_stmt|;
name|gchar
modifier|*
name|uri
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|mime_type
decl_stmt|;
name|gchar
modifier|*
name|escaped_uri
decl_stmt|;
name|time_t
name|timestamp
decl_stmt|;
name|uri
operator|=
name|gimp_recent_item_get_uri_utf8
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|escaped_uri
operator|=
name|g_markup_escape_text
argument_list|(
name|uri
argument_list|,
name|strlen
argument_list|(
name|uri
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|mime_type
operator|=
name|gimp_recent_item_get_mime_type
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|timestamp
operator|=
name|gimp_recent_item_get_timestamp
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_RECENT_ITEM
literal|">\n"
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_URI
literal|">%s</"
name|TAG_URI
literal|">\n"
argument_list|,
name|escaped_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|mime_type
condition|)
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_MIME_TYPE
literal|">%s</"
name|TAG_MIME_TYPE
literal|">\n"
argument_list|,
name|mime_type
argument_list|)
expr_stmt|;
else|else
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_MIME_TYPE
literal|"></"
name|TAG_MIME_TYPE
literal|">\n"
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_TIMESTAMP
literal|">%d</"
name|TAG_TIMESTAMP
literal|">\n"
argument_list|,
operator|(
name|gint
operator|)
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_recent_item_get_private
argument_list|(
name|item
argument_list|)
condition|)
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_PRIVATE
literal|"/>\n"
argument_list|)
expr_stmt|;
name|groups
operator|=
name|gimp_recent_item_get_groups
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|groups
condition|)
block|{
comment|/* write the groups */
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_GROUPS
literal|">\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groups
operator|==
name|NULL
operator|&&
name|gimp_recent_item_get_private
argument_list|(
name|item
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"Item with URI \"%s\" marked as private, but"
literal|" does not belong to any groups.\n"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
while|while
condition|(
name|groups
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|group
init|=
name|groups
operator|->
name|data
decl_stmt|;
name|gchar
modifier|*
name|escaped_group
decl_stmt|;
name|escaped_group
operator|=
name|g_markup_escape_text
argument_list|(
name|group
argument_list|,
name|strlen
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<"
name|TAG_GROUP
literal|">%s</"
name|TAG_GROUP
literal|">\n"
argument_list|,
name|escaped_group
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|escaped_group
argument_list|)
expr_stmt|;
name|groups
operator|=
name|groups
operator|->
name|next
expr_stmt|;
block|}
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</"
name|TAG_GROUPS
literal|">\n"
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</"
name|TAG_RECENT_ITEM
literal|">\n"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|escaped_uri
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|string
operator|=
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</"
name|TAG_RECENT_FILES
literal|">"
argument_list|)
expr_stmt|;
name|success
operator|=
name|gimp_recent_list_write_raw
argument_list|(
name|fd
argument_list|,
name|string
operator|->
name|str
argument_list|,
name|string
operator|->
name|len
argument_list|)
expr_stmt|;
name|g_string_free
argument_list|(
name|string
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_lock_file (gint fd)
name|gimp_recent_list_lock_file
parameter_list|(
name|gint
name|fd
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* Attempt to lock the file 5 times,    * waiting a random interval (< 1 second)    * in between attempts.    * We should really be doing asynchronous    * locking, but requires substantially larger    * changes.    */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|rand_interval
decl_stmt|;
if|if
condition|(
name|lockf
argument_list|(
name|fd
argument_list|,
name|F_TLOCK
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|rand_interval
operator|=
literal|1
operator|+
call|(
name|gint
call|)
argument_list|(
literal|10.0
operator|*
name|rand
argument_list|()
operator|/
operator|(
name|RAND_MAX
operator|+
literal|1.0
operator|)
argument_list|)
expr_stmt|;
name|g_usleep
argument_list|(
literal|100000
operator|*
name|rand_interval
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_unlock_file (gint fd)
name|gimp_recent_list_unlock_file
parameter_list|(
name|gint
name|fd
parameter_list|)
block|{
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|lockf
argument_list|(
name|fd
argument_list|,
name|F_ULOCK
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_recent_list_add_item (GimpRecentItem * item)
name|gimp_recent_list_add_item
parameter_list|(
name|GimpRecentItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|home
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gint
name|fd
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|created
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|updated
init|=
name|FALSE
decl_stmt|;
name|home
operator|=
name|g_get_home_dir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
return|return
name|FALSE
return|;
name|filename
operator|=
name|g_build_filename
argument_list|(
name|home
argument_list|,
name|GIMP_RECENT_LIST_FILE_NAME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fd
operator|=
name|g_open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fd
operator|=
name|g_creat
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
name|created
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|gimp_recent_list_lock_file
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|created
condition|)
name|list
operator|=
name|gimp_recent_list_read
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* if it's already there, we just update it */
name|updated
operator|=
name|gimp_recent_list_update_item
argument_list|(
name|list
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updated
condition|)
block|{
name|list
operator|=
name|g_list_prepend
argument_list|(
name|list
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|gimp_recent_list_enforce_limit
argument_list|(
name|list
argument_list|,
name|GIMP_RECENT_LIST_MAX_ITEMS
argument_list|)
expr_stmt|;
block|}
comment|/* write new stuff */
if|if
condition|(
operator|!
name|gimp_recent_list_write
argument_list|(
name|fd
argument_list|,
name|list
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"Write failed: %s"
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updated
condition|)
name|list
operator|=
name|g_list_remove
argument_list|(
name|list
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|GIMP_RECENT_ITEM_LIST_UNREF
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"Failed to lock:  %s"
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gimp_recent_list_unlock_file
argument_list|(
name|fd
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"Failed to unlock: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_recent_list_add_uri:  * @uri:       an URI  * @mime_type: a MIME type  *  * This function adds an item to the list of recently used URIs.  * See http://freedesktop.org/Standards/recent-file-spec/.  *  * On the Win32 platform, this call is unimplemented and will always  * fail.  *  * Returns: %TRUE on success, %FALSE otherwise  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_recent_list_add_uri (const gchar * uri,const gchar * mime_type)
name|gimp_recent_list_add_uri
parameter_list|(
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_type
parameter_list|)
block|{
name|GimpRecentItem
modifier|*
name|item
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|uri
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mime_type
operator|||
operator|!
name|strlen
argument_list|(
name|mime_type
argument_list|)
operator|||
operator|!
name|g_utf8_validate
argument_list|(
name|mime_type
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|item
operator|=
name|gimp_recent_item_new_from_uri
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
name|FALSE
return|;
name|gimp_recent_item_set_mime_type
argument_list|(
name|item
argument_list|,
name|mime_type
argument_list|)
expr_stmt|;
name|gimp_recent_item_set_timestamp
argument_list|(
name|item
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_recent_item_add_group
argument_list|(
name|item
argument_list|,
name|GIMP_RECENT_LIST_GROUP_GIMP
argument_list|)
expr_stmt|;
name|success
operator|=
name|gimp_recent_list_add_item
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|gimp_recent_item_unref
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* G_OS_WIN32  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_recent_list_add_uri (const gchar * uri,const gchar * mime_type)
name|gimp_recent_list_add_uri
parameter_list|(
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_type
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

