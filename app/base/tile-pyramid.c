begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"base-types.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"tile-pyramid.h"
end_include

begin_define
DECL|macro|PYRAMID_MAX_LEVELS
define|#
directive|define
name|PYRAMID_MAX_LEVELS
value|10
end_define

begin_struct
DECL|struct|_TilePyramid
struct|struct
name|_TilePyramid
block|{
DECL|member|width
name|guint
name|width
decl_stmt|;
DECL|member|height
name|guint
name|height
decl_stmt|;
DECL|member|bytes
name|gint
name|bytes
decl_stmt|;
DECL|member|tiles
name|TileManager
modifier|*
name|tiles
index|[
name|PYRAMID_MAX_LEVELS
index|]
decl_stmt|;
DECL|member|top_level
name|gint
name|top_level
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|gint
name|tile_pyramid_alloc_levels
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|,
name|gint
name|top_level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tile_pyramid_validate_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|TileManager
modifier|*
name|tm_below
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tile_pyramid_validate_upper_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|TileManager
modifier|*
name|tm_below
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tile_pyramid_write_quarter
parameter_list|(
name|Tile
modifier|*
name|dest
parameter_list|,
name|Tile
modifier|*
name|src
parameter_list|,
specifier|const
name|gint
name|i
parameter_list|,
specifier|const
name|gint
name|j
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tile_pyramid_write_upper_quarter
parameter_list|(
name|Tile
modifier|*
name|dest
parameter_list|,
name|Tile
modifier|*
name|src
parameter_list|,
specifier|const
name|gint
name|i
parameter_list|,
specifier|const
name|gint
name|j
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * tile_pyramid_new:  * @bytes:  foo  * @width:  bottom level width  * @height: bottom level height  *  * Creates a new #TilePyramid, managing a set of tile-managers where  * each level is a sized-down version of the level below.  *  * This only works correctly if you set a validate procedure using  * tile_pyramid_set_validate_proc() and invalidate areas. With some  * small changes, it could be made to work for non-validating tile  * managers also. But currently only the projection uses it.  *  * Only the bottom-most tile-manager is allocated at this point. Upper  * levels are created only if they are requested.  *  * Return value: a newly allocate #TilePyramid  **/
end_comment

begin_function
name|TilePyramid
modifier|*
DECL|function|tile_pyramid_new (gint bytes,gint width,gint height)
name|tile_pyramid_new
parameter_list|(
name|gint
name|bytes
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|TilePyramid
modifier|*
name|pyramid
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|width
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|height
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pyramid
operator|=
name|g_slice_new0
argument_list|(
name|TilePyramid
argument_list|)
expr_stmt|;
name|pyramid
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
name|pyramid
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|pyramid
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|pyramid
operator|->
name|tiles
index|[
literal|0
index|]
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
name|pyramid
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_destroy:  * @pyramid: a #TilePyramid  *  * Destroys resources allocated for @pyramid and unrefs all contained  * tile-managers.  **/
end_comment

begin_function
name|void
DECL|function|tile_pyramid_destroy (TilePyramid * pyramid)
name|tile_pyramid_destroy
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|)
block|{
name|gint
name|level
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<=
name|pyramid
operator|->
name|top_level
condition|;
name|level
operator|++
control|)
name|tile_manager_unref
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|TilePyramid
argument_list|,
name|pyramid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_level:  * @width:  width of the bottom level  * @height: height of the bottom level  * @scale:  zoom ratio  *  * Calculates the optimal level to request from a #TilePyramid in order  * to display at a certain @scale.  *  * Return value: the level to use for @scale  **/
end_comment

begin_function
name|gint
DECL|function|tile_pyramid_get_level (gint width,gint height,gdouble scale)
name|tile_pyramid_get_level
parameter_list|(
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gdouble
name|scale
parameter_list|)
block|{
name|gdouble
name|next
init|=
literal|1.0
decl_stmt|;
name|guint
name|w
init|=
operator|(
name|guint
operator|)
name|width
decl_stmt|;
name|guint
name|h
init|=
operator|(
name|guint
operator|)
name|height
decl_stmt|;
name|gint
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|PYRAMID_MAX_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|w
operator|>>=
literal|1
expr_stmt|;
name|h
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|w
operator|<=
name|TILE_WIDTH
operator|&&
name|h
operator|<=
name|TILE_HEIGHT
condition|)
break|break;
name|next
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|next
operator|<
name|scale
condition|)
break|break;
block|}
return|return
name|level
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_tiles:  * @pyramid:    a #TilePyramid  * @level:      level, typically obtained using tile_pyramid_get_level()  * @is_premult: location to store whether the pixel data has the alpha  *              channel pre-multiplied or not  *  * Gives access to the #TileManager at @level of the @pyramid.  *  * Return value: pointer to a #TileManager  **/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|tile_pyramid_get_tiles (TilePyramid * pyramid,gint level,gboolean * is_premult)
name|tile_pyramid_get_tiles
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|,
name|gint
name|level
parameter_list|,
name|gboolean
modifier|*
name|is_premult
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|level
operator|=
name|tile_pyramid_alloc_levels
argument_list|(
name|pyramid
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_premult
condition|)
operator|*
name|is_premult
operator|=
operator|(
name|level
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_invalidate_area:  * @pyramid: a #TilePyramid  * @x:  * @y:  * @width:  * @height:  *  * Invalidates the tiles in the given area on all levels.  **/
end_comment

begin_function
name|void
DECL|function|tile_pyramid_invalidate_area (TilePyramid * pyramid,gint x,gint y,gint width,gint height)
name|tile_pyramid_invalidate_area
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gint
name|level
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|>=
literal|0
operator|&&
name|y
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|width
operator|>=
literal|0
operator|&&
name|height
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<=
name|pyramid
operator|->
name|top_level
condition|;
name|level
operator|++
control|)
block|{
comment|/* Tile invalidation must propagate all the way up in the pyramid,        * so keep width and height> 0.        */
name|tile_manager_invalidate_area
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|MAX
argument_list|(
name|width
argument_list|,
literal|1
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|height
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
name|y
operator|>>=
literal|1
expr_stmt|;
name|width
operator|>>=
literal|1
expr_stmt|;
name|height
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_set_validate_proc:  * @pyramid:   a #TilePyramid  * @proc:      a function to validate the bottom level tiles  * @user_data: data to pass to the validation @proc  *  * Sets a validation procedure on the bottom-most tile manager.  **/
end_comment

begin_function
name|void
DECL|function|tile_pyramid_set_validate_proc (TilePyramid * pyramid,TileValidateProc proc,gpointer user_data)
name|tile_pyramid_set_validate_proc
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|,
name|TileValidateProc
name|proc
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
literal|0
index|]
argument_list|,
name|proc
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_width:  * @pyramid: a #TilePyramid  *  * Return value: the width of the pyramid's bottom level  **/
end_comment

begin_function
name|gint
DECL|function|tile_pyramid_get_width (const TilePyramid * pyramid)
name|tile_pyramid_get_width
parameter_list|(
specifier|const
name|TilePyramid
modifier|*
name|pyramid
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pyramid
operator|->
name|width
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_height:  * @pyramid: a #TilePyramid  *  * Return value: the height of the pyramid's bottom level  **/
end_comment

begin_function
name|gint
DECL|function|tile_pyramid_get_height (const TilePyramid * pyramid)
name|tile_pyramid_get_height
parameter_list|(
specifier|const
name|TilePyramid
modifier|*
name|pyramid
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pyramid
operator|->
name|height
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_bpp:  * @pyramid: a #TilePyramid  *  * Return value: the number of bytes per pixel stored in the @pyramid  **/
end_comment

begin_function
name|gint
DECL|function|tile_pyramid_get_bpp (const TilePyramid * pyramid)
name|tile_pyramid_get_bpp
parameter_list|(
specifier|const
name|TilePyramid
modifier|*
name|pyramid
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pyramid
operator|->
name|bytes
return|;
block|}
end_function

begin_comment
comment|/**  * tile_pyramid_get_memsize:  * @pyramid: a #TilePyramid  *  * Return value: size of memory allocated for the @pyramid  **/
end_comment

begin_function
name|gint64
DECL|function|tile_pyramid_get_memsize (const TilePyramid * pyramid)
name|tile_pyramid_get_memsize
parameter_list|(
specifier|const
name|TilePyramid
modifier|*
name|pyramid
parameter_list|)
block|{
name|gint64
name|memsize
init|=
sizeof|sizeof
argument_list|(
name|TilePyramid
argument_list|)
decl_stmt|;
name|gint
name|level
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|pyramid
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<=
name|pyramid
operator|->
name|top_level
condition|;
name|level
operator|++
control|)
name|memsize
operator|+=
name|tile_manager_get_memsize
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|memsize
return|;
block|}
end_function

begin_comment
comment|/* This function make sure that levels are allocated up to the level  * it returns. The return value may be smaller than the level that  * was actually requested.  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|tile_pyramid_alloc_levels (TilePyramid * pyramid,gint top_level)
name|tile_pyramid_alloc_levels
parameter_list|(
name|TilePyramid
modifier|*
name|pyramid
parameter_list|,
name|gint
name|top_level
parameter_list|)
block|{
name|gint
name|level
decl_stmt|;
name|top_level
operator|=
name|MIN
argument_list|(
name|top_level
argument_list|,
name|PYRAMID_MAX_LEVELS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level
operator|<=
name|pyramid
operator|->
name|top_level
condition|)
return|return
name|top_level
return|;
for|for
control|(
name|level
operator|=
name|pyramid
operator|->
name|top_level
operator|+
literal|1
init|;
name|level
operator|<=
name|top_level
condition|;
name|level
operator|++
control|)
block|{
name|TileValidateProc
name|proc
decl_stmt|;
name|gint
name|width
init|=
name|pyramid
operator|->
name|width
operator|>>
name|level
decl_stmt|;
name|gint
name|height
init|=
name|pyramid
operator|->
name|height
operator|>>
name|level
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
return|return
name|pyramid
operator|->
name|top_level
return|;
comment|/* There is no use having levels that have the same number of        * tiles as the parent level.        */
if|if
condition|(
name|width
operator|<=
name|TILE_WIDTH
operator|/
literal|2
operator|&&
name|height
operator|<=
name|TILE_HEIGHT
operator|/
literal|2
condition|)
return|return
name|pyramid
operator|->
name|top_level
return|;
name|pyramid
operator|->
name|top_level
operator|=
name|level
expr_stmt|;
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|pyramid
operator|->
name|bytes
argument_list|)
expr_stmt|;
comment|/* Use the level below to validate tiles. */
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|proc
operator|=
operator|(
name|TileValidateProc
operator|)
name|tile_pyramid_validate_tile
expr_stmt|;
else|else
name|proc
operator|=
operator|(
name|TileValidateProc
operator|)
name|tile_pyramid_validate_upper_tile
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|pyramid
operator|->
name|tiles
index|[
name|level
index|]
argument_list|,
name|proc
argument_list|,
name|pyramid
operator|->
name|tiles
index|[
name|level
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|pyramid
operator|->
name|top_level
return|;
block|}
end_function

begin_comment
comment|/* This method is used to validate a pyramid tile from four tiles on  * the base level.  It needs to pre-multiply the alpha channel because  * upper levels are pre-multiplied.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|tile_pyramid_validate_tile (TileManager * tm,Tile * tile,TileManager * tm_below)
name|tile_pyramid_validate_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|TileManager
modifier|*
name|tm_below
parameter_list|)
block|{
name|gint
name|tile_col
decl_stmt|;
name|gint
name|tile_row
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tile_manager_get_tile_col_row
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|tile_col
argument_list|,
operator|&
name|tile_row
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|Tile
modifier|*
name|source
init|=
name|tile_manager_get_at
argument_list|(
name|tm_below
argument_list|,
name|tile_col
operator|*
literal|2
operator|+
name|i
argument_list|,
name|tile_row
operator|*
literal|2
operator|+
name|j
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
condition|)
block|{
name|tile_pyramid_write_quarter
argument_list|(
name|tile
argument_list|,
name|source
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|source
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This method is used to validate tiles in the upper pyramid levels.  * Here all data has the alpha channel pre-multiplied.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|tile_pyramid_validate_upper_tile (TileManager * tm,Tile * tile,TileManager * tm_below)
name|tile_pyramid_validate_upper_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|TileManager
modifier|*
name|tm_below
parameter_list|)
block|{
name|gint
name|tile_col
decl_stmt|;
name|gint
name|tile_row
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tile_manager_get_tile_col_row
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|tile_col
argument_list|,
operator|&
name|tile_row
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|Tile
modifier|*
name|source
init|=
name|tile_manager_get_at
argument_list|(
name|tm_below
argument_list|,
name|tile_col
operator|*
literal|2
operator|+
name|i
argument_list|,
name|tile_row
operator|*
literal|2
operator|+
name|j
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
condition|)
block|{
name|tile_pyramid_write_upper_quarter
argument_list|(
name|tile
argument_list|,
name|source
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|source
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Average the src tile to one quarter of the destination tile.  The  * source tile doesn't have pre-multiplied alpha, but the destination  * tile does.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|tile_pyramid_write_quarter (Tile * dest,Tile * src,const gint i,const gint j)
name|tile_pyramid_write_quarter
parameter_list|(
name|Tile
modifier|*
name|dest
parameter_list|,
name|Tile
modifier|*
name|src
parameter_list|,
specifier|const
name|gint
name|i
parameter_list|,
specifier|const
name|gint
name|j
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src_data
init|=
name|tile_data_pointer
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|dest_data
init|=
name|tile_data_pointer
argument_list|(
name|dest
argument_list|,
name|i
operator|*
name|TILE_WIDTH
operator|/
literal|2
argument_list|,
name|j
operator|*
name|TILE_WIDTH
operator|/
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|src_ewidth
init|=
name|tile_ewidth
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|src_eheight
init|=
name|tile_eheight
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|dest_ewidth
init|=
name|tile_ewidth
argument_list|(
name|dest
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|bpp
init|=
name|tile_bpp
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|src_eheight
operator|/
literal|2
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src0
init|=
name|src_data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|src_data
operator|+
name|bpp
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|src0
operator|+
name|bpp
operator|*
name|src_ewidth
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src3
init|=
name|src1
operator|+
name|bpp
operator|*
name|src_ewidth
decl_stmt|;
name|guchar
modifier|*
name|dst
init|=
name|dest_data
decl_stmt|;
name|gint
name|x
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|1
expr_stmt|;
name|src0
operator|+=
literal|2
expr_stmt|;
name|src1
operator|+=
literal|2
expr_stmt|;
name|src2
operator|+=
literal|2
expr_stmt|;
name|src3
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
specifier|const
name|guint
name|a
init|=
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
literal|0
case|:
comment|/* all transparent */
name|dst
index|[
literal|0
index|]
operator|=
name|dst
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1020
case|:
comment|/* all opaque */
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
literal|255
expr_stmt|;
break|break;
default|default:
name|dst
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|src0
index|[
literal|0
index|]
operator|*
operator|(
name|src0
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|+
name|src1
index|[
literal|0
index|]
operator|*
operator|(
name|src1
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|+
name|src2
index|[
literal|0
index|]
operator|*
operator|(
name|src2
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|+
name|src3
index|[
literal|0
index|]
operator|*
operator|(
name|src3
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|)
operator|>>
literal|10
operator|)
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|a
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
block|}
name|dst
operator|+=
literal|2
expr_stmt|;
name|src0
operator|+=
literal|4
expr_stmt|;
name|src1
operator|+=
literal|4
expr_stmt|;
name|src2
operator|+=
literal|4
expr_stmt|;
name|src3
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src0
index|[
literal|2
index|]
operator|+
name|src1
index|[
literal|2
index|]
operator|+
name|src2
index|[
literal|2
index|]
operator|+
name|src3
index|[
literal|2
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|3
expr_stmt|;
name|src0
operator|+=
literal|6
expr_stmt|;
name|src1
operator|+=
literal|6
expr_stmt|;
name|src2
operator|+=
literal|6
expr_stmt|;
name|src3
operator|+=
literal|6
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
specifier|const
name|guint
name|a
init|=
name|src0
index|[
literal|3
index|]
operator|+
name|src1
index|[
literal|3
index|]
operator|+
name|src2
index|[
literal|3
index|]
operator|+
name|src3
index|[
literal|3
index|]
decl_stmt|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
literal|0
case|:
comment|/* all transparent */
name|dst
index|[
literal|0
index|]
operator|=
name|dst
index|[
literal|1
index|]
operator|=
name|dst
index|[
literal|2
index|]
operator|=
name|dst
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1020
case|:
comment|/* all opaque */
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src0
index|[
literal|2
index|]
operator|+
name|src1
index|[
literal|2
index|]
operator|+
name|src2
index|[
literal|2
index|]
operator|+
name|src3
index|[
literal|2
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|guint
name|a0
init|=
name|src0
index|[
literal|3
index|]
operator|+
literal|1
decl_stmt|;
specifier|const
name|guint
name|a1
init|=
name|src1
index|[
literal|3
index|]
operator|+
literal|1
decl_stmt|;
specifier|const
name|guint
name|a2
init|=
name|src2
index|[
literal|3
index|]
operator|+
literal|1
decl_stmt|;
specifier|const
name|guint
name|a3
init|=
name|src3
index|[
literal|3
index|]
operator|+
literal|1
decl_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|*
name|a0
operator|+
name|src1
index|[
literal|0
index|]
operator|*
name|a1
operator|+
name|src2
index|[
literal|0
index|]
operator|*
name|a2
operator|+
name|src3
index|[
literal|0
index|]
operator|*
name|a3
operator|)
operator|>>
literal|10
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|*
name|a0
operator|+
name|src1
index|[
literal|1
index|]
operator|*
name|a1
operator|+
name|src2
index|[
literal|1
index|]
operator|*
name|a2
operator|+
name|src3
index|[
literal|1
index|]
operator|*
name|a3
operator|)
operator|>>
literal|10
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src0
index|[
literal|2
index|]
operator|*
name|a0
operator|+
name|src1
index|[
literal|2
index|]
operator|*
name|a1
operator|+
name|src2
index|[
literal|2
index|]
operator|*
name|a2
operator|+
name|src3
index|[
literal|2
index|]
operator|*
name|a3
operator|)
operator|>>
literal|10
expr_stmt|;
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|a
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
break|break;
block|}
name|dst
operator|+=
literal|4
expr_stmt|;
name|src0
operator|+=
literal|8
expr_stmt|;
name|src1
operator|+=
literal|8
expr_stmt|;
name|src2
operator|+=
literal|8
expr_stmt|;
name|src3
operator|+=
literal|8
expr_stmt|;
block|}
break|break;
block|}
name|dest_data
operator|+=
name|dest_ewidth
operator|*
name|bpp
expr_stmt|;
name|src_data
operator|+=
name|src_ewidth
operator|*
name|bpp
operator|*
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Average the src tile to one quarter of the destination tile.  * The source and destination tiles have pre-multiplied alpha.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|tile_pyramid_write_upper_quarter (Tile * dest,Tile * src,const gint i,const gint j)
name|tile_pyramid_write_upper_quarter
parameter_list|(
name|Tile
modifier|*
name|dest
parameter_list|,
name|Tile
modifier|*
name|src
parameter_list|,
specifier|const
name|gint
name|i
parameter_list|,
specifier|const
name|gint
name|j
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|src_data
init|=
name|tile_data_pointer
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|dest_data
init|=
name|tile_data_pointer
argument_list|(
name|dest
argument_list|,
name|i
operator|*
name|TILE_WIDTH
operator|/
literal|2
argument_list|,
name|j
operator|*
name|TILE_WIDTH
operator|/
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|src_ewidth
init|=
name|tile_ewidth
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|src_eheight
init|=
name|tile_eheight
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|dest_ewidth
init|=
name|tile_ewidth
argument_list|(
name|dest
argument_list|)
decl_stmt|;
specifier|const
name|gint
name|bpp
init|=
name|tile_bpp
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|gint
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|src_eheight
operator|/
literal|2
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src0
init|=
name|src_data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src1
init|=
name|src_data
operator|+
name|bpp
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src2
init|=
name|src0
operator|+
name|bpp
operator|*
name|src_ewidth
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|src3
init|=
name|src1
operator|+
name|bpp
operator|*
name|src_ewidth
decl_stmt|;
name|guchar
modifier|*
name|dst
init|=
name|dest_data
decl_stmt|;
name|gint
name|x
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|1
expr_stmt|;
name|src0
operator|+=
literal|2
expr_stmt|;
name|src1
operator|+=
literal|2
expr_stmt|;
name|src2
operator|+=
literal|2
expr_stmt|;
name|src3
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|src0
operator|+=
literal|4
expr_stmt|;
name|src1
operator|+=
literal|4
expr_stmt|;
name|src2
operator|+=
literal|4
expr_stmt|;
name|src3
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src0
index|[
literal|2
index|]
operator|+
name|src1
index|[
literal|2
index|]
operator|+
name|src2
index|[
literal|2
index|]
operator|+
name|src3
index|[
literal|2
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|3
expr_stmt|;
name|src0
operator|+=
literal|6
expr_stmt|;
name|src1
operator|+=
literal|6
expr_stmt|;
name|src2
operator|+=
literal|6
expr_stmt|;
name|src3
operator|+=
literal|6
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src_ewidth
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src0
index|[
literal|0
index|]
operator|+
name|src1
index|[
literal|0
index|]
operator|+
name|src2
index|[
literal|0
index|]
operator|+
name|src3
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src0
index|[
literal|1
index|]
operator|+
name|src1
index|[
literal|1
index|]
operator|+
name|src2
index|[
literal|1
index|]
operator|+
name|src3
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src0
index|[
literal|2
index|]
operator|+
name|src1
index|[
literal|2
index|]
operator|+
name|src2
index|[
literal|2
index|]
operator|+
name|src3
index|[
literal|2
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|src0
index|[
literal|3
index|]
operator|+
name|src1
index|[
literal|3
index|]
operator|+
name|src2
index|[
literal|3
index|]
operator|+
name|src3
index|[
literal|3
index|]
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
name|dst
operator|+=
literal|4
expr_stmt|;
name|src0
operator|+=
literal|8
expr_stmt|;
name|src1
operator|+=
literal|8
expr_stmt|;
name|src2
operator|+=
literal|8
expr_stmt|;
name|src3
operator|+=
literal|8
expr_stmt|;
block|}
break|break;
block|}
name|dest_data
operator|+=
name|dest_ewidth
operator|*
name|bpp
expr_stmt|;
name|src_data
operator|+=
name|src_ewidth
operator|*
name|bpp
operator|*
literal|2
expr_stmt|;
block|}
block|}
end_function

end_unit

