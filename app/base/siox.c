begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SIOX: Simple Interactive Object Extraction  *  * For algorithm documentation refer to:  * G. Friedland, K. Jantz, L. Knipping, R. Rojas:  * "Image Segmentation by Uniform Color Clustering  *  -- Approach and Benchmark Results",  * Technical Report B-05-07, Department of Computer Science,  * Freie Universitaet Berlin, June 2005.  * http://www.inf.fu-berlin.de/inst/pubs/tr-b-05-07.pdf  *  * See http://www.siox.org/ for more information.  *  * Algorithm idea by Gerald Friedland.  * This implementation is Copyright (C) 2005  * by Gerald Friedland<fland@inf.fu-berlin.de>  * and Kristian Jantz<jantz@inf.fu-berlin.de>  * and Tobias Lenz<tlenz@inf.fu-berlin.de>.  *  * Adapted for GIMP by Sven Neumann<sven@gimp.org>  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  * 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"base-types.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"cpercep.h"
end_include

begin_include
include|#
directive|include
file|"pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"siox.h"
end_include

begin_comment
comment|/* Thresholds in the mask:  *   pixels< SIOX_LOW  are known background  *   pixels> SIOX_HIGH are known foreground  */
end_comment

begin_define
DECL|macro|SIOX_LOW
define|#
directive|define
name|SIOX_LOW
value|1
end_define

begin_define
DECL|macro|SIOX_HIGH
define|#
directive|define
name|SIOX_HIGH
value|254
end_define

begin_comment
comment|/* When clustering:  *   use LAB for color images (3 dims),  *   use L only for grayscale images (1 dim)  */
end_comment

begin_define
DECL|macro|SIOX_COLOR_DIMS
define|#
directive|define
name|SIOX_COLOR_DIMS
value|3
end_define

begin_define
DECL|macro|SIOX_GRAY_DIMS
define|#
directive|define
name|SIOX_GRAY_DIMS
value|1
end_define

begin_comment
comment|/* For findmaxblob:  * Find all blobs with area not smaller than sizefactor of biggest blob  * CHECKME: Should the user decide this with a slider?  */
end_comment

begin_define
DECL|macro|MULTIBLOB_DEFAULT_SIZEFACTOR
define|#
directive|define
name|MULTIBLOB_DEFAULT_SIZEFACTOR
value|4
end_define

begin_define
DECL|macro|MULTIBLOB_ONE_BLOB_ONLY
define|#
directive|define
name|MULTIBLOB_ONE_BLOB_ONLY
value|0
end_define

begin_comment
comment|/* #define SIOX_DEBUG  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277a8b9f0108
block|{
DECL|member|l
name|gfloat
name|l
decl_stmt|;
DECL|member|a
name|gfloat
name|a
decl_stmt|;
DECL|member|b
name|gfloat
name|b
decl_stmt|;
DECL|member|cardinality
name|gint
name|cardinality
decl_stmt|;
DECL|typedef|lab
block|}
name|lab
typedef|;
end_typedef

begin_comment
comment|/* A struct that holds SIOX current state */
end_comment

begin_struct
DECL|struct|_SioxState
struct|struct
name|_SioxState
block|{
DECL|member|pixels
name|TileManager
modifier|*
name|pixels
decl_stmt|;
DECL|member|colormap
specifier|const
name|guchar
modifier|*
name|colormap
decl_stmt|;
DECL|member|bpp
name|gint
name|bpp
decl_stmt|;
DECL|member|offset_x
name|gint
name|offset_x
decl_stmt|;
DECL|member|offset_y
name|gint
name|offset_y
decl_stmt|;
DECL|member|x
name|gint
name|x
decl_stmt|;
DECL|member|y
name|gint
name|y
decl_stmt|;
DECL|member|width
name|gint
name|width
decl_stmt|;
DECL|member|height
name|gint
name|height
decl_stmt|;
DECL|member|cache
name|GHashTable
modifier|*
name|cache
decl_stmt|;
DECL|member|bgsig
name|lab
modifier|*
name|bgsig
decl_stmt|;
DECL|member|fgsig
name|lab
modifier|*
name|fgsig
decl_stmt|;
DECL|member|bgsiglen
name|gint
name|bgsiglen
decl_stmt|;
DECL|member|fgsiglen
name|gint
name|fgsiglen
decl_stmt|;
DECL|member|xsbpp
name|gint
name|xsbpp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A struct that holds the classification result */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277a8b9f0208
block|{
DECL|member|bgdist
name|gfloat
name|bgdist
decl_stmt|;
DECL|member|fgdist
name|gfloat
name|fgdist
decl_stmt|;
DECL|typedef|classresult
block|}
name|classresult
typedef|;
end_typedef

begin_comment
comment|/* Progressbar update callback */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|siox_progress_update (SioxProgressFunc progress_callback,gpointer progress_data,gdouble value)
name|siox_progress_update
parameter_list|(
name|SioxProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|,
name|gdouble
name|value
parameter_list|)
block|{
if|if
condition|(
name|progress_data
condition|)
name|progress_callback
argument_list|(
name|progress_data
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Converts any pixel format to LAB */
end_comment

begin_function
specifier|static
name|void
DECL|function|calc_lab (const guchar * src,gint bpp,const guchar * colormap,lab * pixel)
name|calc_lab
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|bpp
parameter_list|,
specifier|const
name|guchar
modifier|*
name|colormap
parameter_list|,
name|lab
modifier|*
name|pixel
parameter_list|)
block|{
name|gdouble
name|l
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|3
case|:
comment|/* RGB  */
case|case
literal|4
case|:
comment|/* RGBA */
name|cpercep_rgb_to_space
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
if|if
condition|(
name|colormap
condition|)
comment|/* INDEXED(A) */
block|{
name|gint
name|i
init|=
operator|*
name|src
operator|*
literal|3
decl_stmt|;
name|cpercep_rgb_to_space
argument_list|(
name|colormap
index|[
name|i
operator|+
name|RED_PIX
index|]
argument_list|,
name|colormap
index|[
name|i
operator|+
name|GREEN_PIX
index|]
argument_list|,
name|colormap
index|[
name|i
operator|+
name|BLUE_PIX
index|]
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* GRAY(A) */
block|{
comment|/*  FIXME: there should be cpercep_gray_to_space  */
name|cpercep_rgb_to_space
argument_list|(
operator|*
name|src
argument_list|,
operator|*
name|src
argument_list|,
operator|*
name|src
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_return_if_reached
argument_list|()
expr_stmt|;
block|}
name|pixel
operator|->
name|l
operator|=
name|l
expr_stmt|;
name|pixel
operator|->
name|a
operator|=
name|a
expr_stmt|;
name|pixel
operator|->
name|b
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  assumes that lab starts with an array of floats (l,a,b)  */
end_comment

begin_define
DECL|macro|CURRENT_VALUE (points,i,dim)
define|#
directive|define
name|CURRENT_VALUE
parameter_list|(
name|points
parameter_list|,
name|i
parameter_list|,
name|dim
parameter_list|)
value|(((const gfloat *) (points + i))[dim])
end_define

begin_comment
comment|/* Stage one of modified KD-Tree algorithm (see literature above)*/
end_comment

begin_function
specifier|static
name|void
DECL|function|stageone (lab * points,gint left,gint right,gint depth,gint * clusters,const gfloat * limits,const gint dims)
name|stageone
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|gint
name|left
parameter_list|,
name|gint
name|right
parameter_list|,
name|gint
name|depth
parameter_list|,
name|gint
modifier|*
name|clusters
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
specifier|const
name|gint
name|dims
parameter_list|)
block|{
name|gint
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|gfloat
name|min
decl_stmt|,
name|max
decl_stmt|;
name|gfloat
name|curval
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|min
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|left
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
expr_stmt|;
for|for
control|(
name|i
operator|=
name|left
operator|+
literal|1
init|;
name|i
operator|<
name|right
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|gfloat
name|pivot
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2.0
decl_stmt|;
name|gint
name|l
init|=
name|left
decl_stmt|;
name|gint
name|r
init|=
name|right
operator|-
literal|1
decl_stmt|;
name|lab
name|tmp
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
while|while
condition|(
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|l
argument_list|,
name|curdim
argument_list|)
operator|<=
name|pivot
condition|)
operator|++
name|l
expr_stmt|;
while|while
condition|(
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|r
argument_list|,
name|curdim
argument_list|)
operator|>
name|pivot
condition|)
operator|--
name|r
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|r
condition|)
break|break;
name|tmp
operator|=
name|points
index|[
name|l
index|]
expr_stmt|;
name|points
index|[
name|l
index|]
operator|=
name|points
index|[
name|r
index|]
expr_stmt|;
name|points
index|[
name|r
index|]
operator|=
name|tmp
expr_stmt|;
operator|++
name|l
expr_stmt|;
operator|--
name|r
expr_stmt|;
block|}
comment|/* create subtrees */
name|stageone
argument_list|(
name|points
argument_list|,
name|left
argument_list|,
name|l
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|dims
argument_list|)
expr_stmt|;
name|stageone
argument_list|(
name|points
argument_list|,
name|l
argument_list|,
name|right
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* create leave */
name|gfloat
name|l
init|=
literal|0
decl_stmt|;
name|gfloat
name|a
init|=
literal|0
decl_stmt|;
name|gfloat
name|b
init|=
literal|0
decl_stmt|;
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|cardinality
operator|=
name|right
operator|-
name|left
expr_stmt|;
for|for
control|(
init|;
name|left
operator|<
name|right
condition|;
operator|++
name|left
control|)
block|{
name|l
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|l
expr_stmt|;
name|a
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|a
expr_stmt|;
name|b
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|b
expr_stmt|;
block|}
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|l
operator|=
name|l
operator|/
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|cardinality
expr_stmt|;
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|a
operator|=
name|a
operator|/
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|cardinality
expr_stmt|;
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|b
operator|=
name|b
operator|/
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|cardinality
expr_stmt|;
operator|++
operator|(
operator|*
name|clusters
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stage two of modified KD-Tree algorithm (see literature above) */
end_comment

begin_comment
comment|/* This is very similar to stageone... but in future there may be more  * differences => not integrated into method stageone()  */
end_comment

begin_function
specifier|static
name|void
DECL|function|stagetwo (lab * points,gint left,gint right,gint depth,gint * clusters,const gfloat * limits,const gfloat threshold,const gint dims)
name|stagetwo
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|gint
name|left
parameter_list|,
name|gint
name|right
parameter_list|,
name|gint
name|depth
parameter_list|,
name|gint
modifier|*
name|clusters
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
specifier|const
name|gfloat
name|threshold
parameter_list|,
specifier|const
name|gint
name|dims
parameter_list|)
block|{
name|gint
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|gfloat
name|min
decl_stmt|,
name|max
decl_stmt|;
name|gfloat
name|curval
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|min
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|left
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
expr_stmt|;
for|for
control|(
name|i
operator|=
name|left
operator|+
literal|1
init|;
name|i
operator|<
name|right
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|gfloat
name|pivot
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2.0
decl_stmt|;
name|gint
name|l
init|=
name|left
decl_stmt|;
name|gint
name|r
init|=
name|right
operator|-
literal|1
decl_stmt|;
name|lab
name|tmp
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
while|while
condition|(
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|l
argument_list|,
name|curdim
argument_list|)
operator|<=
name|pivot
condition|)
operator|++
name|l
expr_stmt|;
while|while
condition|(
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|r
argument_list|,
name|curdim
argument_list|)
operator|>
name|pivot
condition|)
operator|--
name|r
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|r
condition|)
break|break;
name|tmp
operator|=
name|points
index|[
name|l
index|]
expr_stmt|;
name|points
index|[
name|l
index|]
operator|=
name|points
index|[
name|r
index|]
expr_stmt|;
name|points
index|[
name|r
index|]
operator|=
name|tmp
expr_stmt|;
operator|++
name|l
expr_stmt|;
operator|--
name|r
expr_stmt|;
block|}
comment|/* create subtrees */
name|stagetwo
argument_list|(
name|points
argument_list|,
name|left
argument_list|,
name|l
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|threshold
argument_list|,
name|dims
argument_list|)
expr_stmt|;
name|stagetwo
argument_list|(
name|points
argument_list|,
name|l
argument_list|,
name|right
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|threshold
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* create leave */
block|{
name|gint
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|left
init|;
name|i
operator|<
name|right
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|cardinality
expr_stmt|;
if|if
condition|(
name|sum
operator|>=
name|threshold
condition|)
block|{
specifier|const
name|gint
name|c
init|=
name|right
operator|-
name|left
decl_stmt|;
name|gfloat
name|l
init|=
literal|0
decl_stmt|;
name|gfloat
name|a
init|=
literal|0
decl_stmt|;
name|gfloat
name|b
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|left
operator|<
name|right
condition|;
operator|++
name|left
control|)
block|{
name|l
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|l
expr_stmt|;
name|a
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|a
expr_stmt|;
name|b
operator|+=
name|points
index|[
name|left
index|]
operator|.
name|b
expr_stmt|;
block|}
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|l
operator|=
name|l
operator|/
name|c
expr_stmt|;
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|a
operator|=
name|a
operator|/
name|c
expr_stmt|;
name|points
index|[
operator|*
name|clusters
index|]
operator|.
name|b
operator|=
name|b
operator|/
name|c
expr_stmt|;
operator|++
operator|(
operator|*
name|clusters
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: cluster=%f, %f, %f sum=%d\n"
argument_list|,
name|l
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|sum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* squared euclidean distance */
end_comment

begin_function
specifier|static
specifier|inline
name|float
DECL|function|euklid (const lab * p,const lab * q)
name|euklid
parameter_list|(
specifier|const
name|lab
modifier|*
name|p
parameter_list|,
specifier|const
name|lab
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
name|SQR
argument_list|(
name|p
operator|->
name|l
operator|-
name|q
operator|->
name|l
argument_list|)
operator|+
name|SQR
argument_list|(
name|p
operator|->
name|a
operator|-
name|q
operator|->
name|a
argument_list|)
operator|+
name|SQR
argument_list|(
name|p
operator|->
name|b
operator|-
name|q
operator|->
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns squared clustersize */
end_comment

begin_function
specifier|static
name|gfloat
DECL|function|get_clustersize (const gfloat * limits)
name|get_clustersize
parameter_list|(
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|)
block|{
return|return
operator|(
name|SQR
argument_list|(
name|limits
index|[
literal|0
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|0
index|]
operator|)
argument_list|)
operator|+
name|SQR
argument_list|(
name|limits
index|[
literal|1
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|1
index|]
operator|)
argument_list|)
operator|+
name|SQR
argument_list|(
name|limits
index|[
literal|2
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|2
index|]
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Creates a color signature for a given set of pixels */
end_comment

begin_function
specifier|static
name|lab
modifier|*
DECL|function|create_signature (lab * input,gint length,gint * returnlength,const gfloat * limits,const gint dims,SioxProgressFunc progress_callback,gpointer progress_data,gdouble progress_value)
name|create_signature
parameter_list|(
name|lab
modifier|*
name|input
parameter_list|,
name|gint
name|length
parameter_list|,
name|gint
modifier|*
name|returnlength
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
specifier|const
name|gint
name|dims
parameter_list|,
name|SioxProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|,
name|gdouble
name|progress_value
parameter_list|)
block|{
name|gint
name|size1
init|=
literal|0
decl_stmt|;
name|gint
name|size2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
operator|*
name|returnlength
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stageone
argument_list|(
name|input
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
operator|&
name|size1
argument_list|,
name|limits
argument_list|,
name|dims
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: step #1 -> %d clusters\n"
argument_list|,
name|size1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
name|progress_value
argument_list|)
expr_stmt|;
name|stagetwo
argument_list|(
name|input
argument_list|,
literal|0
argument_list|,
name|size1
argument_list|,
literal|0
argument_list|,
operator|&
name|size2
argument_list|,
name|limits
argument_list|,
name|length
operator|*
literal|0.001
argument_list|,
name|dims
argument_list|)
expr_stmt|;
operator|*
name|returnlength
operator|=
name|size2
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: step #2 -> %d clusters\n"
argument_list|,
operator|*
name|returnlength
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|g_memdup
argument_list|(
name|input
argument_list|,
name|size2
operator|*
sizeof|sizeof
argument_list|(
name|lab
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Smoothes mask by delegation to paint-funcs.c */
end_comment

begin_function
specifier|static
name|void
DECL|function|smooth_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|smooth_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|smooth_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Erodes mask by delegation to paint-funcs.c */
end_comment

begin_function
specifier|static
name|void
DECL|function|erode_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|erode_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|erode_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dilates mask by delegation to paint-funcs.c */
end_comment

begin_function
specifier|static
name|void
DECL|function|dilate_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|dilate_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dilate_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mask settings for threshold_mask  * Do not change these defines! They contain some magic!  * Must all be non-zero and FINAL must be 0xFF!  */
end_comment

begin_define
DECL|macro|FIND_BLOB_SELECTED
define|#
directive|define
name|FIND_BLOB_SELECTED
value|0x1
end_define

begin_define
DECL|macro|FIND_BLOB_FORCEFG
define|#
directive|define
name|FIND_BLOB_FORCEFG
value|0x3
end_define

begin_define
DECL|macro|FIND_BLOB_VISITED
define|#
directive|define
name|FIND_BLOB_VISITED
value|0x7
end_define

begin_define
DECL|macro|FIND_BLOB_FINAL
define|#
directive|define
name|FIND_BLOB_FINAL
value|0xFF
end_define

begin_comment
comment|/* Digitize mask */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|threshold_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|threshold_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|region
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|guchar
modifier|*
name|data
init|=
name|region
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|region
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|data
decl_stmt|;
comment|/* everything that fits the mask is in the image */
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|region
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|>
name|SIOX_HIGH
condition|)
operator|*
name|d
operator|=
name|FIND_BLOB_FORCEFG
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|d
operator|>=
literal|0x80
condition|)
operator|*
name|d
operator|=
name|FIND_BLOB_SELECTED
expr_stmt|;
else|else
operator|*
name|d
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|+=
name|region
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* a struct that contains information about a blob */
end_comment

begin_struct
DECL|struct|blob
struct|struct
name|blob
block|{
DECL|member|seedx
name|gint
name|seedx
decl_stmt|;
DECL|member|seedy
name|gint
name|seedy
decl_stmt|;
DECL|member|size
name|gint
name|size
decl_stmt|;
DECL|member|mustkeep
name|gboolean
name|mustkeep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This method checks out the neighbourhood of the pixel at position  * (x,y) in the TileManager mask, it adds the surrounding pixels to  * the queue to allow further processing it uses maskVal to determine  * if the surrounding pixels have already been visited x,y are passed  * from above.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|depth_first_search (TileManager * mask,gint x,gint y,gint xwidth,gint yheight,struct blob * b,guchar mark)
name|depth_first_search
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|xwidth
parameter_list|,
name|gint
name|yheight
parameter_list|,
name|struct
name|blob
modifier|*
name|b
parameter_list|,
name|guchar
name|mark
parameter_list|)
block|{
name|GSList
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|gint
name|xx
init|=
name|b
operator|->
name|seedx
decl_stmt|;
name|gint
name|yy
init|=
name|b
operator|->
name|seedy
decl_stmt|;
name|gint
name|oldx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|guchar
name|val
decl_stmt|;
if|if
condition|(
name|oldx
operator|==
name|xx
condition|)
block|{
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
break|break;
name|xx
operator|=
name|GPOINTER_TO_INT
argument_list|(
name|stack
operator|->
name|data
argument_list|)
expr_stmt|;
name|stack
operator|=
name|g_slist_delete_link
argument_list|(
name|stack
argument_list|,
name|stack
argument_list|)
expr_stmt|;
name|yy
operator|=
name|GPOINTER_TO_INT
argument_list|(
name|stack
operator|->
name|data
argument_list|)
expr_stmt|;
name|stack
operator|=
name|g_slist_delete_link
argument_list|(
name|stack
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
name|oldx
operator|=
name|xx
expr_stmt|;
name|read_pixel_data_1
argument_list|(
name|mask
argument_list|,
name|xx
argument_list|,
name|yy
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|val
operator|!=
name|mark
operator|)
condition|)
block|{
if|if
condition|(
name|mark
operator|==
name|FIND_BLOB_VISITED
condition|)
block|{
operator|++
operator|(
name|b
operator|->
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|FIND_BLOB_FORCEFG
condition|)
name|b
operator|->
name|mustkeep
operator|=
name|TRUE
expr_stmt|;
block|}
name|write_pixel_data_1
argument_list|(
name|mask
argument_list|,
name|xx
argument_list|,
name|yy
argument_list|,
operator|&
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
operator|>
name|y
condition|)
name|stack
operator|=
name|g_slist_prepend
argument_list|(
name|g_slist_prepend
argument_list|(
name|stack
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|yy
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|xx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
operator|+
literal|1
operator|<
name|yheight
condition|)
name|stack
operator|=
name|g_slist_prepend
argument_list|(
name|g_slist_prepend
argument_list|(
name|stack
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|yy
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|xx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xx
operator|+
literal|1
operator|<
name|xwidth
condition|)
block|{
if|if
condition|(
name|xx
operator|>
name|x
condition|)
name|stack
operator|=
name|g_slist_prepend
argument_list|(
name|g_slist_prepend
argument_list|(
name|stack
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|yy
argument_list|)
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|xx
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|xx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xx
operator|>
name|x
condition|)
block|{
operator|--
name|xx
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This method finds the biggest connected components in mask, it  * clears everything in mask except the biggest components' Pixels that  * should be considererd set in incoming mask, must fulfill (pixel&  * 0x1) the method uses no further memory, except a queue, it finds  * the biggest components by a 2 phase algorithm 1. in the first phase  * the coordinates of an element of the biggest components are  * identified, during this phase all pixels are visited. In the  * second phase first visitation flags are reset, and afterwards  * connected components starting at the found coordinates are  * determined. These are the biggest components, the result is written  * into mask, all pixels that belong to the biggest components are set  * to 255, any other to 0.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_max_blob (TileManager * mask,gint x,gint y,gint width,gint height,const gint size_factor)
name|find_max_blob
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
specifier|const
name|gint
name|size_factor
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|GSList
modifier|*
name|iter
decl_stmt|;
name|PixelRegion
name|region
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|maxsize
init|=
literal|0
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|threshold_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|region
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|gint
name|pos_y
init|=
name|region
operator|.
name|y
decl_stmt|;
name|guchar
modifier|*
name|data
init|=
name|region
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|region
operator|.
name|h
condition|;
name|row
operator|++
operator|,
name|pos_y
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|data
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|region
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|val
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|val
operator|!=
name|FIND_BLOB_VISITED
operator|)
condition|)
block|{
name|struct
name|blob
modifier|*
name|b
init|=
name|g_new
argument_list|(
expr|struct
name|blob
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|b
operator|->
name|seedx
operator|=
name|region
operator|.
name|x
operator|+
name|col
expr_stmt|;
name|b
operator|->
name|seedy
operator|=
name|pos_y
expr_stmt|;
name|b
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|mustkeep
operator|=
name|FALSE
expr_stmt|;
name|depth_first_search
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|width
argument_list|,
name|y
operator|+
name|height
argument_list|,
name|b
argument_list|,
name|FIND_BLOB_VISITED
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|size
operator|>
name|maxsize
condition|)
name|maxsize
operator|=
name|b
operator|->
name|size
expr_stmt|;
block|}
block|}
name|data
operator|+=
name|region
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
for|for
control|(
name|iter
operator|=
name|list
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
name|struct
name|blob
modifier|*
name|b
init|=
name|iter
operator|->
name|data
decl_stmt|;
name|depth_first_search
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|width
argument_list|,
name|y
operator|+
name|height
argument_list|,
name|b
argument_list|,
operator|(
name|b
operator|->
name|mustkeep
operator|||
operator|(
name|b
operator|->
name|size
operator|*
name|size_factor
operator|>=
name|maxsize
operator|)
operator|)
condition|?
name|FIND_BLOB_FINAL
else|:
literal|0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a key for the hashtable from a given pixel color value */
end_comment

begin_function
specifier|static
specifier|inline
name|gint
DECL|function|create_key (const guchar * src,gint bpp,const guchar * colormap)
name|create_key
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|bpp
parameter_list|,
specifier|const
name|guchar
modifier|*
name|colormap
parameter_list|)
block|{
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|3
case|:
comment|/* RGB  */
case|case
literal|4
case|:
comment|/* RGBA */
return|return
operator|(
name|src
index|[
name|RED_PIX
index|]
operator|<<
literal|16
operator||
name|src
index|[
name|GREEN_PIX
index|]
operator|<<
literal|8
operator||
name|src
index|[
name|BLUE_PIX
index|]
operator|)
return|;
case|case
literal|2
case|:
case|case
literal|1
case|:
if|if
condition|(
name|colormap
condition|)
comment|/* INDEXED(A) */
block|{
name|gint
name|i
init|=
operator|*
name|src
operator|*
literal|3
decl_stmt|;
return|return
operator|(
name|colormap
index|[
name|i
operator|+
name|RED_PIX
index|]
operator|<<
literal|16
operator||
name|colormap
index|[
name|i
operator|+
name|GREEN_PIX
index|]
operator|<<
literal|8
operator||
name|colormap
index|[
name|i
operator|+
name|BLUE_PIX
index|]
operator|)
return|;
block|}
else|else
comment|/* GRAY(A) */
block|{
return|return
operator|*
name|src
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clear hashtable entries that get invalid due to refinement */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|siox_cache_remove_bg (gpointer key,gpointer value,gpointer user_data)
name|siox_cache_remove_bg
parameter_list|(
name|gpointer
name|key
parameter_list|,
name|gpointer
name|value
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|classresult
modifier|*
name|cr
init|=
name|value
decl_stmt|;
return|return
operator|(
name|cr
operator|->
name|bgdist
operator|<
name|cr
operator|->
name|fgdist
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|siox_cache_remove_fg (gpointer key,gpointer value,gpointer user_data)
name|siox_cache_remove_fg
parameter_list|(
name|gpointer
name|key
parameter_list|,
name|gpointer
name|value
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|classresult
modifier|*
name|cr
init|=
name|value
decl_stmt|;
return|return
operator|(
name|cr
operator|->
name|bgdist
operator|>=
name|cr
operator|->
name|fgdist
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * siox_init:  * @pixels:   the tiles to extract the foreground from  * @colormap: colormap in case @pixels are indexed, %NULL otherwise  * @offset_x: horizontal offset of @pixels with respect to the @mask  * @offset_y: vertical offset of @pixels with respect to the @mask  * @x:        horizontal offset into the mask  * @y:        vertical offset into the mask  * @width:    width of working area on mask  * @height:   height of working area on mask  *  * Initializes the SIOX segmentator.  * Creates and returns a SioxState struct that has to be passed to all  * function calls of this module as it maintaines the state.  */
end_comment

begin_function
name|SioxState
modifier|*
DECL|function|siox_init (TileManager * pixels,const guchar * colormap,gint offset_x,gint offset_y,gint x,gint y,gint width,gint height)
name|siox_init
parameter_list|(
name|TileManager
modifier|*
name|pixels
parameter_list|,
specifier|const
name|guchar
modifier|*
name|colormap
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|SioxState
modifier|*
name|state
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|pixels
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|x
operator|>=
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|y
operator|>=
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|g_new0
argument_list|(
name|SioxState
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|pixels
operator|=
name|pixels
expr_stmt|;
name|state
operator|->
name|colormap
operator|=
name|colormap
expr_stmt|;
name|state
operator|->
name|offset_x
operator|=
name|offset_x
expr_stmt|;
name|state
operator|->
name|offset_y
operator|=
name|offset_y
expr_stmt|;
name|state
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|state
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|state
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|state
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|state
operator|->
name|bgsig
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|fgsig
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|bgsiglen
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|fgsiglen
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|state
operator|->
name|cache
operator|=
name|g_hash_table_new_full
argument_list|(
name|g_direct_hash
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|cpercep_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: siox_init (bpp=%d, "
literal|"x=%d, y=%d, width=%d, height=%d, offset_x=%d, offset_y=%d)\n"
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/**  * siox_foreground_extract:  * @state:       current state struct as constructed by siox_init  * @refinement:  #SioxRefinementType  * @mask:        a mask indicating sure foreground (255), sure background (0)  *               and undecided regions ([1..254]).  * @x1:          region of interest  * @y1:          region of interest  * @x2:          region of interest  * @y2:          region of interest  * @sensitivity: a double array with three entries specifing the accuracy,  *               a good value is: { 0.64, 1.28, 2.56 }  * @smoothness:  boundary smoothness (a good value is 3)  * @multiblob:   allow multiple blobs (true) or only one (false)  *  * Writes the resulting segmentation into @mask. The region of  * interest as specified using @x1, @y1, @x2 and @y2 defines the  * bounding box of the background and undecided areas. No changes to  * the mask are done outside this rectangle.  */
end_comment

begin_function
name|void
DECL|function|siox_foreground_extract (SioxState * state,SioxRefinementType refinement,TileManager * mask,gint x1,gint y1,gint x2,gint y2,gint smoothness,const gdouble sensitivity[3],gboolean multiblob,SioxProgressFunc progress_callback,gpointer progress_data)
name|siox_foreground_extract
parameter_list|(
name|SioxState
modifier|*
name|state
parameter_list|,
name|SioxRefinementType
name|refinement
parameter_list|,
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|smoothness
parameter_list|,
specifier|const
name|gdouble
name|sensitivity
index|[
literal|3
index|]
parameter_list|,
name|gboolean
name|multiblob
parameter_list|,
name|SioxProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|PixelRegion
name|mapPR
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gfloat
name|clustersize
decl_stmt|;
name|lab
modifier|*
name|surebg
init|=
name|NULL
decl_stmt|;
name|lab
modifier|*
name|surefg
init|=
name|NULL
decl_stmt|;
name|gint
name|surebgcount
init|=
literal|0
decl_stmt|;
name|gint
name|surefgcount
init|=
literal|0
decl_stmt|;
name|gint
name|n
decl_stmt|;
name|gint
name|pixels
decl_stmt|,
name|total
decl_stmt|;
name|gfloat
name|limits
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|mask
operator|!=
name|NULL
operator|&&
name|tile_manager_bpp
argument_list|(
name|mask
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x1
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x2
operator|>
name|x1
operator|&&
name|x2
operator|<=
name|tile_manager_width
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|y1
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|y2
operator|>
name|y1
operator|&&
name|y2
operator|<=
name|tile_manager_height
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|smoothness
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|progress_data
operator|==
name|NULL
operator|||
name|progress_callback
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|state
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|state
operator|->
name|y
expr_stmt|;
name|width
operator|=
name|state
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|state
operator|->
name|height
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|+
name|width
operator|<=
name|tile_manager_width
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|y
operator|+
name|height
operator|<=
name|tile_manager_height
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|limits
index|[
literal|0
index|]
operator|=
name|sensitivity
index|[
literal|0
index|]
expr_stmt|;
name|limits
index|[
literal|1
index|]
operator|=
name|sensitivity
index|[
literal|1
index|]
expr_stmt|;
name|limits
index|[
literal|2
index|]
operator|=
name|sensitivity
index|[
literal|2
index|]
expr_stmt|;
name|clustersize
operator|=
name|get_clustersize
argument_list|(
name|limits
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|total
operator|=
name|width
operator|*
name|height
expr_stmt|;
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_FOREGROUND
condition|)
name|g_hash_table_foreach_remove
argument_list|(
name|state
operator|->
name|cache
argument_list|,
name|siox_cache_remove_bg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_BACKGROUND
condition|)
name|g_hash_table_foreach_remove
argument_list|(
name|state
operator|->
name|cache
argument_list|,
name|siox_cache_remove_fg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_CHANGE_SENSITIVITY
condition|)
block|{
name|refinement
operator|=
name|SIOX_REFINEMENT_RECALCULATE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|state
operator|->
name|bgsig
condition|)
name|refinement
operator||=
name|SIOX_REFINEMENT_ADD_BACKGROUND
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|fgsig
condition|)
name|refinement
operator||=
name|SIOX_REFINEMENT_ADD_FOREGROUND
expr_stmt|;
block|}
if|if
condition|(
name|refinement
operator|&
operator|(
name|SIOX_REFINEMENT_ADD_FOREGROUND
operator||
name|SIOX_REFINEMENT_ADD_BACKGROUND
operator|)
condition|)
block|{
comment|/* count given foreground and background pixels */
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|total
operator|=
name|width
operator|*
name|height
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|mapPR
argument_list|)
operator|,
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|mapPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|mapPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
condition|)
block|{
name|surebgcount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
block|{
name|surefgcount
operator|++
expr_stmt|;
block|}
block|}
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
name|pixels
operator|+=
name|mapPR
operator|.
name|w
operator|*
name|mapPR
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.1
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: usermask #surebg=%d #surefg=%d\n"
argument_list|,
name|surebgcount
argument_list|,
name|surefgcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_FOREGROUND
condition|)
name|surefg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surefgcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_BACKGROUND
condition|)
name|surebg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surebgcount
argument_list|)
expr_stmt|;
comment|/* create inputs for color signatures */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|state
operator|->
name|pixels
argument_list|,
name|x
operator|-
name|state
operator|->
name|offset_x
argument_list|,
name|y
operator|-
name|state
operator|->
name|offset_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|mapPR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_FOREGROUND
operator|)
condition|)
block|{
name|gint
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|state
operator|->
name|bpp
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|,
name|surebg
operator|+
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
name|pixels
operator|+=
name|mapPR
operator|.
name|w
operator|*
name|mapPR
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.1
operator|+
literal|0.1
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_BACKGROUND
operator|)
condition|)
block|{
name|gint
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|state
operator|->
name|bpp
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|,
name|surefg
operator|+
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
name|pixels
operator|+=
name|mapPR
operator|.
name|w
operator|*
name|mapPR
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.1
operator|+
literal|0.1
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* both changed */
block|{
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|gint
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pixels
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|state
operator|->
name|bpp
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|,
name|surebg
operator|+
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|,
name|surefg
operator|+
name|j
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
name|pixels
operator|+=
name|mapPR
operator|.
name|w
operator|*
name|mapPR
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|16
operator|==
literal|0
condition|)
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.1
operator|+
literal|0.1
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_BACKGROUND
condition|)
block|{
comment|/* Create color signature for the background */
name|state
operator|->
name|bgsig
operator|=
name|create_signature
argument_list|(
name|surebg
argument_list|,
name|surebgcount
argument_list|,
operator|&
name|state
operator|->
name|bgsiglen
argument_list|,
name|limits
argument_list|,
name|state
operator|->
name|bpp
operator|==
literal|1
condition|?
name|SIOX_GRAY_DIMS
else|:
name|SIOX_COLOR_DIMS
argument_list|,
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.3
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surebg
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|bgsiglen
operator|<
literal|1
condition|)
block|{
name|g_free
argument_list|(
name|surefg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.4
argument_list|)
expr_stmt|;
if|if
condition|(
name|refinement
operator|&
name|SIOX_REFINEMENT_ADD_FOREGROUND
condition|)
block|{
comment|/* Create color signature for the foreground */
name|state
operator|->
name|fgsig
operator|=
name|create_signature
argument_list|(
name|surefg
argument_list|,
name|surefgcount
argument_list|,
operator|&
name|state
operator|->
name|fgsiglen
argument_list|,
name|limits
argument_list|,
name|state
operator|->
name|bpp
operator|==
literal|1
condition|?
name|SIOX_GRAY_DIMS
else|:
name|SIOX_COLOR_DIMS
argument_list|,
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.45
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surefg
argument_list|)
expr_stmt|;
block|}
block|}
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
comment|/* Reduce the working area to the region of interest */
name|gimp_rectangle_intersect
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
comment|/* Classify - the cached way....Better: Tree traversation? */
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|gint
name|hits
init|=
literal|0
decl_stmt|;
name|gint
name|miss
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|state
operator|->
name|pixels
argument_list|,
name|x
operator|-
name|state
operator|->
name|offset_x
argument_list|,
name|y
operator|-
name|state
operator|->
name|offset_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|total
operator|=
name|width
operator|*
name|height
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|mapPR
argument_list|)
operator|,
name|n
operator|=
literal|0
operator|,
name|pixels
operator|=
literal|0
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|state
operator|->
name|bpp
control|)
block|{
name|lab
name|labpixel
decl_stmt|;
name|gfloat
name|minbg
decl_stmt|,
name|minfg
decl_stmt|,
name|d
decl_stmt|;
name|classresult
modifier|*
name|cr
decl_stmt|;
name|gint
name|key
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
operator|||
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
continue|continue;
name|key
operator|=
name|create_key
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|)
expr_stmt|;
name|cr
operator|=
name|g_hash_table_lookup
argument_list|(
name|state
operator|->
name|cache
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
condition|)
block|{
operator|*
name|m
operator|=
operator|(
name|cr
operator|->
name|bgdist
operator|>=
name|cr
operator|->
name|fgdist
operator|)
condition|?
literal|254
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
operator|++
name|hits
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SIOX_DEBUG
operator|++
name|miss
expr_stmt|;
endif|#
directive|endif
name|cr
operator|=
name|g_new0
argument_list|(
name|classresult
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|calc_lab
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|,
operator|&
name|labpixel
argument_list|)
expr_stmt|;
name|minbg
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|state
operator|->
name|bgsig
operator|+
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|state
operator|->
name|bgsiglen
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|state
operator|->
name|bgsig
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|minbg
condition|)
name|minbg
operator|=
name|d
expr_stmt|;
block|}
name|cr
operator|->
name|bgdist
operator|=
name|minbg
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|fgsiglen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|minbg
operator|<
name|clustersize
condition|)
name|minfg
operator|=
name|minbg
operator|+
name|clustersize
expr_stmt|;
else|else
name|minfg
operator|=
literal|0.00001
expr_stmt|;
comment|/* This is a guess -                                         now we actually require a foreground                                         signature, !=0 to avoid div by zero                                       */
block|}
else|else
block|{
name|minfg
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|state
operator|->
name|fgsig
operator|+
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|state
operator|->
name|fgsiglen
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|state
operator|->
name|fgsig
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|minfg
condition|)
block|{
name|minfg
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
name|cr
operator|->
name|fgdist
operator|=
name|minfg
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|state
operator|->
name|cache
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|key
argument_list|)
argument_list|,
name|cr
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|minbg
operator|>=
name|minfg
condition|?
literal|254
else|:
literal|0
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
name|pixels
operator|+=
name|mapPR
operator|.
name|w
operator|*
name|mapPR
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|8
operator|==
literal|0
condition|)
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.5
operator|+
literal|0.3
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|pixels
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: Hashtable size %d, misses=%d, hits=%d, ratio=%f\n"
argument_list|,
name|g_hash_table_size
argument_list|(
name|state
operator|->
name|cache
argument_list|)
argument_list|,
name|miss
argument_list|,
name|hits
argument_list|,
operator|(
operator|(
name|gfloat
operator|)
name|hits
operator|)
operator|/
name|miss
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* smooth a bit for error killing */
name|smooth_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* erode, to make sure only "strongly connected components"    * keep being connected    */
name|erode_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* search the biggest connected component */
name|find_max_blob
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|multiblob
condition|?
name|MULTIBLOB_DEFAULT_SIZEFACTOR
else|:
name|MULTIBLOB_ONE_BLOB_ONLY
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
comment|/* smooth again - as user specified */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|smoothness
condition|;
name|n
operator|++
control|)
name|smooth_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* search the biggest connected component again to kill jitter */
name|find_max_blob
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|multiblob
condition|?
name|MULTIBLOB_DEFAULT_SIZEFACTOR
else|:
name|MULTIBLOB_ONE_BLOB_ONLY
argument_list|)
expr_stmt|;
comment|/* dilate, to fill up boundary pixels killed by erode */
name|dilate_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * siox_drb:  * @state:        current state struct as constructed by siox_init  * @mask:  * @x:  * @y:  * @brush_radius: the radius of the brush  * @brush_mode:   at this time either SIOX_DRB_ADD or SIOX_DRB_SUBTRACT  * @threshold:    a threshold to be defined by the user.  *                Range for SIOX_DRB_ADD: ]0..1] default: 1.0,  *                range for for SIOX_DRB_SUBTRACT: [0..1[, default: 0.0  *  * drb - detail refinement brush, a brush mask for subpixel classification.  *  * FIXME: Now it is assumed that the brush is a square. Should be able  * to be whatever GIMP offers.  * TODO: This is still an experimental method. There are more tests  * needed to evaluate performance of this!  */
end_comment

begin_function
name|void
DECL|function|siox_drb (SioxState * state,TileManager * mask,gint x,gint y,gint brush_radius,gint brush_mode,gfloat threshold)
name|siox_drb
parameter_list|(
name|SioxState
modifier|*
name|state
parameter_list|,
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|brush_radius
parameter_list|,
name|gint
name|brush_mode
parameter_list|,
name|gfloat
name|threshold
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|PixelRegion
name|mapPR
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|state
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|mask
operator|!=
name|NULL
operator|&&
name|tile_manager_bpp
argument_list|(
name|mask
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|state
operator|->
name|pixels
argument_list|,
name|x
operator|-
name|brush_radius
argument_list|,
name|y
operator|-
name|brush_radius
argument_list|,
name|brush_radius
operator|*
literal|2
argument_list|,
name|brush_radius
operator|*
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
operator|-
name|brush_radius
argument_list|,
name|y
operator|-
name|brush_radius
argument_list|,
name|brush_radius
operator|*
literal|2
argument_list|,
name|brush_radius
operator|*
literal|2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|mapPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|state
operator|->
name|bpp
control|)
block|{
name|gint
name|key
decl_stmt|;
name|classresult
modifier|*
name|cr
decl_stmt|;
name|gfloat
name|mindistbg
decl_stmt|;
name|gfloat
name|mindistfg
decl_stmt|;
name|gfloat
name|alpha
decl_stmt|;
name|key
operator|=
name|create_key
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|bpp
argument_list|,
name|state
operator|->
name|colormap
argument_list|)
expr_stmt|;
name|cr
operator|=
name|g_hash_table_lookup
argument_list|(
name|state
operator|->
name|cache
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cr
condition|)
continue|continue;
comment|/* Unknown color -                              can only be sure background or sure forground */
name|mindistbg
operator|=
operator|(
name|gfloat
operator|)
name|sqrt
argument_list|(
name|cr
operator|->
name|bgdist
argument_list|)
expr_stmt|;
name|mindistfg
operator|=
operator|(
name|gfloat
operator|)
name|sqrt
argument_list|(
name|cr
operator|->
name|fgdist
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush_mode
operator|==
name|SIOX_DRB_ADD
condition|)
block|{
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
continue|continue;
if|if
condition|(
name|mindistfg
operator|==
literal|0.0
condition|)
name|alpha
operator|=
literal|1.0
expr_stmt|;
comment|/* avoid div by zero */
else|else
name|alpha
operator|=
name|MIN
argument_list|(
name|mindistbg
operator|/
name|mindistfg
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*if (brush_mode == SIOX_DRB_SUBTRACT)*/
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_HIGH
condition|)
continue|continue;
if|if
condition|(
name|mindistbg
operator|==
literal|0.0
condition|)
name|alpha
operator|=
literal|0.0
expr_stmt|;
comment|/* avoid div by zero */
else|else
name|alpha
operator|=
literal|1.0
operator|-
name|MIN
argument_list|(
name|mindistfg
operator|/
name|mindistbg
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha
operator|<
name|threshold
condition|)
block|{
comment|/* background with a certain confidence                    * to be decided by user.                    */
operator|*
name|m
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|m
operator|=
call|(
name|gint
call|)
argument_list|(
literal|255.999
operator|*
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * siox_done:  * @state: The state of this tool.  *  * Frees the memory assciated with the state.  */
end_comment

begin_function
name|void
DECL|function|siox_done (SioxState * state)
name|siox_done
parameter_list|(
name|SioxState
modifier|*
name|state
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|state
operator|->
name|fgsig
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|state
operator|->
name|bgsig
argument_list|)
expr_stmt|;
name|g_hash_table_destroy
argument_list|(
name|state
operator|->
name|cache
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOX_DEBUG
name|g_printerr
argument_list|(
literal|"siox.c: siox_done()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

