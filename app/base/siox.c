begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SIOX: Simple Interactive Object Extraction  *  * For algorithm documentation refer to:  * G. Friedland, K. Jantz, L. Knipping, R. Rojas:  * "Image Segmentation by Uniform Color Clustering  *  -- Approach and Benchmark Results",  * Technical Report B-05-07, Department of Computer Science,  * Freie Universitaet Berlin, June 2005.  * http://www.inf.fu-berlin.de/inst/pubs/tr-b-05-07.pdf  *  * See http://www.siox.org/ for more information.  *  * Algorithm idea by Gerald Friedland.  * This implementation is Copyright (C) 2005  * by Gerald Friedland<fland@inf.fu-berlin.de>  * and Kristian Jantz<jantz@inf.fu-berlin.de>.  *  * Adapted for GIMP by Sven Neumann<sven@gimp.org>  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  * 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"base-types.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"cpercep.h"
end_include

begin_include
include|#
directive|include
file|"pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"siox.h"
end_include

begin_include
include|#
directive|include
file|"tile-manager.h"
end_include

begin_comment
comment|/* Amount of color dimensions in one point */
end_comment

begin_define
DECL|macro|SIOX_DIMS
define|#
directive|define
name|SIOX_DIMS
value|3
end_define

begin_comment
comment|/* Thresholds in the mask:  *   pixels< LOW are known background  *   pixels> HIGH are known foreground  */
end_comment

begin_define
DECL|macro|SIOX_LOW
define|#
directive|define
name|SIOX_LOW
value|1
end_define

begin_define
DECL|macro|SIOX_HIGH
define|#
directive|define
name|SIOX_HIGH
value|254
end_define

begin_comment
comment|/* #define DEBUG */
end_comment

begin_comment
comment|/* Simulate a java.util.ArrayList */
end_comment

begin_comment
comment|/* Could be improved. At the moment we are wasting a node per list and  * the tail pointer on each node is only used in the first node.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2945da9e0108
block|{
DECL|member|l
name|gfloat
name|l
decl_stmt|;
DECL|member|a
name|gfloat
name|a
decl_stmt|;
DECL|member|b
name|gfloat
name|b
decl_stmt|;
DECL|member|cardinality
name|gint
name|cardinality
decl_stmt|;
DECL|typedef|lab
block|}
name|lab
typedef|;
end_typedef

begin_typedef
DECL|typedef|ArrayList
typedef|typedef
name|struct
name|_ArrayList
name|ArrayList
typedef|;
end_typedef

begin_struct
DECL|struct|_ArrayList
struct|struct
name|_ArrayList
block|{
DECL|member|array
name|lab
modifier|*
name|array
decl_stmt|;
DECL|member|arraylength
name|guint
name|arraylength
decl_stmt|;
DECL|member|owned
name|gboolean
name|owned
decl_stmt|;
DECL|member|next
name|ArrayList
modifier|*
name|next
decl_stmt|;
DECL|member|tail
name|ArrayList
modifier|*
name|tail
decl_stmt|;
comment|/* only valid in the root item */
block|}
struct|;
end_struct

begin_function
specifier|static
name|ArrayList
modifier|*
DECL|function|list_new (void)
name|list_new
parameter_list|(
name|void
parameter_list|)
block|{
name|ArrayList
modifier|*
name|list
init|=
name|g_new0
argument_list|(
name|ArrayList
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|list
operator|->
name|tail
operator|=
name|list
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|add_to_list (ArrayList * list,lab * array,guint arraylength,gboolean take)
name|add_to_list
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|,
name|lab
modifier|*
name|array
parameter_list|,
name|guint
name|arraylength
parameter_list|,
name|gboolean
name|take
parameter_list|)
block|{
name|ArrayList
modifier|*
name|tail
init|=
name|list
operator|->
name|tail
decl_stmt|;
name|tail
operator|->
name|array
operator|=
name|array
expr_stmt|;
name|tail
operator|->
name|arraylength
operator|=
name|arraylength
expr_stmt|;
name|tail
operator|->
name|owned
operator|=
name|take
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|tail
operator|->
name|next
operator|=
name|g_new0
argument_list|(
name|ArrayList
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|list_size (ArrayList * list)
name|list_size
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|)
block|{
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cur
operator|->
name|array
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|lab
modifier|*
DECL|function|list_to_array (ArrayList * list,gint * returnlength)
name|list_to_array
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|,
name|gint
modifier|*
name|returnlength
parameter_list|)
block|{
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|gint
name|len
init|=
name|list_size
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|lab
modifier|*
name|array
init|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|len
argument_list|)
decl_stmt|;
operator|*
name|returnlength
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|cur
operator|->
name|array
condition|)
block|{
name|array
index|[
name|i
operator|++
index|]
operator|=
name|cur
operator|->
name|array
index|[
literal|0
index|]
expr_stmt|;
comment|/* Every array in the list node has only one point        * when we call this method        */
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|free_list (ArrayList * list)
name|free_list
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|)
block|{
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|ArrayList
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|owned
condition|)
name|g_free
argument_list|(
name|prev
operator|->
name|array
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME: try to use cpersep conversion here, should be faster */
end_comment

begin_function
specifier|static
name|void
DECL|function|calc_lab (const guchar * src,gint bpp,const guchar * colormap,lab * pixel)
name|calc_lab
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|bpp
parameter_list|,
specifier|const
name|guchar
modifier|*
name|colormap
parameter_list|,
name|lab
modifier|*
name|pixel
parameter_list|)
block|{
name|gdouble
name|l
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|3
case|:
comment|/* RGB  */
case|case
literal|4
case|:
comment|/* RGBA */
name|cpercep_rgb_to_space
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
if|if
condition|(
name|colormap
condition|)
comment|/* INDEXED(A) */
block|{
name|gint
name|i
init|=
operator|*
name|src
operator|*
literal|3
decl_stmt|;
name|cpercep_rgb_to_space
argument_list|(
name|colormap
index|[
name|i
operator|+
name|RED_PIX
index|]
argument_list|,
name|colormap
index|[
name|i
operator|+
name|GREEN_PIX
index|]
argument_list|,
name|colormap
index|[
name|i
operator|+
name|BLUE_PIX
index|]
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* GRAY(A) */
block|{
comment|/*  FIXME: there should be cpercep_gray_to_space  */
name|cpercep_rgb_to_space
argument_list|(
operator|*
name|src
argument_list|,
operator|*
name|src
argument_list|,
operator|*
name|src
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_return_if_reached
argument_list|()
expr_stmt|;
block|}
name|pixel
operator|->
name|l
operator|=
name|l
expr_stmt|;
name|pixel
operator|->
name|a
operator|=
name|a
expr_stmt|;
name|pixel
operator|->
name|b
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  assumes that lab starts with an array of floats (l,a,b)  */
end_comment

begin_define
DECL|macro|CURRENT_VALUE (points,i,dim)
define|#
directive|define
name|CURRENT_VALUE
parameter_list|(
name|points
parameter_list|,
name|i
parameter_list|,
name|dim
parameter_list|)
value|(((const gfloat *) (points + i))[dim])
end_define

begin_comment
comment|/* Stage one of modified KD-Tree algorithm */
end_comment

begin_function
specifier|static
name|void
DECL|function|stageone (lab * points,gint dims,gint depth,ArrayList * clusters,const gfloat * limits,gint length)
name|stageone
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|gint
name|dims
parameter_list|,
name|gint
name|depth
parameter_list|,
name|ArrayList
modifier|*
name|clusters
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
name|gint
name|length
parameter_list|)
block|{
name|gint
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|countsm
decl_stmt|,
name|countgr
decl_stmt|,
name|smallc
decl_stmt|,
name|bigc
decl_stmt|;
name|gfloat
name|min
decl_stmt|,
name|max
decl_stmt|;
name|gfloat
name|pivotvalue
decl_stmt|,
name|curval
decl_stmt|;
name|lab
modifier|*
name|smallerpoints
decl_stmt|;
name|lab
modifier|*
name|biggerpoints
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
name|min
operator|=
name|curval
expr_stmt|;
name|max
operator|=
name|curval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|pivotvalue
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|/
literal|2.0
operator|)
operator|+
name|min
expr_stmt|;
name|countsm
operator|=
literal|0
expr_stmt|;
name|countgr
operator|=
literal|0
expr_stmt|;
comment|/* find out cluster sizes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
name|countsm
operator|++
expr_stmt|;
else|else
name|countgr
operator|++
expr_stmt|;
block|}
comment|/* FIXME: consider to sort the array and split in place instead        *        of allocating memory here        */
name|smallerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countsm
argument_list|)
expr_stmt|;
name|biggerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countgr
argument_list|)
expr_stmt|;
name|smallc
operator|=
literal|0
expr_stmt|;
name|bigc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* do actual split */
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
name|smallerpoints
index|[
name|smallc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
else|else
name|biggerpoints
index|[
name|bigc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
comment|/* create subtrees */
name|stageone
argument_list|(
name|smallerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countsm
argument_list|)
expr_stmt|;
name|stageone
argument_list|(
name|biggerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countgr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* create leave */
name|add_to_list
argument_list|(
name|clusters
argument_list|,
name|points
argument_list|,
name|length
argument_list|,
name|depth
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stage two of modified KD-Tree algorithm */
end_comment

begin_comment
comment|/* This is very similar to stageone... but in future there will be more  * differences => not integrated into method stageone()  */
end_comment

begin_function
specifier|static
name|void
DECL|function|stagetwo (lab * points,gint dims,gint depth,ArrayList * clusters,const gfloat * limits,gint length,gint total,gfloat threshold)
name|stagetwo
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|gint
name|dims
parameter_list|,
name|gint
name|depth
parameter_list|,
name|ArrayList
modifier|*
name|clusters
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
name|gint
name|length
parameter_list|,
name|gint
name|total
parameter_list|,
name|gfloat
name|threshold
parameter_list|)
block|{
name|gint
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|gfloat
name|min
decl_stmt|,
name|max
decl_stmt|;
name|gfloat
name|pivotvalue
decl_stmt|,
name|curval
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|countsm
decl_stmt|,
name|countgr
decl_stmt|,
name|smallc
decl_stmt|,
name|bigc
decl_stmt|;
name|gint
name|sum
decl_stmt|;
name|lab
modifier|*
name|point
decl_stmt|;
name|lab
modifier|*
name|smallerpoints
decl_stmt|;
name|lab
modifier|*
name|biggerpoints
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
name|min
operator|=
name|curval
expr_stmt|;
name|max
operator|=
name|curval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|pivotvalue
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|/
literal|2.0
operator|)
operator|+
name|min
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|g_printerr
argument_list|(
literal|"max=%f min=%f pivot=%f\n"
argument_list|,
name|max
argument_list|,
name|min
argument_list|,
name|pivotvalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|countsm
operator|=
literal|0
expr_stmt|;
name|countgr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* find out cluster sizes */
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
name|countsm
operator|++
expr_stmt|;
else|else
name|countgr
operator|++
expr_stmt|;
block|}
comment|/* FIXME: consider to sort the array and split in place instead        *        of allocating memory here        */
name|smallerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countsm
argument_list|)
expr_stmt|;
name|biggerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countgr
argument_list|)
expr_stmt|;
name|smallc
operator|=
literal|0
expr_stmt|;
name|bigc
operator|=
literal|0
expr_stmt|;
comment|/* do actual split */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curval
operator|=
name|CURRENT_VALUE
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|curdim
argument_list|)
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
name|smallerpoints
index|[
name|smallc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
else|else
name|biggerpoints
index|[
name|bigc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
comment|/* create subtrees */
name|stagetwo
argument_list|(
name|smallerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countsm
argument_list|,
name|total
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
name|stagetwo
argument_list|(
name|biggerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countgr
argument_list|,
name|total
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* create leave */
block|{
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|cardinality
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sum
operator|*
literal|100.0
operator|)
operator|/
name|total
operator|)
operator|>=
name|threshold
condition|)
block|{
name|point
operator|=
name|g_new0
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|point
operator|->
name|l
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
name|point
operator|->
name|a
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
name|point
operator|->
name|b
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
block|}
name|point
operator|->
name|l
operator|/=
name|length
expr_stmt|;
name|point
operator|->
name|a
operator|/=
name|length
expr_stmt|;
name|point
operator|->
name|b
operator|/=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|g_printerr
argument_list|(
literal|"cluster=%f, %f, %f sum=%d\n"
argument_list|,
name|point
operator|->
name|l
argument_list|,
name|point
operator|->
name|a
argument_list|,
name|point
operator|->
name|b
argument_list|,
name|sum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_to_list
argument_list|(
name|clusters
argument_list|,
name|point
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* squared euclidean distance */
end_comment

begin_function
specifier|static
specifier|inline
name|float
DECL|function|euklid (const lab * p,const lab * q)
name|euklid
parameter_list|(
specifier|const
name|lab
modifier|*
name|p
parameter_list|,
specifier|const
name|lab
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
operator|->
name|l
operator|-
name|q
operator|->
name|l
operator|)
operator|*
operator|(
name|p
operator|->
name|l
operator|-
name|q
operator|->
name|l
operator|)
operator|+
operator|(
name|p
operator|->
name|a
operator|-
name|q
operator|->
name|a
operator|)
operator|*
operator|(
name|p
operator|->
name|a
operator|-
name|q
operator|->
name|a
operator|)
operator|+
operator|(
name|p
operator|->
name|b
operator|-
name|q
operator|->
name|b
operator|)
operator|*
operator|(
name|p
operator|->
name|b
operator|-
name|q
operator|->
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns squared clustersize */
end_comment

begin_function
specifier|static
name|gfloat
DECL|function|get_clustersize (const gfloat * limits)
name|get_clustersize
parameter_list|(
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|)
block|{
return|return
operator|(
operator|(
name|limits
index|[
literal|0
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|0
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|0
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|0
index|]
operator|)
operator|)
operator|+
operator|(
name|limits
index|[
literal|1
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|1
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|1
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|1
index|]
operator|)
operator|)
operator|+
operator|(
name|limits
index|[
literal|2
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|2
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|2
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|2
index|]
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Creates a color signature for a given set of pixels */
end_comment

begin_function
specifier|static
name|lab
modifier|*
DECL|function|create_signature (lab * input,gint length,const gfloat * limits,gint * returnlength)
name|create_signature
parameter_list|(
name|lab
modifier|*
name|input
parameter_list|,
name|gint
name|length
parameter_list|,
specifier|const
name|gfloat
modifier|*
name|limits
parameter_list|,
name|gint
modifier|*
name|returnlength
parameter_list|)
block|{
name|ArrayList
modifier|*
name|clusters
decl_stmt|;
name|ArrayList
modifier|*
name|curelem
decl_stmt|;
name|lab
modifier|*
name|centroids
decl_stmt|;
name|lab
modifier|*
name|cluster
decl_stmt|;
name|lab
modifier|*
name|rval
decl_stmt|;
name|gint
name|k
decl_stmt|,
name|i
decl_stmt|;
name|gint
name|size
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
operator|*
name|returnlength
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|clusters
operator|=
name|list_new
argument_list|()
expr_stmt|;
name|stageone
argument_list|(
name|input
argument_list|,
name|SIOX_DIMS
argument_list|,
literal|0
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|size
operator|=
name|list_size
argument_list|(
name|clusters
argument_list|)
expr_stmt|;
name|centroids
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|curelem
operator|=
name|clusters
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curelem
operator|->
name|array
condition|)
block|{
name|gfloat
name|l
init|=
literal|0
decl_stmt|;
name|gfloat
name|a
init|=
literal|0
decl_stmt|;
name|gfloat
name|b
init|=
literal|0
decl_stmt|;
name|cluster
operator|=
name|curelem
operator|->
name|array
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|curelem
operator|->
name|arraylength
condition|;
name|k
operator|++
control|)
block|{
name|l
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|l
expr_stmt|;
name|a
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|a
expr_stmt|;
name|b
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|b
expr_stmt|;
block|}
name|centroids
index|[
name|i
index|]
operator|.
name|l
operator|=
name|l
operator|/
name|curelem
operator|->
name|arraylength
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|a
operator|=
name|a
operator|/
name|curelem
operator|->
name|arraylength
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|b
operator|=
name|b
operator|/
name|curelem
operator|->
name|arraylength
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|cardinality
operator|=
name|curelem
operator|->
name|arraylength
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|curelem
operator|=
name|curelem
operator|->
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|g_printerr
argument_list|(
literal|"step #1 -> %d clusters\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_list
argument_list|(
name|clusters
argument_list|)
expr_stmt|;
name|clusters
operator|=
name|list_new
argument_list|()
expr_stmt|;
name|stagetwo
argument_list|(
name|centroids
argument_list|,
name|SIOX_DIMS
argument_list|,
literal|0
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|size
argument_list|,
name|length
argument_list|,
literal|0.1
comment|/* magic constant, see paper by tomasi */
argument_list|)
expr_stmt|;
name|rval
operator|=
name|list_to_array
argument_list|(
name|clusters
argument_list|,
name|returnlength
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|clusters
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|g_printerr
argument_list|(
literal|"step #2 -> %d clusters\n"
argument_list|,
name|returnlength
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|threshold_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|threshold_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|region
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|guchar
modifier|*
name|data
init|=
name|region
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|region
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|data
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|region
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|d
operator|++
control|)
operator|*
name|d
operator|=
operator|(
operator|*
name|d
operator|&
literal|0x80
operator|)
condition|?
literal|255
else|:
literal|0
expr_stmt|;
name|data
operator|+=
name|region
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|smooth_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|smooth_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|smooth_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|erode_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|erode_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|erode_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dilate_mask (TileManager * mask,gint x,gint y,gint width,gint height)
name|dilate_mask
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|PixelRegion
name|region
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dilate_region
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_max_blob (TileManager * mask,gint x,gint y,gint width,gint height)
name|find_max_blob
parameter_list|(
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|GQueue
modifier|*
name|q
init|=
name|g_queue_new
argument_list|()
decl_stmt|;
name|gint
name|length
init|=
name|width
operator|*
name|height
decl_stmt|;
name|gint
modifier|*
name|labelfield
init|=
name|g_new0
argument_list|(
name|gint
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|PixelRegion
name|region
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|curlabel
init|=
literal|1
decl_stmt|;
name|gint
name|maxregion
init|=
literal|0
decl_stmt|;
name|gint
name|maxblob
init|=
literal|0
decl_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|region
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|data
init|=
name|region
operator|.
name|data
decl_stmt|;
name|gint
name|index
init|=
operator|(
name|region
operator|.
name|x
operator|-
name|x
operator|)
operator|+
operator|(
name|region
operator|.
name|y
operator|-
name|y
operator|)
operator|*
name|width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|region
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|gint
name|i
init|=
name|index
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|region
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|d
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|gint
name|regioncount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|labelfield
index|[
name|i
index|]
operator|==
literal|0
operator|&&
operator|*
name|d
operator|>
literal|127
condition|)
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|gint
name|pos
init|=
name|GPOINTER_TO_INT
argument_list|(
name|g_queue_pop_head
argument_list|(
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|length
condition|)
continue|continue;
if|if
condition|(
name|labelfield
index|[
name|pos
index|]
operator|==
literal|0
condition|)
block|{
name|guchar
name|val
decl_stmt|;
name|read_pixel_data_1
argument_list|(
name|mask
argument_list|,
name|pos
operator|%
name|width
argument_list|,
name|pos
operator|/
name|width
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
condition|)
block|{
name|labelfield
index|[
name|pos
index|]
operator|=
name|curlabel
expr_stmt|;
name|regioncount
operator|++
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|pos
operator|+
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|q
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|pos
operator|-
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regioncount
operator|>
name|maxregion
condition|)
block|{
name|maxregion
operator|=
name|regioncount
expr_stmt|;
name|maxblob
operator|=
name|curlabel
expr_stmt|;
block|}
name|curlabel
operator|++
expr_stmt|;
block|}
name|data
operator|+=
name|region
operator|.
name|rowstride
expr_stmt|;
name|index
operator|+=
name|width
expr_stmt|;
block|}
block|}
name|pixel_region_init
argument_list|(
operator|&
name|region
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|region
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|guchar
modifier|*
name|data
init|=
name|region
operator|.
name|data
decl_stmt|;
name|gint
name|index
init|=
operator|(
name|region
operator|.
name|x
operator|-
name|x
operator|)
operator|+
operator|(
name|region
operator|.
name|y
operator|-
name|y
operator|)
operator|*
name|width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|region
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|guchar
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|gint
name|i
init|=
name|index
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|region
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|d
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|labelfield
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|labelfield
index|[
name|i
index|]
operator|!=
name|maxblob
condition|)
operator|*
name|d
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|+=
name|region
operator|.
name|rowstride
expr_stmt|;
name|index
operator|+=
name|width
expr_stmt|;
block|}
block|}
name|g_queue_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|labelfield
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|siox_progress_update (SioxProgressFunc progress_callback,gpointer progress_data,gdouble value)
name|siox_progress_update
parameter_list|(
name|SioxProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|,
name|gdouble
name|value
parameter_list|)
block|{
if|if
condition|(
name|progress_data
condition|)
name|progress_callback
argument_list|(
name|progress_data
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * siox_foreground_extract:  * @pixels:     the tiles to extract the foreground from  * @colormap:   colormap in case @pixels are indexed, %NULL otherwise  * @offset_x:   horizontal offset of @pixels with respect to the @mask  * @offset_y:   vertical offset of @pixels with respect to the @mask   * @mask:       a mask indicating sure foreground (255), sure background (0)  *              and undecided regions ([1..254]).  * @x:          horizontal offset into the mask  * @y:          vertical offset into the mask  * @width:      width of working area on mask  * @height:     height of working area on mask  * @limits:     a double array with three entries specifing the accuracy,  *              a good value is: { 0.66, 1.25, 2.5 }  * @smoothness: boundary smoothness (a good value is 3)  *  * Writes the resulting segmentation into @mask.  */
end_comment

begin_function
name|void
DECL|function|siox_foreground_extract (TileManager * pixels,const guchar * colormap,gint offset_x,gint offset_y,TileManager * mask,gint x,gint y,gint width,gint height,gint smoothness,const gdouble limits[SIOX_DIMS],SioxProgressFunc progress_callback,gpointer progress_data)
name|siox_foreground_extract
parameter_list|(
name|TileManager
modifier|*
name|pixels
parameter_list|,
specifier|const
name|guchar
modifier|*
name|colormap
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|,
name|TileManager
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|smoothness
parameter_list|,
specifier|const
name|gdouble
name|limits
index|[
name|SIOX_DIMS
index|]
parameter_list|,
name|SioxProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|PixelRegion
name|mapPR
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gfloat
name|clustersize
decl_stmt|;
name|gint
name|surebgcount
init|=
literal|0
decl_stmt|;
name|gint
name|surefgcount
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|bgsiglen
decl_stmt|,
name|fgsiglen
decl_stmt|;
name|lab
modifier|*
name|surebg
decl_stmt|;
name|lab
modifier|*
name|surefg
decl_stmt|;
name|lab
modifier|*
name|bgsig
decl_stmt|;
name|lab
modifier|*
name|fgsig
decl_stmt|;
name|gfloat
name|flimits
index|[
literal|3
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|pixels
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|mask
operator|!=
name|NULL
operator|&&
name|tile_manager_bpp
argument_list|(
name|mask
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|y
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|+
name|width
operator|<=
name|tile_manager_width
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|y
operator|+
name|height
operator|<=
name|tile_manager_height
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|smoothness
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|progress_data
operator|==
name|NULL
operator|||
name|progress_callback
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cpercep_init
argument_list|()
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|flimits
index|[
literal|0
index|]
operator|=
name|limits
index|[
literal|0
index|]
expr_stmt|;
name|flimits
index|[
literal|1
index|]
operator|=
name|limits
index|[
literal|1
index|]
expr_stmt|;
name|flimits
index|[
literal|2
index|]
operator|=
name|limits
index|[
literal|2
index|]
expr_stmt|;
name|clustersize
operator|=
name|get_clustersize
argument_list|(
name|flimits
argument_list|)
expr_stmt|;
comment|/* count given foreground and background pixels */
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|mapPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|mapPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|mapPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
condition|)
name|surebgcount
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
name|surefgcount
operator|++
expr_stmt|;
block|}
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
name|surebg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surebgcount
argument_list|)
expr_stmt|;
name|surefg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surefgcount
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
comment|/* create inputs for color signatures */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|pixels
argument_list|,
name|x
operator|-
name|offset_x
argument_list|,
name|y
operator|-
name|offset_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|mapPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|bpp
control|)
block|{
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|bpp
argument_list|,
name|colormap
argument_list|,
name|surebg
operator|+
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
block|{
name|calc_lab
argument_list|(
name|s
argument_list|,
name|bpp
argument_list|,
name|colormap
argument_list|,
name|surefg
operator|+
name|j
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.2
argument_list|)
expr_stmt|;
comment|/* Create color signature for the background */
name|bgsig
operator|=
name|create_signature
argument_list|(
name|surebg
argument_list|,
name|surebgcount
argument_list|,
name|flimits
argument_list|,
operator|&
name|bgsiglen
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surebg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgsiglen
operator|<
literal|1
condition|)
block|{
name|g_free
argument_list|(
name|surefg
argument_list|)
expr_stmt|;
return|return;
block|}
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.3
argument_list|)
expr_stmt|;
comment|/* Create color signature for the foreground */
name|fgsig
operator|=
name|create_signature
argument_list|(
name|surefg
argument_list|,
name|surefgcount
argument_list|,
name|flimits
argument_list|,
operator|&
name|fgsiglen
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surefg
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.4
argument_list|)
expr_stmt|;
comment|/* Classify - the slow way....Better: Tree traversation */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|pixels
argument_list|,
name|x
operator|-
name|offset_x
argument_list|,
name|y
operator|-
name|offset_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mapPR
argument_list|,
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|mapPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|srcPR
operator|.
name|data
decl_stmt|;
name|guchar
modifier|*
name|map
init|=
name|mapPR
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|srcPR
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|guchar
modifier|*
name|m
init|=
name|map
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|srcPR
operator|.
name|w
condition|;
name|col
operator|++
operator|,
name|m
operator|++
operator|,
name|s
operator|+=
name|bpp
control|)
block|{
name|lab
name|labpixel
decl_stmt|;
name|gboolean
name|background
init|=
name|FALSE
decl_stmt|;
name|gfloat
name|min
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
operator|*
name|m
operator|<
name|SIOX_LOW
operator|||
operator|*
name|m
operator|>
name|SIOX_HIGH
condition|)
continue|continue;
name|calc_lab
argument_list|(
name|s
argument_list|,
name|bpp
argument_list|,
name|colormap
argument_list|,
operator|&
name|labpixel
argument_list|)
expr_stmt|;
name|background
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|bgsig
operator|+
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|bgsiglen
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|bgsig
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|min
condition|)
name|min
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|fgsiglen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|min
operator|<
name|clustersize
condition|)
name|background
operator|=
name|TRUE
expr_stmt|;
else|else
name|background
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fgsiglen
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
operator|&
name|labpixel
argument_list|,
name|fgsig
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|d
expr_stmt|;
name|background
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|m
operator|=
name|background
condition|?
literal|0
else|:
literal|255
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|map
operator|+=
name|mapPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|fgsig
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bgsig
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
comment|/* Smooth a bit for error killing */
name|smooth_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Now erode, to make sure only "strongly connected components"    * keep being connected    */
name|erode_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* search the biggest connected component */
name|find_max_blob
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* smooth again - as user specified */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|smoothness
condition|;
name|i
operator|++
control|)
name|smooth_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Threshold the values */
name|threshold_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* search the biggest connected component again to kill jitter */
name|find_max_blob
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Now dilate, to fill up boundary pixels killed by erode */
name|dilate_mask
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|siox_progress_update
argument_list|(
name|progress_callback
argument_list|,
name|progress_data
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

