begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The GIMP Foreground Extraction Utility  * segmentator.c - main algorithm.  *  * For algorithm documentation refer to:  * G. Friedland, K. Jantz, L. Knipping, R. Rojas:  * "Image Segmentation by Uniform Color Clustering  *  -- Approach and Benchmark Results",  * Technical Report B-05-07, Department of Computer Science,  * Freie Universitaet Berlin, June 2005.  * http://www.inf.fu-berlin.de/inst/pubs/tr-b-05-07.pdf  *  * Algorithm idea by Gerald Friedland.  * This implementation is Copyright (C) 2005  * by Gerald Friedland<fland@inf.fu-berlin.de>  * and Kristian Jantz<jantz@inf.fu-berlin.de>.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  * 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"segmentator.h"
end_include

begin_comment
comment|/* Please look all the way down for an explanation of JNI_COMPILE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JNI_COMPILE
end_ifdef

begin_include
include|#
directive|include
file|"NativeExperimentalPipe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Simulate a java.util.ArrayList */
end_comment

begin_comment
comment|/* These methods are NOT generic */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c113e290108
block|{
DECL|member|l
name|float
name|l
decl_stmt|;
DECL|member|a
name|float
name|a
decl_stmt|;
DECL|member|b
name|float
name|b
decl_stmt|;
DECL|member|cardinality
name|int
name|cardinality
decl_stmt|;
DECL|typedef|lab
block|}
name|lab
typedef|;
end_typedef

begin_typedef
DECL|typedef|ArrayList
typedef|typedef
name|struct
name|_ArrayList
name|ArrayList
typedef|;
end_typedef

begin_struct
DECL|struct|_ArrayList
struct|struct
name|_ArrayList
block|{
DECL|member|array
name|lab
modifier|*
name|array
decl_stmt|;
DECL|member|arraylength
name|int
name|arraylength
decl_stmt|;
DECL|member|next
name|ArrayList
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
DECL|function|addtoList (ArrayList * list,lab * newarray,int newarraylength)
name|addtoList
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|,
name|lab
modifier|*
name|newarray
parameter_list|,
name|int
name|newarraylength
parameter_list|)
block|{
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
name|ArrayList
modifier|*
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|cur
condition|)
do|;
name|prev
operator|->
name|next
operator|=
name|g_new0
argument_list|(
name|ArrayList
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prev
operator|->
name|array
operator|=
name|newarray
expr_stmt|;
name|prev
operator|->
name|arraylength
operator|=
name|newarraylength
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|listSize (ArrayList * list)
name|listSize
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
while|while
condition|(
name|cur
operator|->
name|array
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|lab
modifier|*
DECL|function|listToArray (ArrayList * list,int * returnlength)
name|listToArray
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|returnlength
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
name|lab
modifier|*
name|arraytoreturn
decl_stmt|;
name|len
operator|=
name|listSize
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|arraytoreturn
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|returnlength
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|cur
operator|->
name|array
condition|)
block|{
name|arraytoreturn
index|[
name|i
operator|++
index|]
operator|=
name|cur
operator|->
name|array
index|[
literal|0
index|]
expr_stmt|;
comment|/* Every array in the list node has only one point        * when we call this method        */
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
return|return
name|arraytoreturn
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|freelist (ArrayList * list)
name|freelist
parameter_list|(
name|ArrayList
modifier|*
name|list
parameter_list|)
block|{
name|ArrayList
modifier|*
name|cur
init|=
name|list
decl_stmt|;
name|ArrayList
modifier|*
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|array
condition|)
name|g_free
argument_list|(
name|prev
operator|->
name|array
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cur
condition|)
do|;
block|}
end_function

begin_comment
comment|/* RGB -> CIELAB and other interesting methods... */
end_comment

begin_function
DECL|function|getRed (guint rgb)
specifier|static
name|guchar
name|getRed
parameter_list|(
name|guint
name|rgb
parameter_list|)
block|{
return|return
operator|(
name|rgb
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_function
DECL|function|getGreen (guint rgb)
specifier|static
name|guchar
name|getGreen
parameter_list|(
name|guint
name|rgb
parameter_list|)
block|{
return|return
operator|(
name|rgb
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_function
DECL|function|getBlue (guint rgb)
specifier|static
name|guchar
name|getBlue
parameter_list|(
name|guint
name|rgb
parameter_list|)
block|{
return|return
operator|(
name|rgb
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static guchar getAlpha (guint rgb) {   return (rgb>> 24)& 0xFF; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Gets an int containing rgb, and an lab struct */
end_comment

begin_function
DECL|function|calcLAB (guint rgb,lab * newpixel)
specifier|static
name|lab
modifier|*
name|calcLAB
parameter_list|(
name|guint
name|rgb
parameter_list|,
name|lab
modifier|*
name|newpixel
parameter_list|)
block|{
name|float
name|var_R
init|=
operator|(
name|getRed
argument_list|(
name|rgb
argument_list|)
operator|/
literal|255.0
operator|)
decl_stmt|;
name|float
name|var_G
init|=
operator|(
name|getGreen
argument_list|(
name|rgb
argument_list|)
operator|/
literal|255.0
operator|)
decl_stmt|;
name|float
name|var_B
init|=
operator|(
name|getBlue
argument_list|(
name|rgb
argument_list|)
operator|/
literal|255.0
operator|)
decl_stmt|;
name|float
name|X
decl_stmt|,
name|Y
decl_stmt|,
name|Z
decl_stmt|,
name|var_X
decl_stmt|,
name|var_Y
decl_stmt|,
name|var_Z
decl_stmt|;
if|if
condition|(
name|var_R
operator|>
literal|0.04045
condition|)
name|var_R
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|var_R
operator|+
literal|0.055
operator|)
operator|/
literal|1.055
argument_list|,
literal|2.4
argument_list|)
expr_stmt|;
else|else
name|var_R
operator|=
name|var_R
operator|/
literal|12.92
expr_stmt|;
if|if
condition|(
name|var_G
operator|>
literal|0.04045
condition|)
name|var_G
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|var_G
operator|+
literal|0.055
operator|)
operator|/
literal|1.055
argument_list|,
literal|2.4
argument_list|)
expr_stmt|;
else|else
name|var_G
operator|=
name|var_G
operator|/
literal|12.92
expr_stmt|;
if|if
condition|(
name|var_B
operator|>
literal|0.04045
condition|)
name|var_B
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|var_B
operator|+
literal|0.055
operator|)
operator|/
literal|1.055
argument_list|,
literal|2.4
argument_list|)
expr_stmt|;
else|else
name|var_B
operator|=
name|var_B
operator|/
literal|12.92
expr_stmt|;
name|var_R
operator|=
name|var_R
operator|*
literal|100.0
expr_stmt|;
name|var_G
operator|=
name|var_G
operator|*
literal|100.0
expr_stmt|;
name|var_B
operator|=
name|var_B
operator|*
literal|100.0
expr_stmt|;
comment|/* Observer. = 2Â°, Illuminant = D65 */
name|X
operator|=
call|(
name|float
call|)
argument_list|(
name|var_R
operator|*
literal|0.4124
operator|+
name|var_G
operator|*
literal|0.3576
operator|+
name|var_B
operator|*
literal|0.1805
argument_list|)
expr_stmt|;
name|Y
operator|=
call|(
name|float
call|)
argument_list|(
name|var_R
operator|*
literal|0.2126
operator|+
name|var_G
operator|*
literal|0.7152
operator|+
name|var_B
operator|*
literal|0.0722
argument_list|)
expr_stmt|;
name|Z
operator|=
call|(
name|float
call|)
argument_list|(
name|var_R
operator|*
literal|0.0193
operator|+
name|var_G
operator|*
literal|0.1192
operator|+
name|var_B
operator|*
literal|0.9505
argument_list|)
expr_stmt|;
name|var_X
operator|=
name|X
operator|/
literal|95.047
expr_stmt|;
comment|/* Observer = 2, Illuminant = D65 */
name|var_Y
operator|=
name|Y
operator|/
literal|100.0
expr_stmt|;
name|var_Z
operator|=
name|Z
operator|/
literal|108.883
expr_stmt|;
if|if
condition|(
name|var_X
operator|>
literal|0.008856
condition|)
name|var_X
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
name|var_X
argument_list|,
operator|(
literal|1.0
operator|/
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|var_X
operator|=
operator|(
literal|7.787
operator|*
name|var_X
operator|)
operator|+
operator|(
literal|16.0
operator|/
literal|116
operator|)
expr_stmt|;
if|if
condition|(
name|var_Y
operator|>
literal|0.008856
condition|)
name|var_Y
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
name|var_Y
argument_list|,
operator|(
literal|1.0
operator|/
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|var_Y
operator|=
operator|(
literal|7.787
operator|*
name|var_Y
operator|)
operator|+
operator|(
literal|16.0
operator|/
literal|116
operator|)
expr_stmt|;
if|if
condition|(
name|var_Z
operator|>
literal|0.008856
condition|)
name|var_Z
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
name|var_Z
argument_list|,
operator|(
literal|1.0
operator|/
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|var_Z
operator|=
operator|(
literal|7.787
operator|*
name|var_Z
operator|)
operator|+
operator|(
literal|16.0
operator|/
literal|116
operator|)
expr_stmt|;
name|newpixel
operator|->
name|l
operator|=
operator|(
literal|116
operator|*
name|var_Y
operator|)
operator|-
literal|16
expr_stmt|;
name|newpixel
operator|->
name|a
operator|=
literal|500
operator|*
operator|(
name|var_X
operator|-
name|var_Y
operator|)
expr_stmt|;
name|newpixel
operator|->
name|b
operator|=
literal|200
operator|*
operator|(
name|var_Y
operator|-
name|var_Z
operator|)
expr_stmt|;
return|return
name|newpixel
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static float cie_f (float t) {   return t> 0.008856 ? (1 / 3.0) : 7.787 * t + 16.0 / 116.0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stage one of modified KD-Tree algorithm */
end_comment

begin_function
specifier|static
name|void
DECL|function|stageone (lab * points,int dims,int depth,ArrayList * clusters,float limits[DIMS],int length)
name|stageone
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|int
name|dims
parameter_list|,
name|int
name|depth
parameter_list|,
name|ArrayList
modifier|*
name|clusters
parameter_list|,
name|float
name|limits
index|[
name|DIMS
index|]
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|float
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* find maximum and minimum */
name|int
name|i
decl_stmt|,
name|countsm
decl_stmt|,
name|countgr
decl_stmt|,
name|smallc
decl_stmt|,
name|bigc
decl_stmt|;
name|float
name|pivotvalue
decl_stmt|,
name|curval
decl_stmt|;
name|lab
modifier|*
name|smallerpoints
decl_stmt|;
name|lab
modifier|*
name|biggerpoints
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|a
expr_stmt|;
else|else
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|b
expr_stmt|;
name|min
operator|=
name|curval
expr_stmt|;
name|max
operator|=
name|curval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|pivotvalue
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|/
literal|2.0
operator|)
operator|+
name|min
expr_stmt|;
name|countsm
operator|=
literal|0
expr_stmt|;
name|countgr
operator|=
literal|0
expr_stmt|;
comment|/* find out cluster sizes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
block|{
name|countsm
operator|++
expr_stmt|;
block|}
else|else
block|{
name|countgr
operator|++
expr_stmt|;
block|}
block|}
name|smallerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countsm
argument_list|)
expr_stmt|;
name|biggerpoints
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|countgr
argument_list|)
expr_stmt|;
name|smallc
operator|=
literal|0
expr_stmt|;
name|bigc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* do actual split */
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
block|{
name|smallerpoints
index|[
name|smallc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|biggerpoints
index|[
name|bigc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* create subtrees */
name|stageone
argument_list|(
name|smallerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countsm
argument_list|)
expr_stmt|;
name|stageone
argument_list|(
name|biggerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countgr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* create leave */
name|addtoList
argument_list|(
name|clusters
argument_list|,
name|points
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stage two of modified KD-Tree algorithm */
end_comment

begin_comment
comment|/* This is very similar to stageone... but in future there will be more  * differences => not integrated into method stageone()  */
end_comment

begin_function
specifier|static
name|void
DECL|function|stagetwo (lab * points,int dims,int depth,ArrayList * clusters,float limits[DIMS],int length,int total,float threshold)
name|stagetwo
parameter_list|(
name|lab
modifier|*
name|points
parameter_list|,
name|int
name|dims
parameter_list|,
name|int
name|depth
parameter_list|,
name|ArrayList
modifier|*
name|clusters
parameter_list|,
name|float
name|limits
index|[
name|DIMS
index|]
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|total
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
name|int
name|curdim
init|=
name|depth
operator|%
name|dims
decl_stmt|;
name|float
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* find maximum and minimum */
name|int
name|i
decl_stmt|,
name|countsm
decl_stmt|,
name|countgr
decl_stmt|,
name|smallc
decl_stmt|,
name|bigc
decl_stmt|;
name|float
name|pivotvalue
decl_stmt|,
name|curval
decl_stmt|;
name|int
name|sum
decl_stmt|;
name|lab
modifier|*
name|point
decl_stmt|;
name|lab
modifier|*
name|smallerpoints
decl_stmt|;
name|lab
modifier|*
name|biggerpoints
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|a
expr_stmt|;
else|else
name|curval
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|b
expr_stmt|;
name|min
operator|=
name|curval
expr_stmt|;
name|max
operator|=
name|curval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|curval
condition|)
name|min
operator|=
name|curval
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|curval
condition|)
name|max
operator|=
name|curval
expr_stmt|;
block|}
comment|/* Split according to Rubner-Rule */
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|limits
index|[
name|curdim
index|]
condition|)
block|{
name|pivotvalue
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|/
literal|2.0
operator|)
operator|+
name|min
expr_stmt|;
comment|/*  g_printerr ("max=%f min=%f pivot=%f\n",max,min,pivotvalue); */
name|countsm
operator|=
literal|0
expr_stmt|;
name|countgr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* find out cluster sizes */
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
block|{
name|countsm
operator|++
expr_stmt|;
block|}
else|else
block|{
name|countgr
operator|++
expr_stmt|;
block|}
block|}
name|smallerpoints
operator|=
name|g_malloc
argument_list|(
name|countsm
operator|*
sizeof|sizeof
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
name|biggerpoints
operator|=
name|g_malloc
argument_list|(
name|countgr
operator|*
sizeof|sizeof
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
name|smallc
operator|=
literal|0
expr_stmt|;
name|bigc
operator|=
literal|0
expr_stmt|;
comment|/* do actual split */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|curdim
operator|==
literal|0
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|1
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|curdim
operator|==
literal|2
condition|)
name|curval
operator|=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|curval
operator|<=
name|pivotvalue
condition|)
block|{
name|smallerpoints
index|[
name|smallc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|biggerpoints
index|[
name|bigc
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* create subtrees */
name|stagetwo
argument_list|(
name|smallerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countsm
argument_list|,
name|total
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
name|stagetwo
argument_list|(
name|biggerpoints
argument_list|,
name|dims
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|clusters
argument_list|,
name|limits
argument_list|,
name|countgr
argument_list|,
name|total
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
comment|/*  g_free (smallerpoints);        *  g_free (biggerpoints);        */
block|}
else|else
comment|/* create leave */
block|{
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|cardinality
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|sum
operator|*
literal|100.0
operator|)
operator|/
name|total
operator|)
operator|>=
name|threshold
condition|)
block|{
name|point
operator|=
name|g_new0
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|point
operator|->
name|l
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
name|point
operator|->
name|a
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|a
expr_stmt|;
name|point
operator|->
name|b
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|b
expr_stmt|;
block|}
name|point
operator|->
name|l
operator|/=
operator|(
name|length
operator|*
literal|1.0
operator|)
expr_stmt|;
name|point
operator|->
name|a
operator|/=
operator|(
name|length
operator|*
literal|1.0
operator|)
expr_stmt|;
name|point
operator|->
name|b
operator|/=
operator|(
name|length
operator|*
literal|1.0
operator|)
expr_stmt|;
comment|/* g_printerr ("cluster=%f, %f, %f sum=%d\n",                           point->l, point->a, point->b, sum);            */
name|addtoList
argument_list|(
name|clusters
argument_list|,
name|point
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* squared euclidean distance */
end_comment

begin_function
specifier|static
specifier|inline
name|float
DECL|function|euklid (const lab p,const lab q)
name|euklid
parameter_list|(
specifier|const
name|lab
name|p
parameter_list|,
specifier|const
name|lab
name|q
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
operator|.
name|l
operator|-
name|q
operator|.
name|l
operator|)
operator|*
operator|(
name|p
operator|.
name|l
operator|-
name|q
operator|.
name|l
operator|)
operator|+
operator|(
name|p
operator|.
name|a
operator|-
name|q
operator|.
name|a
operator|)
operator|*
operator|(
name|p
operator|.
name|a
operator|-
name|q
operator|.
name|a
operator|)
operator|+
operator|(
name|p
operator|.
name|b
operator|-
name|q
operator|.
name|b
operator|)
operator|*
operator|(
name|p
operator|.
name|b
operator|-
name|q
operator|.
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Creates a color signature for a given set of pixels */
end_comment

begin_function
specifier|static
name|lab
modifier|*
DECL|function|createSignature (lab * input,int length,float limits[DIMS],int * returnlength)
name|createSignature
parameter_list|(
name|lab
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|float
name|limits
index|[
name|DIMS
index|]
parameter_list|,
name|int
modifier|*
name|returnlength
parameter_list|)
block|{
name|ArrayList
modifier|*
name|clusters1
decl_stmt|;
name|ArrayList
modifier|*
name|clusters2
decl_stmt|;
name|ArrayList
modifier|*
name|curelem
decl_stmt|;
name|lab
modifier|*
name|centroids
decl_stmt|;
name|lab
modifier|*
name|cluster
decl_stmt|;
name|lab
name|centroid
decl_stmt|;
name|lab
modifier|*
name|rval
decl_stmt|;
name|int
name|k
decl_stmt|,
name|i
decl_stmt|;
name|int
name|clusters1size
decl_stmt|;
name|clusters1
operator|=
name|g_new0
argument_list|(
name|ArrayList
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stageone
argument_list|(
name|input
argument_list|,
name|DIMS
argument_list|,
literal|0
argument_list|,
name|clusters1
argument_list|,
name|limits
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|clusters1size
operator|=
name|listSize
argument_list|(
name|clusters1
argument_list|)
expr_stmt|;
name|centroids
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|clusters1size
argument_list|)
expr_stmt|;
name|curelem
operator|=
name|clusters1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curelem
operator|->
name|array
condition|)
block|{
name|centroid
operator|.
name|l
operator|=
literal|0
expr_stmt|;
name|centroid
operator|.
name|a
operator|=
literal|0
expr_stmt|;
name|centroid
operator|.
name|b
operator|=
literal|0
expr_stmt|;
name|cluster
operator|=
name|curelem
operator|->
name|array
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|curelem
operator|->
name|arraylength
condition|;
name|k
operator|++
control|)
block|{
name|centroid
operator|.
name|l
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|l
expr_stmt|;
name|centroid
operator|.
name|a
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|a
expr_stmt|;
name|centroid
operator|.
name|b
operator|+=
name|cluster
index|[
name|k
index|]
operator|.
name|b
expr_stmt|;
block|}
name|centroids
index|[
name|i
index|]
operator|.
name|l
operator|=
name|centroid
operator|.
name|l
operator|/
operator|(
name|curelem
operator|->
name|arraylength
operator|*
literal|1.0
operator|)
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|a
operator|=
name|centroid
operator|.
name|a
operator|/
operator|(
name|curelem
operator|->
name|arraylength
operator|*
literal|1.0
operator|)
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|b
operator|=
name|centroid
operator|.
name|b
operator|/
operator|(
name|curelem
operator|->
name|arraylength
operator|*
literal|1.0
operator|)
expr_stmt|;
name|centroids
index|[
name|i
index|]
operator|.
name|cardinality
operator|=
name|curelem
operator|->
name|arraylength
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|curelem
operator|=
name|curelem
operator|->
name|next
expr_stmt|;
block|}
comment|/* g_printerr ("step #1 -> %d clusters\n", clusters1size); */
name|clusters2
operator|=
name|g_new0
argument_list|(
name|ArrayList
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stagetwo
argument_list|(
name|centroids
argument_list|,
name|DIMS
argument_list|,
literal|0
argument_list|,
name|clusters2
argument_list|,
name|limits
argument_list|,
name|clusters1size
argument_list|,
name|length
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
comment|/* see paper by tomasi */
name|rval
operator|=
name|listToArray
argument_list|(
name|clusters2
argument_list|,
name|returnlength
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|clusters1
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|clusters2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|centroids
argument_list|)
expr_stmt|;
comment|/* g_printerr ("step #2 -> %d clusters\n", returnlength[0]); */
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Smoothes the confidence matrix */
end_comment

begin_function
specifier|static
name|void
DECL|function|smoothcm (float * cm,int xres,int yres,float f1,float f2,float f3)
name|smoothcm
parameter_list|(
name|float
modifier|*
name|cm
parameter_list|,
name|int
name|xres
parameter_list|,
name|int
name|yres
parameter_list|,
name|float
name|f1
parameter_list|,
name|float
name|f2
parameter_list|,
name|float
name|f3
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|,
name|idx
decl_stmt|;
comment|/* Smoothright */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
operator|-
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|f1
operator|*
name|cm
index|[
name|idx
index|]
operator|+
name|f2
operator|*
name|cm
index|[
name|idx
operator|+
literal|1
index|]
operator|+
name|f3
operator|*
name|cm
index|[
name|idx
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* Smoothleft */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|xres
operator|-
literal|1
init|;
name|x
operator|>=
literal|2
condition|;
name|x
operator|--
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|f3
operator|*
name|cm
index|[
name|idx
operator|-
literal|2
index|]
operator|+
name|f2
operator|*
name|cm
index|[
name|idx
operator|-
literal|1
index|]
operator|+
name|f1
operator|*
name|cm
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
comment|/* Smoothdown */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
operator|-
literal|2
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|f1
operator|*
name|cm
index|[
name|idx
index|]
operator|+
name|f2
operator|*
name|cm
index|[
operator|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
operator|+
name|f3
operator|*
name|cm
index|[
operator|(
operator|(
name|y
operator|+
literal|2
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
expr_stmt|;
block|}
block|}
comment|/* Smoothup */
for|for
control|(
name|y
operator|=
name|yres
operator|-
literal|1
init|;
name|y
operator|>=
literal|2
condition|;
name|y
operator|--
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|f3
operator|*
name|cm
index|[
operator|(
operator|(
name|y
operator|-
literal|2
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
operator|+
name|f2
operator|*
name|cm
index|[
operator|(
operator|(
name|y
operator|-
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
operator|+
name|f1
operator|*
name|cm
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Simulate a queue needed for region growing */
end_comment

begin_comment
comment|/* The methods are NOT generic */
end_comment

begin_typedef
DECL|typedef|Queue
typedef|typedef
name|struct
name|_Queue
name|Queue
typedef|;
end_typedef

begin_struct
DECL|struct|_Queue
struct|struct
name|_Queue
block|{
DECL|member|val
name|int
name|val
decl_stmt|;
DECL|member|valid
name|gboolean
name|valid
decl_stmt|;
DECL|member|next
name|Queue
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|Queue
modifier|*
DECL|function|createqueue (void)
name|createqueue
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|g_new0
argument_list|(
name|Queue
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|addtoqueue (Queue * q,int val)
name|addtoqueue
parameter_list|(
name|Queue
modifier|*
name|q
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|Queue
modifier|*
name|cur
init|=
name|q
decl_stmt|;
while|while
condition|(
name|cur
operator|->
name|valid
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|cur
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|cur
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|createqueue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|isempty (Queue * q)
name|isempty
parameter_list|(
name|Queue
modifier|*
name|q
parameter_list|)
block|{
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|q
operator|->
name|valid
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|headval (Queue * q)
name|headval
parameter_list|(
name|Queue
modifier|*
name|q
parameter_list|)
block|{
return|return
name|q
operator|->
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|Queue
modifier|*
DECL|function|removehead (Queue * q)
name|removehead
parameter_list|(
name|Queue
modifier|*
name|q
parameter_list|)
block|{
name|Queue
modifier|*
name|n
decl_stmt|;
name|q
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|next
condition|)
block|{
name|n
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|q
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Region growing */
end_comment

begin_function
specifier|static
name|void
DECL|function|findmaxblob (float * cm,guint * image,int xres,int yres)
name|findmaxblob
parameter_list|(
name|float
modifier|*
name|cm
parameter_list|,
name|guint
modifier|*
name|image
parameter_list|,
name|int
name|xres
parameter_list|,
name|int
name|yres
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|curlabel
init|=
literal|1
decl_stmt|;
name|int
name|maxregion
init|=
literal|0
decl_stmt|;
name|int
name|maxblob
init|=
literal|0
decl_stmt|;
name|int
name|regioncount
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|xres
operator|*
name|yres
decl_stmt|;
name|int
modifier|*
name|labelfield
init|=
name|g_new0
argument_list|(
name|int
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|Queue
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|createqueue
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|regioncount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|labelfield
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|cm
index|[
name|i
index|]
operator|>=
literal|0.5
condition|)
block|{
name|addtoqueue
argument_list|(
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|isempty
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|pos
operator|=
name|headval
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|removehead
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|length
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|labelfield
index|[
name|pos
index|]
operator|==
literal|0
operator|&&
name|cm
index|[
name|pos
index|]
operator|>=
literal|0.5f
condition|)
block|{
name|labelfield
index|[
name|pos
index|]
operator|=
name|curlabel
expr_stmt|;
name|regioncount
operator|++
expr_stmt|;
name|addtoqueue
argument_list|(
name|q
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|addtoqueue
argument_list|(
name|q
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addtoqueue
argument_list|(
name|q
argument_list|,
name|pos
operator|+
name|xres
argument_list|)
expr_stmt|;
name|addtoqueue
argument_list|(
name|q
argument_list|,
name|pos
operator|-
name|xres
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regioncount
operator|>
name|maxregion
condition|)
block|{
name|maxregion
operator|=
name|regioncount
expr_stmt|;
name|maxblob
operator|=
name|curlabel
expr_stmt|;
block|}
name|curlabel
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* Kill everything that is not biggest blob! */
if|if
condition|(
name|labelfield
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|labelfield
index|[
name|i
index|]
operator|!=
name|maxblob
condition|)
block|{
name|cm
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|labelfield
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns squared clustersize */
end_comment

begin_function
specifier|static
name|float
DECL|function|getclustersize (float limits[DIMS])
name|getclustersize
parameter_list|(
name|float
name|limits
index|[
name|DIMS
index|]
parameter_list|)
block|{
name|float
name|sum
init|=
operator|(
name|limits
index|[
literal|0
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|0
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|0
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|0
index|]
operator|)
operator|)
decl_stmt|;
name|sum
operator|+=
operator|(
name|limits
index|[
literal|1
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|1
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|1
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|limits
index|[
literal|2
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|2
index|]
operator|)
operator|)
operator|*
operator|(
name|limits
index|[
literal|2
index|]
operator|-
operator|(
operator|-
name|limits
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* calculates alpha\timesConfidencematrix */
end_comment

begin_function
specifier|static
name|void
DECL|function|premultiplyMatrix (float alpha,float * cm,int length)
name|premultiplyMatrix
parameter_list|(
name|float
name|alpha
parameter_list|,
name|float
modifier|*
name|cm
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cm
index|[
name|i
index|]
operator|=
name|alpha
operator|*
name|cm
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Normalizes a confidencematrix */
end_comment

begin_function
specifier|static
name|void
DECL|function|normalizeMatrix (float * cm,int length)
name|normalizeMatrix
parameter_list|(
name|float
modifier|*
name|cm
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|float
name|max
init|=
literal|0.0
decl_stmt|;
name|float
name|alpha
init|=
literal|0.0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max
operator|<
name|cm
index|[
name|i
index|]
condition|)
name|max
operator|=
name|cm
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|<=
literal|0.0
condition|)
return|return;
if|if
condition|(
name|max
operator|==
literal|1.00
condition|)
return|return;
name|alpha
operator|=
literal|1.00f
operator|/
name|max
expr_stmt|;
name|premultiplyMatrix
argument_list|(
name|alpha
argument_list|,
name|cm
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A confidence matrix eroder */
end_comment

begin_function
specifier|static
name|void
DECL|function|erode2 (float * cm,int xres,int yres)
name|erode2
parameter_list|(
name|float
modifier|*
name|cm
parameter_list|,
name|int
name|xres
parameter_list|,
name|int
name|yres
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* From right */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MIN
argument_list|(
name|cm
index|[
name|idx
index|]
argument_list|,
name|cm
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From left */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|xres
operator|-
literal|1
init|;
name|x
operator|>=
literal|1
condition|;
name|x
operator|--
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MIN
argument_list|(
name|cm
index|[
name|idx
operator|-
literal|1
index|]
argument_list|,
name|cm
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From down */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MIN
argument_list|(
name|cm
index|[
name|idx
index|]
argument_list|,
name|cm
index|[
operator|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From up */
for|for
control|(
name|y
operator|=
name|yres
operator|-
literal|1
init|;
name|y
operator|>=
literal|1
condition|;
name|y
operator|--
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MIN
argument_list|(
name|cm
index|[
operator|(
operator|(
name|y
operator|-
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
argument_list|,
name|cm
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A confidence matrix dilater */
end_comment

begin_function
specifier|static
name|void
DECL|function|dilate2 (float * cm,int xres,int yres)
name|dilate2
parameter_list|(
name|float
modifier|*
name|cm
parameter_list|,
name|int
name|xres
parameter_list|,
name|int
name|yres
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|idx
decl_stmt|;
comment|/* From right */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MAX
argument_list|(
name|cm
index|[
name|idx
index|]
argument_list|,
name|cm
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From left */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|xres
operator|-
literal|1
init|;
name|x
operator|>=
literal|1
condition|;
name|x
operator|--
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MAX
argument_list|(
name|cm
index|[
name|idx
operator|-
literal|1
index|]
argument_list|,
name|cm
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From down */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|yres
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MAX
argument_list|(
name|cm
index|[
name|idx
index|]
argument_list|,
name|cm
index|[
operator|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* From up */
for|for
control|(
name|y
operator|=
name|yres
operator|-
literal|1
init|;
name|y
operator|>=
literal|1
condition|;
name|y
operator|--
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xres
condition|;
name|x
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|y
operator|*
name|xres
operator|)
operator|+
name|x
expr_stmt|;
name|cm
index|[
name|idx
index|]
operator|=
name|MAX
argument_list|(
name|cm
index|[
operator|(
operator|(
name|y
operator|-
literal|1
operator|)
operator|*
name|xres
operator|)
operator|+
name|x
index|]
argument_list|,
name|cm
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Call this method:  * rgbs - the picture  * confidencematrix - a confidencematrix with values<=0.1 is sure background,  *>=0.9 is sure foreground, rest unknown  * xres, yres - the dimensions of the picture and the confidencematrix  * limits - a three dimensional float array specifing the accuracy  *          a good value is: {0.66,1.25,2.5}  * int smoothness - specifies how smooth the boundaries of a picture should  *                  be made (value greater or equal to 0).  *                  More smooth = fault tolerant,  *                  less smooth = exact boundaries - try 3 for a first guess.  * returns and writes into the confidencematrix the resulting segmentation  */
end_comment

begin_function
name|float
modifier|*
DECL|function|segmentate (guint * rgbs,float * confidencematrix,int xres,int yres,float limits[DIMS],int smoothness)
name|segmentate
parameter_list|(
name|guint
modifier|*
name|rgbs
parameter_list|,
name|float
modifier|*
name|confidencematrix
parameter_list|,
name|int
name|xres
parameter_list|,
name|int
name|yres
parameter_list|,
name|float
name|limits
index|[
name|DIMS
index|]
parameter_list|,
name|int
name|smoothness
parameter_list|)
block|{
name|float
name|clustersize
init|=
name|getclustersize
argument_list|(
name|limits
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|xres
operator|*
name|yres
decl_stmt|;
name|int
name|surebgcount
init|=
literal|0
decl_stmt|,
name|surefgcount
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|j
decl_stmt|;
name|int
name|bgsiglen
decl_stmt|,
name|fgsiglen
decl_stmt|;
name|lab
modifier|*
name|surebg
decl_stmt|,
modifier|*
name|surefg
init|=
name|NULL
decl_stmt|,
modifier|*
name|bgsig
decl_stmt|,
modifier|*
name|fgsig
init|=
name|NULL
decl_stmt|;
name|char
name|background
init|=
literal|0
decl_stmt|;
name|float
name|min
decl_stmt|,
name|d
decl_stmt|;
name|lab
name|labpixel
decl_stmt|;
comment|/* count given foreground and background pixels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|<=
literal|0.10f
condition|)
block|{
name|surebgcount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|>=
literal|0.90f
condition|)
block|{
name|surefgcount
operator|++
expr_stmt|;
block|}
block|}
name|surebg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surebgcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|surefgcount
operator|>
literal|0
condition|)
name|surefg
operator|=
name|g_new
argument_list|(
name|lab
argument_list|,
name|surefgcount
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* create inputs for colorsignatures */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|<=
literal|0.10f
condition|)
block|{
name|calcLAB
argument_list|(
name|rgbs
index|[
name|i
index|]
argument_list|,
operator|&
name|surebg
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|>=
literal|0.90f
condition|)
block|{
name|calcLAB
argument_list|(
name|rgbs
index|[
name|i
index|]
argument_list|,
operator|&
name|surefg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
comment|/* Create color signature for bg */
name|bgsig
operator|=
name|createSignature
argument_list|(
name|surebg
argument_list|,
name|surebgcount
argument_list|,
name|limits
argument_list|,
operator|&
name|bgsiglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgsiglen
operator|<
literal|1
condition|)
return|return
name|confidencematrix
return|;
comment|/* No segmentation possible */
comment|/* Create color signature for fg if possible */
if|if
condition|(
name|surefgcount
operator|>
literal|0
condition|)
name|fgsig
operator|=
name|createSignature
argument_list|(
name|surefg
argument_list|,
name|surefgcount
argument_list|,
name|limits
argument_list|,
operator|&
name|fgsiglen
argument_list|)
expr_stmt|;
else|else
name|fgsiglen
operator|=
literal|0
expr_stmt|;
comment|/* Classify - the slow way....Better: Tree traversation */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|>=
literal|0.90
condition|)
block|{
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|1.0f
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|<=
literal|0.10
condition|)
block|{
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|0.0f
expr_stmt|;
continue|continue;
block|}
name|calcLAB
argument_list|(
name|rgbs
index|[
name|i
index|]
argument_list|,
operator|&
name|labpixel
argument_list|)
expr_stmt|;
name|background
operator|=
literal|1
expr_stmt|;
name|min
operator|=
name|euklid
argument_list|(
name|labpixel
argument_list|,
name|bgsig
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|bgsiglen
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
name|labpixel
argument_list|,
name|bgsig
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|d
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fgsiglen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|min
operator|<
name|clustersize
condition|)
name|background
operator|=
literal|1
expr_stmt|;
else|else
name|background
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fgsiglen
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|euklid
argument_list|(
name|labpixel
argument_list|,
name|fgsig
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|d
expr_stmt|;
name|background
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|background
operator|==
literal|0
condition|)
block|{
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|0.0f
expr_stmt|;
block|}
block|}
comment|/* Smooth a bit for error killing */
name|smoothcm
argument_list|(
name|confidencematrix
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|,
literal|0.33
argument_list|,
literal|0.33
argument_list|,
literal|0.33
argument_list|)
expr_stmt|;
name|normalizeMatrix
argument_list|(
name|confidencematrix
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Now erode, to make sure only "strongly connected components"    * keep being connected    */
name|erode2
argument_list|(
name|confidencematrix
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
expr_stmt|;
comment|/* search the biggest connected component */
name|findmaxblob
argument_list|(
name|confidencematrix
argument_list|,
name|rgbs
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|smoothness
condition|;
name|i
operator|++
control|)
block|{
comment|/* smooth again - as user specified */
name|smoothcm
argument_list|(
name|confidencematrix
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|,
literal|0.33
argument_list|,
literal|0.33
argument_list|,
literal|0.33
argument_list|)
expr_stmt|;
block|}
name|normalizeMatrix
argument_list|(
name|confidencematrix
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Threshold the values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|confidencematrix
index|[
name|i
index|]
operator|>=
literal|0.5
condition|)
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|1.0
expr_stmt|;
else|else
name|confidencematrix
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/* search the biggest connected component again      to make sure jitter is killed    */
name|findmaxblob
argument_list|(
name|confidencematrix
argument_list|,
name|rgbs
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
expr_stmt|;
comment|/* Now dilate, to fill up boundary pixels killed by erode */
name|dilate2
argument_list|(
name|confidencematrix
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surefg
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|surebg
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bgsig
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|fgsig
argument_list|)
expr_stmt|;
return|return
name|confidencematrix
return|;
block|}
end_function

begin_comment
comment|/* If JNI_COMPILE is defined, we provide a Java binding for the segmentate  * funtion.  This allows me to use an existing benchmark as a unit test.  * The plan is to implement this test as a GIMP plug-in later. Until then,  * please leave this code in.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JNI_COMPILE
end_ifdef

begin_function
DECL|function|Java_NativeExperimentalPipe_segmentate (JNIEnv * env,jobject obj,jintArray rgbs,jfloatArray cm,jint xres,jint yres,jfloatArray limits)
name|JNIEXPORT
name|void
name|JNICALL
name|Java_NativeExperimentalPipe_segmentate
parameter_list|(
name|JNIEnv
modifier|*
name|env
parameter_list|,
name|jobject
name|obj
parameter_list|,
name|jintArray
name|rgbs
parameter_list|,
name|jfloatArray
name|cm
parameter_list|,
name|jint
name|xres
parameter_list|,
name|jint
name|yres
parameter_list|,
name|jfloatArray
name|limits
parameter_list|)
block|{
name|jint
modifier|*
name|jrgbs
init|=
operator|(
operator|*
name|env
operator|)
operator|->
name|GetIntArrayElements
argument_list|(
name|env
argument_list|,
name|rgbs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|jfloat
modifier|*
name|jcm
init|=
operator|(
operator|*
name|env
operator|)
operator|->
name|GetFloatArrayElements
argument_list|(
name|env
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|jfloat
modifier|*
name|jlimits
init|=
operator|(
operator|*
name|env
operator|)
operator|->
name|GetFloatArrayElements
argument_list|(
name|env
argument_list|,
name|limits
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|segmentate
argument_list|(
name|jrgbs
argument_list|,
name|jcm
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|,
name|jlimits
argument_list|,
literal|6
argument_list|)
expr_stmt|;
operator|(
operator|*
name|env
operator|)
operator|->
name|ReleaseFloatArrayElements
argument_list|(
name|env
argument_list|,
name|cm
argument_list|,
name|jcm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

