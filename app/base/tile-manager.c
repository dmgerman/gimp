begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"base-types.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"tile-cache.h"
end_include

begin_include
include|#
directive|include
file|"tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"tile-manager-private.h"
end_include

begin_include
include|#
directive|include
file|"tile-rowhints.h"
end_include

begin_include
include|#
directive|include
file|"tile-swap.h"
end_include

begin_include
include|#
directive|include
file|"tile-private.h"
end_include

begin_function_decl
specifier|static
name|void
name|tile_manager_allocate_tiles
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TILE_PROFILING
end_ifdef

begin_decl_stmt
specifier|extern
name|gint
name|tile_exist_peak
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|gint
name|tile_exist_count
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
end_ifdef

begin_decl_stmt
DECL|variable|tile_managers
name|GList
modifier|*
name|tile_managers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|GType
DECL|function|gimp_tile_manager_get_type (void)
name|gimp_tile_manager_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GType
name|type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|g_boxed_type_register_static
argument_list|(
literal|"TileManager"
argument_list|,
operator|(
name|GBoxedCopyFunc
operator|)
name|tile_manager_ref
argument_list|,
operator|(
name|GBoxedFreeFunc
operator|)
name|tile_manager_unref
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
end_ifdef

begin_function
name|void
DECL|function|tile_manager_exit (void)
name|tile_manager_exit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tile_managers
condition|)
block|{
name|g_warning
argument_list|(
literal|"%d tile managers leaked"
argument_list|,
name|g_list_length
argument_list|(
name|tile_managers
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|tile_managers
condition|)
block|{
name|g_printerr
argument_list|(
literal|"unref tile manager %p (%d x %d)\n"
argument_list|,
name|tile_managers
operator|->
name|data
argument_list|,
name|tile_manager_width
argument_list|(
name|tile_managers
operator|->
name|data
argument_list|)
argument_list|,
name|tile_manager_height
argument_list|(
name|tile_managers
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|tile_managers
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|gint
DECL|function|tile_manager_get_tile_num (TileManager * tm,gint xpixel,gint ypixel)
name|tile_manager_get_tile_num
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xpixel
parameter_list|,
name|gint
name|ypixel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|xpixel
operator|<
literal|0
operator|)
operator|||
operator|(
name|xpixel
operator|>=
name|tm
operator|->
name|width
operator|)
operator|||
operator|(
name|ypixel
operator|<
literal|0
operator|)
operator|||
operator|(
name|ypixel
operator|>=
name|tm
operator|->
name|height
operator|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ypixel
operator|/
name|TILE_HEIGHT
operator|)
operator|*
name|tm
operator|->
name|ntile_cols
operator|+
operator|(
name|xpixel
operator|/
name|TILE_WIDTH
operator|)
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|tile_manager_new (gint width,gint height,gint bpp)
name|tile_manager_new
parameter_list|(
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bpp
parameter_list|)
block|{
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|bpp
operator|>
literal|0
operator|&&
name|bpp
operator|<=
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|=
name|g_slice_new0
argument_list|(
name|TileManager
argument_list|)
expr_stmt|;
name|tm
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|tm
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|tm
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|tm
operator|->
name|bpp
operator|=
name|bpp
expr_stmt|;
name|tm
operator|->
name|ntile_rows
operator|=
operator|(
name|height
operator|+
name|TILE_HEIGHT
operator|-
literal|1
operator|)
operator|/
name|TILE_HEIGHT
expr_stmt|;
name|tm
operator|->
name|ntile_cols
operator|=
operator|(
name|width
operator|+
name|TILE_WIDTH
operator|-
literal|1
operator|)
operator|/
name|TILE_WIDTH
expr_stmt|;
name|tm
operator|->
name|cached_num
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
name|tile_managers
operator|=
name|g_list_prepend
argument_list|(
name|tile_managers
argument_list|,
name|tm
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tm
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|tile_manager_ref (TileManager * tm)
name|tile_manager_ref
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|->
name|ref_count
operator|++
expr_stmt|;
return|return
name|tm
return|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_unref (TileManager * tm)
name|tile_manager_unref
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|ref_count
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
name|tile_managers
operator|=
name|g_list_remove
argument_list|(
name|tile_managers
argument_list|,
name|tm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tm
operator|->
name|cached_tile
condition|)
name|tile_release
argument_list|(
name|tm
operator|->
name|cached_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tiles
condition|)
block|{
name|gint
name|ntiles
init|=
name|tm
operator|->
name|ntile_rows
operator|*
name|tm
operator|->
name|ntile_cols
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
name|tile_detach
argument_list|(
name|tm
operator|->
name|tiles
index|[
name|i
index|]
argument_list|,
name|tm
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tm
operator|->
name|tiles
argument_list|)
expr_stmt|;
block|}
name|g_slice_free
argument_list|(
name|TileManager
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|tile_manager_duplicate (TileManager * tm)
name|tile_manager_duplicate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|TileManager
modifier|*
name|copy
decl_stmt|;
name|gint
name|n_tiles
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|copy
operator|=
name|tile_manager_new
argument_list|(
name|tm
operator|->
name|width
argument_list|,
name|tm
operator|->
name|height
argument_list|,
name|tm
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|tile_manager_allocate_tiles
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|n_tiles
operator|=
name|tm
operator|->
name|ntile_rows
operator|*
name|tm
operator|->
name|ntile_cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_tiles
condition|;
name|i
operator|++
control|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|tile
operator|=
name|tile_manager_get
argument_list|(
name|tm
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile_manager_map
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|tile
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_set_validate_proc (TileManager * tm,TileValidateProc proc,gpointer user_data)
name|tile_manager_set_validate_proc
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|TileValidateProc
name|proc
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|->
name|validate_proc
operator|=
name|proc
expr_stmt|;
name|tm
operator|->
name|user_data
operator|=
name|user_data
expr_stmt|;
block|}
end_function

begin_function
name|Tile
modifier|*
DECL|function|tile_manager_get_tile (TileManager * tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
name|tile_manager_get_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xpixel
parameter_list|,
name|gint
name|ypixel
parameter_list|,
name|gboolean
name|wantread
parameter_list|,
name|gboolean
name|wantwrite
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|tile_manager_get
argument_list|(
name|tm
argument_list|,
name|tile_manager_get_tile_num
argument_list|(
name|tm
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
argument_list|,
name|wantread
argument_list|,
name|wantwrite
argument_list|)
return|;
block|}
end_function

begin_function
name|Tile
modifier|*
DECL|function|tile_manager_get (TileManager * tm,gint tile_num,gboolean wantread,gboolean wantwrite)
name|tile_manager_get
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|tile_num
parameter_list|,
name|gboolean
name|wantread
parameter_list|,
name|gboolean
name|wantwrite
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|gint
name|ntiles
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ntiles
operator|=
name|tm
operator|->
name|ntile_rows
operator|*
name|tm
operator|->
name|ntile_cols
expr_stmt|;
if|if
condition|(
operator|(
name|tile_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|tile_num
operator|>=
name|ntiles
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|tm
operator|->
name|tiles
condition|)
name|tile_manager_allocate_tiles
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|tile
operator|=
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
expr_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|wantwrite
operator|&&
operator|!
name|wantread
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"WRITE-ONLY TILE... UNTESTED!"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tile
operator|->
name|share_count
operator|&&
name|tile
operator|->
name|write_count
argument_list|)
condition|)
name|g_printerr
argument_list|(
literal|">> MEEPITY %d,%d<<\n"
argument_list|,
name|tile
operator|->
name|share_count
argument_list|,
name|tile
operator|->
name|write_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wantread
condition|)
block|{
if|if
condition|(
name|wantwrite
condition|)
block|{
if|if
condition|(
name|tile_num
operator|==
name|tm
operator|->
name|cached_num
condition|)
block|{
name|tile_release
argument_list|(
name|tm
operator|->
name|cached_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cached_tile
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cached_num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tile
operator|->
name|share_count
operator|>
literal|1
condition|)
block|{
comment|/* Copy-on-write required */
name|Tile
modifier|*
name|new
init|=
name|tile_new
argument_list|(
name|tile
operator|->
name|bpp
argument_list|)
decl_stmt|;
name|new
operator|->
name|ewidth
operator|=
name|tile
operator|->
name|ewidth
expr_stmt|;
name|new
operator|->
name|eheight
operator|=
name|tile
operator|->
name|eheight
expr_stmt|;
name|new
operator|->
name|valid
operator|=
name|tile
operator|->
name|valid
expr_stmt|;
name|new
operator|->
name|size
operator|=
name|new
operator|->
name|ewidth
operator|*
name|new
operator|->
name|eheight
operator|*
name|new
operator|->
name|bpp
expr_stmt|;
name|new
operator|->
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|new
operator|->
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILE_PROFILING
name|tile_exist_count
operator|++
expr_stmt|;
if|if
condition|(
name|tile_exist_count
operator|>
name|tile_exist_peak
condition|)
name|tile_exist_peak
operator|=
name|tile_exist_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tile
operator|->
name|rowhint
condition|)
block|{
name|tile_allocate_rowhints
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|rowhint
argument_list|,
name|tile
operator|->
name|rowhint
argument_list|,
name|new
operator|->
name|eheight
operator|*
sizeof|sizeof
argument_list|(
name|TileRowHint
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tile
operator|->
name|data
condition|)
block|{
name|memcpy
argument_list|(
name|new
operator|->
name|data
argument_list|,
name|tile
operator|->
name|data
argument_list|,
name|new
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|data
argument_list|,
name|tile
operator|->
name|data
argument_list|,
name|new
operator|->
name|size
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|tile_detach
argument_list|(
name|tile
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
name|tile_attach
argument_list|(
name|new
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
name|tile
operator|=
name|new
expr_stmt|;
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
operator|=
name|tile
expr_stmt|;
block|}
comment|/* must lock before marking dirty */
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|tile
operator|->
name|write_count
operator|++
expr_stmt|;
name|tile
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tile
operator|->
name|write_count
argument_list|)
condition|)
name|g_printerr
argument_list|(
literal|"STINK! r/o on r/w tile (%d)\n"
argument_list|,
name|tile
operator|->
name|write_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tile
return|;
block|}
end_function

begin_function
name|Tile
modifier|*
DECL|function|tile_manager_get_at (TileManager * tm,gint tile_col,gint tile_row,gboolean wantread,gboolean wantwrite)
name|tile_manager_get_at
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|tile_col
parameter_list|,
name|gint
name|tile_row
parameter_list|,
name|gboolean
name|wantread
parameter_list|,
name|gboolean
name|wantwrite
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile_col
operator|<
literal|0
operator|||
name|tile_col
operator|>=
name|tm
operator|->
name|ntile_cols
operator|||
name|tile_row
operator|<
literal|0
operator|||
name|tile_row
operator|>=
name|tm
operator|->
name|ntile_rows
condition|)
return|return
name|NULL
return|;
return|return
name|tile_manager_get
argument_list|(
name|tm
argument_list|,
name|tile_row
operator|*
name|tm
operator|->
name|ntile_cols
operator|+
name|tile_col
argument_list|,
name|wantread
argument_list|,
name|wantwrite
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_validate_tile (TileManager * tm,Tile * tile)
name|tile_manager_validate_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tile
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|validate_proc
condition|)
block|{
call|(
modifier|*
name|tm
operator|->
name|validate_proc
call|)
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
name|tm
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Set the contents of the tile to empty  */
name|memset
argument_list|(
name|tile
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
name|g_printerr
argument_list|(
literal|"%c"
argument_list|,
name|tm
operator|->
name|user_data
condition|?
literal|'V'
else|:
literal|'v'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|tile_manager_allocate_tiles (TileManager * tm)
name|tile_manager_allocate_tiles
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|Tile
modifier|*
modifier|*
name|tiles
decl_stmt|;
specifier|const
name|gint
name|nrows
init|=
name|tm
operator|->
name|ntile_rows
decl_stmt|;
specifier|const
name|gint
name|ncols
init|=
name|tm
operator|->
name|ntile_cols
decl_stmt|;
specifier|const
name|gint
name|right_tile
init|=
name|tm
operator|->
name|width
operator|-
operator|(
operator|(
name|ncols
operator|-
literal|1
operator|)
operator|*
name|TILE_WIDTH
operator|)
decl_stmt|;
specifier|const
name|gint
name|bottom_tile
init|=
name|tm
operator|->
name|height
operator|-
operator|(
operator|(
name|nrows
operator|-
literal|1
operator|)
operator|*
name|TILE_HEIGHT
operator|)
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|g_assert
argument_list|(
name|tm
operator|->
name|tiles
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tiles
operator|=
name|g_new
argument_list|(
name|Tile
operator|*
argument_list|,
name|nrows
operator|*
name|ncols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|nrows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncols
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
name|Tile
modifier|*
name|new
init|=
name|tile_new
argument_list|(
name|tm
operator|->
name|bpp
argument_list|)
decl_stmt|;
name|tile_attach
argument_list|(
name|new
argument_list|,
name|tm
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|(
name|ncols
operator|-
literal|1
operator|)
condition|)
name|new
operator|->
name|ewidth
operator|=
name|right_tile
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|nrows
operator|-
literal|1
operator|)
condition|)
name|new
operator|->
name|eheight
operator|=
name|bottom_tile
expr_stmt|;
name|new
operator|->
name|size
operator|=
name|new
operator|->
name|ewidth
operator|*
name|new
operator|->
name|eheight
operator|*
name|new
operator|->
name|bpp
expr_stmt|;
name|tiles
index|[
name|k
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
name|tm
operator|->
name|tiles
operator|=
name|tiles
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|tile_manager_invalidate_tile (TileManager * tm,gint tile_num)
name|tile_manager_invalidate_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|tile_num
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
init|=
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tile
operator|->
name|valid
condition|)
return|return;
if|if
condition|(
name|tile_num
operator|==
name|tm
operator|->
name|cached_num
condition|)
block|{
name|tile_release
argument_list|(
name|tm
operator|->
name|cached_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cached_tile
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cached_num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tile
operator|->
name|cached
condition|)
name|tile_cache_flush
argument_list|(
name|tile
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tile
operator|->
name|share_count
operator|>
literal|1
argument_list|)
condition|)
block|{
comment|/* This tile is shared.  Replace it with a new invalid tile. */
name|Tile
modifier|*
name|new
init|=
name|tile_new
argument_list|(
name|tile
operator|->
name|bpp
argument_list|)
decl_stmt|;
name|new
operator|->
name|ewidth
operator|=
name|tile
operator|->
name|ewidth
expr_stmt|;
name|new
operator|->
name|eheight
operator|=
name|tile
operator|->
name|eheight
expr_stmt|;
name|new
operator|->
name|size
operator|=
name|tile
operator|->
name|size
expr_stmt|;
name|tile_detach
argument_list|(
name|tile
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
name|tile_attach
argument_list|(
name|new
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
name|tile
operator|=
name|new
expr_stmt|;
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
operator|=
name|tile
expr_stmt|;
block|}
name|tile
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|data
condition|)
block|{
name|g_free
argument_list|(
name|tile
operator|->
name|data
argument_list|)
expr_stmt|;
name|tile
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|TILE_PROFILING
name|tile_exist_count
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tile
operator|->
name|swap_offset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the tile is on disk, then delete its        *  presence there.        */
name|tile_swap_delete
argument_list|(
name|tile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|tile_manager_invalidate_pixel (TileManager * tm,gint xpixel,gint ypixel)
name|tile_manager_invalidate_pixel
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xpixel
parameter_list|,
name|gint
name|ypixel
parameter_list|)
block|{
name|gint
name|num
init|=
name|tile_manager_get_tile_num
argument_list|(
name|tm
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return;
name|tile_manager_invalidate_tile
argument_list|(
name|tm
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_map_tile (TileManager * tm,gint xpixel,gint ypixel,Tile * srctile)
name|tile_manager_map_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|xpixel
parameter_list|,
name|gint
name|ypixel
parameter_list|,
name|Tile
modifier|*
name|srctile
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|srctile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tile_manager_map
argument_list|(
name|tm
argument_list|,
name|tile_manager_get_tile_num
argument_list|(
name|tm
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
argument_list|,
name|srctile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_map (TileManager * tm,gint tile_num,Tile * srctile)
name|tile_manager_map
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|tile_num
parameter_list|,
name|Tile
modifier|*
name|srctile
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|srctile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile_num
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile_num
operator|<
name|tm
operator|->
name|ntile_rows
operator|*
name|tm
operator|->
name|ntile_cols
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
operator|!
name|tm
operator|->
name|tiles
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: empty tile level - initializing"
argument_list|,
name|G_STRLOC
argument_list|)
expr_stmt|;
name|tile_manager_allocate_tiles
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
name|tile
operator|=
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
name|g_printerr
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|G_UNLIKELY
argument_list|(
operator|!
name|srctile
operator|->
name|valid
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"%s: srctile not validated yet!  please report"
argument_list|,
name|G_STRLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tile
operator|->
name|ewidth
operator|!=
name|srctile
operator|->
name|ewidth
operator|||
name|tile
operator|->
name|eheight
operator|!=
name|srctile
operator|->
name|eheight
operator|||
name|tile
operator|->
name|bpp
operator|!=
name|srctile
operator|->
name|bpp
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: nonconformant map (%p -> %p)"
argument_list|,
name|G_STRLOC
argument_list|,
name|srctile
argument_list|,
name|tile
argument_list|)
expr_stmt|;
block|}
name|tile_detach
argument_list|(
name|tile
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
name|g_printerr
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
name|g_printerr
argument_list|(
literal|" [src:%p tm:%p tn:%d] "
argument_list|,
name|srctile
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tile_attach
argument_list|(
name|srctile
argument_list|,
name|tm
argument_list|,
name|tile_num
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tiles
index|[
name|tile_num
index|]
operator|=
name|srctile
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TILE_MANAGER
name|g_printerr
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_invalidate_area (TileManager * tm,gint x,gint y,gint w,gint h)
name|tile_manager_invalidate_area
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|j
decl_stmt|;
comment|/*  if no tiles have been allocated, there's no need to invalidate any  */
if|if
condition|(
operator|!
name|tm
operator|->
name|tiles
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile_manager_invalidate_pixel
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|tile_manager_width (const TileManager * tm)
name|tile_manager_width
parameter_list|(
specifier|const
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tm
operator|->
name|width
return|;
block|}
end_function

begin_function
name|gint
DECL|function|tile_manager_height (const TileManager * tm)
name|tile_manager_height
parameter_list|(
specifier|const
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tm
operator|->
name|height
return|;
block|}
end_function

begin_function
name|gint
DECL|function|tile_manager_bpp (const TileManager * tm)
name|tile_manager_bpp
parameter_list|(
specifier|const
name|TileManager
modifier|*
name|tm
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tm
operator|->
name|bpp
return|;
block|}
end_function

begin_function
name|gint64
DECL|function|tile_manager_get_memsize (const TileManager * tm,gboolean sparse)
name|tile_manager_get_memsize
parameter_list|(
specifier|const
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gboolean
name|sparse
parameter_list|)
block|{
comment|/*  the tile manager itself  */
name|gint64
name|memsize
init|=
sizeof|sizeof
argument_list|(
name|TileManager
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tm
condition|)
return|return
literal|0
return|;
comment|/*  the array of tiles  */
name|memsize
operator|+=
operator|(
name|gint64
operator|)
name|tm
operator|->
name|ntile_rows
operator|*
name|tm
operator|->
name|ntile_cols
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|Tile
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|gpointer
argument_list|)
operator|)
expr_stmt|;
comment|/*  the memory allocated for the tiles  */
if|if
condition|(
name|sparse
condition|)
block|{
if|if
condition|(
name|tm
operator|->
name|tiles
condition|)
block|{
name|Tile
modifier|*
modifier|*
name|tiles
init|=
name|tm
operator|->
name|tiles
decl_stmt|;
name|gint64
name|size
init|=
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
name|tm
operator|->
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tm
operator|->
name|ntile_rows
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tm
operator|->
name|ntile_cols
condition|;
name|j
operator|++
operator|,
name|tiles
operator|++
control|)
block|{
if|if
condition|(
name|tile_is_valid
argument_list|(
operator|*
name|tiles
argument_list|)
condition|)
name|memsize
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|memsize
operator|+=
operator|(
name|gint64
operator|)
name|tm
operator|->
name|width
operator|*
name|tm
operator|->
name|height
operator|*
name|tm
operator|->
name|bpp
expr_stmt|;
block|}
return|return
name|memsize
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gint
DECL|function|tile_manager_locate_tile (TileManager * tm,Tile * tile)
name|tile_manager_locate_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|TileLink
modifier|*
name|tl
decl_stmt|;
for|for
control|(
name|tl
operator|=
name|tile
operator|->
name|tlink
init|;
name|tl
condition|;
name|tl
operator|=
name|tl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tl
operator|->
name|tm
operator|==
name|tm
condition|)
break|break;
block|}
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tl
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: tile not attached to manager"
argument_list|,
name|G_STRLOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|tl
operator|->
name|tile_num
return|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_get_tile_col_row (TileManager * tm,Tile * tile,gint * tile_col,gint * tile_row)
name|tile_manager_get_tile_col_row
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
modifier|*
name|tile_col
parameter_list|,
name|gint
modifier|*
name|tile_row
parameter_list|)
block|{
name|gint
name|tile_num
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile_col
operator|!=
name|NULL
operator|&&
name|tile_row
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tile_num
operator|=
name|tile_manager_locate_tile
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|)
expr_stmt|;
operator|*
name|tile_col
operator|=
name|tile_num
operator|%
name|tm
operator|->
name|ntile_cols
expr_stmt|;
operator|*
name|tile_row
operator|=
name|tile_num
operator|/
name|tm
operator|->
name|ntile_cols
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_get_tile_coordinates (TileManager * tm,Tile * tile,gint * x,gint * y)
name|tile_manager_get_tile_coordinates
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|)
block|{
name|gint
name|tile_col
decl_stmt|;
name|gint
name|tile_row
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|x
operator|!=
name|NULL
operator|&&
name|y
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tile_manager_get_tile_col_row
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|tile_col
argument_list|,
operator|&
name|tile_row
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|TILE_WIDTH
operator|*
name|tile_col
expr_stmt|;
operator|*
name|y
operator|=
name|TILE_HEIGHT
operator|*
name|tile_row
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|tile_manager_map_over_tile (TileManager * tm,Tile * tile,Tile * srctile)
name|tile_manager_map_over_tile
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|Tile
modifier|*
name|srctile
parameter_list|)
block|{
name|TileLink
modifier|*
name|tl
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|tm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|srctile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|tl
operator|=
name|tile
operator|->
name|tlink
init|;
name|tl
condition|;
name|tl
operator|=
name|tl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tl
operator|->
name|tm
operator|==
name|tm
condition|)
break|break;
block|}
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|tl
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: tile not attached to manager"
argument_list|,
name|G_STRLOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|tile_manager_map
argument_list|(
name|tm
argument_list|,
name|tl
operator|->
name|tile_num
argument_list|,
name|srctile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|read_pixel_data (TileManager * tm,gint x1,gint y1,gint x2,gint y2,guchar * buffer,guint stride)
name|read_pixel_data
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|buffer
parameter_list|,
name|guint
name|stride
parameter_list|)
block|{
name|guint
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|+=
name|TILE_HEIGHT
operator|-
operator|(
name|y
operator|%
name|TILE_HEIGHT
operator|)
control|)
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|+=
name|TILE_WIDTH
operator|-
operator|(
name|x
operator|%
name|TILE_WIDTH
operator|)
control|)
block|{
name|Tile
modifier|*
name|tile
init|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|s
init|=
name|TILE_DATA_POINTER
argument_list|(
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|buffer
operator|+
name|stride
operator|*
operator|(
name|y
operator|-
name|y1
operator|)
operator|+
name|tm
operator|->
name|bpp
operator|*
operator|(
name|x
operator|-
name|x1
operator|)
decl_stmt|;
name|guint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|guint
name|srcstride
decl_stmt|;
name|rows
operator|=
name|tile
operator|->
name|eheight
operator|-
name|y
operator|%
name|TILE_HEIGHT
expr_stmt|;
if|if
condition|(
name|rows
operator|>
operator|(
name|y2
operator|-
name|y
operator|+
literal|1
operator|)
condition|)
name|rows
operator|=
name|y2
operator|-
name|y
operator|+
literal|1
expr_stmt|;
name|cols
operator|=
name|tile
operator|->
name|ewidth
operator|-
name|x
operator|%
name|TILE_WIDTH
expr_stmt|;
if|if
condition|(
name|cols
operator|>
operator|(
name|x2
operator|-
name|x
operator|+
literal|1
operator|)
condition|)
name|cols
operator|=
name|x2
operator|-
name|x
operator|+
literal|1
expr_stmt|;
name|srcstride
operator|=
name|tile
operator|->
name|ewidth
operator|*
name|tile
operator|->
name|bpp
expr_stmt|;
while|while
condition|(
name|rows
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|cols
operator|*
name|tm
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|s
operator|+=
name|srcstride
expr_stmt|;
name|d
operator|+=
name|stride
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|write_pixel_data (TileManager * tm,gint x1,gint y1,gint x2,gint y2,const guchar * buffer,guint stride)
name|write_pixel_data
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
specifier|const
name|guchar
modifier|*
name|buffer
parameter_list|,
name|guint
name|stride
parameter_list|)
block|{
name|guint
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|+=
name|TILE_HEIGHT
operator|-
operator|(
name|y
operator|%
name|TILE_HEIGHT
operator|)
control|)
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|+=
name|TILE_WIDTH
operator|-
operator|(
name|x
operator|%
name|TILE_WIDTH
operator|)
control|)
block|{
name|Tile
modifier|*
name|tile
init|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|s
init|=
name|buffer
operator|+
name|stride
operator|*
operator|(
name|y
operator|-
name|y1
operator|)
operator|+
name|tm
operator|->
name|bpp
operator|*
operator|(
name|x
operator|-
name|x1
operator|)
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|TILE_DATA_POINTER
argument_list|(
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|guint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|guint
name|dststride
decl_stmt|;
name|rows
operator|=
name|tile
operator|->
name|eheight
operator|-
name|y
operator|%
name|TILE_HEIGHT
expr_stmt|;
if|if
condition|(
name|rows
operator|>
operator|(
name|y2
operator|-
name|y
operator|+
literal|1
operator|)
condition|)
name|rows
operator|=
name|y2
operator|-
name|y
operator|+
literal|1
expr_stmt|;
name|cols
operator|=
name|tile
operator|->
name|ewidth
operator|-
name|x
operator|%
name|TILE_WIDTH
expr_stmt|;
if|if
condition|(
name|cols
operator|>
operator|(
name|x2
operator|-
name|x
operator|+
literal|1
operator|)
condition|)
name|cols
operator|=
name|x2
operator|-
name|x
operator|+
literal|1
expr_stmt|;
name|dststride
operator|=
name|tile
operator|->
name|ewidth
operator|*
name|tile
operator|->
name|bpp
expr_stmt|;
while|while
condition|(
name|rows
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|cols
operator|*
name|tm
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|s
operator|+=
name|stride
expr_stmt|;
name|d
operator|+=
name|dststride
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|read_pixel_data_1 (TileManager * tm,gint x,gint y,guchar * buffer)
name|read_pixel_data_1
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
name|buffer
parameter_list|)
block|{
specifier|const
name|gint
name|num
init|=
name|tile_manager_get_tile_num
argument_list|(
name|tm
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|num
operator|!=
name|tm
operator|->
name|cached_num
condition|)
comment|/* must fetch a new tile */
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
if|if
condition|(
name|tm
operator|->
name|cached_tile
condition|)
name|tile_release
argument_list|(
name|tm
operator|->
name|cached_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cached_num
operator|=
operator|-
literal|1
expr_stmt|;
name|tm
operator|->
name|cached_tile
operator|=
name|NULL
expr_stmt|;
comment|/*  use a temporary variable instead of assigning to        *  tm->cached_tile directly to make sure tm->cached_num        *  and tm->cached_tile are always in a consistent state.        *  (the requested tile might be invalid and needs to be        *  validated, which would call tile_manager_get() recursively,        *  which in turn would clear the cached tile) See bug #472770.        */
name|tile
operator|=
name|tile_manager_get
argument_list|(
name|tm
argument_list|,
name|num
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cached_num
operator|=
name|num
expr_stmt|;
name|tm
operator|->
name|cached_tile
operator|=
name|tile
expr_stmt|;
block|}
block|{
specifier|const
name|guchar
modifier|*
name|src
init|=
name|TILE_DATA_POINTER
argument_list|(
name|tm
operator|->
name|cached_tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tm
operator|->
name|bpp
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|write_pixel_data_1 (TileManager * tm,gint x,gint y,const guchar * buffer)
name|write_pixel_data_1
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
specifier|const
name|guchar
modifier|*
name|buffer
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
init|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|TILE_DATA_POINTER
argument_list|(
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tm
operator|->
name|bpp
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|dest
operator|++
operator|=
operator|*
name|buffer
operator|++
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|dest
operator|++
operator|=
operator|*
name|buffer
operator|++
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|dest
operator|++
operator|=
operator|*
name|buffer
operator|++
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|dest
operator|++
operator|=
operator|*
name|buffer
operator|++
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

