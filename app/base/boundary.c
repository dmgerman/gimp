begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"boundary.h"
end_include

begin_include
include|#
directive|include
file|"tile_pvt.h"
end_include

begin_comment
comment|/* ick. */
end_comment

begin_comment
comment|/* half intensity for mask */
end_comment

begin_define
DECL|macro|HALF_WAY
define|#
directive|define
name|HALF_WAY
value|127
end_define

begin_comment
comment|/* BoundSeg array growth parameter */
end_comment

begin_define
DECL|macro|MAX_SEGS_INC
define|#
directive|define
name|MAX_SEGS_INC
value|2048
end_define

begin_comment
comment|/*  The array of vertical segments  */
end_comment

begin_decl_stmt
DECL|variable|vert_segs
specifier|static
name|int
modifier|*
name|vert_segs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The array of segments  */
end_comment

begin_decl_stmt
DECL|variable|tmp_segs
specifier|static
name|BoundSeg
modifier|*
name|tmp_segs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_segs
specifier|static
name|int
name|num_segs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_segs
specifier|static
name|int
name|max_segs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static empty segment arrays */
end_comment

begin_decl_stmt
DECL|variable|empty_segs_n
specifier|static
name|int
modifier|*
name|empty_segs_n
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_empty_n
specifier|static
name|int
name|num_empty_n
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|empty_segs_c
specifier|static
name|int
modifier|*
name|empty_segs_c
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_empty_c
specifier|static
name|int
name|num_empty_c
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|empty_segs_l
specifier|static
name|int
modifier|*
name|empty_segs_l
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_empty_l
specifier|static
name|int
name|num_empty_l
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_empty_segs
specifier|static
name|int
name|max_empty_segs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global state variables--improve parameter efficiency */
end_comment

begin_decl_stmt
DECL|variable|cur_PR
specifier|static
name|PixelRegion
modifier|*
name|cur_PR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_empty_segs
parameter_list|(
name|PixelRegion
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|BoundaryType
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_seg
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_vert_segs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_empty_segs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_horiz_seg
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_horiz_segs
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_boundary
parameter_list|(
name|BoundaryType
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Function definitions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_empty_segs (PixelRegion * maskPR,int scanline,int empty_segs[],int max_empty,int * num_empty,BoundaryType type,int x1,int y1,int x2,int y2)
name|find_empty_segs
parameter_list|(
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|int
name|scanline
parameter_list|,
name|int
name|empty_segs
index|[]
parameter_list|,
name|int
name|max_empty
parameter_list|,
name|int
modifier|*
name|num_empty
parameter_list|,
name|BoundaryType
name|type
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|val
decl_stmt|,
name|last
decl_stmt|;
name|int
name|tilex
decl_stmt|;
name|Tile
modifier|*
name|tile
init|=
name|NULL
decl_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
operator|*
name|num_empty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scanline
operator|<
name|maskPR
operator|->
name|y
operator|||
name|scanline
operator|>=
operator|(
name|maskPR
operator|->
name|y
operator|+
name|maskPR
operator|->
name|h
operator|)
condition|)
block|{
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
name|G_MAXINT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|WithinBounds
condition|)
block|{
if|if
condition|(
name|scanline
operator|<
name|y1
operator|||
name|scanline
operator|>=
name|y2
condition|)
block|{
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
name|G_MAXINT
expr_stmt|;
return|return;
block|}
name|start
operator|=
name|x1
expr_stmt|;
name|end
operator|=
name|x2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IgnoreBounds
condition|)
block|{
name|start
operator|=
name|maskPR
operator|->
name|x
expr_stmt|;
name|end
operator|=
name|maskPR
operator|->
name|x
operator|+
name|maskPR
operator|->
name|w
expr_stmt|;
if|if
condition|(
name|scanline
operator|<
name|y1
operator|||
name|scanline
operator|>=
name|y2
condition|)
name|x2
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|tilex
operator|=
operator|-
literal|1
expr_stmt|;
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|start
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
comment|/*  Check to see if we must advance to next tile  */
if|if
condition|(
operator|(
name|x
operator|/
name|TILE_WIDTH
operator|)
operator|!=
name|tilex
condition|)
block|{
if|if
condition|(
name|tile
condition|)
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|maskPR
operator|->
name|tiles
argument_list|,
name|x
argument_list|,
name|scanline
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|data
operator|=
name|tile
operator|->
name|data
operator|+
name|tile
operator|->
name|bpp
operator|*
operator|(
operator|(
name|scanline
operator|%
name|TILE_HEIGHT
operator|)
operator|*
name|tile
operator|->
name|ewidth
operator|+
operator|(
name|x
operator|%
name|TILE_WIDTH
operator|)
operator|)
operator|+
operator|(
name|tile
operator|->
name|bpp
operator|-
literal|1
operator|)
expr_stmt|;
name|tilex
operator|=
name|x
operator|/
name|TILE_WIDTH
expr_stmt|;
block|}
name|empty_segs
index|[
operator|*
name|num_empty
index|]
operator|=
name|x
expr_stmt|;
name|val
operator|=
operator|(
operator|*
name|data
operator|>
name|HALF_WAY
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
comment|/*  The IgnoreBounds case  */
if|if
condition|(
name|val
operator|==
literal|1
operator|&&
name|type
operator|==
name|IgnoreBounds
condition|)
if|if
condition|(
name|x
operator|>=
name|x1
operator|&&
name|x
operator|<
name|x2
condition|)
name|val
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|*
name|val
operator|<
literal|0
condition|)
operator|(
operator|*
name|num_empty
operator|)
operator|++
expr_stmt|;
name|last
operator|=
name|val
expr_stmt|;
name|data
operator|+=
name|tile
operator|->
name|bpp
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>
literal|0
condition|)
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
name|x
expr_stmt|;
name|empty_segs
index|[
operator|(
operator|*
name|num_empty
operator|)
operator|++
index|]
operator|=
name|G_MAXINT
expr_stmt|;
if|if
condition|(
name|tile
condition|)
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|make_seg (int x1,int y1,int x2,int y2,int open)
name|make_seg
parameter_list|(
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
name|int
name|open
parameter_list|)
block|{
if|if
condition|(
name|num_segs
operator|>=
name|max_segs
condition|)
block|{
name|max_segs
operator|+=
name|MAX_SEGS_INC
expr_stmt|;
name|tmp_segs
operator|=
operator|(
name|BoundSeg
operator|*
operator|)
name|g_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tmp_segs
argument_list|,
sizeof|sizeof
argument_list|(
name|BoundSeg
argument_list|)
operator|*
name|max_segs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_segs
condition|)
name|fatal_error
argument_list|(
literal|"Unable to reallocate segments array for mask boundary."
argument_list|)
expr_stmt|;
block|}
name|tmp_segs
index|[
name|num_segs
index|]
operator|.
name|x1
operator|=
name|x1
expr_stmt|;
name|tmp_segs
index|[
name|num_segs
index|]
operator|.
name|y1
operator|=
name|y1
expr_stmt|;
name|tmp_segs
index|[
name|num_segs
index|]
operator|.
name|x2
operator|=
name|x2
expr_stmt|;
name|tmp_segs
index|[
name|num_segs
index|]
operator|.
name|y2
operator|=
name|y2
expr_stmt|;
name|tmp_segs
index|[
name|num_segs
index|]
operator|.
name|open
operator|=
name|open
expr_stmt|;
name|num_segs
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|allocate_vert_segs (void)
name|allocate_vert_segs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*  allocate and initialize the vert_segs array  */
name|vert_segs
operator|=
operator|(
name|int
operator|*
operator|)
name|g_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vert_segs
argument_list|,
operator|(
name|cur_PR
operator|->
name|w
operator|+
name|cur_PR
operator|->
name|x
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|cur_PR
operator|->
name|w
operator|+
name|cur_PR
operator|->
name|x
operator|)
condition|;
name|i
operator|++
control|)
name|vert_segs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|allocate_empty_segs (void)
name|allocate_empty_segs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|need_num_segs
decl_stmt|;
comment|/*  find the maximum possible number of empty segments given the current mask  */
name|need_num_segs
operator|=
name|cur_PR
operator|->
name|w
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|need_num_segs
operator|>
name|max_empty_segs
condition|)
block|{
name|max_empty_segs
operator|=
name|need_num_segs
expr_stmt|;
name|empty_segs_n
operator|=
operator|(
name|int
operator|*
operator|)
name|g_realloc
argument_list|(
name|empty_segs_n
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_empty_segs
argument_list|)
expr_stmt|;
name|empty_segs_c
operator|=
operator|(
name|int
operator|*
operator|)
name|g_realloc
argument_list|(
name|empty_segs_c
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_empty_segs
argument_list|)
expr_stmt|;
name|empty_segs_l
operator|=
operator|(
name|int
operator|*
operator|)
name|g_realloc
argument_list|(
name|empty_segs_l
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_empty_segs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty_segs_n
operator|||
operator|!
name|empty_segs_l
operator|||
operator|!
name|empty_segs_c
condition|)
name|fatal_error
argument_list|(
literal|"Unable to reallocate empty segments array for mask boundary."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|process_horiz_seg (int x1,int y1,int x2,int y2,int open)
name|process_horiz_seg
parameter_list|(
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
name|int
name|open
parameter_list|)
block|{
comment|/*  This procedure accounts for any vertical segments that must be       drawn to close in the horizontal segments.                     */
if|if
condition|(
name|vert_segs
index|[
name|x1
index|]
operator|>=
literal|0
condition|)
block|{
name|make_seg
argument_list|(
name|x1
argument_list|,
name|vert_segs
index|[
name|x1
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|!
name|open
argument_list|)
expr_stmt|;
name|vert_segs
index|[
name|x1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|vert_segs
index|[
name|x1
index|]
operator|=
name|y1
expr_stmt|;
if|if
condition|(
name|vert_segs
index|[
name|x2
index|]
operator|>=
literal|0
condition|)
block|{
name|make_seg
argument_list|(
name|x2
argument_list|,
name|vert_segs
index|[
name|x2
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|open
argument_list|)
expr_stmt|;
name|vert_segs
index|[
name|x2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|vert_segs
index|[
name|x2
index|]
operator|=
name|y2
expr_stmt|;
name|make_seg
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|open
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|make_horiz_segs (int start,int end,int scanline,int empty[],int num_empty,int top)
name|make_horiz_segs
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|scanline
parameter_list|,
name|int
name|empty
index|[]
parameter_list|,
name|int
name|num_empty
parameter_list|,
name|int
name|top
parameter_list|)
block|{
name|int
name|empty_index
decl_stmt|;
name|int
name|e_s
decl_stmt|,
name|e_e
decl_stmt|;
comment|/* empty segment start and end values */
for|for
control|(
name|empty_index
operator|=
literal|0
init|;
name|empty_index
operator|<
name|num_empty
condition|;
name|empty_index
operator|+=
literal|2
control|)
block|{
name|e_s
operator|=
operator|*
name|empty
operator|++
expr_stmt|;
name|e_e
operator|=
operator|*
name|empty
operator|++
expr_stmt|;
if|if
condition|(
name|e_s
operator|<=
name|start
operator|&&
name|e_e
operator|>=
name|end
condition|)
name|process_horiz_seg
argument_list|(
name|start
argument_list|,
name|scanline
argument_list|,
name|end
argument_list|,
name|scanline
argument_list|,
name|top
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_s
operator|>
name|start
operator|&&
name|e_s
operator|<
name|end
operator|)
operator|||
operator|(
name|e_e
operator|<
name|end
operator|&&
name|e_e
operator|>
name|start
operator|)
condition|)
name|process_horiz_seg
argument_list|(
name|MAXIMUM
argument_list|(
name|e_s
argument_list|,
name|start
argument_list|)
argument_list|,
name|scanline
argument_list|,
name|MINIMUM
argument_list|(
name|e_e
argument_list|,
name|end
argument_list|)
argument_list|,
name|scanline
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|generate_boundary (BoundaryType type,int x1,int y1,int x2,int y2)
name|generate_boundary
parameter_list|(
name|BoundaryType
name|type
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|scanline
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
modifier|*
name|tmp_segs
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
comment|/*  array for determining the vertical line segments which must be drawn  */
name|allocate_vert_segs
argument_list|()
expr_stmt|;
comment|/*  make sure there is enough space for the empty segment array  */
name|allocate_empty_segs
argument_list|()
expr_stmt|;
name|num_segs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|WithinBounds
condition|)
block|{
name|start
operator|=
name|y1
expr_stmt|;
name|end
operator|=
name|y2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IgnoreBounds
condition|)
block|{
name|start
operator|=
name|cur_PR
operator|->
name|y
expr_stmt|;
name|end
operator|=
name|cur_PR
operator|->
name|y
operator|+
name|cur_PR
operator|->
name|h
expr_stmt|;
block|}
comment|/*  Find the empty segments for the previous and current scanlines  */
name|find_empty_segs
argument_list|(
name|cur_PR
argument_list|,
name|start
operator|-
literal|1
argument_list|,
name|empty_segs_l
argument_list|,
name|max_empty_segs
argument_list|,
operator|&
name|num_empty_l
argument_list|,
name|type
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|find_empty_segs
argument_list|(
name|cur_PR
argument_list|,
name|start
argument_list|,
name|empty_segs_c
argument_list|,
name|max_empty_segs
argument_list|,
operator|&
name|num_empty_c
argument_list|,
name|type
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
for|for
control|(
name|scanline
operator|=
name|start
init|;
name|scanline
operator|<
name|end
condition|;
name|scanline
operator|++
control|)
block|{
comment|/*  find the empty segment list for the next scanline  */
name|find_empty_segs
argument_list|(
name|cur_PR
argument_list|,
name|scanline
operator|+
literal|1
argument_list|,
name|empty_segs_n
argument_list|,
name|max_empty_segs
argument_list|,
operator|&
name|num_empty_n
argument_list|,
name|type
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/*  process the segments on the current scanline  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_empty_c
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|make_horiz_segs
argument_list|(
name|empty_segs_c
index|[
name|i
index|]
argument_list|,
name|empty_segs_c
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|scanline
argument_list|,
name|empty_segs_l
argument_list|,
name|num_empty_l
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|make_horiz_segs
argument_list|(
name|empty_segs_c
index|[
name|i
index|]
argument_list|,
name|empty_segs_c
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|scanline
operator|+
literal|1
argument_list|,
name|empty_segs_n
argument_list|,
name|num_empty_n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  get the next scanline of empty segments, swap others  */
name|tmp_segs
operator|=
name|empty_segs_l
expr_stmt|;
name|empty_segs_l
operator|=
name|empty_segs_c
expr_stmt|;
name|num_empty_l
operator|=
name|num_empty_c
expr_stmt|;
name|empty_segs_c
operator|=
name|empty_segs_n
expr_stmt|;
name|num_empty_c
operator|=
name|num_empty_n
expr_stmt|;
name|empty_segs_n
operator|=
name|tmp_segs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|BoundSeg
modifier|*
DECL|function|find_mask_boundary (PixelRegion * maskPR,int * num_elems,BoundaryType type,int x1,int y1,int x2,int y2)
name|find_mask_boundary
parameter_list|(
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|int
modifier|*
name|num_elems
parameter_list|,
name|BoundaryType
name|type
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|BoundSeg
modifier|*
name|new_segs
init|=
name|NULL
decl_stmt|;
comment|/*  The mask paramater can be any PixelRegion.  If the region    *  has more than 1 bytes/pixel, the last byte of each pixel is    *  used to determine the boundary outline.    */
name|cur_PR
operator|=
name|maskPR
expr_stmt|;
comment|/*  Calculate the boundary  */
name|generate_boundary
argument_list|(
name|type
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/*  Set the number of X segments  */
operator|*
name|num_elems
operator|=
name|num_segs
expr_stmt|;
comment|/*  Make a copy of the boundary  */
if|if
condition|(
name|num_segs
condition|)
block|{
name|new_segs
operator|=
operator|(
name|BoundSeg
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BoundSeg
argument_list|)
operator|*
name|num_segs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_segs
argument_list|,
name|tmp_segs
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|BoundSeg
argument_list|)
operator|*
name|num_segs
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  Return the new boundary  */
return|return
name|new_segs
return|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  Sorting a Boundary  */
end_comment

begin_function_decl
specifier|static
name|int
name|find_segment
parameter_list|(
name|BoundSeg
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
DECL|function|find_segment (BoundSeg * segs,int ns,int x,int y)
name|find_segment
parameter_list|(
name|BoundSeg
modifier|*
name|segs
parameter_list|,
name|int
name|ns
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|ns
condition|;
name|index
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|segs
index|[
name|index
index|]
operator|.
name|x1
operator|==
name|x
operator|&&
name|segs
index|[
name|index
index|]
operator|.
name|y1
operator|==
name|y
operator|)
operator|||
operator|(
name|segs
index|[
name|index
index|]
operator|.
name|x2
operator|==
name|x
operator|&&
name|segs
index|[
name|index
index|]
operator|.
name|y2
operator|==
name|y
operator|)
operator|)
operator|&&
name|segs
index|[
name|index
index|]
operator|.
name|visited
operator|==
name|FALSE
condition|)
return|return
name|index
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|BoundSeg
modifier|*
DECL|function|sort_boundary (BoundSeg * segs,int ns,int * num_groups)
name|sort_boundary
parameter_list|(
name|BoundSeg
modifier|*
name|segs
parameter_list|,
name|int
name|ns
parameter_list|,
name|int
modifier|*
name|num_groups
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|startx
decl_stmt|,
name|starty
decl_stmt|;
name|int
name|empty
init|=
operator|(
name|num_segs
operator|==
literal|0
operator|)
decl_stmt|;
name|BoundSeg
modifier|*
name|new_segs
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|new_segs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ns
condition|;
name|i
operator|++
control|)
name|segs
index|[
name|i
index|]
operator|.
name|visited
operator|=
name|FALSE
expr_stmt|;
name|num_segs
operator|=
literal|0
expr_stmt|;
operator|*
name|num_groups
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|empty
condition|)
block|{
name|empty
operator|=
name|TRUE
expr_stmt|;
comment|/*  find the index of a non-visited segment to start a group  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ns
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|segs
index|[
name|i
index|]
operator|.
name|visited
operator|==
name|FALSE
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
name|empty
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|ns
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|empty
condition|)
block|{
name|make_seg
argument_list|(
name|segs
index|[
name|index
index|]
operator|.
name|x1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|x2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|open
argument_list|)
expr_stmt|;
name|segs
index|[
name|index
index|]
operator|.
name|visited
operator|=
name|TRUE
expr_stmt|;
name|startx
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|x1
expr_stmt|;
name|starty
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|y1
expr_stmt|;
name|x
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|x2
expr_stmt|;
name|y
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|y2
expr_stmt|;
while|while
condition|(
operator|(
name|index
operator|=
name|find_segment
argument_list|(
name|segs
argument_list|,
name|ns
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*  make sure ordering is correct  */
if|if
condition|(
name|x
operator|==
name|segs
index|[
name|index
index|]
operator|.
name|x1
operator|&&
name|y
operator|==
name|segs
index|[
name|index
index|]
operator|.
name|y1
condition|)
block|{
name|make_seg
argument_list|(
name|segs
index|[
name|index
index|]
operator|.
name|x1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|x2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|open
argument_list|)
expr_stmt|;
name|x
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|x2
expr_stmt|;
name|y
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|y2
expr_stmt|;
block|}
else|else
block|{
name|make_seg
argument_list|(
name|segs
index|[
name|index
index|]
operator|.
name|x2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y2
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|x1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|y1
argument_list|,
name|segs
index|[
name|index
index|]
operator|.
name|open
argument_list|)
expr_stmt|;
name|x
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|x1
expr_stmt|;
name|y
operator|=
name|segs
index|[
name|index
index|]
operator|.
name|y1
expr_stmt|;
block|}
name|segs
index|[
name|index
index|]
operator|.
name|visited
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|startx
operator|||
name|y
operator|!=
name|starty
condition|)
name|g_message
argument_list|(
literal|"sort_boundary(): Unconnected boundary group!"
argument_list|)
expr_stmt|;
comment|/*  Mark the end of a group  */
operator|*
name|num_groups
operator|=
operator|*
name|num_groups
operator|+
literal|1
expr_stmt|;
name|make_seg
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Make a copy of the boundary  */
if|if
condition|(
name|num_segs
condition|)
block|{
name|new_segs
operator|=
operator|(
name|BoundSeg
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BoundSeg
argument_list|)
operator|*
name|num_segs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_segs
argument_list|,
name|tmp_segs
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|BoundSeg
argument_list|)
operator|*
name|num_segs
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  Return the new boundary  */
return|return
name|new_segs
return|;
block|}
end_function

end_unit

