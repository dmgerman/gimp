begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"base-types.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"tile-rowhints.h"
end_include

begin_include
include|#
directive|include
file|"tile-private.h"
end_include

begin_comment
comment|/*  Sanity checks on tile hinting code  */
end_comment

begin_comment
comment|/*  #define HINTS_SANITY */
end_comment

begin_function
name|void
DECL|function|tile_allocate_rowhints (Tile * tile)
name|tile_allocate_rowhints
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tile
operator|->
name|rowhint
condition|)
name|tile
operator|->
name|rowhint
operator|=
name|g_slice_alloc0
argument_list|(
sizeof|sizeof
argument_list|(
name|TileRowHint
argument_list|)
operator|*
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|TileRowHint
DECL|function|tile_get_rowhint (Tile * tile,gint yoff)
name|tile_get_rowhint
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|yoff
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tile
operator|->
name|rowhint
condition|)
return|return
name|TILEROWHINT_UNKNOWN
return|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|yoff
operator|<
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|&&
name|yoff
operator|>=
literal|0
condition|)
block|{
return|return
name|tile
operator|->
name|rowhint
index|[
name|yoff
index|]
return|;
block|}
else|else
block|{
name|g_error
argument_list|(
literal|"GET_ROWHINT OUT OF RANGE"
argument_list|)
expr_stmt|;
block|}
return|return
name|TILEROWHINT_OUTOFRANGE
return|;
else|#
directive|else
return|return
name|tile
operator|->
name|rowhint
index|[
name|yoff
index|]
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|tile_set_rowhint (Tile * tile,gint yoff,TileRowHint rowhint)
name|tile_set_rowhint
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|yoff
parameter_list|,
name|TileRowHint
name|rowhint
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|yoff
operator|<
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|&&
name|yoff
operator|>=
literal|0
condition|)
block|{
name|tile
operator|->
name|rowhint
index|[
name|yoff
index|]
operator|=
name|rowhint
expr_stmt|;
block|}
else|else
block|{
name|g_error
argument_list|(
literal|"SET_ROWHINT OUT OF RANGE"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|tile
operator|->
name|rowhint
index|[
name|yoff
index|]
operator|=
name|rowhint
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|tile_update_rowhints (Tile * tile,gint start,gint rows)
name|tile_update_rowhints
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|start
parameter_list|,
name|gint
name|rows
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|ptr
decl_stmt|;
name|gint
name|bpp
decl_stmt|,
name|ewidth
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tile_allocate_rowhints
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|ewidth
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
for|for
control|(
name|y
operator|=
name|start
init|;
name|y
operator|<
name|start
operator|+
name|rows
condition|;
name|y
operator|++
control|)
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|y
operator|=
name|start
init|;
name|y
operator|<
name|start
operator|+
name|rows
condition|;
name|y
operator|++
control|)
block|{
name|TileRowHint
name|hint
init|=
name|tile_get_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_BROKEN
condition|)
name|g_error
argument_list|(
literal|"BROKEN y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_OUTOFRANGE
condition|)
name|g_error
argument_list|(
literal|"OOR y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_UNDEFINED
condition|)
name|g_error
argument_list|(
literal|"UNDEFINED y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_TRANSPARENT
operator|||
name|hint
operator|==
name|TILEROWHINT_MIXED
operator|||
name|hint
operator|==
name|TILEROWHINT_OPAQUE
condition|)
block|{
goto|goto
name|next_row4
goto|;
block|}
if|if
condition|(
name|hint
operator|!=
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|g_error
argument_list|(
literal|"MEGABOGUS y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_UNKNOWN
condition|)
block|{
specifier|const
name|guchar
name|alpha
init|=
name|ptr
index|[
literal|3
index|]
decl_stmt|;
comment|/* row is all-opaque or all-transparent? */
if|if
condition|(
name|alpha
operator|==
literal|0
operator|||
name|alpha
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|ewidth
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|ewidth
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|x
operator|*
literal|4
operator|+
literal|3
index|]
operator|!=
name|alpha
condition|)
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
goto|goto
name|next_row4
goto|;
block|}
block|}
block|}
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
operator|(
name|alpha
operator|==
literal|0
operator|)
condition|?
name|TILEROWHINT_TRANSPARENT
else|:
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
block|}
block|}
name|next_row4
label|:
name|ptr
operator|+=
literal|4
operator|*
name|ewidth
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|y
operator|=
name|start
init|;
name|y
operator|<
name|start
operator|+
name|rows
condition|;
name|y
operator|++
control|)
block|{
name|TileRowHint
name|hint
init|=
name|tile_get_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_BROKEN
condition|)
name|g_error
argument_list|(
literal|"BROKEN y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_OUTOFRANGE
condition|)
name|g_error
argument_list|(
literal|"OOR y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_UNDEFINED
condition|)
name|g_error
argument_list|(
literal|"UNDEFINED y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_TRANSPARENT
operator|||
name|hint
operator|==
name|TILEROWHINT_MIXED
operator|||
name|hint
operator|==
name|TILEROWHINT_OPAQUE
condition|)
block|{
goto|goto
name|next_row2
goto|;
block|}
if|if
condition|(
name|hint
operator|!=
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|g_error
argument_list|(
literal|"MEGABOGUS y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_UNKNOWN
condition|)
block|{
specifier|const
name|guchar
name|alpha
init|=
name|ptr
index|[
literal|1
index|]
decl_stmt|;
comment|/* row is all-opaque or all-transparent? */
if|if
condition|(
name|alpha
operator|==
literal|0
operator|||
name|alpha
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|ewidth
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|ewidth
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|!=
name|alpha
condition|)
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
goto|goto
name|next_row2
goto|;
block|}
block|}
block|}
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
operator|(
name|alpha
operator|==
literal|0
operator|)
condition|?
name|TILEROWHINT_TRANSPARENT
else|:
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
block|}
block|}
name|next_row2
label|:
name|ptr
operator|+=
literal|2
operator|*
name|ewidth
expr_stmt|;
block|}
break|break;
default|default:
name|g_return_if_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

