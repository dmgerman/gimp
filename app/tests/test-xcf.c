begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 2009 Martin Nordholts  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"widgets/widgets-types.h"
end_include

begin_include
include|#
directive|include
file|"widgets/gimpuimanager.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel-select.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpgrid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpgrouplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpguide.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-grid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-guides.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-sample-points.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpsamplepoint.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpanchor.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpbezierstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"file/file-open.h"
end_include

begin_include
include|#
directive|include
file|"file/file-procedure.h"
end_include

begin_include
include|#
directive|include
file|"file/file-save.h"
end_include

begin_include
include|#
directive|include
file|"plug-in/gimppluginmanager.h"
end_include

begin_include
include|#
directive|include
file|"tests.h"
end_include

begin_include
include|#
directive|include
file|"gimp-app-test-utils.h"
end_include

begin_define
DECL|macro|GIMP_MAINIMAGE_WIDTH
define|#
directive|define
name|GIMP_MAINIMAGE_WIDTH
value|100
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_HEIGHT
define|#
directive|define
name|GIMP_MAINIMAGE_HEIGHT
value|90
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_TYPE
define|#
directive|define
name|GIMP_MAINIMAGE_TYPE
value|GIMP_RGB
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_NAME
value|"layer1"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_WIDTH
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_WIDTH
value|50
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_HEIGHT
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
value|51
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_TYPE
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_TYPE
value|GIMP_RGBA_IMAGE
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_OPACITY
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_OPACITY
value|1.0
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER1_MODE
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER1_MODE
value|GIMP_NORMAL_MODE
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_NAME
value|"layer2"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_WIDTH
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_WIDTH
value|25
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_HEIGHT
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_HEIGHT
value|251
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_TYPE
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_TYPE
value|GIMP_RGB_IMAGE
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_OPACITY
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_OPACITY
value|0.0
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER2_MODE
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER2_MODE
value|GIMP_MULTIPLY_MODE
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_GROUP1_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_GROUP1_NAME
value|"group1"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER3_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER3_NAME
value|"layer3"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER4_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER4_NAME
value|"layer4"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_GROUP2_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_GROUP2_NAME
value|"group2"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_LAYER5_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_LAYER5_NAME
value|"layer5"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VGUIDE1_POS
define|#
directive|define
name|GIMP_MAINIMAGE_VGUIDE1_POS
value|42
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VGUIDE2_POS
define|#
directive|define
name|GIMP_MAINIMAGE_VGUIDE2_POS
value|82
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_HGUIDE1_POS
define|#
directive|define
name|GIMP_MAINIMAGE_HGUIDE1_POS
value|3
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_HGUIDE2_POS
define|#
directive|define
name|GIMP_MAINIMAGE_HGUIDE2_POS
value|4
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SAMPLEPOINT1_X
define|#
directive|define
name|GIMP_MAINIMAGE_SAMPLEPOINT1_X
value|10
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SAMPLEPOINT1_Y
define|#
directive|define
name|GIMP_MAINIMAGE_SAMPLEPOINT1_Y
value|12
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SAMPLEPOINT2_X
define|#
directive|define
name|GIMP_MAINIMAGE_SAMPLEPOINT2_X
value|41
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SAMPLEPOINT2_Y
define|#
directive|define
name|GIMP_MAINIMAGE_SAMPLEPOINT2_Y
value|49
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_RESOLUTIONX
define|#
directive|define
name|GIMP_MAINIMAGE_RESOLUTIONX
value|400
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_RESOLUTIONY
define|#
directive|define
name|GIMP_MAINIMAGE_RESOLUTIONY
value|410
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_PARASITE_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_PARASITE_NAME
value|"test-parasite"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_PARASITE_DATA
define|#
directive|define
name|GIMP_MAINIMAGE_PARASITE_DATA
value|"foo"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_PARASITE_SIZE
define|#
directive|define
name|GIMP_MAINIMAGE_PARASITE_SIZE
value|4
end_define

begin_comment
DECL|macro|GIMP_MAINIMAGE_PARASITE_SIZE
comment|/* 'f' 'o' 'o' '\0' */
end_comment

begin_define
DECL|macro|GIMP_MAINIMAGE_COMMENT
define|#
directive|define
name|GIMP_MAINIMAGE_COMMENT
value|"Created with code from "\                                         "app/tests/test-xcf.c in the GIMP "\                                         "source tree, i.e. it was not created "\                                         "manually and may thus look weird if "\                                         "opened and inspected in GIMP."
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_UNIT
define|#
directive|define
name|GIMP_MAINIMAGE_UNIT
value|GIMP_UNIT_PICA
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_GRIDXSPACING
define|#
directive|define
name|GIMP_MAINIMAGE_GRIDXSPACING
value|25.0
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_GRIDYSPACING
define|#
directive|define
name|GIMP_MAINIMAGE_GRIDYSPACING
value|27.0
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_CHANNEL1_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_CHANNEL1_NAME
value|"channel1"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_CHANNEL1_WIDTH
define|#
directive|define
name|GIMP_MAINIMAGE_CHANNEL1_WIDTH
value|GIMP_MAINIMAGE_WIDTH
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_CHANNEL1_HEIGHT
define|#
directive|define
name|GIMP_MAINIMAGE_CHANNEL1_HEIGHT
value|GIMP_MAINIMAGE_HEIGHT
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_CHANNEL1_COLOR
define|#
directive|define
name|GIMP_MAINIMAGE_CHANNEL1_COLOR
value|{ 1.0, 0.0, 1.0, 1.0 }
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SELECTION_X
define|#
directive|define
name|GIMP_MAINIMAGE_SELECTION_X
value|5
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SELECTION_Y
define|#
directive|define
name|GIMP_MAINIMAGE_SELECTION_Y
value|6
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SELECTION_W
define|#
directive|define
name|GIMP_MAINIMAGE_SELECTION_W
value|7
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_SELECTION_H
define|#
directive|define
name|GIMP_MAINIMAGE_SELECTION_H
value|8
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VECTORS1_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_VECTORS1_NAME
value|"vectors1"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VECTORS1_COORDS
define|#
directive|define
name|GIMP_MAINIMAGE_VECTORS1_COORDS
value|{ { 11.0, 12.0,
comment|/* pad zeroes */
value|},\                                           { 21.0, 22.0,
comment|/* pad zeroes */
value|},\                                           { 31.0, 32.0,
comment|/* pad zeroes */
value|}, }
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VECTORS2_NAME
define|#
directive|define
name|GIMP_MAINIMAGE_VECTORS2_NAME
value|"vectors2"
end_define

begin_define
DECL|macro|GIMP_MAINIMAGE_VECTORS2_COORDS
define|#
directive|define
name|GIMP_MAINIMAGE_VECTORS2_COORDS
value|{ { 911.0, 912.0,
comment|/* pad zeroes */
value|},\                                           { 921.0, 922.0,
comment|/* pad zeroes */
value|},\                                           { 931.0, 932.0,
comment|/* pad zeroes */
value|}, }
end_define

begin_define
DECL|macro|ADD_TEST (function)
define|#
directive|define
name|ADD_TEST
parameter_list|(
name|function
parameter_list|)
define|\
value|g_test_add_data_func ("/gimp-xcf/" #function, gimp, function);
end_define

begin_function_decl
name|GimpImage
modifier|*
name|gimp_test_load_image
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_write_and_read_file
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|gimp_create_mainimage
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_assert_mainimage
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * write_and_read_gimp_2_6_format:  * @data:  *  * Do a write and read test on a file that could as well be  * constructed with GIMP 2.6.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|write_and_read_gimp_2_6_format (gconstpointer data)
name|write_and_read_gimp_2_6_format
parameter_list|(
name|gconstpointer
name|data
parameter_list|)
block|{
name|Gimp
modifier|*
name|gimp
init|=
name|GIMP
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gimp_write_and_read_file
argument_list|(
name|gimp
argument_list|,
name|FALSE
comment|/*with_unusual_stuff*/
argument_list|,
name|FALSE
comment|/*compat_paths*/
argument_list|,
name|FALSE
comment|/*use_gimp_2_8_features*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * write_and_read_gimp_2_6_format_unusual:  * @data:  *  * Do a write and read test on a file that could as well be  * constructed with GIMP 2.6, and make it unusual, like compatible  * vectors and with a floating selection.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|write_and_read_gimp_2_6_format_unusual (gconstpointer data)
name|write_and_read_gimp_2_6_format_unusual
parameter_list|(
name|gconstpointer
name|data
parameter_list|)
block|{
name|Gimp
modifier|*
name|gimp
init|=
name|GIMP
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gimp_write_and_read_file
argument_list|(
name|gimp
argument_list|,
name|TRUE
comment|/*with_unusual_stuff*/
argument_list|,
name|TRUE
comment|/*compat_paths*/
argument_list|,
name|FALSE
comment|/*use_gimp_2_8_features*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * load_gimp_2_6_file:  * @data:  *  * Loads a file created with GIMP 2.6 and makes sure it loaded as  * expected.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|load_gimp_2_6_file (gconstpointer data)
name|load_gimp_2_6_file
parameter_list|(
name|gconstpointer
name|data
parameter_list|)
block|{
name|Gimp
modifier|*
name|gimp
init|=
name|GIMP
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|uri
init|=
name|NULL
decl_stmt|;
name|uri
operator|=
name|g_build_filename
argument_list|(
name|g_getenv
argument_list|(
literal|"GIMP_TESTING_ABS_TOP_SRCDIR"
argument_list|)
argument_list|,
literal|"app/tests/files/gimp-2-6-file.xcf"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_test_load_image
argument_list|(
name|gimp
argument_list|,
name|uri
argument_list|)
expr_stmt|;
comment|/* The image file was constructed by running    * gimp_write_and_read_file (FALSE, FALSE) in GIMP 2.6 by    * copy-pasting the code to GIMP 2.6 and adapting it to changes in    * the core API, so we can use gimp_assert_mainimage() to make sure    * the file was loaded successfully.    */
name|gimp_assert_mainimage
argument_list|(
name|image
argument_list|,
name|FALSE
comment|/*with_unusual_stuff*/
argument_list|,
name|FALSE
comment|/*compat_paths*/
argument_list|,
name|FALSE
comment|/*use_gimp_2_8_features*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * write_and_read_gimp_2_8_format:  * @data:  *  * Writes an XCF file that uses GIMP 2.8 features such as layer  * groups, then reads the file and make sure no relevant information  * was lost.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|write_and_read_gimp_2_8_format (gconstpointer data)
name|write_and_read_gimp_2_8_format
parameter_list|(
name|gconstpointer
name|data
parameter_list|)
block|{
name|Gimp
modifier|*
name|gimp
init|=
name|GIMP
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gimp_write_and_read_file
argument_list|(
name|gimp
argument_list|,
name|FALSE
comment|/*with_unusual_stuff*/
argument_list|,
name|FALSE
comment|/*compat_paths*/
argument_list|,
name|TRUE
comment|/*use_gimp_2_8_features*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_test_load_image (Gimp * gimp,const gchar * uri)
name|gimp_test_load_image
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|)
block|{
name|GimpPlugInProcedure
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|GimpPDBStatusType
name|not_used
init|=
literal|0
decl_stmt|;
name|proc
operator|=
name|file_procedure_find
argument_list|(
name|gimp
operator|->
name|plug_in_manager
operator|->
name|load_procs
argument_list|,
name|uri
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
name|image
operator|=
name|file_open_image
argument_list|(
name|gimp
argument_list|,
name|gimp_get_user_context
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|NULL
comment|/*progress*/
argument_list|,
name|uri
argument_list|,
literal|"irrelevant"
comment|/*entered_filename*/
argument_list|,
name|FALSE
comment|/*as_new*/
argument_list|,
name|proc
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
operator|&
name|not_used
comment|/*status*/
argument_list|,
name|NULL
comment|/*mime_type*/
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_write_and_read_file:  *  * Constructs the main test image and asserts its state, writes it to  * a file, reads the image from the file, and asserts the state of the  * loaded file. The function takes various parameters so the same  * function can be used for different formats.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_write_and_read_file (Gimp * gimp,gboolean with_unusual_stuff,gboolean compat_paths,gboolean use_gimp_2_8_features)
name|gimp_write_and_read_file
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|GimpImage
modifier|*
name|loaded_image
init|=
name|NULL
decl_stmt|;
name|GimpPlugInProcedure
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|uri
init|=
name|NULL
decl_stmt|;
comment|/* Create the image */
name|image
operator|=
name|gimp_create_mainimage
argument_list|(
name|gimp
argument_list|,
name|with_unusual_stuff
argument_list|,
name|compat_paths
argument_list|,
name|use_gimp_2_8_features
argument_list|)
expr_stmt|;
comment|/* Assert valid state */
name|gimp_assert_mainimage
argument_list|(
name|image
argument_list|,
name|with_unusual_stuff
argument_list|,
name|compat_paths
argument_list|,
name|use_gimp_2_8_features
argument_list|)
expr_stmt|;
comment|/* Write to file */
name|uri
operator|=
name|g_build_filename
argument_list|(
name|g_get_tmp_dir
argument_list|()
argument_list|,
literal|"gimp-test.xcf"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|proc
operator|=
name|file_procedure_find
argument_list|(
name|image
operator|->
name|gimp
operator|->
name|plug_in_manager
operator|->
name|save_procs
argument_list|,
name|uri
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
name|file_save
argument_list|(
name|gimp
argument_list|,
name|image
argument_list|,
name|NULL
comment|/*progress*/
argument_list|,
name|uri
argument_list|,
name|proc
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
name|FALSE
comment|/*change_saved_state*/
argument_list|,
name|FALSE
comment|/*export*/
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
comment|/* Load from file */
name|loaded_image
operator|=
name|gimp_test_load_image
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|uri
argument_list|)
expr_stmt|;
comment|/* Assert on the loaded file. If success, it means that there is no    * significant information loss when we wrote the image to a file    * and loaded it again    */
name|gimp_assert_mainimage
argument_list|(
name|loaded_image
argument_list|,
name|with_unusual_stuff
argument_list|,
name|compat_paths
argument_list|,
name|use_gimp_2_8_features
argument_list|)
expr_stmt|;
name|g_unlink
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_create_mainimage:  *  * Creates the main test image, i.e. the image that we use for most of  * our XCF testing purposes.  *  * Returns: The #GimpImage  **/
end_comment

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|gimp_create_mainimage (Gimp * gimp,gboolean with_unusual_stuff,gboolean compat_paths,gboolean use_gimp_2_8_features)
name|gimp_create_mainimage
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
init|=
name|NULL
decl_stmt|;
name|GimpGrid
modifier|*
name|grid
init|=
name|NULL
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|GimpRGB
name|channel_color
init|=
name|GIMP_MAINIMAGE_CHANNEL1_COLOR
decl_stmt|;
name|GimpChannel
modifier|*
name|selection
init|=
name|NULL
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
init|=
name|NULL
decl_stmt|;
name|GimpCoords
name|vectors1_coords
index|[]
init|=
name|GIMP_MAINIMAGE_VECTORS1_COORDS
decl_stmt|;
name|GimpCoords
name|vectors2_coords
index|[]
init|=
name|GIMP_MAINIMAGE_VECTORS2_COORDS
decl_stmt|;
name|GimpStroke
modifier|*
name|stroke
init|=
name|NULL
decl_stmt|;
name|GimpLayerMask
modifier|*
name|layer_mask
init|=
name|NULL
decl_stmt|;
comment|/* Image size and type */
name|image
operator|=
name|gimp_image_new
argument_list|(
name|gimp
argument_list|,
name|GIMP_MAINIMAGE_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_TYPE
argument_list|)
expr_stmt|;
comment|/* Layers */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_TYPE
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_NAME
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_OPACITY
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_TYPE
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_NAME
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_OPACITY
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Layer mask */
name|layer_mask
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer
argument_list|,
name|GIMP_ADD_BLACK_MASK
argument_list|,
name|NULL
comment|/*channel*/
argument_list|)
expr_stmt|;
name|gimp_layer_add_mask
argument_list|(
name|layer
argument_list|,
name|layer_mask
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
comment|/* Image compression type    *    * We don't do any explicit test, only implicit when we read tile    * data in other tests    */
comment|/* Guides, note we add them in reversed order */
name|gimp_image_add_hguide
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_HGUIDE2_POS
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|gimp_image_add_hguide
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_HGUIDE1_POS
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|gimp_image_add_vguide
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VGUIDE2_POS
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|gimp_image_add_vguide
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VGUIDE1_POS
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Sample points */
name|gimp_image_add_sample_point_at_pos
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT1_X
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT1_Y
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|gimp_image_add_sample_point_at_pos
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT2_X
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT2_Y
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Tatto    * We don't bother testing this, not yet at least    */
comment|/* Resolution */
name|gimp_image_set_resolution
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_RESOLUTIONX
argument_list|,
name|GIMP_MAINIMAGE_RESOLUTIONY
argument_list|)
expr_stmt|;
comment|/* Parasites */
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|GIMP_MAINIMAGE_PARASITE_NAME
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|GIMP_MAINIMAGE_PARASITE_SIZE
argument_list|,
name|GIMP_MAINIMAGE_PARASITE_DATA
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|GIMP_MAINIMAGE_COMMENT
argument_list|)
operator|+
literal|1
argument_list|,
name|GIMP_MAINIMAGE_COMMENT
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
comment|/* Unit */
name|gimp_image_set_unit
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_UNIT
argument_list|)
expr_stmt|;
comment|/* Grid */
name|grid
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_GRID
argument_list|,
literal|"xspacing"
argument_list|,
name|GIMP_MAINIMAGE_GRIDXSPACING
argument_list|,
literal|"yspacing"
argument_list|,
name|GIMP_MAINIMAGE_GRIDYSPACING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_image_set_grid
argument_list|(
name|image
argument_list|,
name|grid
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|grid
argument_list|)
expr_stmt|;
comment|/* Channel */
name|channel
operator|=
name|gimp_channel_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_NAME
argument_list|,
operator|&
name|channel_color
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Selection */
name|selection
operator|=
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_channel_select_rectangle
argument_list|(
name|selection
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_X
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_Y
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_W
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_H
argument_list|,
name|GIMP_CHANNEL_OP_REPLACE
argument_list|,
name|FALSE
comment|/*feather*/
argument_list|,
literal|0.0
comment|/*feather_radius_x*/
argument_list|,
literal|0.0
comment|/*feather_radius_y*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Vectors 1 */
name|vectors
operator|=
name|gimp_vectors_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VECTORS1_NAME
argument_list|)
expr_stmt|;
comment|/* The XCF file can save vectors in two kind of ways, one old way    * and a new way. Parameterize the way so we can test both variants,    * i.e. gimp_vectors_compat_is_compatible() must return both TRUE    * and FALSE.    */
if|if
condition|(
operator|!
name|compat_paths
condition|)
block|{
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Add test for non-closed stroke. The order of the anchor    * points changes for open strokes, so it's boring to test    */
name|stroke
operator|=
name|gimp_bezier_stroke_new_from_coords
argument_list|(
name|vectors1_coords
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|vectors1_coords
argument_list|)
argument_list|,
name|TRUE
comment|/*closed*/
argument_list|)
expr_stmt|;
name|gimp_vectors_stroke_add
argument_list|(
name|vectors
argument_list|,
name|stroke
argument_list|)
expr_stmt|;
name|gimp_image_add_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|NULL
comment|/*parent*/
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Vectors 2 */
name|vectors
operator|=
name|gimp_vectors_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VECTORS2_NAME
argument_list|)
expr_stmt|;
name|stroke
operator|=
name|gimp_bezier_stroke_new_from_coords
argument_list|(
name|vectors2_coords
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|vectors2_coords
argument_list|)
argument_list|,
name|TRUE
comment|/*closed*/
argument_list|)
expr_stmt|;
name|gimp_vectors_stroke_add
argument_list|(
name|vectors
argument_list|,
name|stroke
argument_list|)
expr_stmt|;
name|gimp_image_add_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|NULL
comment|/*parent*/
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* Some of these things are pretty unusual, parameterize the    * inclusion of this in the written file so we can do our test both    * with and without    */
if|if
condition|(
name|with_unusual_stuff
condition|)
block|{
comment|/* Floating selection */
name|gimp_selection_float
argument_list|(
name|GIMP_SELECTION
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|gimp_image_get_active_drawable
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_get_user_context
argument_list|(
name|gimp
argument_list|)
argument_list|,
name|TRUE
comment|/*cut_image*/
argument_list|,
literal|0
comment|/*off_x*/
argument_list|,
literal|0
comment|/*off_y*/
argument_list|,
name|NULL
comment|/*error*/
argument_list|)
expr_stmt|;
block|}
comment|/* Adds stuff like layer groups */
if|if
condition|(
name|use_gimp_2_8_features
condition|)
block|{
name|GimpLayer
modifier|*
name|parent
decl_stmt|;
comment|/* Add a layer group and some layers:        *        *  group1        *    layer3        *    layer4        *    group2        *      layer5        */
comment|/* group1 */
name|layer
operator|=
name|gimp_group_layer_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|GIMP_MAINIMAGE_GROUP1_NAME
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
comment|/*parent*/
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|parent
operator|=
name|layer
expr_stmt|;
comment|/* layer3 */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_TYPE
argument_list|,
name|GIMP_MAINIMAGE_LAYER3_NAME
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_OPACITY
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|parent
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* layer4 */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_TYPE
argument_list|,
name|GIMP_MAINIMAGE_LAYER4_NAME
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_OPACITY
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|parent
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
comment|/* group2 */
name|layer
operator|=
name|gimp_group_layer_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
name|GIMP_MAINIMAGE_GROUP2_NAME
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|parent
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
name|parent
operator|=
name|layer
expr_stmt|;
comment|/* layer5 */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_WIDTH
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_TYPE
argument_list|,
name|GIMP_MAINIMAGE_LAYER5_NAME
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_OPACITY
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|parent
argument_list|,
operator|-
literal|1
comment|/*position*/
argument_list|,
name|FALSE
comment|/*push_undo*/
argument_list|)
expr_stmt|;
block|}
comment|/* Todo, should be tested somehow:    *    * - Color maps    * - Custom user units    * - Text layers    * - Layer parasites    * - Channel parasites    * - Different tile compression methods    */
return|return
name|image
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_assert_vectors (GimpImage * image,const gchar * name,GimpCoords coords[],gsize coords_size,gboolean visible)
name|gimp_assert_vectors
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|GimpCoords
name|coords
index|[]
parameter_list|,
name|gsize
name|coords_size
parameter_list|,
name|gboolean
name|visible
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|vectors
init|=
name|NULL
decl_stmt|;
name|GimpStroke
modifier|*
name|stroke
init|=
name|NULL
decl_stmt|;
name|GArray
modifier|*
name|control_points
init|=
name|NULL
decl_stmt|;
name|gboolean
name|closed
init|=
name|FALSE
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|vectors
operator|=
name|gimp_image_get_vectors_by_name
argument_list|(
name|image
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|stroke
operator|=
name|gimp_vectors_stroke_get_next
argument_list|(
name|vectors
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|stroke
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|control_points
operator|=
name|gimp_stroke_control_points_get
argument_list|(
name|stroke
argument_list|,
operator|&
name|closed
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|closed
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|control_points
operator|->
name|len
argument_list|,
operator|==
argument_list|,
name|coords_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|control_points
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|g_assert_cmpint
argument_list|(
name|coords
index|[
name|i
index|]
operator|.
name|x
argument_list|,
operator|==
argument_list|,
name|g_array_index
argument_list|(
name|control_points
argument_list|,
name|GimpAnchor
argument_list|,
name|i
argument_list|)
operator|.
name|position
operator|.
name|x
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|coords
index|[
name|i
index|]
operator|.
name|y
argument_list|,
operator|==
argument_list|,
name|g_array_index
argument_list|(
name|control_points
argument_list|,
name|GimpAnchor
argument_list|,
name|i
argument_list|)
operator|.
name|position
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|g_assert
argument_list|(
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
operator|==
name|visible
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_assert_mainimage:  * @image:  *  * Verifies that the passed #GimpImage contains all the information  * that was put in it by gimp_create_mainimage().  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_assert_mainimage (GimpImage * image,gboolean with_unusual_stuff,gboolean compat_paths,gboolean use_gimp_2_8_features)
name|gimp_assert_mainimage
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gboolean
name|with_unusual_stuff
parameter_list|,
name|gboolean
name|compat_paths
parameter_list|,
name|gboolean
name|use_gimp_2_8_features
parameter_list|)
block|{
specifier|const
name|GimpParasite
modifier|*
name|parasite
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|GimpGuide
modifier|*
name|guide
init|=
name|NULL
decl_stmt|;
name|GimpSamplePoint
modifier|*
name|sample_point
init|=
name|NULL
decl_stmt|;
name|gdouble
name|xres
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|yres
init|=
literal|0.0
decl_stmt|;
name|GimpGrid
modifier|*
name|grid
init|=
name|NULL
decl_stmt|;
name|gdouble
name|xspacing
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|yspacing
init|=
literal|0.0
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|GimpRGB
name|expected_channel_color
init|=
name|GIMP_MAINIMAGE_CHANNEL1_COLOR
decl_stmt|;
name|GimpRGB
name|actual_channel_color
init|=
block|{
literal|0
block|, }
decl_stmt|;
name|GimpChannel
modifier|*
name|selection
init|=
name|NULL
decl_stmt|;
name|gint
name|x1
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|y1
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|x2
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|y2
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|w
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|h
init|=
operator|-
literal|1
decl_stmt|;
name|GimpCoords
name|vectors1_coords
index|[]
init|=
name|GIMP_MAINIMAGE_VECTORS1_COORDS
decl_stmt|;
name|GimpCoords
name|vectors2_coords
index|[]
init|=
name|GIMP_MAINIMAGE_VECTORS2_COORDS
decl_stmt|;
comment|/* Image size and type */
name|g_assert_cmpint
argument_list|(
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_WIDTH
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_HEIGHT
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_image_base_type
argument_list|(
name|image
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_TYPE
argument_list|)
expr_stmt|;
comment|/* Layers */
name|layer
operator|=
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_NAME
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_WIDTH
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_HEIGHT
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_TYPE
argument_list|)
expr_stmt|;
name|g_assert_cmpstr
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_NAME
argument_list|)
expr_stmt|;
name|g_assert_cmpfloat
argument_list|(
name|gimp_layer_get_opacity
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_OPACITY
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_layer_get_mode
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER1_MODE
argument_list|)
expr_stmt|;
name|layer
operator|=
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_NAME
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_WIDTH
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_HEIGHT
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_TYPE
argument_list|)
expr_stmt|;
name|g_assert_cmpstr
argument_list|(
name|gimp_object_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_NAME
argument_list|)
expr_stmt|;
name|g_assert_cmpfloat
argument_list|(
name|gimp_layer_get_opacity
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_OPACITY
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_layer_get_mode
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_LAYER2_MODE
argument_list|)
expr_stmt|;
comment|/* Guides, note that we rely on internal ordering */
name|iter
operator|=
name|gimp_image_get_guides
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|GIMP_GUIDE
argument_list|(
name|iter
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_guide_get_position
argument_list|(
name|guide
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_VGUIDE1_POS
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|GIMP_GUIDE
argument_list|(
name|iter
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_guide_get_position
argument_list|(
name|guide
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_VGUIDE2_POS
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|GIMP_GUIDE
argument_list|(
name|iter
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_guide_get_position
argument_list|(
name|guide
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_HGUIDE1_POS
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|guide
operator|=
name|GIMP_GUIDE
argument_list|(
name|iter
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_guide_get_position
argument_list|(
name|guide
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_HGUIDE2_POS
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Sample points, we rely on the same ordering as when we added    * them, although this ordering is not a necessaity    */
name|iter
operator|=
name|gimp_image_get_sample_points
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sample_point
operator|=
operator|(
name|GimpSamplePoint
operator|*
operator|)
name|iter
operator|->
name|data
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|sample_point
operator|->
name|x
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT1_X
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|sample_point
operator|->
name|y
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT1_Y
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sample_point
operator|=
operator|(
name|GimpSamplePoint
operator|*
operator|)
name|iter
operator|->
name|data
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|sample_point
operator|->
name|x
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT2_X
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|sample_point
operator|->
name|y
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SAMPLEPOINT2_Y
argument_list|)
expr_stmt|;
name|iter
operator|=
name|g_list_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|iter
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Resolution */
name|gimp_image_get_resolution
argument_list|(
name|image
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|xres
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_RESOLUTIONX
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|yres
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_RESOLUTIONY
argument_list|)
expr_stmt|;
comment|/* Parasites */
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_PARASITE_NAME
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_PARASITE_SIZE
argument_list|)
expr_stmt|;
name|g_assert_cmpstr
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_PARASITE_DATA
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|,
operator|==
argument_list|,
name|strlen
argument_list|(
name|GIMP_MAINIMAGE_COMMENT
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_assert_cmpstr
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_COMMENT
argument_list|)
expr_stmt|;
comment|/* Unit */
name|g_assert_cmpint
argument_list|(
name|gimp_image_get_unit
argument_list|(
name|image
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_UNIT
argument_list|)
expr_stmt|;
comment|/* Grid */
name|grid
operator|=
name|gimp_image_get_grid
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_object_get
argument_list|(
name|grid
argument_list|,
literal|"xspacing"
argument_list|,
operator|&
name|xspacing
argument_list|,
literal|"yspacing"
argument_list|,
operator|&
name|yspacing
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|xspacing
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_GRIDXSPACING
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|yspacing
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_GRIDYSPACING
argument_list|)
expr_stmt|;
comment|/* Channel */
name|channel
operator|=
name|gimp_image_get_channel_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_NAME
argument_list|)
expr_stmt|;
name|gimp_channel_get_color
argument_list|(
name|channel
argument_list|,
operator|&
name|actual_channel_color
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_WIDTH
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_CHANNEL1_HEIGHT
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|memcmp
argument_list|(
operator|&
name|expected_channel_color
argument_list|,
operator|&
name|actual_channel_color
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpRGB
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Selection, if the image contains unusual stuff it contains a    * floating select, and when floating a selection, the selection    * mask is cleared, so don't test for the presence of the selection    * mask in that case    */
if|if
condition|(
operator|!
name|with_unusual_stuff
condition|)
block|{
name|selection
operator|=
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_channel_bounds
argument_list|(
name|selection
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|x1
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_X
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|y1
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_Y
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|w
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_W
argument_list|)
expr_stmt|;
name|g_assert_cmpint
argument_list|(
name|h
argument_list|,
operator|==
argument_list|,
name|GIMP_MAINIMAGE_SELECTION_H
argument_list|)
expr_stmt|;
block|}
comment|/* Vectors 1 */
name|gimp_assert_vectors
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VECTORS1_NAME
argument_list|,
name|vectors1_coords
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|vectors1_coords
argument_list|)
argument_list|,
operator|!
name|compat_paths
comment|/*visible*/
argument_list|)
expr_stmt|;
comment|/* Vectors 2 (always visible FALSE) */
name|gimp_assert_vectors
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_VECTORS2_NAME
argument_list|,
name|vectors2_coords
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|vectors2_coords
argument_list|)
argument_list|,
name|FALSE
comment|/*visible*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_unusual_stuff
condition|)
name|g_assert
argument_list|(
name|gimp_image_get_floating_selection
argument_list|(
name|image
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
else|else
comment|/* if (! with_unusual_stuff) */
name|g_assert
argument_list|(
name|gimp_image_get_floating_selection
argument_list|(
name|image
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gimp_2_8_features
condition|)
block|{
comment|/* Only verify the parent relationships, the layer attributes        * are tested above        */
name|GimpItem
modifier|*
name|group1
init|=
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_GROUP1_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|GimpItem
modifier|*
name|layer3
init|=
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER3_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|GimpItem
modifier|*
name|layer4
init|=
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER4_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|GimpItem
modifier|*
name|group2
init|=
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_GROUP2_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|GimpItem
modifier|*
name|layer5
init|=
name|GIMP_ITEM
argument_list|(
name|gimp_image_get_layer_by_name
argument_list|(
name|image
argument_list|,
name|GIMP_MAINIMAGE_LAYER5_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|g_assert
argument_list|(
name|gimp_item_get_parent
argument_list|(
name|group1
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|gimp_item_get_parent
argument_list|(
name|layer3
argument_list|)
operator|==
name|group1
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|gimp_item_get_parent
argument_list|(
name|layer4
argument_list|)
operator|==
name|group1
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|gimp_item_get_parent
argument_list|(
name|group2
argument_list|)
operator|==
name|group1
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|gimp_item_get_parent
argument_list|(
name|layer5
argument_list|)
operator|==
name|group2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * main:  * @argc:  * @argv:  *  * These tests intend to  *  *  - Make sure that we are backwards compatible with files created by  *    older version of GIMP, i.e. that we can load files from earlier  *    version of GIMP  *  *  - Make sure that the information put into a #GimpImage is not lost  *    when the #GimpImage is written to a file and then read again  **/
end_comment

begin_function
name|int
DECL|function|main (int argc,char ** argv)
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|Gimp
modifier|*
name|gimp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|g_thread_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|g_type_init
argument_list|()
expr_stmt|;
name|g_test_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_test_utils_set_gimp2_directory
argument_list|(
literal|"GIMP_TESTING_ABS_TOP_SRCDIR"
argument_list|,
literal|"app/tests/gimpdir"
argument_list|)
expr_stmt|;
comment|/* We share the same application instance across all tests. We need    * the GUI variant for the file procs    */
name|gimp
operator|=
name|gimp_init_for_testing
argument_list|()
expr_stmt|;
comment|/* Add tests */
name|ADD_TEST
argument_list|(
name|write_and_read_gimp_2_6_format
argument_list|)
expr_stmt|;
name|ADD_TEST
argument_list|(
name|write_and_read_gimp_2_6_format_unusual
argument_list|)
expr_stmt|;
name|ADD_TEST
argument_list|(
name|load_gimp_2_6_file
argument_list|)
expr_stmt|;
name|ADD_TEST
argument_list|(
name|write_and_read_gimp_2_8_format
argument_list|)
expr_stmt|;
comment|/* Don't write files to the source dir */
name|gimp_test_utils_set_gimp2_directory
argument_list|(
literal|"GIMP_TESTING_ABS_TOP_BUILDDIR"
argument_list|,
literal|"app/tests/gimpdir-output"
argument_list|)
expr_stmt|;
comment|/* Run the tests */
name|result
operator|=
name|g_test_run
argument_list|()
expr_stmt|;
comment|/* Exit so we don't break script-fu plug-in wire */
name|gimp_exit
argument_list|(
name|gimp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

