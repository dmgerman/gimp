begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"brush_select.h"
end_include

begin_include
include|#
directive|include
file|"bucket_fill.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"fuzzy_select.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"palette.h"
end_include

begin_include
include|#
directive|include
file|"patterns.h"
end_include

begin_include
include|#
directive|include
file|"selection.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_comment
comment|/*  the Bucket Fill structures  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon274c22ea0103
block|{
DECL|enumerator|FgColorFill
name|FgColorFill
block|,
DECL|enumerator|BgColorFill
name|BgColorFill
block|,
DECL|enumerator|PatternFill
name|PatternFill
DECL|typedef|FillMode
block|}
name|FillMode
typedef|;
end_typedef

begin_typedef
DECL|typedef|BucketTool
typedef|typedef
name|struct
name|_BucketTool
name|BucketTool
typedef|;
end_typedef

begin_struct
DECL|struct|_BucketTool
struct|struct
name|_BucketTool
block|{
DECL|member|target_x
name|int
name|target_x
decl_stmt|;
comment|/*  starting x coord          */
DECL|member|target_y
name|int
name|target_y
decl_stmt|;
comment|/*  starting y coord          */
block|}
struct|;
end_struct

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|bucket_fill_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_cursor_update
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|FillMode
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_region
parameter_list|(
name|FillMode
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|TempBuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_line_color
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_fill_line_pattern
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|TempBuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|bucket_fill_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
DECL|typedef|BucketOptions
typedef|typedef
name|struct
name|_BucketOptions
name|BucketOptions
typedef|;
end_typedef

begin_struct
DECL|struct|_BucketOptions
struct|struct
name|_BucketOptions
block|{
DECL|member|opacity
name|double
name|opacity
decl_stmt|;
DECL|member|threshold
name|double
name|threshold
decl_stmt|;
DECL|member|fill_mode
name|FillMode
name|fill_mode
decl_stmt|;
DECL|member|paint_mode
name|int
name|paint_mode
decl_stmt|;
DECL|member|sample_merged
name|int
name|sample_merged
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  local variables  */
end_comment

begin_decl_stmt
DECL|variable|bucket_options
specifier|static
name|BucketOptions
modifier|*
name|bucket_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|bucket_fill_toggle_update (GtkWidget * widget,gpointer data)
name|bucket_fill_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_scale_update (GtkAdjustment * adjustment,gpointer data)
name|bucket_fill_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|double
modifier|*
name|scale_val
decl_stmt|;
name|scale_val
operator|=
operator|(
name|double
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|scale_val
operator|=
name|adjustment
operator|->
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_mode_callback (GtkWidget * w,gpointer client_data)
name|bucket_fill_mode_callback
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|client_data
parameter_list|)
block|{
name|bucket_options
operator|->
name|fill_mode
operator|=
operator|(
name|FillMode
operator|)
name|client_data
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_paint_mode_callback (GtkWidget * w,gpointer client_data)
name|bucket_fill_paint_mode_callback
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|client_data
parameter_list|)
block|{
name|bucket_options
operator|->
name|paint_mode
operator|=
operator|(
name|long
operator|)
name|client_data
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|BucketOptions
modifier|*
DECL|function|create_bucket_options (void)
name|create_bucket_options
parameter_list|(
name|void
parameter_list|)
block|{
name|BucketOptions
modifier|*
name|options
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|option_menu
decl_stmt|;
name|GtkWidget
modifier|*
name|menu
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_frame
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_box
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_button
decl_stmt|;
name|GtkWidget
modifier|*
name|opacity_scale
decl_stmt|;
name|GtkWidget
modifier|*
name|sample_merged_toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|threshold_scale
decl_stmt|;
name|GtkObject
modifier|*
name|opacity_scale_data
decl_stmt|;
name|GtkObject
modifier|*
name|threshold_scale_data
decl_stmt|;
name|GSList
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|button_names
index|[
literal|2
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Color Fill"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern Fill"
argument_list|)
block|}
decl_stmt|;
comment|/*  the new options structure  */
name|options
operator|=
operator|(
name|BucketOptions
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketOptions
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|->
name|opacity
operator|=
literal|100.0
expr_stmt|;
name|options
operator|->
name|threshold
operator|=
literal|15.0
expr_stmt|;
name|options
operator|->
name|fill_mode
operator|=
name|FgColorFill
expr_stmt|;
name|options
operator|->
name|paint_mode
operator|=
name|NORMAL
expr_stmt|;
name|options
operator|->
name|sample_merged
operator|=
name|FALSE
expr_stmt|;
comment|/*  the main vbox  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  the main label  */
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Bucket Fill Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/*  the opacity scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Fill Opacity: "
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|opacity_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|100.0
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|opacity_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|opacity_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|opacity_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|opacity_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|opacity_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|opacity_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|bucket_fill_scale_update
argument_list|,
operator|&
name|options
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|opacity_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the threshold scale  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Fill Threshold: "
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|threshold_scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
literal|15.0
argument_list|,
literal|1.0
argument_list|,
literal|255.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|threshold_scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|threshold_scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|threshold_scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|threshold_scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|threshold_scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|threshold_scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|bucket_fill_scale_update
argument_list|,
operator|&
name|options
operator|->
name|threshold
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|threshold_scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the paint mode menu  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Mode: "
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|menu
operator|=
name|create_paint_mode_menu
argument_list|(
name|bucket_fill_paint_mode_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|option_menu
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|option_menu
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|option_menu
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/*  the radio frame and box  */
name|radio_frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Fill Type: "
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|radio_frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|radio_box
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|radio_box
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|radio_frame
argument_list|)
argument_list|,
name|radio_box
argument_list|)
expr_stmt|;
comment|/*  the radio buttons  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|radio_button
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|group
argument_list|,
name|gettext
argument_list|(
name|button_names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|radio_button
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|radio_button
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|bucket_fill_mode_callback
argument_list|,
call|(
name|gpointer
call|)
argument_list|(
call|(
name|long
call|)
argument_list|(
name|i
operator|==
literal|1
condition|?
name|PatternFill
else|:
name|FgColorFill
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* kludgy */
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|radio_box
argument_list|)
argument_list|,
name|radio_button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|radio_button
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|radio_box
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|radio_frame
argument_list|)
expr_stmt|;
comment|/*  the sample merged toggle  */
name|sample_merged_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Sample Merged"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|sample_merged_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|bucket_fill_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|sample_merged
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|sample_merged_toggle
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|sample_merged_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|sample_merged_toggle
argument_list|)
expr_stmt|;
comment|/*  Register this selection options widget with the main tools options dialog  */
name|tools_register_options
argument_list|(
name|BUCKET_FILL
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
comment|/*  Post initialization  */
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|option_menu
argument_list|)
argument_list|,
name|menu
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_button_press (tool,bevent,gdisp_ptr)
name|bucket_fill_button_press
parameter_list|(
name|tool
parameter_list|,
name|bevent
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|GdkEventButton
modifier|*
name|bevent
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BucketTool
modifier|*
name|bucket_tool
decl_stmt|;
name|int
name|use_offsets
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bucket_tool
operator|=
operator|(
name|BucketTool
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|use_offsets
operator|=
operator|(
name|bucket_options
operator|->
name|sample_merged
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|bucket_tool
operator|->
name|target_x
argument_list|,
operator|&
name|bucket_tool
operator|->
name|target_y
argument_list|,
name|FALSE
argument_list|,
name|use_offsets
argument_list|)
expr_stmt|;
comment|/*  Make the tool active and set the gdisplay which owns it  */
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
comment|/*  Make the tool active and set the gdisplay which owns it  */
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_button_release (tool,bevent,gdisp_ptr)
name|bucket_fill_button_release
parameter_list|(
name|tool
parameter_list|,
name|bevent
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|GdkEventButton
modifier|*
name|bevent
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BucketTool
modifier|*
name|bucket_tool
decl_stmt|;
name|FillMode
name|fill_mode
decl_stmt|;
name|Argument
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bucket_tool
operator|=
operator|(
name|BucketTool
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
comment|/*  if the 3rd button isn't pressed, fill the selected region  */
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_BUTTON3_MASK
operator|)
condition|)
block|{
name|fill_mode
operator|=
name|bucket_options
operator|->
name|fill_mode
expr_stmt|;
comment|/*  If the mode is color filling, and shift mask is down, fill with background  */
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|&&
name|fill_mode
operator|==
name|FgColorFill
condition|)
name|fill_mode
operator|=
name|BgColorFill
expr_stmt|;
name|return_vals
operator|=
name|procedural_db_run_proc
argument_list|(
literal|"gimp_bucket_fill"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PDB_DRAWABLE
argument_list|,
name|drawable_ID
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|)
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|fill_mode
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|bucket_options
operator|->
name|paint_mode
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
name|bucket_options
operator|->
name|opacity
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
name|bucket_options
operator|->
name|threshold
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|bucket_options
operator|->
name|sample_merged
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
name|bucket_tool
operator|->
name|target_x
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
name|bucket_tool
operator|->
name|target_y
argument_list|,
name|PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|==
name|PDB_SUCCESS
condition|)
name|gdisplays_flush
argument_list|()
expr_stmt|;
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Bucket Fill operation failed."
argument_list|)
argument_list|)
expr_stmt|;
name|procedural_db_destroy_args
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
block|}
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_motion (tool,mevent,gdisp_ptr)
name|bucket_fill_motion
parameter_list|(
name|tool
parameter_list|,
name|mevent
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|GdkEventMotion
modifier|*
name|mevent
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_cursor_update (tool,mevent,gdisp_ptr)
name|bucket_fill_cursor_update
parameter_list|(
name|tool
parameter_list|,
name|mevent
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|GdkEventMotion
modifier|*
name|mevent
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GdkCursorType
name|ctype
init|=
name|GDK_TOP_LEFT_ARROW
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|)
condition|)
block|{
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|off_x
operator|&&
name|y
operator|>=
name|off_y
operator|&&
name|x
operator|<
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|&&
name|y
operator|<
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/*  One more test--is there a selected region? 	   *  if so, is cursor inside? 	   */
if|if
condition|(
name|gimage_mask_is_empty
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
condition|)
name|ctype
operator|=
name|GDK_TCROSS
expr_stmt|;
elseif|else
if|if
condition|(
name|gimage_mask_value
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
name|ctype
operator|=
name|GDK_TCROSS
expr_stmt|;
block|}
block|}
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_control (tool,action,gdisp_ptr)
name|bucket_fill_control
parameter_list|(
name|tool
parameter_list|,
name|action
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|int
name|action
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill (gimage,drawable,fill_mode,paint_mode,opacity,threshold,sample_merged,x,y)
name|bucket_fill
parameter_list|(
name|gimage
parameter_list|,
name|drawable
parameter_list|,
name|fill_mode
parameter_list|,
name|paint_mode
parameter_list|,
name|opacity
parameter_list|,
name|threshold
parameter_list|,
name|sample_merged
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|FillMode
name|fill_mode
decl_stmt|;
name|int
name|paint_mode
decl_stmt|;
name|double
name|opacity
decl_stmt|;
name|double
name|threshold
decl_stmt|;
name|int
name|sample_merged
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|TileManager
modifier|*
name|buf_tiles
decl_stmt|;
name|PixelRegion
name|bufPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|Channel
modifier|*
name|mask
init|=
name|NULL
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|has_alpha
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|unsigned
name|char
name|col
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d2
decl_stmt|;
name|GPatternP
name|pattern
decl_stmt|;
name|TempBuf
modifier|*
name|pat_buf
decl_stmt|;
name|int
name|new_buf
init|=
literal|0
decl_stmt|;
name|pat_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fill_mode
operator|==
name|FgColorFill
condition|)
name|gimage_get_foreground
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fill_mode
operator|==
name|BgColorFill
condition|)
name|gimage_get_background
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fill_mode
operator|==
name|PatternFill
condition|)
block|{
name|pattern
operator|=
name|get_active_pattern
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"No available patterns for this operation."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  If the pattern doesn't match the image in terms of color type,        *  transform it.  (ie  pattern is RGB, image is indexed)        */
if|if
condition|(
operator|(
operator|(
name|pattern
operator|->
name|mask
operator|->
name|bytes
operator|==
literal|3
operator|)
operator|&&
operator|!
name|drawable_color
argument_list|(
name|drawable
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|pattern
operator|->
name|mask
operator|->
name|bytes
operator|==
literal|1
operator|)
operator|&&
operator|!
name|drawable_gray
argument_list|(
name|drawable
argument_list|)
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|->
name|mask
operator|->
name|bytes
operator|==
literal|1
operator|)
operator|&&
name|drawable_color
argument_list|(
name|drawable
argument_list|)
condition|)
name|pat_buf
operator|=
name|temp_buf_new
argument_list|(
name|pattern
operator|->
name|mask
operator|->
name|width
argument_list|,
name|pattern
operator|->
name|mask
operator|->
name|height
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pat_buf
operator|=
name|temp_buf_new
argument_list|(
name|pattern
operator|->
name|mask
operator|->
name|width
argument_list|,
name|pattern
operator|->
name|mask
operator|->
name|height
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|d1
operator|=
name|temp_buf_data
argument_list|(
name|pattern
operator|->
name|mask
argument_list|)
expr_stmt|;
name|d2
operator|=
name|temp_buf_data
argument_list|(
name|pat_buf
argument_list|)
expr_stmt|;
name|size
operator|=
name|pattern
operator|->
name|mask
operator|->
name|width
operator|*
name|pattern
operator|->
name|mask
operator|->
name|height
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|gimage_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|,
operator|(
name|pattern
operator|->
name|mask
operator|->
name|bytes
operator|==
literal|3
operator|)
condition|?
name|RGB
else|:
name|GRAY
argument_list|)
expr_stmt|;
name|d1
operator|+=
name|pattern
operator|->
name|mask
operator|->
name|bytes
expr_stmt|;
name|d2
operator|+=
name|pat_buf
operator|->
name|bytes
expr_stmt|;
block|}
name|new_buf
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pat_buf
operator|=
name|pattern
operator|->
name|mask
expr_stmt|;
block|}
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|drawable_bytes
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*  If there is no selection mask, the do a seed bucket    *  fill...To do this, calculate a new contiguous region    */
if|if
condition|(
operator|!
name|drawable_mask_bounds
argument_list|(
name|drawable
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
condition|)
block|{
name|mask
operator|=
name|find_contiguous_region
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|TRUE
argument_list|,
operator|(
name|int
operator|)
name|threshold
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
name|sample_merged
argument_list|)
expr_stmt|;
name|channel_bounds
argument_list|(
name|mask
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
comment|/*  make sure we handle the mask correctly if it was sample-merged  */
if|if
condition|(
name|sample_merged
condition|)
block|{
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  Limit the channel bounds to the drawable's extents  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x1
argument_list|,
name|off_x
argument_list|,
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|drawable
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y1
argument_list|,
name|off_y
argument_list|,
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|drawable
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x2
argument_list|,
name|off_x
argument_list|,
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|drawable
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y2
argument_list|,
name|off_y
argument_list|,
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|drawable
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  translate mask bounds to drawable coords  */
name|x1
operator|-=
name|off_x
expr_stmt|;
name|y1
operator|-=
name|off_y
expr_stmt|;
name|x2
operator|-=
name|off_x
expr_stmt|;
name|y2
operator|-=
name|off_y
expr_stmt|;
block|}
else|else
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  if the gimage doesn't have an alpha channel,        *  make sure that the temp buf does.  We need the        *  alpha channel to fill with the region calculated above        */
if|if
condition|(
operator|!
name|has_alpha
condition|)
block|{
name|bytes
operator|++
expr_stmt|;
name|has_alpha
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|buf_tiles
operator|=
name|tile_manager_new
argument_list|(
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|bufPR
argument_list|,
name|buf_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|bucket_fill_region
argument_list|(
name|fill_mode
argument_list|,
operator|&
name|bufPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|col
argument_list|,
name|pat_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
else|else
name|bucket_fill_region
argument_list|(
name|fill_mode
argument_list|,
operator|&
name|bufPR
argument_list|,
name|NULL
argument_list|,
name|col
argument_list|,
name|pat_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|bufPR
argument_list|,
name|buf_tiles
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimage_apply_image
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|bufPR
argument_list|,
name|TRUE
argument_list|,
operator|(
name|opacity
operator|*
literal|255
operator|)
operator|/
literal|100
argument_list|,
name|paint_mode
argument_list|,
name|NULL
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
comment|/*  update the image  */
name|drawable_update
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
comment|/*  free the temporary buffer  */
name|tile_manager_destroy
argument_list|(
name|buf_tiles
argument_list|)
expr_stmt|;
comment|/*  free the mask  */
if|if
condition|(
name|mask
condition|)
name|channel_delete
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
condition|)
name|temp_buf_free
argument_list|(
name|pat_buf
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bucket_fill_line_color (buf,mask,col,has_alpha,bytes,width)
name|bucket_fill_line_color
parameter_list|(
name|buf
parameter_list|,
name|mask
parameter_list|,
name|col
parameter_list|,
name|has_alpha
parameter_list|,
name|bytes
parameter_list|,
name|width
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|has_alpha
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|alpha
operator|=
operator|(
name|has_alpha
operator|)
condition|?
name|bytes
operator|-
literal|1
else|:
name|bytes
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|buf
index|[
name|b
index|]
operator|=
name|col
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
name|mask
condition|)
name|buf
index|[
name|alpha
index|]
operator|=
operator|*
name|mask
operator|++
expr_stmt|;
else|else
name|buf
index|[
name|alpha
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
block|}
name|buf
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
DECL|function|bucket_fill_line_pattern (buf,mask,pattern,has_alpha,bytes,x,y,width)
name|bucket_fill_line_pattern
parameter_list|(
name|buf
parameter_list|,
name|mask
parameter_list|,
name|pattern
parameter_list|,
name|has_alpha
parameter_list|,
name|bytes
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|width
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|TempBuf
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|has_alpha
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|pat
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  Get a pointer to the appropriate scanline of the pattern buffer  */
name|pat
operator|=
name|temp_buf_data
argument_list|(
name|pattern
argument_list|)
operator|+
operator|(
name|y
operator|%
name|pattern
operator|->
name|height
operator|)
operator|*
name|pattern
operator|->
name|width
operator|*
name|pattern
operator|->
name|bytes
expr_stmt|;
name|alpha
operator|=
operator|(
name|has_alpha
operator|)
condition|?
name|bytes
operator|-
literal|1
else|:
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|pat
operator|+
operator|(
operator|(
name|i
operator|+
name|x
operator|)
operator|%
name|pattern
operator|->
name|width
operator|)
operator|*
name|pattern
operator|->
name|bytes
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|buf
index|[
name|b
index|]
operator|=
name|p
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
if|if
condition|(
name|mask
condition|)
name|buf
index|[
name|alpha
index|]
operator|=
operator|*
name|mask
operator|++
expr_stmt|;
else|else
name|buf
index|[
name|alpha
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
block|}
name|buf
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
DECL|function|bucket_fill_region (fill_mode,bufPR,maskPR,col,pattern,off_x,off_y,has_alpha)
name|bucket_fill_region
parameter_list|(
name|fill_mode
parameter_list|,
name|bufPR
parameter_list|,
name|maskPR
parameter_list|,
name|col
parameter_list|,
name|pattern
parameter_list|,
name|off_x
parameter_list|,
name|off_y
parameter_list|,
name|has_alpha
parameter_list|)
name|FillMode
name|fill_mode
decl_stmt|;
name|PixelRegion
modifier|*
name|bufPR
decl_stmt|;
name|PixelRegion
modifier|*
name|maskPR
decl_stmt|;
name|unsigned
name|char
modifier|*
name|col
decl_stmt|;
name|TempBuf
modifier|*
name|pattern
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|has_alpha
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|y
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|bufPR
argument_list|,
name|maskPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|bufPR
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|maskPR
condition|)
name|m
operator|=
name|maskPR
operator|->
name|data
expr_stmt|;
else|else
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|bufPR
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
switch|switch
condition|(
name|fill_mode
condition|)
block|{
case|case
name|FgColorFill
case|:
case|case
name|BgColorFill
case|:
name|bucket_fill_line_color
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|col
argument_list|,
name|has_alpha
argument_list|,
name|bufPR
operator|->
name|bytes
argument_list|,
name|bufPR
operator|->
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|PatternFill
case|:
name|bucket_fill_line_pattern
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|pattern
argument_list|,
name|has_alpha
argument_list|,
name|bufPR
operator|->
name|bytes
argument_list|,
name|off_x
operator|+
name|bufPR
operator|->
name|x
argument_list|,
name|off_y
operator|+
name|y
operator|+
name|bufPR
operator|->
name|y
argument_list|,
name|bufPR
operator|->
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|+=
name|bufPR
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|maskPR
condition|)
name|m
operator|+=
name|maskPR
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  Global bucket fill functions */
end_comment

begin_comment
comment|/*********************************/
end_comment

begin_function
name|Tool
modifier|*
DECL|function|tools_new_bucket_fill ()
name|tools_new_bucket_fill
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BucketTool
modifier|*
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|bucket_options
condition|)
name|bucket_options
operator|=
name|create_bucket_options
argument_list|()
expr_stmt|;
name|tool
operator|=
operator|(
name|Tool
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
name|BucketTool
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketTool
argument_list|)
argument_list|)
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|BUCKET_FILL
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|1
expr_stmt|;
comment|/*  Disallow scrolling  */
name|tool
operator|->
name|auto_snap_to
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|private
operator|=
name|private
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|bucket_fill_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|bucket_fill_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|bucket_fill_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|bucket_fill_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|bucket_fill_control
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|TRUE
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_bucket_fill (tool)
name|tools_free_bucket_fill
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|BucketTool
modifier|*
name|bucket_tool
decl_stmt|;
name|bucket_tool
operator|=
operator|(
name|BucketTool
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|g_free
argument_list|(
name|bucket_tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  The bucket fill procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|bucket_fill_args
name|ProcArg
name|bucket_fill_args
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"fill_mode"
block|,
literal|"the type of fill: { FG-BUCKET-FILL (0), BG-BUCKET-FILL (1), PATTERN-BUCKET-FILL (2) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"paint_mode"
block|,
literal|"the paint application mode: { NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY/BURN (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14), DIVIDE/DODGE (15) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"the opacity of the final bucket fill (0<= opacity<= 100)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"threshold"
block|,
literal|"the threshold determines how extensive the seed fill will be.  It's value is specified in terms of intensity levels (0<= threshold<= 255).  This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"use the composite image, not the drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"the x coordinate of this bucket fill's application.  This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"the y coordinate of this bucket fill's application.  This parameter is only valid when there is no selection in the specified image."
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bucket_fill_proc
name|ProcRecord
name|bucket_fill_proc
init|=
block|{
literal|"gimp_bucket_fill"
block|,
literal|"Fill the area specified either by the current selection if there is one, or by a seed fill starting at the specified coordinates."
block|,
literal|"This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern.  If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter.  If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused.  If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable.  This is equivalent to sampling for colors after merging all visible layers.  In the case of merged sampling, the x,y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|8
block|,
name|bucket_fill_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|bucket_fill_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|bucket_fill_invoker (args)
name|bucket_fill_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|FillMode
name|fill_mode
decl_stmt|;
name|int
name|paint_mode
decl_stmt|;
name|double
name|opacity
decl_stmt|;
name|double
name|threshold
decl_stmt|;
name|int
name|sample_merged
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|double
name|fp_value
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|fill_mode
operator|=
name|BgColorFill
expr_stmt|;
name|paint_mode
operator|=
name|NORMAL_MODE
expr_stmt|;
name|opacity
operator|=
literal|100.0
expr_stmt|;
name|threshold
operator|=
literal|0.0
expr_stmt|;
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
comment|/*  fill mode  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|fill_mode
operator|=
name|FgColorFill
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fill_mode
operator|=
name|BgColorFill
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fill_mode
operator|=
name|PatternFill
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/*  paint mode  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>=
name|NORMAL_MODE
operator|&&
name|int_value
operator|<=
name|VALUE_MODE
condition|)
name|paint_mode
operator|=
name|int_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  opacity  */
if|if
condition|(
name|success
condition|)
block|{
name|fp_value
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|fp_value
operator|>=
literal|0.0
operator|&&
name|fp_value
operator|<=
literal|100.0
condition|)
name|opacity
operator|=
name|fp_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  threshold  */
if|if
condition|(
name|success
condition|)
block|{
name|fp_value
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|fp_value
operator|>=
literal|0.0
operator|&&
name|fp_value
operator|<=
literal|255.0
condition|)
name|threshold
operator|=
name|fp_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  sample_merged  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|sample_merged
operator|=
operator|(
name|int_value
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
comment|/*  x, y  */
if|if
condition|(
name|success
condition|)
block|{
name|x
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
block|}
comment|/*  call the blend procedure  */
if|if
condition|(
name|success
condition|)
block|{
name|bucket_fill
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|fill_mode
argument_list|,
name|paint_mode
argument_list|,
name|opacity
argument_list|,
name|threshold
argument_list|,
name|sample_merged
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|bucket_fill_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

end_unit

