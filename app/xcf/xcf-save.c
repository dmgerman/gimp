begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"core/core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager-private.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontainer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpgrid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpguide.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-grid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-guides.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-sample-points.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpparasitelist.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpsamplepoint.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpunit.h"
end_include

begin_include
include|#
directive|include
file|"text/gimptextlayer.h"
end_include

begin_include
include|#
directive|include
file|"text/gimptextlayer-xcf.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpanchor.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpbezierstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors-compat.h"
end_include

begin_include
include|#
directive|include
file|"xcf-private.h"
end_include

begin_include
include|#
directive|include
file|"xcf-read.h"
end_include

begin_include
include|#
directive|include
file|"xcf-save.h"
end_include

begin_include
include|#
directive|include
file|"xcf-seek.h"
end_include

begin_include
include|#
directive|include
file|"xcf-write.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|guchar
modifier|*
name|rlebuf
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_parasite_list
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpParasiteList
modifier|*
name|parasite
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_old_paths
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_save_vectors
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* private convenience macros */
end_comment

begin_define
DECL|macro|xcf_write_int32_check_error (info,data,count)
define|#
directive|define
name|xcf_write_int32_check_error
parameter_list|(
name|info
parameter_list|,
name|data
parameter_list|,
name|count
parameter_list|)
value|G_STMT_START { \   info->cp += xcf_write_int32 (info->fp, data, count,&tmp_error); \   if (tmp_error)                                                   \     {                                                              \       g_propagate_error (error, tmp_error);                        \       return FALSE;                                                \     }                                                              \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_write_int8_check_error (info,data,count)
define|#
directive|define
name|xcf_write_int8_check_error
parameter_list|(
name|info
parameter_list|,
name|data
parameter_list|,
name|count
parameter_list|)
value|G_STMT_START { \   info->cp += xcf_write_int8 (info->fp, data, count,&tmp_error); \   if (tmp_error)                                                  \     {                                                             \       g_propagate_error (error, tmp_error);                       \       return FALSE;                                               \     }                                                             \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_write_float_check_error (info,data,count)
define|#
directive|define
name|xcf_write_float_check_error
parameter_list|(
name|info
parameter_list|,
name|data
parameter_list|,
name|count
parameter_list|)
value|G_STMT_START { \   info->cp += xcf_write_float (info->fp, data, count,&tmp_error); \   if (tmp_error)                                                   \     {                                                              \       g_propagate_error (error, tmp_error);                        \       return FALSE;                                                \     }                                                              \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_write_string_check_error (info,data,count)
define|#
directive|define
name|xcf_write_string_check_error
parameter_list|(
name|info
parameter_list|,
name|data
parameter_list|,
name|count
parameter_list|)
value|G_STMT_START { \   info->cp += xcf_write_string (info->fp, data, count,&tmp_error); \   if (tmp_error)                                                    \     {                                                               \       g_propagate_error (error, tmp_error);                         \       return FALSE;                                                 \     }                                                               \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_write_prop_type_check_error (info,prop_type)
define|#
directive|define
name|xcf_write_prop_type_check_error
parameter_list|(
name|info
parameter_list|,
name|prop_type
parameter_list|)
value|G_STMT_START { \   guint32 _prop_int32 = prop_type;                     \   xcf_write_int32_check_error (info,&_prop_int32, 1); \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_check_error (x)
define|#
directive|define
name|xcf_check_error
parameter_list|(
name|x
parameter_list|)
value|G_STMT_START { \   if (! (x))                                                  \     return FALSE;                                             \   } G_STMT_END
end_define

begin_define
DECL|macro|xcf_progress_update (info)
define|#
directive|define
name|xcf_progress_update
parameter_list|(
name|info
parameter_list|)
value|G_STMT_START  \   {                                             \     progress++;                                 \     if (info->progress)                         \       gimp_progress_set_value (info->progress,  \                                (gdouble) progress / (gdouble) max_progress); \   } G_STMT_END
end_define

begin_function
name|void
DECL|function|xcf_save_choose_format (XcfInfo * info,GimpImage * image)
name|xcf_save_choose_format
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|gint
name|save_version
init|=
literal|0
decl_stmt|;
comment|/* default to oldest */
if|if
condition|(
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|)
condition|)
name|save_version
operator|=
literal|1
expr_stmt|;
comment|/* need version 1 for colormaps */
for|for
control|(
name|list
operator|=
name|gimp_image_get_layer_iter
argument_list|(
name|image
argument_list|)
init|;
name|list
operator|&&
name|save_version
operator|<
literal|2
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|GIMP_LAYER
argument_list|(
name|list
operator|->
name|data
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|gimp_layer_get_mode
argument_list|(
name|layer
argument_list|)
condition|)
block|{
comment|/* new layer modes not supported by gimp-1.2 */
case|case
name|GIMP_SOFTLIGHT_MODE
case|:
case|case
name|GIMP_GRAIN_EXTRACT_MODE
case|:
case|case
name|GIMP_GRAIN_MERGE_MODE
case|:
case|case
name|GIMP_COLOR_ERASE_MODE
case|:
name|save_version
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|info
operator|->
name|file_version
operator|=
name|save_version
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|xcf_save_image (XcfInfo * info,GimpImage * image,GError ** error)
name|xcf_save_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GList
modifier|*
name|all_layers
decl_stmt|;
name|GList
modifier|*
name|all_channels
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|value
decl_stmt|;
name|guint
name|n_layers
decl_stmt|;
name|guint
name|n_channels
decl_stmt|;
name|guint
name|progress
init|=
literal|0
decl_stmt|;
name|guint
name|max_progress
decl_stmt|;
name|gint
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|gchar
name|version_tag
index|[
literal|16
index|]
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
comment|/* write out the tag information for the image */
if|if
condition|(
name|info
operator|->
name|file_version
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf v%03d"
argument_list|,
name|info
operator|->
name|file_version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf file"
argument_list|)
expr_stmt|;
block|}
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|version_tag
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* write out the width, height and image type information for the image */
name|value
operator|=
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_image_base_type
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* determine the number of layers and channels in the image */
name|all_layers
operator|=
name|gimp_image_get_layer_list
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|all_channels
operator|=
name|gimp_image_get_channel_list
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/* check and see if we have to save out the selection */
if|if
condition|(
name|gimp_channel_bounds
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t3
argument_list|,
operator|&
name|t4
argument_list|)
condition|)
block|{
name|all_channels
operator|=
name|g_list_append
argument_list|(
name|all_channels
argument_list|,
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n_layers
operator|=
operator|(
name|guint
operator|)
name|g_list_length
argument_list|(
name|all_layers
argument_list|)
expr_stmt|;
name|n_channels
operator|=
operator|(
name|guint
operator|)
name|g_list_length
argument_list|(
name|all_channels
argument_list|)
expr_stmt|;
name|max_progress
operator|=
literal|1
operator|+
name|n_layers
operator|+
name|n_channels
expr_stmt|;
comment|/* write the property information for the image.    */
name|xcf_check_error
argument_list|(
name|xcf_save_image_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* save the current file position as it is the start of where    *  we place the layer offset information.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to after the offset lists */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|n_layers
operator|+
name|n_channels
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|all_layers
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|list
operator|->
name|data
decl_stmt|;
comment|/* save the start offset of where we are writing        *  out the next layer.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_check_error
argument_list|(
name|xcf_save_layer
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|layer
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  layer offset and write it out.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next layer.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the layer offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|all_channels
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpChannel
modifier|*
name|channel
init|=
name|list
operator|->
name|data
decl_stmt|;
comment|/* save the start offset of where we are writing        *  out the next channel.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_check_error
argument_list|(
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|channel
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  channel offset and write it out.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next channel.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_list_free
argument_list|(
name|all_layers
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|all_channels
argument_list|)
expr_stmt|;
comment|/* write out a '0' offset position to indicate the end    *  of the channel offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
return|return
operator|!
name|ferror
argument_list|(
name|info
operator|->
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_image_props (XcfInfo * info,GimpImage * image,GError ** error)
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|NULL
decl_stmt|;
name|GimpUnit
name|unit
init|=
name|gimp_image_get_unit
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|gdouble
name|xres
decl_stmt|;
name|gdouble
name|yres
decl_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|image
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
comment|/* check and see if we should save the colormap property */
if|if
condition|(
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_COLORMAP
argument_list|,
name|error
argument_list|,
name|gimp_image_get_colormap_size
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|compression
operator|!=
name|COMPRESS_NONE
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_COMPRESSION
argument_list|,
name|error
argument_list|,
name|info
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_image_get_guides
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_GUIDES
argument_list|,
name|error
argument_list|,
name|gimp_image_get_guides
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_image_get_sample_points
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_SAMPLE_POINTS
argument_list|,
name|error
argument_list|,
name|gimp_image_get_sample_points
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_RESOLUTION
argument_list|,
name|error
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_TATTOO
argument_list|,
name|error
argument_list|,
name|gimp_image_get_tattoo_state
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
name|_gimp_unit_get_number_of_built_in_units
argument_list|(
name|image
operator|->
name|gimp
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_UNIT
argument_list|,
name|error
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_container_get_n_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|gimp_vectors_compat_is_compatible
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_PATHS
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_VECTORS
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|>=
name|_gimp_unit_get_number_of_built_in_units
argument_list|(
name|image
operator|->
name|gimp
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_USER_UNIT
argument_list|,
name|error
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_GRID
argument_list|(
name|image
operator|->
name|grid
argument_list|)
condition|)
block|{
name|GimpGrid
modifier|*
name|grid
init|=
name|gimp_image_get_grid
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|parasite
operator|=
name|gimp_grid_to_parasite
argument_list|(
name|grid
argument_list|)
expr_stmt|;
name|gimp_parasite_list_add
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_parasite_list_length
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_PARASITES
argument_list|,
name|error
argument_list|,
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parasite
condition|)
block|{
name|gimp_parasite_list_remove
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
operator|->
name|parasites
argument_list|,
name|gimp_parasite_name
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_END
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_layer_props (XcfInfo * info,GimpImage * image,GimpLayer * layer,GError ** error)
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|NULL
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
if|if
condition|(
name|layer
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_ACTIVE_LAYER
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|gimp_image_get_floating_selection
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|info
operator|->
name|floating_sel_drawable
operator|=
name|gimp_layer_get_floating_sel_drawable
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_FLOATING_SELECTION
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_OPACITY
argument_list|,
name|error
argument_list|,
name|gimp_layer_get_opacity
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|error
argument_list|,
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_LINKED
argument_list|,
name|error
argument_list|,
name|gimp_item_get_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_LOCK_CONTENT
argument_list|,
name|error
argument_list|,
name|gimp_item_get_lock_content
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_LOCK_ALPHA
argument_list|,
name|error
argument_list|,
name|gimp_layer_get_lock_alpha
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_layer_get_mask
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|layer
argument_list|)
decl_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
name|error
argument_list|,
name|gimp_layer_mask_get_apply
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
name|error
argument_list|,
name|gimp_layer_mask_get_edit
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
name|error
argument_list|,
name|gimp_layer_mask_get_show
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
name|error
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
name|error
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
name|error
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_item_get_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_OFFSETS
argument_list|,
name|error
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_MODE
argument_list|,
name|error
argument_list|,
name|gimp_layer_get_mode
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_TATTOO
argument_list|,
name|error
argument_list|,
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_IS_TEXT_LAYER
argument_list|(
name|layer
argument_list|)
operator|&&
name|GIMP_TEXT_LAYER
argument_list|(
name|layer
argument_list|)
operator|->
name|text
condition|)
block|{
name|GimpTextLayer
modifier|*
name|text_layer
init|=
name|GIMP_TEXT_LAYER
argument_list|(
name|layer
argument_list|)
decl_stmt|;
name|guint32
name|flags
init|=
name|gimp_text_layer_get_xcf_flags
argument_list|(
name|text_layer
argument_list|)
decl_stmt|;
name|gimp_text_layer_xcf_save_prepare
argument_list|(
name|text_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_TEXT_LAYER_FLAGS
argument_list|,
name|error
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_parasite_list_length
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_PARASITES
argument_list|,
name|error
argument_list|,
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parasite
condition|)
block|{
name|gimp_parasite_list_remove
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|,
name|gimp_parasite_name
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_END
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_channel_props (XcfInfo * info,GimpImage * image,GimpChannel * channel,GError ** error)
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_ACTIVE_CHANNEL
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_SELECTION
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_OPACITY
argument_list|,
name|error
argument_list|,
name|gimp_channel_get_opacity
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|error
argument_list|,
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_LINKED
argument_list|,
name|error
argument_list|,
name|gimp_item_get_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_LOCK_CONTENT
argument_list|,
name|error
argument_list|,
name|gimp_item_get_lock_content
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_SHOW_MASKED
argument_list|,
name|error
argument_list|,
name|gimp_channel_get_show_masked
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|channel
operator|->
name|color
argument_list|,
operator|&
name|col
index|[
literal|0
index|]
argument_list|,
operator|&
name|col
index|[
literal|1
index|]
argument_list|,
operator|&
name|col
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_COLOR
argument_list|,
name|error
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_TATTOO
argument_list|,
name|error
argument_list|,
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_parasite_list_length
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_PARASITES
argument_list|,
name|error
argument_list|,
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|PROP_END
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_prop (XcfInfo * info,GimpImage * image,PropType prop_type,GError ** error,...)
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
modifier|...
parameter_list|)
block|{
name|guint32
name|size
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_COLORMAP
case|:
block|{
name|guint32
name|n_colors
decl_stmt|;
name|guchar
modifier|*
name|colors
decl_stmt|;
name|n_colors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|colors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|+
name|n_colors
operator|*
literal|3
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|n_colors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
name|colors
argument_list|,
name|n_colors
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_ACTIVE_LAYER
case|:
case|case
name|PROP_ACTIVE_CHANNEL
case|:
case|case
name|PROP_SELECTION
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
block|{
name|guint32
name|dummy
decl_stmt|;
name|dummy
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|floating_sel_offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|gdouble
name|opacity
decl_stmt|;
name|guint32
name|uint_opacity
decl_stmt|;
name|opacity
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gdouble
argument_list|)
expr_stmt|;
name|uint_opacity
operator|=
name|opacity
operator|*
literal|255.999
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|uint_opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_MODE
case|:
block|{
name|gint32
name|mode
decl_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|guint32
name|visible
decl_stmt|;
name|visible
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
block|{
name|guint32
name|linked
decl_stmt|;
name|linked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LOCK_CONTENT
case|:
block|{
name|guint32
name|lock_content
decl_stmt|;
name|lock_content
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|lock_content
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LOCK_ALPHA
case|:
block|{
name|guint32
name|lock_alpha
decl_stmt|;
name|lock_alpha
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|lock_alpha
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_APPLY_MASK
case|:
block|{
name|guint32
name|apply_mask
decl_stmt|;
name|apply_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_EDIT_MASK
case|:
block|{
name|guint32
name|edit_mask
decl_stmt|;
name|edit_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASK
case|:
block|{
name|guint32
name|show_mask
decl_stmt|;
name|show_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
block|{
name|guint32
name|show_masked
decl_stmt|;
name|show_masked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OFFSETS
case|:
block|{
name|gint32
name|offsets
index|[
literal|2
index|]
decl_stmt|;
name|offsets
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|offsets
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COLOR
case|:
block|{
name|guchar
modifier|*
name|color
decl_stmt|;
name|color
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
name|color
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|compression
operator|=
operator|(
name|guint8
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|GList
modifier|*
name|guides
decl_stmt|;
name|gint
name|n_guides
decl_stmt|;
name|guides
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GList
operator|*
argument_list|)
expr_stmt|;
name|n_guides
operator|=
name|g_list_length
argument_list|(
name|guides
argument_list|)
expr_stmt|;
name|size
operator|=
name|n_guides
operator|*
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|guides
condition|;
name|guides
operator|=
name|g_list_next
argument_list|(
name|guides
argument_list|)
control|)
block|{
name|GimpGuide
modifier|*
name|guide
init|=
name|guides
operator|->
name|data
decl_stmt|;
name|gint32
name|position
init|=
name|gimp_guide_get_position
argument_list|(
name|guide
argument_list|)
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
switch|switch
condition|(
name|gimp_guide_get_orientation
argument_list|(
name|guide
argument_list|)
condition|)
block|{
case|case
name|GIMP_ORIENTATION_HORIZONTAL
case|:
name|orientation
operator|=
name|XCF_ORIENTATION_HORIZONTAL
expr_stmt|;
break|break;
case|case
name|GIMP_ORIENTATION_VERTICAL
case|:
name|orientation
operator|=
name|XCF_ORIENTATION_VERTICAL
expr_stmt|;
break|break;
default|default:
name|g_warning
argument_list|(
literal|"%s: skipping guide with bad orientation"
argument_list|,
name|G_STRFUNC
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_SAMPLE_POINTS
case|:
block|{
name|GList
modifier|*
name|sample_points
decl_stmt|;
name|gint
name|n_sample_points
decl_stmt|;
name|sample_points
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GList
operator|*
argument_list|)
expr_stmt|;
name|n_sample_points
operator|=
name|g_list_length
argument_list|(
name|sample_points
argument_list|)
expr_stmt|;
name|size
operator|=
name|n_sample_points
operator|*
operator|(
literal|4
operator|+
literal|4
operator|)
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sample_points
condition|;
name|sample_points
operator|=
name|g_list_next
argument_list|(
name|sample_points
argument_list|)
control|)
block|{
name|GimpSamplePoint
modifier|*
name|sample_point
init|=
name|sample_points
operator|->
name|data
decl_stmt|;
name|gint32
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|sample_point
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|sample_point
operator|->
name|y
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|gfloat
name|xresolution
decl_stmt|,
name|yresolution
decl_stmt|;
comment|/* we pass in floats,            but they are promoted to double by the compiler */
name|xresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|yresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|*
literal|2
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|xresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|yresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|guint32
name|tattoo
decl_stmt|;
name|tattoo
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|GimpParasiteList
modifier|*
name|list
decl_stmt|;
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|list
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpParasiteList
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_parasite_list_persistent_length
argument_list|(
name|list
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the parasite list will take              * we save the file position and write the length later              */
name|pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_parasite_list
argument_list|(
name|info
argument_list|,
name|list
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_error
condition|)
block|{
name|g_propagate_error
argument_list|(
name|error
argument_list|,
name|tmp_error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_UNIT
case|:
block|{
name|guint32
name|unit
decl_stmt|;
name|unit
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PATHS
case|:
block|{
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|glong
name|pos
decl_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the paths list will take          * we save the file position and write the length later          */
name|pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_old_paths
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_error
condition|)
block|{
name|g_propagate_error
argument_list|(
name|error
argument_list|,
name|tmp_error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_USER_UNIT
case|:
block|{
name|GimpUnit
name|unit
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|unit_strings
index|[
literal|5
index|]
decl_stmt|;
name|gfloat
name|factor
decl_stmt|;
name|guint32
name|digits
decl_stmt|;
name|unit
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
comment|/* write the entire unit definition */
name|unit_strings
index|[
literal|0
index|]
operator|=
name|_gimp_unit_get_identifier
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|factor
operator|=
name|_gimp_unit_get_factor
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|digits
operator|=
name|_gimp_unit_get_digits
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|1
index|]
operator|=
name|_gimp_unit_get_symbol
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|2
index|]
operator|=
name|_gimp_unit_get_abbreviation
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|3
index|]
operator|=
name|_gimp_unit_get_singular
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|4
index|]
operator|=
name|_gimp_unit_get_plural
argument_list|(
name|image
operator|->
name|gimp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|*
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|1
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|1
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|2
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|2
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|3
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|3
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|4
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|4
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|factor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|digits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
name|unit_strings
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VECTORS
case|:
block|{
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|glong
name|pos
decl_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the paths list will take          * we save the file position and write the length later          */
name|pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_vectors
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_error
condition|)
block|{
name|g_propagate_error
argument_list|(
name|error
argument_list|,
name|tmp_error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TEXT_LAYER_FLAGS
case|:
block|{
name|guint32
name|flags
decl_stmt|;
name|flags
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|xcf_write_prop_type_check_error
argument_list|(
name|info
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_layer (XcfInfo * info,GimpImage * image,GimpLayer * layer,GError ** error)
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|value
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|string
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|saved_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width, height and image type information for the layer */
name|value
operator|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the layers name */
name|string
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the layer properties */
name|xcf_save_layer_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|layer
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer tile hierarchy */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|8
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer mask */
if|if
condition|(
name|gimp_layer_get_mask
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|GimpLayerMask
modifier|*
name|mask
init|=
name|gimp_layer_get_mask
argument_list|(
name|layer
argument_list|)
decl_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|mask
argument_list|)
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_channel (XcfInfo * info,GimpImage * image,GimpChannel * channel,GError ** error)
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|value
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|string
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|saved_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width and height information for the channel */
name|value
operator|=
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channels name */
name|string
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channel properties */
name|xcf_save_channel_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
name|channel
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the channel tile hierarchy */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|4
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_calc_levels (gint size,gint tile_size)
name|xcf_calc_levels
parameter_list|(
name|gint
name|size
parameter_list|,
name|gint
name|tile_size
parameter_list|)
block|{
name|int
name|levels
decl_stmt|;
name|levels
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|tile_size
condition|)
block|{
name|size
operator|/=
literal|2
expr_stmt|;
name|levels
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|levels
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_hierarchy (XcfInfo * info,TileManager * tiles,GError ** error)
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|width
decl_stmt|;
name|guint32
name|height
decl_stmt|;
name|guint32
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|nlevels
decl_stmt|;
name|gint
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|tmp1
operator|=
name|xcf_calc_levels
argument_list|(
name|width
argument_list|,
name|TILE_WIDTH
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|xcf_calc_levels
argument_list|(
name|height
argument_list|,
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|MAX
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
literal|1
operator|+
name|nlevels
operator|)
operator|*
literal|4
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* write out the level. */
name|xcf_check_error
argument_list|(
name|xcf_save_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fake an empty level */
name|tmp1
operator|=
literal|0
expr_stmt|;
name|width
operator|/=
literal|2
expr_stmt|;
name|height
operator|/=
literal|2
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tmp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* seek back to where we are to write out the next        *  level offset and write it out.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next level.        */
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_level (XcfInfo * info,TileManager * level,GError ** error)
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|level
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|width
decl_stmt|;
name|guint32
name|height
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guchar
modifier|*
name|rlebuf
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* allocate a temporary buffer to store the rle data before it is      written to disk */
name|rlebuf
operator|=
name|g_malloc
argument_list|(
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
name|tile_manager_bpp
argument_list|(
name|level
argument_list|)
operator|*
literal|1.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|tiles
condition|)
block|{
name|ntiles
operator|=
name|level
operator|->
name|ntile_rows
operator|*
name|level
operator|->
name|ntile_cols
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|ntiles
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
comment|/* save the start offset of where we are writing            *  out the next tile.            */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the tile. */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
name|xcf_check_error
argument_list|(
name|xcf_save_tile
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
name|xcf_check_error
argument_list|(
name|xcf_save_tile_rle
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|,
name|rlebuf
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|g_error
argument_list|(
literal|"xcf: fractal compression unimplemented"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* seek back to where we are to write out the next            *  tile offset and write it out.            */
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the            *  next offset.            */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where            *  we will write out the next tile.            */
name|xcf_check_error
argument_list|(
name|xcf_seek_end
argument_list|(
name|info
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|rlebuf
argument_list|)
expr_stmt|;
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_tile (XcfInfo * info,Tile * tile,GError ** error)
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_tile_rle (XcfInfo * info,Tile * tile,guchar * rlebuf,GError ** error)
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|guchar
modifier|*
name|rlebuf
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|gint
name|len
init|=
literal|0
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|data
init|=
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
decl_stmt|;
name|gint
name|state
init|=
literal|0
decl_stmt|;
name|gint
name|length
init|=
literal|0
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
name|gint
name|size
init|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
decl_stmt|;
name|guint
name|last
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* in state 0 we try to find a long sequence of                *  matching values.                */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
operator|)
condition|)
block|{
name|count
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|127
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|last
expr_stmt|;
block|}
else|else
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|last
expr_stmt|;
block|}
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* in state 1 we try and find a long sequence of                *  non-matching values.                */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|last
operator|==
operator|*
name|data
operator|)
operator|&&
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|==
literal|1
operator|||
name|last
operator|==
name|data
index|[
name|bpp
index|]
operator|)
operator|)
condition|)
block|{
specifier|const
name|guchar
modifier|*
name|t
decl_stmt|;
name|count
operator|+=
name|length
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|255
operator|-
literal|127
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
block|}
else|else
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|t
operator|=
name|data
operator|-
name|length
operator|*
name|bpp
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|+=
name|bpp
expr_stmt|;
block|}
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|length
operator|+=
literal|1
expr_stmt|;
name|last
operator|=
operator|*
name|data
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
operator|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
condition|)
name|g_message
argument_list|(
literal|"xcf: uh oh! xcf rle tile saving error: %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
name|rlebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_parasite (XcfInfo * info,GimpParasite * parasite,GError ** error)
name|xcf_save_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|gimp_parasite_is_persistent
argument_list|(
name|parasite
argument_list|)
condition|)
block|{
name|guint32
name|value
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|string
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
name|string
operator|=
name|gimp_parasite_name
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_parasite_flags
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29229c750108
block|{
DECL|member|info
name|XcfInfo
modifier|*
name|info
decl_stmt|;
DECL|member|error
name|GError
modifier|*
name|error
decl_stmt|;
DECL|typedef|XcfParasiteData
block|}
name|XcfParasiteData
typedef|;
end_typedef

begin_function
specifier|static
name|void
DECL|function|xcf_save_parasite_func (gchar * key,GimpParasite * parasite,XcfParasiteData * data)
name|xcf_save_parasite_func
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|,
name|XcfParasiteData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
operator|->
name|error
condition|)
name|xcf_save_parasite
argument_list|(
name|data
operator|->
name|info
argument_list|,
name|parasite
argument_list|,
operator|&
name|data
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_parasite_list (XcfInfo * info,GimpParasiteList * list,GError ** error)
name|xcf_save_parasite_list
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpParasiteList
modifier|*
name|list
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XcfParasiteData
name|data
decl_stmt|;
name|data
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|data
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|gimp_parasite_list_foreach
argument_list|(
name|list
argument_list|,
operator|(
name|GHFunc
operator|)
name|xcf_save_parasite_func
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|error
condition|)
block|{
name|g_propagate_error
argument_list|(
name|error
argument_list|,
name|data
operator|.
name|error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_old_paths (XcfInfo * info,GimpImage * image,GError ** error)
name|xcf_save_old_paths
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|guint32
name|num_paths
decl_stmt|;
name|guint32
name|active_index
init|=
literal|0
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
comment|/* Write out the following:-    *    * last_selected_row (gint)    * number_of_paths (gint)    *    * then each path:-    */
name|num_paths
operator|=
name|gimp_container_get_n_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|active_vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vectors
condition|)
name|active_index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_vectors
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|active_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|gimp_image_get_vectors_iter
argument_list|(
name|image
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpVectors
modifier|*
name|vectors
init|=
name|list
operator|->
name|data
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|guint32
name|locked
decl_stmt|;
name|guint8
name|state
decl_stmt|;
name|guint32
name|version
decl_stmt|;
name|guint32
name|pathtype
decl_stmt|;
name|guint32
name|tattoo
decl_stmt|;
name|GimpVectorsCompatPoint
modifier|*
name|points
decl_stmt|;
name|guint32
name|num_points
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*        * name (string)        * locked (gint)        * state (gchar)        * closed (gint)        * number points (gint)        * version (gint)        * pathtype (gint)        * tattoo (gint)        * then each point.        */
name|points
operator|=
name|gimp_vectors_compat_get_points
argument_list|(
name|vectors
argument_list|,
operator|(
name|gint32
operator|*
operator|)
operator|&
name|num_points
argument_list|,
operator|(
name|gint32
operator|*
operator|)
operator|&
name|closed
argument_list|)
expr_stmt|;
comment|/* if no points are generated because of a faulty path we should        * skip saving the path - this is unfortunately impossible, because        * we already saved the number of paths and I wont start seeking        * around to fix that cruft  */
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|locked
operator|=
name|gimp_item_get_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|closed
condition|?
literal|4
else|:
literal|2
expr_stmt|;
comment|/* EDIT : ADD  (editing state, 1.2 compat) */
name|version
operator|=
literal|3
expr_stmt|;
name|pathtype
operator|=
literal|1
expr_stmt|;
comment|/* BEZIER  (1.2 compat) */
name|tattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int8_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|pathtype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
control|)
block|{
name|gfloat
name|x
decl_stmt|;
name|gfloat
name|y
decl_stmt|;
name|x
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|y
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
comment|/*            * type (gint)            * x (gfloat)            * y (gfloat)            */
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|points
index|[
name|i
index|]
operator|.
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_save_vectors (XcfInfo * info,GimpImage * image,GError ** error)
name|xcf_save_vectors
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|guint32
name|version
init|=
literal|1
decl_stmt|;
name|guint32
name|active_index
init|=
literal|0
decl_stmt|;
name|guint32
name|num_paths
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|stroke_list
decl_stmt|;
name|GError
modifier|*
name|tmp_error
init|=
name|NULL
decl_stmt|;
comment|/* Write out the following:-    *    * version (gint)    * active_index (gint)    * num_paths (gint)    *    * then each path:-    */
name|active_vectors
operator|=
name|gimp_image_get_active_vectors
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vectors
condition|)
name|active_index
operator|=
name|gimp_container_get_child_index
argument_list|(
name|image
operator|->
name|vectors
argument_list|,
name|GIMP_OBJECT
argument_list|(
name|active_vectors
argument_list|)
argument_list|)
expr_stmt|;
name|num_paths
operator|=
name|gimp_container_get_n_children
argument_list|(
name|image
operator|->
name|vectors
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|active_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|gimp_image_get_vectors_iter
argument_list|(
name|image
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpVectors
modifier|*
name|vectors
init|=
name|list
operator|->
name|data
decl_stmt|;
name|GimpParasiteList
modifier|*
name|parasites
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
name|guint32
name|tattoo
decl_stmt|;
name|guint32
name|visible
decl_stmt|;
name|guint32
name|linked
decl_stmt|;
name|guint32
name|num_parasites
decl_stmt|;
name|guint32
name|num_strokes
decl_stmt|;
comment|/*        * name (string)        * tattoo (gint)        * visible (gint)        * linked (gint)        * num_parasites (gint)        * num_strokes (gint)        *        * then each parasite        * then each stroke        */
name|parasites
operator|=
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
operator|->
name|parasites
expr_stmt|;
name|name
operator|=
name|gimp_object_get_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|visible
operator|=
name|gimp_item_get_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|linked
operator|=
name|gimp_item_get_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|tattoo
operator|=
name|gimp_item_get_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|)
expr_stmt|;
name|num_parasites
operator|=
name|gimp_parasite_list_persistent_length
argument_list|(
name|parasites
argument_list|)
expr_stmt|;
name|num_strokes
operator|=
name|g_list_length
argument_list|(
name|vectors
operator|->
name|strokes
argument_list|)
expr_stmt|;
name|xcf_write_string_check_error
argument_list|(
name|info
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_parasites
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_strokes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_check_error
argument_list|(
name|xcf_save_parasite_list
argument_list|(
name|info
argument_list|,
name|parasites
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|stroke_list
operator|=
name|g_list_first
argument_list|(
name|vectors
operator|->
name|strokes
argument_list|)
init|;
name|stroke_list
condition|;
name|stroke_list
operator|=
name|g_list_next
argument_list|(
name|stroke_list
argument_list|)
control|)
block|{
name|GimpStroke
modifier|*
name|stroke
init|=
name|stroke_list
operator|->
name|data
decl_stmt|;
name|guint32
name|stroke_type
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|guint32
name|num_axes
decl_stmt|;
name|GArray
modifier|*
name|control_points
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guint32
name|type
decl_stmt|;
name|gfloat
name|coords
index|[
literal|6
index|]
decl_stmt|;
comment|/*            * stroke_type (gint)            * closed (gint)            * num_axes (gint)            * num_control_points (gint)            *            * then each control point.            */
if|if
condition|(
name|GIMP_IS_BEZIER_STROKE
argument_list|(
name|stroke
argument_list|)
condition|)
block|{
name|stroke_type
operator|=
name|XCF_STROKETYPE_BEZIER_STROKE
expr_stmt|;
name|num_axes
operator|=
literal|2
expr_stmt|;
comment|/* hardcoded, might be increased later */
block|}
else|else
block|{
name|g_printerr
argument_list|(
literal|"Skipping unknown stroke type!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|control_points
operator|=
name|gimp_stroke_control_points_get
argument_list|(
name|stroke
argument_list|,
operator|(
name|gint32
operator|*
operator|)
operator|&
name|closed
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|stroke_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|num_axes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|control_points
operator|->
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|control_points
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|GimpAnchor
modifier|*
name|anchor
decl_stmt|;
name|anchor
operator|=
operator|&
operator|(
name|g_array_index
argument_list|(
name|control_points
argument_list|,
name|GimpAnchor
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|anchor
operator|->
name|type
expr_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|x
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|y
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|pressure
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|xtilt
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|ytilt
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|anchor
operator|->
name|position
operator|.
name|wheel
expr_stmt|;
comment|/*                * type (gint)                *                * the first num_axis elements of:                * [0] x (gfloat)                * [1] y (gfloat)                * [2] pressure (gfloat)                * [3] xtilt (gfloat)                * [4] ytilt (gfloat)                * [5] wheel (gfloat)                */
name|xcf_write_int32_check_error
argument_list|(
name|info
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_write_float_check_error
argument_list|(
name|info
argument_list|,
name|coords
argument_list|,
name|num_axes
argument_list|)
expr_stmt|;
block|}
name|g_array_free
argument_list|(
name|control_points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

