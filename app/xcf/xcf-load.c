begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpbase.h"
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"core/core-types.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager-private.h"
end_include

begin_include
include|#
directive|include
file|"config/gimpcoreconfig.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontainer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable-private.h"
end_include

begin_comment
comment|/* eek */
end_comment

begin_include
include|#
directive|include
file|"core/gimpgrid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpgrouplayer.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-colormap.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-grid.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-guides.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-private.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-sample-points.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-undo.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpitemstack.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayer-floating-sel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpparasitelist.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpprogress.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpselection.h"
end_include

begin_include
include|#
directive|include
file|"core/gimptemplate.h"
end_include

begin_include
include|#
directive|include
file|"text/gimptextlayer.h"
end_include

begin_include
include|#
directive|include
file|"text/gimptextlayer-xcf.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpanchor.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpbezierstroke.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors-compat.h"
end_include

begin_include
include|#
directive|include
file|"xcf-private.h"
end_include

begin_include
include|#
directive|include
file|"xcf-load.h"
end_include

begin_include
include|#
directive|include
file|"xcf-read.h"
end_include

begin_include
include|#
directive|include
file|"xcf-seek.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_comment
comment|/* #define GIMP_XCF_PATH_DEBUG */
end_comment

begin_function_decl
specifier|static
name|void
name|xcf_load_add_masks
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
modifier|*
name|layer
parameter_list|,
name|GList
modifier|*
modifier|*
name|item_path
parameter_list|,
name|gboolean
modifier|*
name|apply_mask
parameter_list|,
name|gboolean
modifier|*
name|edit_mask
parameter_list|,
name|gboolean
modifier|*
name|show_mask
parameter_list|,
name|guint32
modifier|*
name|text_layer_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpLayer
modifier|*
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GList
modifier|*
modifier|*
name|item_path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpChannel
modifier|*
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpLayerMask
modifier|*
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|data_length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpParasite
modifier|*
name|xcf_load_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_old_paths
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_old_path
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_vectors
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_vector
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_skip_unknown_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|gsize
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|xcf_progress_update (info)
define|#
directive|define
name|xcf_progress_update
parameter_list|(
name|info
parameter_list|)
value|G_STMT_START  \   {                                             \     if (info->progress)                         \       gimp_progress_pulse (info->progress);     \   } G_STMT_END
end_define

begin_function
name|GimpImage
modifier|*
DECL|function|xcf_load_image (Gimp * gimp,XcfInfo * info,GError ** error)
name|xcf_load_image
parameter_list|(
name|Gimp
modifier|*
name|gimp
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpImage
modifier|*
name|image
decl_stmt|;
specifier|const
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|image_type
decl_stmt|;
name|gint
name|num_successful_elements
init|=
literal|0
decl_stmt|;
comment|/* read in the image width, height and type */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|image_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_create_image
argument_list|(
name|gimp
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|image_type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_image_undo_disable
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* read the image properties */
if|if
condition|(
operator|!
name|xcf_load_image_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
condition|)
goto|goto
name|hard_error
goto|;
comment|/* check for a GimpGrid parasite */
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_grid_parasite_name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|GimpGrid
modifier|*
name|grid
init|=
name|gimp_grid_from_parasite
argument_list|(
name|parasite
argument_list|)
decl_stmt|;
if|if
condition|(
name|grid
condition|)
block|{
name|GimpImagePrivate
modifier|*
name|private
init|=
name|GIMP_IMAGE_GET_PRIVATE
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|gimp_parasite_list_remove
argument_list|(
name|private
operator|->
name|parasites
argument_list|,
name|gimp_parasite_name
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_set_grid
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|grid
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|grid
argument_list|)
expr_stmt|;
block|}
block|}
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GList
modifier|*
name|item_path
init|=
name|NULL
decl_stmt|;
comment|/* read in the offset of the next layer */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the layer list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next layer offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the layer offset */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read in the layer */
name|layer
operator|=
name|xcf_load_layer
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
operator|&
name|item_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
goto|goto
name|error
goto|;
name|num_successful_elements
operator|++
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* add the layer to the image if its not the floating selection */
if|if
condition|(
name|layer
operator|!=
name|info
operator|->
name|floating_sel
condition|)
block|{
name|GimpContainer
modifier|*
name|layers
init|=
name|gimp_image_get_layers
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|GimpContainer
modifier|*
name|container
decl_stmt|;
name|GimpLayer
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|item_path
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|floating_sel
condition|)
block|{
comment|/* there is a floating selection, but it will get                    * added after all layers are loaded, so toplevel                    * layer indices are off-by-one. Adjust item paths                    * accordingly:                    */
name|gint
name|toplevel_index
decl_stmt|;
name|toplevel_index
operator|=
name|GPOINTER_TO_UINT
argument_list|(
name|item_path
operator|->
name|data
argument_list|)
expr_stmt|;
name|toplevel_index
operator|--
expr_stmt|;
name|item_path
operator|->
name|data
operator|=
name|GUINT_TO_POINTER
argument_list|(
name|toplevel_index
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|GIMP_LAYER
argument_list|(
name|gimp_item_stack_get_parent_by_path
argument_list|(
name|GIMP_ITEM_STACK
argument_list|(
name|layers
argument_list|)
argument_list|,
name|item_path
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|container
operator|=
name|gimp_viewable_get_children
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|=
name|NULL
expr_stmt|;
name|container
operator|=
name|layers
expr_stmt|;
block|}
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|parent
argument_list|,
name|gimp_container_get_n_children
argument_list|(
name|container
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
comment|/* read in the offset of the next channel */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the channel list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next channel offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the channel offset */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read in the channel */
name|channel
operator|=
name|xcf_load_channel
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
goto|goto
name|error
goto|;
name|num_successful_elements
operator|++
expr_stmt|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* add the channel to the image if its not the selection */
if|if
condition|(
name|channel
operator|!=
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
condition|)
name|gimp_image_add_channel
argument_list|(
name|image
argument_list|,
name|channel
argument_list|,
name|NULL
argument_list|,
comment|/* FIXME tree */
name|gimp_container_get_n_children
argument_list|(
name|gimp_image_get_channels
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
name|xcf_load_add_masks
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|floating_sel
operator|&&
name|info
operator|->
name|floating_sel_drawable
condition|)
name|floating_sel_attach
argument_list|(
name|info
operator|->
name|floating_sel
argument_list|,
name|info
operator|->
name|floating_sel_drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|active_layer
condition|)
name|gimp_image_set_active_layer
argument_list|(
name|image
argument_list|,
name|info
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|active_channel
condition|)
name|gimp_image_set_active_channel
argument_list|(
name|image
argument_list|,
name|info
operator|->
name|active_channel
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|tattoo_state
operator|>
literal|0
condition|)
name|gimp_image_set_tattoo_state
argument_list|(
name|image
argument_list|,
name|info
operator|->
name|tattoo_state
argument_list|)
expr_stmt|;
name|gimp_image_undo_enable
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|image
return|;
name|error
label|:
if|if
condition|(
name|num_successful_elements
operator|==
literal|0
condition|)
goto|goto
name|hard_error
goto|;
name|gimp_message_literal
argument_list|(
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
name|_
argument_list|(
literal|"This XCF file is corrupt!  I have loaded as much "
literal|"of it as I can, but it is incomplete."
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_load_add_masks
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_image_undo_enable
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|image
return|;
name|hard_error
label|:
name|g_set_error_literal
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"This XCF file is corrupt!  I could not even "
literal|"salvage any partial image data from it."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_load_add_masks (GimpImage * image)
name|xcf_load_add_masks
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GList
modifier|*
name|layers
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|layers
operator|=
name|gimp_image_get_layer_list
argument_list|(
name|image
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|layers
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpLayer
modifier|*
name|layer
init|=
name|list
operator|->
name|data
decl_stmt|;
name|GimpLayerMask
modifier|*
name|mask
decl_stmt|;
name|mask
operator|=
name|g_object_get_data
argument_list|(
name|G_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|"gimp-layer-mask"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|gimp_layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|"gimp-layer-mask"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|g_list_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_image_props (XcfInfo * info,GimpImage * image)
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_COLORMAP
case|:
block|{
name|guint32
name|n_colors
decl_stmt|;
name|guchar
name|cmap
index|[
name|GIMP_IMAGE_COLORMAP_SIZE
index|]
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|n_colors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_colors
operator|>
operator|(
name|GIMP_IMAGE_COLORMAP_SIZE
operator|/
literal|3
operator|)
condition|)
block|{
name|gimp_message
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_ERROR
argument_list|,
literal|"Maximum colormap size (%d) exceeded"
argument_list|,
name|GIMP_IMAGE_COLORMAP_SIZE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|file_version
operator|==
literal|0
condition|)
block|{
name|gint
name|i
decl_stmt|;
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
name|_
argument_list|(
literal|"XCF warning: version 0 of XCF file format\n"
literal|"did not save indexed colormaps correctly.\n"
literal|"Substituting grayscale map."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
name|n_colors
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_colors
condition|;
name|i
operator|++
control|)
block|{
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|cmap
argument_list|,
name|n_colors
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* only set color map if image is not indexed, this is              * just sanity checking to make sure gimp doesn't end up              * with an image state that is impossible.              */
if|if
condition|(
name|gimp_image_base_type
argument_list|(
name|image
argument_list|)
operator|==
name|GIMP_INDEXED
condition|)
name|gimp_image_set_colormap
argument_list|(
name|image
argument_list|,
name|cmap
argument_list|,
name|n_colors
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compression
operator|!=
name|COMPRESS_NONE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_RLE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_ZLIB
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_FRACTAL
operator|)
condition|)
block|{
name|gimp_message
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_ERROR
argument_list|,
literal|"Unknown compression type: %d"
argument_list|,
operator|(
name|gint
operator|)
name|compression
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|->
name|compression
operator|=
name|compression
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|GimpImagePrivate
modifier|*
name|private
init|=
name|GIMP_IMAGE_GET_PRIVATE
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|nguides
decl_stmt|;
name|nguides
operator|=
name|prop_size
operator|/
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nguides
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  skip -1 guides from old XCFs  */
if|if
condition|(
name|position
operator|<
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|orientation
condition|)
block|{
case|case
name|XCF_ORIENTATION_HORIZONTAL
case|:
name|gimp_image_add_hguide
argument_list|(
name|image
argument_list|,
name|position
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCF_ORIENTATION_VERTICAL
case|:
name|gimp_image_add_vguide
argument_list|(
name|image
argument_list|,
name|position
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Guide orientation out of range in XCF file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/*  this is silly as the order of guides doesn't really matter,              *  but it restores the list to its original order, which              *  cannot be wrong  --Mitch              */
name|private
operator|->
name|guides
operator|=
name|g_list_reverse
argument_list|(
name|private
operator|->
name|guides
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SAMPLE_POINTS
case|:
block|{
name|gint32
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|n_sample_points
decl_stmt|;
name|n_sample_points
operator|=
name|prop_size
operator|/
operator|(
literal|4
operator|+
literal|4
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sample_points
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_image_add_sample_point_at_pos
argument_list|(
name|image
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|gfloat
name|xres
decl_stmt|,
name|yres
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|xres
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|yres
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xres
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xres
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
name|yres
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yres
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
block|{
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Warning, resolution out of range in XCF file"
argument_list|)
expr_stmt|;
name|xres
operator|=
name|image
operator|->
name|gimp
operator|->
name|config
operator|->
name|default_image
operator|->
name|xresolution
expr_stmt|;
name|yres
operator|=
name|image
operator|->
name|gimp
operator|->
name|config
operator|->
name|default_image
operator|->
name|yresolution
expr_stmt|;
block|}
name|gimp_image_set_resolution
argument_list|(
name|image
argument_list|,
name|xres
argument_list|,
name|yres
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|info
operator|->
name|tattoo_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|glong
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|xcf_load_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|image
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Error while loading an image's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_UNIT
case|:
block|{
name|guint32
name|unit
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|<=
name|GIMP_UNIT_PIXEL
operator|)
operator|||
operator|(
name|unit
operator|>=
name|gimp_unit_get_number_of_built_in_units
argument_list|()
operator|)
condition|)
block|{
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Warning, unit out of range in XCF file, "
literal|"falling back to inches"
argument_list|)
expr_stmt|;
name|unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
block|}
name|gimp_image_set_unit
argument_list|(
name|image
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PATHS
case|:
name|xcf_load_old_paths
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_USER_UNIT
case|:
block|{
name|gchar
modifier|*
name|unit_strings
index|[
literal|5
index|]
decl_stmt|;
name|float
name|factor
decl_stmt|;
name|guint32
name|digits
decl_stmt|;
name|GimpUnit
name|unit
decl_stmt|;
name|gint
name|num_units
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|factor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|digits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|unit_strings
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|unit_strings
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|unit_strings
index|[
name|i
index|]
operator|=
name|g_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|num_units
operator|=
name|gimp_unit_get_number_of_units
argument_list|()
expr_stmt|;
for|for
control|(
name|unit
operator|=
name|gimp_unit_get_number_of_built_in_units
argument_list|()
init|;
name|unit
operator|<
name|num_units
condition|;
name|unit
operator|++
control|)
block|{
comment|/* if the factor and the identifier match some unit                  * in unitrc, use the unitrc unit                  */
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|gimp_unit_get_factor
argument_list|(
name|unit
argument_list|)
operator|-
name|factor
argument_list|)
operator|<
literal|1e-5
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|,
name|gimp_unit_get_identifier
argument_list|(
name|unit
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* no match */
if|if
condition|(
name|unit
operator|==
name|num_units
condition|)
name|unit
operator|=
name|gimp_unit_new
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|,
name|factor
argument_list|,
name|digits
argument_list|,
name|unit_strings
index|[
literal|1
index|]
argument_list|,
name|unit_strings
index|[
literal|2
index|]
argument_list|,
name|unit_strings
index|[
literal|3
index|]
argument_list|,
name|unit_strings
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|gimp_image_set_unit
argument_list|(
name|image
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|unit_strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VECTORS
case|:
block|{
name|guint32
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
if|if
condition|(
name|xcf_load_vectors
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
condition|)
block|{
if|if
condition|(
name|base
operator|+
name|prop_size
operator|!=
name|info
operator|->
name|cp
condition|)
block|{
name|g_printerr
argument_list|(
literal|"Mismatch in PROP_VECTORS size: "
literal|"skipping %d bytes.\n"
argument_list|,
name|base
operator|+
name|prop_size
operator|-
name|info
operator|->
name|cp
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|base
operator|+
name|prop_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* skip silently since we don't understand the format and                  * xcf_load_vectors already explained what was wrong                  */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|base
operator|+
name|prop_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
name|g_printerr
argument_list|(
literal|"unexpected/unknown image property: %d (skipping)\n"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|xcf_skip_unknown_prop
argument_list|(
name|info
argument_list|,
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_layer_props (XcfInfo * info,GimpImage * image,GimpLayer ** layer,GList ** item_path,gboolean * apply_mask,gboolean * edit_mask,gboolean * show_mask,guint32 * text_layer_flags)
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpLayer
modifier|*
modifier|*
name|layer
parameter_list|,
name|GList
modifier|*
modifier|*
name|item_path
parameter_list|,
name|gboolean
modifier|*
name|apply_mask
parameter_list|,
name|gboolean
modifier|*
name|edit_mask
parameter_list|,
name|gboolean
modifier|*
name|show_mask
parameter_list|,
name|guint32
modifier|*
name|text_layer_flags
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_LAYER
case|:
name|info
operator|->
name|active_layer
operator|=
operator|*
name|layer
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
name|info
operator|->
name|floating_sel
operator|=
operator|*
name|layer
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|info
operator|->
name|floating_sel_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|guint32
name|opacity
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_layer_set_opacity
argument_list|(
operator|*
name|layer
argument_list|,
operator|(
name|gdouble
operator|)
name|opacity
operator|/
literal|255.0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|gboolean
name|visible
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|visible
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
block|{
name|gboolean
name|linked
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|linked
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LOCK_CONTENT
case|:
block|{
name|gboolean
name|lock_content
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|lock_content
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_item_can_lock_content
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|)
condition|)
name|gimp_item_set_lock_content
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|lock_content
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LOCK_ALPHA
case|:
block|{
name|gboolean
name|lock_alpha
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|lock_alpha
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_layer_can_lock_alpha
argument_list|(
operator|*
name|layer
argument_list|)
condition|)
name|gimp_layer_set_lock_alpha
argument_list|(
operator|*
name|layer
argument_list|,
name|lock_alpha
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_APPLY_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_EDIT_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
block|{
name|guint32
name|offset_x
decl_stmt|;
name|guint32
name|offset_y
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset_x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset_y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_offset
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_MODE
case|:
block|{
name|guint32
name|mode
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_layer_set_mode
argument_list|(
operator|*
name|layer
argument_list|,
operator|(
name|GimpLayerModeEffects
operator|)
name|mode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|GimpTattoo
name|tattoo
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|glong
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|xcf_load_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_item_parasite_attach
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Error while loading a layer's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TEXT_LAYER_FLAGS
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|text_layer_flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_GROUP_ITEM
case|:
block|{
name|GimpLayer
modifier|*
name|group
decl_stmt|;
name|group
operator|=
name|gimp_group_layer_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|group
argument_list|)
argument_list|,
name|gimp_object_get_name
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|group
argument_list|)
operator|->
name|type
operator|=
name|gimp_drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
operator|*
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_ref_sink
argument_list|(
operator|*
name|layer
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
operator|*
name|layer
argument_list|)
expr_stmt|;
operator|*
name|layer
operator|=
name|group
expr_stmt|;
block|}
break|break;
case|case
name|PROP_ITEM_PATH
case|:
block|{
name|glong
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GList
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|guint32
name|index
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|path
operator|=
name|g_list_append
argument_list|(
name|path
argument_list|,
name|GUINT_TO_POINTER
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|item_path
operator|=
name|path
expr_stmt|;
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
name|g_printerr
argument_list|(
literal|"unexpected/unknown layer property: %d (skipping)\n"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|xcf_skip_unknown_prop
argument_list|(
name|info
argument_list|,
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_channel_props (XcfInfo * info,GimpImage * image,GimpChannel ** channel)
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpChannel
modifier|*
modifier|*
name|channel
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_CHANNEL
case|:
name|info
operator|->
name|active_channel
operator|=
operator|*
name|channel
expr_stmt|;
break|break;
case|case
name|PROP_SELECTION
case|:
block|{
name|GimpImagePrivate
modifier|*
name|private
init|=
name|GIMP_IMAGE_GET_PRIVATE
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|g_object_unref
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|private
operator|->
name|selection_mask
operator|=
name|gimp_selection_new
argument_list|(
name|image
argument_list|,
name|gimp_item_get_width
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
argument_list|,
name|gimp_item_get_height
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_ref_sink
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|tile_manager_unref
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
operator|->
name|private
operator|->
name|tiles
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
operator|->
name|private
operator|->
name|tiles
operator|=
name|GIMP_DRAWABLE
argument_list|(
operator|*
name|channel
argument_list|)
operator|->
name|private
operator|->
name|tiles
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
operator|*
name|channel
argument_list|)
operator|->
name|private
operator|->
name|tiles
operator|=
name|NULL
expr_stmt|;
name|g_object_unref
argument_list|(
operator|*
name|channel
argument_list|)
expr_stmt|;
operator|*
name|channel
operator|=
name|mask
expr_stmt|;
operator|(
operator|*
name|channel
operator|)
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|channel
operator|)
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|guint32
name|opacity
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_channel_set_opacity
argument_list|(
operator|*
name|channel
argument_list|,
name|opacity
operator|/
literal|255.0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|gboolean
name|visible
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|,
name|visible
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
block|{
name|gboolean
name|linked
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|,
name|linked
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LOCK_CONTENT
case|:
block|{
name|gboolean
name|lock_content
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|lock_content
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_lock_content
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|,
name|lock_content
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
block|{
name|gboolean
name|show_masked
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_channel_set_show_masked
argument_list|(
operator|*
name|channel
argument_list|,
name|show_masked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COLOR
case|:
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gimp_rgb_set_uchar
argument_list|(
operator|&
operator|(
operator|*
name|channel
operator|)
operator|->
name|color
argument_list|,
name|col
index|[
literal|0
index|]
argument_list|,
name|col
index|[
literal|1
index|]
argument_list|,
name|col
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|GimpTattoo
name|tattoo
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_item_set_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|glong
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|info
operator|->
name|cp
operator|-
name|base
operator|)
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|xcf_load_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_item_parasite_attach
argument_list|(
name|GIMP_ITEM
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Error while loading a channel's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|GIMP_UNSTABLE
name|g_printerr
argument_list|(
literal|"unexpected/unknown channel property: %d (skipping)\n"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|xcf_skip_unknown_prop
argument_list|(
name|info
argument_list|,
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_prop (XcfInfo * info,PropType * prop_type,guint32 * prop_size)
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
block|{
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_type
argument_list|,
literal|1
argument_list|)
operator|!=
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|cp
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_size
argument_list|,
literal|1
argument_list|)
operator|!=
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|cp
operator|+=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|GimpLayer
modifier|*
DECL|function|xcf_load_layer (XcfInfo * info,GimpImage * image,GList ** item_path)
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GList
modifier|*
modifier|*
name|item_path
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|guint32
name|layer_mask_offset
decl_stmt|;
name|gboolean
name|apply_mask
init|=
name|TRUE
decl_stmt|;
name|gboolean
name|edit_mask
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|show_mask
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|active
decl_stmt|;
name|gboolean
name|floating
decl_stmt|;
name|guint32
name|text_layer_flags
init|=
literal|0
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gboolean
name|is_fs_drawable
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment in our caller.    */
name|is_fs_drawable
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height, type and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
literal|255
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
return|return
name|NULL
return|;
comment|/* read in the layer properties */
if|if
condition|(
operator|!
name|xcf_load_layer_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
operator|&
name|layer
argument_list|,
name|item_path
argument_list|,
operator|&
name|apply_mask
argument_list|,
operator|&
name|edit_mask
argument_list|,
operator|&
name|show_mask
argument_list|,
operator|&
name|text_layer_flags
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* call the evil text layer hack that might change our layer pointer */
name|active
operator|=
operator|(
name|info
operator|->
name|active_layer
operator|==
name|layer
operator|)
expr_stmt|;
name|floating
operator|=
operator|(
name|info
operator|->
name|floating_sel
operator|==
name|layer
operator|)
expr_stmt|;
if|if
condition|(
name|gimp_text_layer_xcf_load_hack
argument_list|(
operator|&
name|layer
argument_list|)
condition|)
block|{
name|gimp_text_layer_set_xcf_flags
argument_list|(
name|GIMP_TEXT_LAYER
argument_list|(
name|layer
argument_list|)
argument_list|,
name|text_layer_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|info
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
if|if
condition|(
name|floating
condition|)
name|info
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
block|}
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|layer_mask_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy (ignore it for group layers, both as an    * optimization and because the hierarchy's extents don't match    * the group layer's tiles)    */
if|if
condition|(
operator|!
name|gimp_viewable_get_children
argument_list|(
name|GIMP_VIEWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* read in the layer mask */
if|if
condition|(
name|layer_mask_offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|layer_mask_offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|layer_mask
operator|=
name|xcf_load_layer_mask
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_layer_mask_set_apply
argument_list|(
name|layer_mask
argument_list|,
name|apply_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_layer_mask_set_edit
argument_list|(
name|layer_mask
argument_list|,
name|edit_mask
argument_list|)
expr_stmt|;
name|gimp_layer_mask_set_show
argument_list|(
name|layer_mask
argument_list|,
name|show_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* don't add the layer mask yet, that won't work for group        * layers which update their size automatically; instead        * attach it so it can be added when all layers are loaded        */
name|g_object_set_data_full
argument_list|(
name|G_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|,
literal|"gimp-layer-mask"
argument_list|,
name|g_object_ref
argument_list|(
name|layer_mask
argument_list|)
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_object_unref
argument_list|)
expr_stmt|;
name|g_object_ref_sink
argument_list|(
name|layer_mask
argument_list|)
expr_stmt|;
block|}
comment|/* attach the floating selection... */
if|if
condition|(
name|is_fs_drawable
condition|)
name|info
operator|->
name|floating_sel_drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
name|error
label|:
name|g_object_unref
argument_list|(
name|layer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpChannel
modifier|*
DECL|function|xcf_load_channel (XcfInfo * info,GimpImage * image)
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gboolean
name|is_fs_drawable
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpRGB
name|color
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
name|GIMP_OPACITY_OPAQUE
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment in our caller.    */
name|is_fs_drawable
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new channel */
name|channel
operator|=
name|gimp_channel_new
argument_list|(
name|image
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
return|return
name|NULL
return|;
comment|/* read in the channel properties */
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
operator|&
name|channel
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_fs_drawable
condition|)
name|info
operator|->
name|floating_sel_drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
name|error
label|:
name|g_object_unref
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpLayerMask
modifier|*
DECL|function|xcf_load_layer_mask (XcfInfo * info,GimpImage * image)
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpLayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gboolean
name|is_fs_drawable
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpRGB
name|color
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
name|GIMP_OPACITY_OPAQUE
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment in our caller.    */
name|is_fs_drawable
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer mask */
name|layer_mask
operator|=
name|gimp_layer_mask_new
argument_list|(
name|image
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
return|return
name|NULL
return|;
comment|/* read in the layer_mask properties */
name|channel
operator|=
name|GIMP_CHANNEL
argument_list|(
name|layer_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|image
argument_list|,
operator|&
name|channel
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|xcf_progress_update
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* attach the floating selection... */
if|if
condition|(
name|is_fs_drawable
condition|)
name|info
operator|->
name|floating_sel_drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
expr_stmt|;
return|return
name|layer_mask
return|;
name|error
label|:
name|g_object_unref
argument_list|(
name|layer_mask
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_hierarchy (XcfInfo * info,TileManager * tiles)
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|junk
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure the values in the file correspond to the values    *  calculated when the TileManager was created.    */
if|if
condition|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
operator|||
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
operator|||
name|bpp
operator|!=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* load in the levels...we make sure that the number of levels    *  calculated when the TileManager was created is the same    *  as the number of levels found in the file.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* top level */
comment|/* discard offsets for layers below first, if any.    */
do|do
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|junk
operator|!=
literal|0
condition|)
do|;
comment|/* save the current position as it is where the    *  next level offset is stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the level offset */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* read in the level */
if|if
condition|(
operator|!
name|xcf_load_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* restore the saved position so we'll be ready to    *  read the next offset.    */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_level (XcfInfo * info,TileManager * tiles)
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|fail
decl_stmt|;
name|Tile
modifier|*
name|previous
decl_stmt|;
name|Tile
modifier|*
name|tile
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
operator|||
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* read in the first tile offset.    *  if it is '0', then this tile level is empty    *  and we can simply return.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Initialise the reference for the in-memory tile-compression    */
name|previous
operator|=
name|NULL
expr_stmt|;
name|ntiles
operator|=
name|tiles
operator|->
name|ntile_rows
operator|*
name|tiles
operator|->
name|ntile_cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
name|fail
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|gimp_message_literal
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_ERROR
argument_list|,
literal|"not enough tiles found in level"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* save the current position as it is where the        *  next tile offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* read in the offset of the next tile so we can calculate the amount          of data needed for this tile*/
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we need to read in the maximum possible          allowing for negative compression */
if|if
condition|(
name|offset2
operator|==
literal|0
condition|)
name|offset2
operator|=
name|offset
operator|+
name|TILE_WIDTH
operator|*
name|TILE_WIDTH
operator|*
literal|4
operator|*
literal|1.5
expr_stmt|;
comment|/* 1.5 is probably more                                            than we need to allow */
comment|/* seek to the tile offset */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* get the tile from the tile manager */
name|tile
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* read in the tile */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile
argument_list|(
name|info
argument_list|,
name|tile
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile_rle
argument_list|(
name|info
argument_list|,
name|tile
argument_list|,
name|offset2
operator|-
name|offset
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|g_error
argument_list|(
literal|"xcf: fractal compression unimplemented"
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* To potentially save memory, we compare the        *  newly-fetched tile against the last one, and        *  if they're the same we copy-on-write mirror one against        *  the other.        */
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
name|tile_lock
argument_list|(
name|previous
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_ewidth
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_eheight
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_bpp
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_bpp
argument_list|(
name|previous
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_data_pointer
argument_list|(
name|previous
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|tile_manager_map
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|previous
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|previous
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
if|if
condition|(
operator|!
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* read in the offset of the next tile */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|gimp_message
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_ERROR
argument_list|,
literal|"encountered garbage after reading level: %d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_tile (XcfInfo * info,Tile * tile)
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_tile_rle (XcfInfo * info,Tile * tile,int data_length)
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|nmemb_read_successfully
decl_stmt|;
name|guchar
modifier|*
name|xcfdata
decl_stmt|,
modifier|*
name|xcfodata
decl_stmt|,
modifier|*
name|xcfdatalimit
decl_stmt|;
comment|/* Workaround for bug #357809: avoid crashing on g_malloc() and skip    * this tile (return TRUE without storing data) as if it did not    * contain any data.  It is better than returning FALSE, which would    * skip the whole hierarchy while there may still be some valid    * tiles in the file.    */
if|if
condition|(
name|data_length
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
name|data
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|xcfdata
operator|=
name|xcfodata
operator|=
name|g_malloc
argument_list|(
name|data_length
argument_list|)
expr_stmt|;
comment|/* we have to use fread instead of xcf_read_* because we may be      reading past the end of the file here */
name|nmemb_read_successfully
operator|=
name|fread
argument_list|(
operator|(
name|gchar
operator|*
operator|)
name|xcfdata
argument_list|,
sizeof|sizeof
argument_list|(
name|gchar
argument_list|)
argument_list|,
name|data_length
argument_list|,
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|nmemb_read_successfully
expr_stmt|;
name|xcfdatalimit
operator|=
operator|&
name|xcfodata
index|[
name|nmemb_read_successfully
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
expr_stmt|;
name|size
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|val
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
name|length
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|length
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>=
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|length
operator|=
operator|(
operator|*
name|xcfdata
operator|<<
literal|8
operator|)
operator|+
name|xcfdata
index|[
literal|1
index|]
expr_stmt|;
name|xcfdata
operator|+=
literal|2
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
if|if
condition|(
operator|&
name|xcfdata
index|[
name|length
operator|-
literal|1
index|]
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|data
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>=
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|length
operator|=
operator|(
operator|*
name|xcfdata
operator|<<
literal|8
operator|)
operator|+
name|xcfdata
index|[
literal|1
index|]
expr_stmt|;
name|xcfdata
operator|+=
literal|2
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
if|if
condition|(
name|xcfdata
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|val
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|data
operator|=
name|val
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
block|}
name|g_free
argument_list|(
name|xcfodata
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|bogus_rle
label|:
if|if
condition|(
name|xcfodata
condition|)
name|g_free
argument_list|(
name|xcfodata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|GimpParasite
modifier|*
DECL|function|xcf_load_parasite (XcfInfo * info)
name|xcf_load_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|guint32
name|flags
decl_stmt|;
name|guint32
name|size
decl_stmt|;
name|gpointer
name|data
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|parasite
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_old_paths (XcfInfo * info,GimpImage * image)
name|xcf_load_old_paths
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|guint32
name|num_paths
decl_stmt|;
name|guint32
name|last_selected_row
decl_stmt|;
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|last_selected_row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_paths
operator|--
operator|>
literal|0
condition|)
name|xcf_load_old_path
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|active_vectors
operator|=
name|GIMP_VECTORS
argument_list|(
name|gimp_container_get_child_by_index
argument_list|(
name|gimp_image_get_vectors
argument_list|(
name|image
argument_list|)
argument_list|,
name|last_selected_row
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vectors
condition|)
name|gimp_image_set_active_vectors
argument_list|(
name|image
argument_list|,
name|active_vectors
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_old_path (XcfInfo * info,GimpImage * image)
name|xcf_load_old_path
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gchar
modifier|*
name|name
decl_stmt|;
name|guint32
name|locked
decl_stmt|;
name|guint8
name|state
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|guint32
name|num_points
decl_stmt|;
name|guint32
name|version
decl_stmt|;
comment|/* changed from num_paths */
name|GimpTattoo
name|tattoo
init|=
literal|0
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|GimpVectorsCompatPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
literal|2
condition|)
block|{
name|guint32
name|dummy
decl_stmt|;
comment|/* Had extra type field and points are stored as doubles */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|3
condition|)
block|{
name|guint32
name|dummy
decl_stmt|;
comment|/* Has extra tatto field */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
name|g_warning
argument_list|(
literal|"Unknown path type. Possibly corrupt XCF file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* skip empty compatibility paths */
if|if
condition|(
name|num_points
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|points
operator|=
name|g_new0
argument_list|(
name|GimpVectorsCompatPoint
argument_list|,
name|num_points
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|gint32
name|x
decl_stmt|;
name|gint32
name|y
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|points
index|[
name|i
index|]
operator|.
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|gfloat
name|x
decl_stmt|;
name|gfloat
name|y
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|points
index|[
name|i
index|]
operator|.
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
block|}
name|vectors
operator|=
name|gimp_vectors_compat_new
argument_list|(
name|image
argument_list|,
name|name
argument_list|,
name|points
argument_list|,
name|num_points
argument_list|,
name|closed
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
name|gimp_item_set_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|locked
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tattoo
condition|)
name|gimp_item_set_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
name|gimp_image_add_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|NULL
argument_list|,
comment|/* can't be a tree */
name|gimp_container_get_n_children
argument_list|(
name|gimp_image_get_vectors
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_vectors (XcfInfo * info,GimpImage * image)
name|xcf_load_vectors
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|guint32
name|version
decl_stmt|;
name|guint32
name|active_index
decl_stmt|;
name|guint32
name|num_paths
decl_stmt|;
name|GimpVectors
modifier|*
name|active_vectors
decl_stmt|;
name|guint32
name|base
decl_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"xcf_load_vectors\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
name|gimp_message
argument_list|(
name|info
operator|->
name|gimp
argument_list|,
name|G_OBJECT
argument_list|(
name|info
operator|->
name|progress
argument_list|)
argument_list|,
name|GIMP_MESSAGE_WARNING
argument_list|,
literal|"Unknown vectors version: %d (skipping)"
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|active_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"%d paths (active: %d)\n"
argument_list|,
name|num_paths
argument_list|,
name|active_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|num_paths
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|xcf_load_vector
argument_list|(
name|info
argument_list|,
name|image
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* FIXME tree */
name|active_vectors
operator|=
name|GIMP_VECTORS
argument_list|(
name|gimp_container_get_child_by_index
argument_list|(
name|gimp_image_get_vectors
argument_list|(
name|image
argument_list|)
argument_list|,
name|active_index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vectors
condition|)
name|gimp_image_set_active_vectors
argument_list|(
name|image
argument_list|,
name|active_vectors
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"xcf_load_vectors: loaded %d bytes\n"
argument_list|,
name|info
operator|->
name|cp
operator|-
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_vector (XcfInfo * info,GimpImage * image)
name|xcf_load_vector
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpTattoo
name|tattoo
init|=
literal|0
decl_stmt|;
name|guint32
name|visible
decl_stmt|;
name|guint32
name|linked
decl_stmt|;
name|guint32
name|num_parasites
decl_stmt|;
name|guint32
name|num_strokes
decl_stmt|;
name|GimpVectors
modifier|*
name|vectors
decl_stmt|;
name|gint
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"xcf_load_vector\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_parasites
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_strokes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"name: %s, tattoo: %d, visible: %d, linked: %d, "
literal|"num_parasites %d, num_strokes %d\n"
argument_list|,
name|name
argument_list|,
name|tattoo
argument_list|,
name|visible
argument_list|,
name|linked
argument_list|,
name|num_parasites
argument_list|,
name|num_strokes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vectors
operator|=
name|gimp_vectors_new
argument_list|(
name|image
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_item_set_visible
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|visible
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_item_set_linked
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|linked
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tattoo
condition|)
name|gimp_item_set_tattoo
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parasites
condition|;
name|i
operator|++
control|)
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|xcf_load_parasite
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parasite
condition|)
return|return
name|FALSE
return|;
name|gimp_item_parasite_attach
argument_list|(
name|GIMP_ITEM
argument_list|(
name|vectors
argument_list|)
argument_list|,
name|parasite
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_strokes
condition|;
name|i
operator|++
control|)
block|{
name|guint32
name|stroke_type_id
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|guint32
name|num_axes
decl_stmt|;
name|guint32
name|num_control_points
decl_stmt|;
name|guint32
name|type
decl_stmt|;
name|gfloat
name|coords
index|[
literal|8
index|]
init|=
name|GIMP_COORDS_DEFAULT_VALUES
decl_stmt|;
name|GimpStroke
modifier|*
name|stroke
decl_stmt|;
name|gint
name|j
decl_stmt|;
name|GValueArray
modifier|*
name|control_points
decl_stmt|;
name|GValue
name|value
init|=
block|{
literal|0
block|, }
decl_stmt|;
name|GimpAnchor
name|anchor
decl_stmt|;
name|GType
name|stroke_type
decl_stmt|;
name|g_value_init
argument_list|(
operator|&
name|value
argument_list|,
name|GIMP_TYPE_ANCHOR
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|stroke_type_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_axes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_control_points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"stroke_type: %d, closed: %d, num_axes %d, len %d\n"
argument_list|,
name|stroke_type_id
argument_list|,
name|closed
argument_list|,
name|num_axes
argument_list|,
name|num_control_points
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|stroke_type_id
condition|)
block|{
case|case
name|XCF_STROKETYPE_BEZIER_STROKE
case|:
name|stroke_type
operator|=
name|GIMP_TYPE_BEZIER_STROKE
expr_stmt|;
break|break;
default|default:
name|g_printerr
argument_list|(
literal|"skipping unknown stroke type\n"
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|4
operator|*
name|num_axes
operator|*
name|num_control_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|num_axes
operator|<
literal|2
operator|||
name|num_axes
operator|>
literal|6
condition|)
block|{
name|g_printerr
argument_list|(
literal|"bad number of axes in stroke description\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|control_points
operator|=
name|g_value_array_new
argument_list|(
name|num_control_points
argument_list|)
expr_stmt|;
name|anchor
operator|.
name|selected
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_control_points
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|coords
argument_list|,
name|num_axes
argument_list|)
expr_stmt|;
name|anchor
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|x
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|y
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|pressure
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|xtilt
operator|=
name|coords
index|[
literal|3
index|]
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|ytilt
operator|=
name|coords
index|[
literal|4
index|]
expr_stmt|;
name|anchor
operator|.
name|position
operator|.
name|wheel
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
name|g_value_set_boxed
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|anchor
argument_list|)
expr_stmt|;
name|g_value_array_append
argument_list|(
name|control_points
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_XCF_PATH_DEBUG
name|g_printerr
argument_list|(
literal|"Anchor: %d, (%f, %f, %f, %f, %f, %f)\n"
argument_list|,
name|type
argument_list|,
name|coords
index|[
literal|0
index|]
argument_list|,
name|coords
index|[
literal|1
index|]
argument_list|,
name|coords
index|[
literal|2
index|]
argument_list|,
name|coords
index|[
literal|3
index|]
argument_list|,
name|coords
index|[
literal|4
index|]
argument_list|,
name|coords
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|g_value_unset
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|stroke
operator|=
name|g_object_new
argument_list|(
name|stroke_type
argument_list|,
literal|"closed"
argument_list|,
name|closed
argument_list|,
literal|"control-points"
argument_list|,
name|control_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_vectors_stroke_add
argument_list|(
name|vectors
argument_list|,
name|stroke
argument_list|)
expr_stmt|;
block|}
name|gimp_image_add_vectors
argument_list|(
name|image
argument_list|,
name|vectors
argument_list|,
name|NULL
argument_list|,
comment|/* FIXME tree */
name|gimp_container_get_n_children
argument_list|(
name|gimp_image_get_vectors
argument_list|(
name|image
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_skip_unknown_prop (XcfInfo * info,gsize size)
name|xcf_skip_unknown_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|gsize
name|size
parameter_list|)
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|info
operator|->
name|fp
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

