begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"equalize.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_function_decl
specifier|static
name|void
name|equalize
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eq_histogram
parameter_list|(
name|double
index|[
literal|3
index|]
index|[
literal|256
index|]
parameter_list|,
name|unsigned
name|char
index|[
literal|3
index|]
index|[
literal|256
index|]
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|equalize_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
DECL|function|image_equalize (gimage_ptr)
name|image_equalize
parameter_list|(
name|gimage_ptr
parameter_list|)
name|void
modifier|*
name|gimage_ptr
decl_stmt|;
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|drawable_id
decl_stmt|;
name|int
name|mask_only
init|=
name|TRUE
decl_stmt|;
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|gimage_ptr
expr_stmt|;
name|drawable_id
operator|=
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_indexed
argument_list|(
name|drawable_id
argument_list|)
condition|)
block|{
name|message_box
argument_list|(
literal|"Equalize does not operate on indexed drawables."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|equalize
argument_list|(
name|gimage
argument_list|,
name|drawable_id
argument_list|,
name|mask_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|equalize (gimage,drawable_id,mask_only)
name|equalize
parameter_list|(
name|gimage
parameter_list|,
name|drawable_id
parameter_list|,
name|mask_only
parameter_list|)
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|drawable_id
decl_stmt|;
name|int
name|mask_only
decl_stmt|;
block|{
name|Channel
modifier|*
name|sel_mask
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|,
modifier|*
name|sel_maskPR
decl_stmt|;
name|double
name|hist
index|[
literal|3
index|]
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|lut
index|[
literal|3
index|]
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mask
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|no_mask
decl_stmt|;
name|int
name|h
decl_stmt|,
name|j
decl_stmt|,
name|b
decl_stmt|;
name|int
name|has_alpha
decl_stmt|;
name|int
name|alpha
decl_stmt|,
name|bytes
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|double
name|count
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
name|mask
operator|=
name|NULL
expr_stmt|;
name|sel_mask
operator|=
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|drawable_id
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|drawable_bytes
argument_list|(
name|drawable_id
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|drawable_has_alpha
argument_list|(
name|drawable_id
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|has_alpha
condition|?
operator|(
name|bytes
operator|-
literal|1
operator|)
else|:
name|bytes
expr_stmt|;
name|count
operator|=
literal|0.0
expr_stmt|;
comment|/*  Determine the histogram from the drawable data and the attendant mask  */
name|no_mask
operator|=
operator|(
name|drawable_mask_bounds
argument_list|(
name|drawable_id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
operator|==
name|FALSE
operator|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable_id
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sel_maskPR
operator|=
operator|(
name|no_mask
operator|)
condition|?
name|NULL
else|:
operator|&
name|maskPR
expr_stmt|;
if|if
condition|(
name|sel_maskPR
condition|)
name|pixel_region_init
argument_list|(
name|sel_maskPR
argument_list|,
name|sel_mask
operator|->
name|tiles
argument_list|,
name|x1
operator|+
name|off_x
argument_list|,
name|y1
operator|+
name|off_y
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Initialize histogram */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
name|hist
index|[
name|b
index|]
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
name|sel_maskPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|sel_maskPR
condition|)
name|mask
operator|=
name|sel_maskPR
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|srcPR
operator|.
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|m
operator|=
name|mask
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srcPR
operator|.
name|w
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sel_maskPR
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|hist
index|[
name|b
index|]
index|[
name|s
index|[
name|b
index|]
index|]
operator|+=
operator|(
name|double
operator|)
operator|*
name|m
operator|/
literal|255.0
expr_stmt|;
name|count
operator|+=
operator|(
name|double
operator|)
operator|*
name|m
operator|/
literal|255.0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|hist
index|[
name|b
index|]
index|[
name|s
index|[
name|b
index|]
index|]
operator|+=
literal|1.0
expr_stmt|;
name|count
operator|+=
literal|1.0
expr_stmt|;
block|}
name|s
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|sel_maskPR
condition|)
name|m
operator|++
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
if|if
condition|(
name|sel_maskPR
condition|)
name|mask
operator|+=
name|sel_maskPR
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
comment|/* Build equalization LUT */
name|eq_histogram
argument_list|(
name|hist
argument_list|,
name|lut
argument_list|,
name|alpha
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*  Apply the histogram  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable_id
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_shadow
argument_list|(
name|drawable_id
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|dest
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
name|h
operator|=
name|srcPR
operator|.
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srcPR
operator|.
name|w
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|d
index|[
name|b
index|]
operator|=
name|lut
index|[
name|b
index|]
index|[
name|s
index|[
name|b
index|]
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
name|d
index|[
name|alpha
index|]
operator|=
name|s
index|[
name|alpha
index|]
expr_stmt|;
name|s
operator|+=
name|bytes
expr_stmt|;
name|d
operator|+=
name|bytes
expr_stmt|;
block|}
name|src
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
name|drawable_merge_shadow
argument_list|(
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|drawable_id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|eq_histogram (hist,lut,bytes,count)
name|eq_histogram
parameter_list|(
name|hist
parameter_list|,
name|lut
parameter_list|,
name|bytes
parameter_list|,
name|count
parameter_list|)
name|double
name|hist
index|[
literal|3
index|]
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|lut
index|[
literal|3
index|]
index|[
literal|256
index|]
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|double
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|j
decl_stmt|;
name|int
name|part
index|[
literal|3
index|]
index|[
literal|257
index|]
decl_stmt|;
comment|/* Partition */
name|double
name|pixels_per_value
decl_stmt|;
name|double
name|desired
decl_stmt|;
comment|/* Calculate partial sums */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|hist
index|[
name|k
index|]
index|[
name|i
index|]
operator|+=
name|hist
index|[
name|k
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Find partition points */
name|pixels_per_value
operator|=
name|count
operator|/
literal|256.0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
control|)
block|{
comment|/* First and last points in partition */
name|part
index|[
name|k
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|part
index|[
name|k
index|]
index|[
literal|256
index|]
operator|=
literal|256
expr_stmt|;
comment|/* Find intermediate points */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|desired
operator|=
name|i
operator|*
name|pixels_per_value
expr_stmt|;
while|while
condition|(
name|hist
index|[
name|k
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|<=
name|desired
condition|)
name|j
operator|++
expr_stmt|;
comment|/* Nearest sum */
if|if
condition|(
operator|(
name|desired
operator|-
name|hist
index|[
name|k
index|]
index|[
name|j
index|]
operator|)
operator|<
operator|(
name|hist
index|[
name|k
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|desired
operator|)
condition|)
name|part
index|[
name|k
index|]
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
else|else
name|part
index|[
name|k
index|]
index|[
name|i
index|]
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Create equalization LUT */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|part
index|[
name|k
index|]
index|[
name|i
operator|+
literal|1
index|]
operator|<=
name|j
condition|)
name|i
operator|++
expr_stmt|;
name|lut
index|[
name|k
index|]
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  The equalize procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|equalize_args
name|ProcArg
name|equalize_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"mask_only"
block|,
literal|"equalization option"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|equalize_proc
name|ProcRecord
name|equalize_proc
init|=
block|{
literal|"gimp_equalize"
block|,
literal|"Equalize the contents of the specified drawable"
block|,
literal|"This procedure equalizes the contents of the specified drawable.  Each intensity channel is equalizeed independently.  The equalizeed intensity is given as inten' = (255 - inten).  Indexed color drawables are not valid for this operation.  The 'mask_only' option specifies whether to adjust only the area of the image within the selection bounds, or the entire image based on the histogram of the selected area.  If there is no selection, the entire image is adjusted based on the histogram for the entire image."
block|,
literal|"Federico Mena Quintero& Spencer Kimball& Peter Mattis"
block|,
literal|"Federico Mena Quintero& Spencer Kimball& Peter Mattis"
block|,
literal|"1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|equalize_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|equalize_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|equalize_invoker (args)
name|equalize_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|int
name|mask_only
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|drawable_id
decl_stmt|;
name|drawable_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|int_value
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|drawable_id
operator|=
name|int_value
expr_stmt|;
block|}
comment|/*  the mask only option  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|mask_only
operator|=
operator|(
name|int_value
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
comment|/*  make sure the drawable is not indexed color  */
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|!
name|drawable_indexed
argument_list|(
name|drawable_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|equalize
argument_list|(
name|gimage
argument_list|,
name|drawable_id
argument_list|,
name|mask_only
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|equalize_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

end_unit

