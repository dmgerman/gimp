begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"gimage_cmds.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_comment
comment|/* ick. */
end_comment

begin_include
include|#
directive|include
file|"drawable_pvt.h"
end_include

begin_comment
comment|/* ick ick. */
end_comment

begin_decl_stmt
DECL|variable|int_value
specifier|static
name|int
name|int_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|success
specifier|static
name|int
name|success
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|return_args
specifier|static
name|Argument
modifier|*
name|return_args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GSList
modifier|*
name|image_list
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GImage
modifier|*
name|duplicate
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|channel_ops_duplicate_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_LIST_IMAGES  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_list_images_invoker (Argument * args)
name|gimage_list_images_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|num_images
decl_stmt|;
name|int
modifier|*
name|image_ids
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|image_list
expr_stmt|;
name|num_images
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|image_ids
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|num_images
condition|)
block|{
name|int
name|i
decl_stmt|;
name|image_ids
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|num_images
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_images
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
control|)
name|image_ids
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|GImage
operator|*
operator|)
name|list
operator|->
name|data
operator|)
operator|->
name|ID
expr_stmt|;
block|}
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_images
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|image_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_list_images_out_args
name|ProcArg
name|gimage_list_images_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_images"
block|,
literal|"The number of images currently open"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"image_ids"
block|,
literal|"The list of images currently open"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_list_images_proc
name|ProcRecord
name|gimage_list_images_proc
init|=
block|{
literal|"gimp_list_images"
block|,
literal|"Returns the list of images currently open"
block|,
literal|"This procedure returns the list of images currently open in the GIMP."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Output arguments  */
literal|2
block|,
name|gimage_list_images_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_list_images_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************/
end_comment

begin_comment
comment|/*  GIMAGE_NEW_IMAGE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_new_invoker (Argument * args)
name|gimage_new_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|type
operator|=
name|RGB
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
name|height
operator|=
literal|1
expr_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>
literal|0
condition|)
name|width
operator|=
name|int_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>
literal|0
condition|)
name|height
operator|=
name|int_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>=
name|RGB
operator|&&
name|int_value
operator|<=
name|INDEXED
condition|)
name|type
operator|=
name|int_value
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  create the new image  */
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|gimage
operator|=
name|gimage_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_new_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|ID
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_new_args
name|ProcArg
name|gimage_new_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"width"
block|,
literal|"The width of the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"height"
block|,
literal|"The height of the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"type"
block|,
literal|"The type of image: { RGB (0), GRAY (1), INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_new_out_args
name|ProcArg
name|gimage_new_out_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the newly created image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_new_proc
name|ProcRecord
name|gimage_new_proc
init|=
block|{
literal|"gimp_image_new"
block|,
literal|"Creates a new image with the specified width, height, and type"
block|,
literal|"Creates a new image, undisplayed with the specified extents and type.  A layer should be created and added before this image is displayed, or subsequent calls to 'gimp_display_new' with this image as an argument will fail.  Layers can be created using the 'gimp_layer_new' commands.  They can be added to an image using the 'gimp_image_add_layer' command."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_new_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_new_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_new_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/*  GIMAGE_RESIZE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_resize_invoker (Argument * args)
name|gimage_resize_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|int
name|offx
decl_stmt|,
name|offy
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
operator|||
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|offx
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|offy
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_resize
argument_list|(
name|gimage
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_resize_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_resize_args
name|ProcArg
name|gimage_resize_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_width"
block|,
literal|"new image width: (new_width> 0)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_height"
block|,
literal|"new image height: (new_height> 0)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offx"
block|,
literal|"x offset between upper left corner of old and new images: (new - old)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offy"
block|,
literal|"y offset between upper left corner of old and new images: (new - old)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_resize_proc
name|ProcRecord
name|gimage_resize_proc
init|=
block|{
literal|"gimp_image_resize"
block|,
literal|"Resize the image to the specified extents."
block|,
literal|"This procedure resizes the image so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous image's content.  No bounds checking is currently provided, so don't supply parameters that are out of bounds.  All channels within the image are resized according to the specified parameters; this includes the image selection mask.  All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|5
block|,
name|gimage_resize_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_resize_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/*  GIMAGE_SCALE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_scale_invoker (Argument * args)
name|gimage_scale_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|new_width
decl_stmt|,
name|new_height
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
operator|||
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_scale
argument_list|(
name|gimage
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_scale_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_scale_args
name|ProcArg
name|gimage_scale_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_width"
block|,
literal|"new image width: (new_width> 0)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_height"
block|,
literal|"new image height: (new_height> 0)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_scale_proc
name|ProcRecord
name|gimage_scale_proc
init|=
block|{
literal|"gimp_image_scale"
block|,
literal|"Scale the image to the specified extents."
block|,
literal|"This procedure scales the image so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous image's content.  No bounds checking is currently provided, so don't supply parameters that are out of bounds.  All channels within the image are scaled according to the specified parameters; this includes the image selection mask.  All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_scale_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_scale_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/*  GIMAGE_DELETE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_delete_invoker (Argument * args)
name|gimage_delete_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|gimage_delete
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_delete_args
name|ProcArg
name|gimage_delete_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image ID"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_delete_proc
name|ProcRecord
name|gimage_delete_proc
init|=
block|{
literal|"gimp_image_delete"
block|,
literal|"Delete the specified image"
block|,
literal|"If there are no other references to this image it will be deleted.  Other references are possible when more than one view to an image exists."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_delete_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_delete_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_FREE_SHADOW  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_free_shadow_invoker (Argument * args)
name|gimage_free_shadow_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|gimage_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_free_shadow_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_free_shadow_args
name|ProcArg
name|gimage_free_shadow_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image ID"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_free_shadow_proc
name|ProcRecord
name|gimage_free_shadow_proc
init|=
block|{
literal|"gimp_image_free_shadow"
block|,
literal|"Free the specified image's shadow data (if it exists)"
block|,
literal|"This procedure is intended as a memory saving device.  If any shadow memory has been allocated, it will be freed automatically on a call to 'gimp_image_delete'."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_free_shadow_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_free_shadow_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_LAYERS  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_layers_invoker (Argument * args)
name|gimage_get_layers_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|int
name|num_layers
decl_stmt|;
name|int
modifier|*
name|layer_ids
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|success
operator|=
operator|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|num_layers
operator|=
name|g_slist_length
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
name|layer_ids
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|num_layers
condition|)
block|{
name|int
name|i
decl_stmt|;
name|layer_ids
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|num_layers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_layers
condition|;
name|i
operator|++
operator|,
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
control|)
name|layer_ids
index|[
name|i
index|]
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
operator|(
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_layers
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|layer_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_layers_args
name|ProcArg
name|gimage_get_layers_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_layers_out_args
name|ProcArg
name|gimage_get_layers_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_layers"
block|,
literal|"The number of layers contained in the image"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"layer_ids"
block|,
literal|"The list of layers contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_layers_proc
name|ProcRecord
name|gimage_get_layers_proc
init|=
block|{
literal|"gimp_image_get_layers"
block|,
literal|"Returns the list of layers contained in the specified image"
block|,
literal|"This procedure returns the list of layers contained in the specified image.  The order of layers is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_layers_args
block|,
comment|/*  Output arguments  */
literal|2
block|,
name|gimage_get_layers_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_layers_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_CHANNELS  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_channels_invoker (Argument * args)
name|gimage_get_channels_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|num_channels
decl_stmt|;
name|int
modifier|*
name|channel_ids
decl_stmt|;
name|GSList
modifier|*
name|channel_list
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|success
operator|=
operator|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_channels_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|channel_list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|num_channels
operator|=
name|g_slist_length
argument_list|(
name|channel_list
argument_list|)
expr_stmt|;
name|channel_ids
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|num_channels
condition|)
block|{
name|int
name|i
decl_stmt|;
name|channel_ids
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
operator|,
name|channel_list
operator|=
name|g_slist_next
argument_list|(
name|channel_list
argument_list|)
control|)
name|channel_ids
index|[
name|i
index|]
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
operator|(
operator|(
name|Channel
operator|*
operator|)
name|channel_list
operator|->
name|data
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_channels
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|channel_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_channels_args
name|ProcArg
name|gimage_get_channels_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_channels_out_args
name|ProcArg
name|gimage_get_channels_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_channels"
block|,
literal|"The number of channels contained in the image"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"channel_ids"
block|,
literal|"The list of channels contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_channels_proc
name|ProcRecord
name|gimage_get_channels_proc
init|=
block|{
literal|"gimp_image_get_channels"
block|,
literal|"Returns the list of channels contained in the specified image"
block|,
literal|"This procedure returns the list of channels contained in the specified image.  This does not include the selection mask, or layer masks.  The order is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_channels_args
block|,
comment|/*  Output arguments  */
literal|2
block|,
name|gimage_get_channels_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_channels_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_ACTIVE_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_active_layer_invoker (Argument * args)
name|gimage_get_active_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_active_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
operator|(
name|layer
operator|)
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_active_layer_args
name|ProcArg
name|gimage_get_active_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_active_layer_out_args
name|ProcArg
name|gimage_get_active_layer_out_args
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer_ID"
block|,
literal|"The ID of the active layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_active_layer_proc
name|ProcRecord
name|gimage_get_active_layer_proc
init|=
block|{
literal|"gimp_image_get_active_layer"
block|,
literal|"Returns the active layer of the specified image"
block|,
literal|"If there is an active layer, its ID will be returned, otherwise, -1.  If a channel is currently active, then no layer will be.  If a layer mask is active, then this will return the associated layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_active_layer_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_active_layer_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_active_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_ACTIVE_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_active_channel_invoker (Argument * args)
name|gimage_get_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|channel
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|channel
operator|=
name|gimage_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_active_channel_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
operator|(
name|channel
operator|)
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_active_channel_args
name|ProcArg
name|gimage_get_active_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_active_channel_out_args
name|ProcArg
name|gimage_get_active_channel_out_args
index|[]
init|=
block|{
block|{
name|PDB_CHANNEL
block|,
literal|"channel ID"
block|,
literal|"The ID of the active channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_active_channel_proc
name|ProcRecord
name|gimage_get_active_channel_proc
init|=
block|{
literal|"gimp_image_get_active_channel"
block|,
literal|"Returns the active channel of the specified image"
block|,
literal|"If there is an active channel, this will return the channel ID, otherwise, -1."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_active_channel_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_active_channel_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_active_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_SELECTION  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_selection_invoker (Argument * args)
name|gimage_get_selection_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|mask
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|mask
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
operator|(
operator|(
name|mask
operator|=
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_selection_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_selection_args
name|ProcArg
name|gimage_get_selection_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_selection_out_args
name|ProcArg
name|gimage_get_selection_out_args
index|[]
init|=
block|{
block|{
name|PDB_SELECTION
block|,
literal|"selection mask ID"
block|,
literal|"The ID of the selection channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_selection_proc
name|ProcRecord
name|gimage_get_selection_proc
init|=
block|{
literal|"gimp_image_get_selection"
block|,
literal|"Returns the selection of the specified image"
block|,
literal|"This will always return a valid ID for a selection--which is represented as a channel internally."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_selection_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_selection_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_selection_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_COMPONENT_ACTIVE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_component_active_invoker (Argument * args)
name|gimage_get_component_active_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|comp_type
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|comp_type
operator|=
name|Green
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|comp_type
operator|=
name|Blue
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|comp_type
operator|=
name|Gray
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|comp_type
operator|=
name|Indexed
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
operator|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_component_active_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage_get_component_active
argument_list|(
name|gimage
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_component_active_args
name|ProcArg
name|gimage_get_component_active_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_component_active_out_args
name|ProcArg
name|gimage_get_component_active_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"active"
block|,
literal|"1 for active, 0 for inactive"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_component_active_proc
name|ProcRecord
name|gimage_get_component_active_proc
init|=
block|{
literal|"gimp_image_get_component_active"
block|,
literal|"Returns whether the specified component is active"
block|,
literal|"This procedure returns information on whether the specified image component (ie. red, green, blue intensity channels in an RGB image) is active or inactive--whether or not it can be modified.  If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_get_component_active_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_component_active_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_component_active_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_COMPONENT_VISIBLE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_component_visible_invoker (Argument * args)
name|gimage_get_component_visible_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|comp_type
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|comp_type
operator|=
name|Green
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|comp_type
operator|=
name|Blue
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|comp_type
operator|=
name|Gray
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|comp_type
operator|=
name|Indexed
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
operator|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_component_visible_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_component_visible_args
name|ProcArg
name|gimage_get_component_visible_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: {RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_component_visible_out_args
name|ProcArg
name|gimage_get_component_visible_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"visible"
block|,
literal|"1 for visible, 0 for invisible"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_component_visible_proc
name|ProcRecord
name|gimage_get_component_visible_proc
init|=
block|{
literal|"gimp_image_get_component_visible"
block|,
literal|"Returns whether the specified component is visible"
block|,
literal|"This procedure returns information on whether the specified image component (ie. Red, Green, Blue intensity channels in an RGB image) is visible or invisible--whether or not it can be modified.  If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_get_component_visible_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_component_visible_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_component_visible_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_ACTIVE_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_active_layer_invoker (Argument * args)
name|gimage_set_active_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_active_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_active_layer_args
name|ProcArg
name|gimage_set_active_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to be set active"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_active_layer_proc
name|ProcRecord
name|gimage_set_active_layer_proc
init|=
block|{
literal|"gimp_image_set_active_layer"
block|,
literal|"Sets the specified layer as active in the specified image."
block|,
literal|"If the layer exists, it is set as the active layer in the image.  Any previous active layer or channel is set to inactive.  An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_set_active_layer_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_active_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_ACTIVE_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_active_channel_invoker (Argument * args)
name|gimage_set_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_active_channel_args
name|ProcArg
name|gimage_set_active_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel to be set active"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_active_channel_proc
name|ProcRecord
name|gimage_set_active_channel_proc
init|=
block|{
literal|"gimp_image_set_active_channel"
block|,
literal|"Sets the specified channel as active in the specified image."
block|,
literal|"If the channel exists, it is set as the active channel in the image.  Any previous active channel or channel is set to inactive.  An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_set_active_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_active_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_UNSET_ACTIVE_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_unset_active_channel_invoker (Argument * args)
name|gimage_unset_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|gimage_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_unset_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_unset_active_channel_args
name|ProcArg
name|gimage_unset_active_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_unset_active_channel_proc
name|ProcRecord
name|gimage_unset_active_channel_proc
init|=
block|{
literal|"gimp_image_unset_active_channel"
block|,
literal|"Unsets the active channel in the specified image."
block|,
literal|"If an active channel exists, it is unset.  There then exists no active channel, and if desired, one can be set through a call to 'Set Active Channel'.  No error is returned in the case of no existing active channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_unset_active_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_unset_active_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_COMPONENT_ACTIVE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_component_active_invoker (Argument * args)
name|gimage_set_component_active_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|comp_type
decl_stmt|;
name|int
name|active
decl_stmt|;
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|comp_type
operator|=
name|Green
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|comp_type
operator|=
name|Blue
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|comp_type
operator|=
name|Gray
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|comp_type
operator|=
name|Indexed
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
operator|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|active
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_component_active
argument_list|(
name|gimage
argument_list|,
name|comp_type
argument_list|,
name|active
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_component_active_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_component_active_args
name|ProcArg
name|gimage_set_component_active_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"active"
block|,
literal|"Active? 1 for true, 0 for false"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_component_active_proc
name|ProcRecord
name|gimage_set_component_active_proc
init|=
block|{
literal|"gimp_image_set_component_active"
block|,
literal|"Sets the specified component's sensitivity"
block|,
literal|"This procedure sets whether the specified component is active or inactive--that is, whether it can be affected during painting operations.  If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_set_component_active_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_component_active_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_COMPONENT_VISIBLE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_component_visible_invoker (Argument * args)
name|gimage_set_component_visible_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|comp_type
decl_stmt|;
name|int
name|visible
decl_stmt|;
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|comp_type
operator|=
name|Red
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|comp_type
operator|=
name|Green
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|comp_type
operator|=
name|Blue
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|comp_type
operator|=
name|Gray
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|comp_type
operator|=
name|Indexed
expr_stmt|;
name|success
operator|=
operator|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
operator|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|visible
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_component_visible
argument_list|(
name|gimage
argument_list|,
name|comp_type
argument_list|,
name|visible
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_component_visible_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_component_visible_args
name|ProcArg
name|gimage_set_component_visible_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"visible"
block|,
literal|"Visible? 1 for true, 0 for false"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_component_visible_proc
name|ProcRecord
name|gimage_set_component_visible_proc
init|=
block|{
literal|"gimp_image_set_component_visible"
block|,
literal|"Sets the specified component's visibility"
block|,
literal|"This procedure sets whether the specified component is visible or invisible.  If the specified component is not valid for the image type, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_set_component_visible_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_component_visible_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_PICK_CORRELATE_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_pick_correlate_layer_invoker (Argument * args)
name|gimage_pick_correlate_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|layer
operator|=
name|gimage_pick_correlate_layer
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_pick_correlate_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_pick_correlate_layer_args
name|ProcArg
name|gimage_pick_correlate_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"x"
block|,
literal|"The x coordinate for the pick"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"y"
block|,
literal|"The y coordinate for the pick"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_pick_correlate_layer_out_args
name|ProcArg
name|gimage_pick_correlate_layer_out_args
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer found at the specified coordinates"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_pick_correlate_layer_proc
name|ProcRecord
name|gimage_pick_correlate_layer_proc
init|=
block|{
literal|"gimp_image_pick_correlate_layer"
block|,
literal|"Find the layer visible at the specified coordinates"
block|,
literal|"This procedure finds the layer which is visible at the specified coordinates.  Layers which do not qualify are those whose extents do not pass within the specified coordinates, or which are transparent at the specified coordinates.  This procedure will return -1 if no layer is found."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_pick_correlate_layer_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_pick_correlate_layer_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_pick_correlate_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_RAISE_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_raise_layer_invoker (Argument * args)
name|gimage_raise_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|gimage_raise_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_raise_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_raise_layer_args
name|ProcArg
name|gimage_raise_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_raise_layer_proc
name|ProcRecord
name|gimage_raise_layer_proc
init|=
block|{
literal|"gimp_image_raise_layer"
block|,
literal|"Raise the specified layer in the image's layer stack"
block|,
literal|"This procedure raises the specified layer one step in the existing layer stack.  It will not move the layer if there is no layer above it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_raise_layer_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_raise_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_LOWER_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_lower_layer_invoker (Argument * args)
name|gimage_lower_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|gimage_lower_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_lower_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_lower_layer_args
name|ProcArg
name|gimage_lower_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_lower_layer_proc
name|ProcRecord
name|gimage_lower_layer_proc
init|=
block|{
literal|"gimp_image_lower_layer"
block|,
literal|"Lower the specified layer in the image's layer stack"
block|,
literal|"This procedure lowers the specified layer one step in the existing layer stack.  It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_lower_layer_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_lower_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/*  GIMAGE_MERGE_VISIBLE_LAYERS  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_merge_visible_layers_invoker (Argument * args)
name|gimage_merge_visible_layers_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|MergeType
name|merge_type
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|merge_type
operator|=
name|ExpandAsNecessary
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|merge_type
operator|=
name|ExpandAsNecessary
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|merge_type
operator|=
name|ClipToImage
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|merge_type
operator|=
name|ClipToBottomLayer
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|layer
operator|=
name|gimage_merge_visible_layers
argument_list|(
name|gimage
argument_list|,
name|merge_type
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_merge_visible_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_merge_visible_layers_args
name|ProcArg
name|gimage_merge_visible_layers_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"merge_type"
block|,
literal|"The type of merge: { EXPAND-AS-NECESSARY (0), CLIP-TO-IMAGE (1), CLIP-TO-BOTTOM-LAYER (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_merge_visible_layers_out_args
name|ProcArg
name|gimage_merge_visible_layers_out_args
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_merge_visible_layers_proc
name|ProcRecord
name|gimage_merge_visible_layers_proc
init|=
block|{
literal|"gimp_image_merge_visible_layers"
block|,
literal|"Merge the visible image layers into one"
block|,
literal|"This procedure combines the visible layers into a single layer using the specified merge type.  A merge type of EXPAND-AS-NECESSARY expands the final layer to encompass the areas of the visible layers.  A merge type of CLIP-TO-IMAGE clips the final layer to the extents of the image.  A merge type of CLIP-TO-BOTTOM-LAYER clips the final layer to the size of the bottommost layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_merge_visible_layers_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_merge_visible_layers_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_merge_visible_layers_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************/
end_comment

begin_comment
comment|/*  GIMAGE_FLATTEN  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_flatten_invoker (Argument * args)
name|gimage_flatten_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|layer
operator|=
name|gimage_flatten
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_flatten_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_flatten_args
name|ProcArg
name|gimage_flatten_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_flatten_out_args
name|ProcArg
name|gimage_flatten_out_args
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_flatten_proc
name|ProcRecord
name|gimage_flatten_proc
init|=
block|{
literal|"gimp_image_flatten"
block|,
literal|"Flatten all visible layers into a single layer.  Discard all invisible layers"
block|,
literal|"This procedure combines the visible layers in a manner analogous to merging with the ClipToImage merge type.  Non-visible layers are discarded, and the resulting image is stripped of its alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_flatten_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_flatten_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_flatten_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************/
end_comment

begin_comment
comment|/*  GIMAGE_ADD_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_add_layer_invoker (Argument * args)
name|gimage_add_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|position
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/*  make sure that this layer can be added to the specified image  */
if|if
condition|(
operator|(
operator|!
name|success
operator|)
operator|||
operator|(
name|drawable_color
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|RGB
operator|)
operator|||
operator|(
name|drawable_gray
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|GRAY
operator|)
operator|||
operator|(
name|drawable_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|INDEXED
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|position
operator|=
name|MAXIMUM
argument_list|(
name|int_value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  make sure it's -1 or greater  */
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimage_add_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|position
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_add_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_add_layer_args
name|ProcArg
name|gimage_add_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"the layer"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"position"
block|,
literal|"the layer position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_add_layer_proc
name|ProcRecord
name|gimage_add_layer_proc
init|=
block|{
literal|"gimp_image_add_layer"
block|,
literal|"Add the specified layer to the image"
block|,
literal|"This procedure adds the specified layer to the gimage at the given position.  If the position is specified as -1, then the layer is inserted at the top of the layer stack.  If the layer to be added has no alpha channel, it must be added at position 0.  The layer type must be compatible with the image base type."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_add_layer_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_add_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_REMOVE_LAYER  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_remove_layer_invoker (Argument * args)
name|gimage_remove_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_remove_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_remove_layer_args
name|ProcArg
name|gimage_remove_layer_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"the layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_remove_layer_proc
name|ProcRecord
name|gimage_remove_layer_proc
init|=
block|{
literal|"gimp_image_remove_layer"
block|,
literal|"Remove the specified layer from the image"
block|,
literal|"This procedure removes the specified layer from the image.  If the layer doesn't exist, an error is returned.  If there are no layers left in the image, this call will fail.  If this layer is the last layer remaining, the image will become empty and have no active layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_remove_layer_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_remove_layer_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************/
end_comment

begin_comment
comment|/*  GIMAGE_ADD_LAYER_MASK  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_add_layer_mask_invoker (Argument * args)
name|gimage_add_layer_mask_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|LayerMask
modifier|*
name|mask
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|=
name|layer_mask_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|mask
operator|=
name|gimage_add_layer_mask
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|mask
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_add_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_add_layer_mask_args
name|ProcArg
name|gimage_add_layer_mask_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the layer's image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"the layer to receive the mask"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"mask"
block|,
literal|"the mask to add to the layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_add_layer_mask_proc
name|ProcRecord
name|gimage_add_layer_mask_proc
init|=
block|{
literal|"gimp_image_add_layer_mask"
block|,
literal|"Add a layer mask to the specified layer"
block|,
literal|"This procedure adds a layer mask to the specified layer.  Layer masks serve as an additional alpha channel for a layer.  This procedure will fail if a number of prerequisites aren't met.  The layer cannot already have a layer mask.  The specified mask must exist and have the same dimensions as the layer.  Both the mask and the layer must have been created for use with the specified image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_add_layer_mask_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_add_layer_mask_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************/
end_comment

begin_comment
comment|/*  GIMAGE_REMOVE_LAYER_MASK  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_remove_layer_mask_invoker (Argument * args)
name|gimage_remove_layer_mask_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|mode
operator|=
name|APPLY
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
name|APPLY
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mode
operator|=
name|DISCARD
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|gimage_remove_layer_mask
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_remove_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_remove_layer_mask_args
name|ProcArg
name|gimage_remove_layer_mask_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the layer's image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"the layer from which to remove mask"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"mode"
block|,
literal|"removal mode: { APPLY (0), DISCARD (1) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_remove_layer_mask_proc
name|ProcRecord
name|gimage_remove_layer_mask_proc
init|=
block|{
literal|"gimp_image_remove_layer_mask"
block|,
literal|"Remove the specified layer mask from the layer"
block|,
literal|"This procedure removes the specified layer mask from the layer.  If the mask doesn't exist, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_remove_layer_mask_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_remove_layer_mask_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************/
end_comment

begin_comment
comment|/*  GIMAGE_RAISE_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_raise_channel_invoker (Argument * args)
name|gimage_raise_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|gimage_raise_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_raise_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_raise_channel_args
name|ProcArg
name|gimage_raise_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_raise_channel_proc
name|ProcRecord
name|gimage_raise_channel_proc
init|=
block|{
literal|"gimp_image_raise_channel"
block|,
literal|"Raise the specified channel in the image's channel stack"
block|,
literal|"This procedure raises the specified channel one step in the existing channel stack.  It will not move the channel if there is no channel above it."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_raise_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_raise_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_LOWER_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_lower_channel_invoker (Argument * args)
name|gimage_lower_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|gimage_lower_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_lower_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_lower_channel_args
name|ProcArg
name|gimage_lower_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_lower_channel_proc
name|ProcRecord
name|gimage_lower_channel_proc
init|=
block|{
literal|"gimp_image_lower_channel"
block|,
literal|"Lower the specified channel in the image's channel stack"
block|,
literal|"This procedure lowers the specified channel one step in the existing channel stack.  It will not move the channel if there is no channel below it."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_lower_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_lower_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_ADD_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_add_channel_invoker (Argument * args)
name|gimage_add_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|int
name|position
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|position
operator|=
name|MAXIMUM
argument_list|(
name|int_value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  make sure it's -1 or greater  */
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimage_add_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|position
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_add_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_add_channel_args
name|ProcArg
name|gimage_add_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"the channel"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"position"
block|,
literal|"the channel position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_add_channel_proc
name|ProcRecord
name|gimage_add_channel_proc
init|=
block|{
literal|"gimp_image_add_channel"
block|,
literal|"Add the specified channel to the image"
block|,
literal|"This procedure adds the specified channel to the gimage.  The position channel is not currently used, so the channel is always inserted at the top of the channel stack."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_add_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_add_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************/
end_comment

begin_comment
comment|/*  GIMAGE_REMOVE_CHANNEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_remove_channel_invoker (Argument * args)
name|gimage_remove_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimage_remove_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_remove_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_remove_channel_args
name|ProcArg
name|gimage_remove_channel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"the channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_remove_channel_proc
name|ProcRecord
name|gimage_remove_channel_proc
init|=
block|{
literal|"gimp_image_remove_channel"
block|,
literal|"Remove the specified channel from the image"
block|,
literal|"This procedure removes the specified channel from the image.  If the channel doesn't exist, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_remove_channel_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_remove_channel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************/
end_comment

begin_comment
comment|/*  GIMAGE_ACTIVE_DRAWABLE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_active_drawable_invoker (Argument * args)
name|gimage_active_drawable_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
operator|(
operator|(
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_active_drawable_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_active_drawable_args
name|ProcArg
name|gimage_active_drawable_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_active_drawable_out_args
name|ProcArg
name|gimage_active_drawable_out_args
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the active drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_active_drawable_proc
name|ProcRecord
name|gimage_active_drawable_proc
init|=
block|{
literal|"gimp_image_active_drawable"
block|,
literal|"Get the image's active drawable"
block|,
literal|"This procedure returns the ID of the image's active drawable.  This can be either a layer, a channel, or a layer mask.  The active drawable is specified by the active image channel.  If that is -1, then by the active image layer.  If the active image layer has a layer mask and the layer mask is in edit mode, then the layer mask is the active drawable."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_active_drawable_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_active_drawable_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_active_drawable_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************/
end_comment

begin_comment
comment|/*  GIMAGE_BASE_TYPE  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_base_type_invoker (Argument * args)
name|gimage_base_type_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|base_type
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|base_type
operator|=
name|RGB_GIMAGE
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|base_type
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_base_type_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|base_type
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_base_type_args
name|ProcArg
name|gimage_base_type_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_base_type_out_args
name|ProcArg
name|gimage_base_type_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"base_type"
block|,
literal|"the image's base type: { RGB (0), GRAY (1), INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_base_type_proc
name|ProcRecord
name|gimage_base_type_proc
init|=
block|{
literal|"gimp_image_base_type"
block|,
literal|"Get the base type of the image"
block|,
literal|"This procedure returns the image's base type, which is one of: { RGB-CHANNEL, GRAY-CHANNEL, INDEXED-CHANNEL }.  Layers in the image must be of this subtype, but can have an optional alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_base_type_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_base_type_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_base_type_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_FILENAME  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_filename_invoker (Argument * args)
name|gimage_get_filename_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|filename
operator|=
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_filename_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
operator|(
name|filename
operator|)
condition|?
name|g_strdup
argument_list|(
name|filename
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_filename_args
name|ProcArg
name|gimage_get_filename_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_filename_out_args
name|ProcArg
name|gimage_get_filename_out_args
index|[]
init|=
block|{
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"the image's filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_filename_proc
name|ProcRecord
name|gimage_get_filename_proc
init|=
block|{
literal|"gimp_image_get_filename"
block|,
literal|"Return the filename of the image"
block|,
literal|"This procedure returns the image's filename--if it was loaded or has since been saved.  Otherwise, returns NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_filename_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_get_filename_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_filename_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_FILENAME  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_filename_invoker (Argument * args)
name|gimage_set_filename_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|filename
operator|=
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_set_filename
argument_list|(
name|gimage
argument_list|,
operator|(
name|char
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_filename_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_filename_args
name|ProcArg
name|gimage_set_filename_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"the image's filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_filename_proc
name|ProcRecord
name|gimage_set_filename_proc
init|=
block|{
literal|"gimp_image_set_filename"
block|,
literal|"Set the image's filename"
block|,
literal|"This procedure sets the image's filename."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|2
block|,
name|gimage_set_filename_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_filename_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************/
end_comment

begin_comment
comment|/*  GIMAGE_WIDTH  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_width_invoker (Argument * args)
name|gimage_width_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|width
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|width
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_width_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|width
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_width_args
name|ProcArg
name|gimage_width_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_width_out_args
name|ProcArg
name|gimage_width_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"width"
block|,
literal|"the image's width"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_width_proc
name|ProcRecord
name|gimage_width_proc
init|=
block|{
literal|"gimp_image_width"
block|,
literal|"Return the width of the image"
block|,
literal|"This procedure returns the image's width.  This value is independent of any of the layers in this image.  This is the \"canvas\" width."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_width_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_width_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_width_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/*  GIMAGE_HEIGHT  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_height_invoker (Argument * args)
name|gimage_height_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|height
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|height
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|height
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_height_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|height
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_height_args
name|ProcArg
name|gimage_height_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_height_out_args
name|ProcArg
name|gimage_height_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"height"
block|,
literal|"the image's height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_height_proc
name|ProcRecord
name|gimage_height_proc
init|=
block|{
literal|"gimp_image_height"
block|,
literal|"Return the height of the image"
block|,
literal|"This procedure returns the image's height.  This value is independent of any of the layers in this image.  This is the \"canvas\" height."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_height_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_height_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_height_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************/
end_comment

begin_comment
comment|/*  GIMAGE_GET_CMAP  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_get_cmap_invoker (Argument * args)
name|gimage_get_cmap_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cmap
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_get_cmap_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|cmap
operator|=
name|g_malloc
argument_list|(
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cmap
argument_list|,
name|gimage_cmap
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|num_cols
operator|*
literal|3
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|cmap
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_get_cmap_args
name|ProcArg
name|gimage_get_cmap_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_cmap_out_args
name|ProcArg
name|gimage_get_cmap_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_bytes"
block|,
literal|"number of bytes in the colormap array: 0<= num_bytes<= 768"
block|}
block|,
block|{
name|PDB_INT8ARRAY
block|,
literal|"cmap"
block|,
literal|"the image's colormap"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_get_cmap_proc
name|ProcRecord
name|gimage_get_cmap_proc
init|=
block|{
literal|"gimp_image_get_cmap"
block|,
literal|"Returns the image's colormap"
block|,
literal|"This procedure returns an actual pointer to the image's colormap, as well as the number of bytes contained in the colormap.  The actual number of colors in the transmitted colormap will be \"num_bytes\" / 3.  If the image is not of base type INDEXED, this pointer will be NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_get_cmap_args
block|,
comment|/*  Output arguments  */
literal|2
block|,
name|gimage_get_cmap_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_get_cmap_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************/
end_comment

begin_comment
comment|/*  GIMAGE_SET_CMAP  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_set_cmap_invoker (Argument * args)
name|gimage_set_cmap_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|num_cols
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cmap
decl_stmt|;
name|num_cols
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|<
literal|0
operator|||
name|int_value
operator|>
name|COLORMAP_SIZE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|num_cols
operator|=
name|int_value
operator|/
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|cmap
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|num_cols
operator|&&
name|gimage
operator|->
name|cmap
condition|)
block|{
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|num_cols
condition|)
block|{
name|gimage
operator|->
name|cmap
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|cmap
argument_list|,
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|num_cols
operator|=
name|num_cols
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_set_cmap_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_set_cmap_args
name|ProcArg
name|gimage_set_cmap_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_bytes"
block|,
literal|"number of bytes in the new colormap: 0<= num_colors<= 768"
block|}
block|,
block|{
name|PDB_INT8ARRAY
block|,
literal|"cmap"
block|,
literal|"the new colormap values"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_set_cmap_proc
name|ProcRecord
name|gimage_set_cmap_proc
init|=
block|{
literal|"gimp_image_set_cmap"
block|,
literal|"Sets the entries in the image's colormap"
block|,
literal|"This procedure sets the entries in the specified image's colormap.  The number of entries is specified by the \"num_bytes\" parameter and corresponds the the number of INT8 triples that must be contained in the \"cmap\" array.  The actual number of colors in the transmitted colormap is \"num_bytes\" / 3."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|3
block|,
name|gimage_set_cmap_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_set_cmap_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/*  GIMAGE_ENABLE_UNDO  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_enable_undo_invoker (Argument * args)
name|gimage_enable_undo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_enable_undo
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_enable_undo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
operator|(
name|success
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_enable_undo_args
name|ProcArg
name|gimage_enable_undo_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_enable_undo_out_args
name|ProcArg
name|gimage_enable_undo_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"enabled"
block|,
literal|"true if the image undo has been enabled"
block|,   }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_enable_undo_proc
name|ProcRecord
name|gimage_enable_undo_proc
init|=
block|{
literal|"gimp_image_enable_undo"
block|,
literal|"Enable the image's undo stack"
block|,
literal|"This procedure enables the image's undo stack, allowing subsequent operations to store their undo steps.  This is generally called in conjunction with 'gimp_image_disable_undo' to temporarily disable an image undo stack."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_enable_undo_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_enable_undo_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_enable_undo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_DISABLE_UNDO  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_disable_undo_invoker (Argument * args)
name|gimage_disable_undo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_disable_undo
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_disable_undo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
operator|(
name|success
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_disable_undo_args
name|ProcArg
name|gimage_disable_undo_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_disable_undo_out_args
name|ProcArg
name|gimage_disable_undo_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"disabled"
block|,
literal|"true if the image undo has been disabled"
block|,   }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_disable_undo_proc
name|ProcRecord
name|gimage_disable_undo_proc
init|=
block|{
literal|"gimp_image_disable_undo"
block|,
literal|"Disable the image's undo stack"
block|,
literal|"This procedure disables the image's undo stack, allowing subsequent operations to ignore their undo steps.  This is generally called in conjunction with 'gimp_image_enable_undo' to temporarily disable an image undo stack.  This is advantageous because saving undo steps can be time and memory intensive."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_disable_undo_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_disable_undo_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_disable_undo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************/
end_comment

begin_comment
comment|/*  GIMAGE_CLEAN_ALL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_clean_all_invoker (Argument * args)
name|gimage_clean_all_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|gimage_clean_all
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_clean_all_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_clean_all_args
name|ProcArg
name|gimage_clean_all_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_clean_all_proc
name|ProcRecord
name|gimage_clean_all_proc
init|=
block|{
literal|"gimp_image_clean_all"
block|,
literal|"Set the image dirty count to 0"
block|,
literal|"This procedure sets the specified image's dirty count to 0, allowing operations to occur without having a 'dirtied' image.  This is especially useful for creating and loading images which should not initially be considered dirty, even though layers must be created, filled, and installed in the image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_clean_all_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_clean_all_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************/
end_comment

begin_comment
comment|/*  GIMAGE_FLOATING_SEL  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|gimage_floating_sel_invoker (Argument * args)
name|gimage_floating_sel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|floating_sel
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|gimage_floating_sel_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
operator|(
name|floating_sel
operator|)
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|floating_sel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|gimage_floating_sel_args
name|ProcArg
name|gimage_floating_sel_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_floating_sel_out_args
name|ProcArg
name|gimage_floating_sel_out_args
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"floating_sel"
block|,
literal|"the image's floating selection"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimage_floating_sel_proc
name|ProcRecord
name|gimage_floating_sel_proc
init|=
block|{
literal|"gimp_image_floating_selection"
block|,
literal|"Return the floating selection of the image"
block|,
literal|"This procedure returns the image's floating_sel, if it exists.  If it doesn't exist, -1 is returned as the layer ID."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|gimage_floating_sel_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|gimage_floating_sel_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|gimage_floating_sel_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|GImage
modifier|*
DECL|function|duplicate (GImage * gimage)
name|duplicate
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|GImage
modifier|*
name|new_gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|,
modifier|*
name|new_layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|,
modifier|*
name|new_channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|Layer
modifier|*
name|active_layer
init|=
name|NULL
decl_stmt|;
name|Channel
modifier|*
name|active_channel
init|=
name|NULL
decl_stmt|;
name|GimpDrawable
modifier|*
name|new_floating_sel_drawable
init|=
name|NULL
decl_stmt|;
name|GimpDrawable
modifier|*
name|floating_sel_drawable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/*  Create a new image  */
name|new_gimage
operator|=
name|gimage_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|gimage
operator|->
name|base_type
argument_list|)
expr_stmt|;
name|gimage_disable_undo
argument_list|(
name|new_gimage
argument_list|)
expr_stmt|;
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
block|{
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|floating_sel_drawable
operator|=
name|floating_layer
operator|->
name|fs
operator|.
name|drawable
expr_stmt|;
name|floating_layer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  Copy the layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|new_layer
operator|=
name|layer_copy
argument_list|(
name|layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
argument_list|)
operator|->
name|gimage
operator|=
name|new_gimage
expr_stmt|;
comment|/*  Make sure the copied layer doesn't say: "<old layer> copy"  */
name|g_free
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
argument_list|)
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Make sure if the layer has a layer mask, it's name isn't screwed up  */
if|if
condition|(
name|new_layer
operator|->
name|mask
condition|)
block|{
name|g_free
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
operator|->
name|mask
argument_list|)
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|==
name|layer
condition|)
name|active_layer
operator|=
name|new_layer
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
name|floating_layer
operator|=
name|new_layer
expr_stmt|;
if|if
condition|(
name|floating_sel_drawable
operator|==
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
condition|)
name|new_floating_sel_drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|new_layer
argument_list|)
expr_stmt|;
comment|/*  Add the layer  */
if|if
condition|(
name|floating_layer
operator|!=
name|new_layer
condition|)
name|gimage_add_layer
argument_list|(
name|new_gimage
argument_list|,
name|new_layer
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/*  Copy the channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|new_channel
operator|=
name|channel_copy
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|new_channel
argument_list|)
operator|->
name|gimage
operator|=
name|new_gimage
expr_stmt|;
comment|/*  Make sure the copied channel doesn't say: "<old channel> copy"  */
name|g_free
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|new_channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|new_channel
argument_list|)
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|==
name|channel
condition|)
name|active_channel
operator|=
operator|(
name|new_channel
operator|)
expr_stmt|;
if|if
condition|(
name|floating_sel_drawable
operator|==
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
condition|)
name|new_floating_sel_drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|new_channel
argument_list|)
expr_stmt|;
comment|/*  Add the channel  */
name|gimage_add_channel
argument_list|(
name|new_gimage
argument_list|,
name|new_channel
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/*  Copy the selection mask  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|new_gimage
operator|->
name|selection_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
name|new_gimage
operator|->
name|selection_mask
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
name|new_gimage
operator|->
name|selection_mask
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
comment|/*  Set active layer, active channel  */
name|new_gimage
operator|->
name|active_layer
operator|=
name|active_layer
expr_stmt|;
name|new_gimage
operator|->
name|active_channel
operator|=
name|active_channel
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_attach
argument_list|(
name|floating_layer
argument_list|,
name|new_floating_sel_drawable
argument_list|)
expr_stmt|;
comment|/*  Copy the colormap if necessary  */
if|if
condition|(
name|new_gimage
operator|->
name|base_type
operator|==
name|INDEXED
condition|)
name|memcpy
argument_list|(
name|new_gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|new_gimage
operator|->
name|num_cols
operator|=
name|gimage
operator|->
name|num_cols
expr_stmt|;
comment|/*  copy state of all color channels  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|MAX_CHANNELS
condition|;
name|count
operator|++
control|)
block|{
name|new_gimage
operator|->
name|visible
index|[
name|count
index|]
operator|=
name|gimage
operator|->
name|visible
index|[
name|count
index|]
expr_stmt|;
name|new_gimage
operator|->
name|active
index|[
name|count
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|count
index|]
expr_stmt|;
block|}
name|gimage_enable_undo
argument_list|(
name|new_gimage
argument_list|)
expr_stmt|;
return|return
name|new_gimage
return|;
block|}
end_function

begin_comment
comment|/*  The duplicate procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|channel_ops_duplicate_args
name|ProcArg
name|channel_ops_duplicate_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|channel_ops_duplicate_out_args
name|ProcArg
name|channel_ops_duplicate_out_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"new_image"
block|,
literal|"the new, duplicated image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|channel_ops_duplicate_proc
name|ProcRecord
name|channel_ops_duplicate_proc
init|=
block|{
literal|"gimp_channel_ops_duplicate"
block|,
literal|"Duplicate the specified image"
block|,
literal|"This procedure duplicates the specified image, copying all layers, channels, and image information."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1997"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|1
block|,
name|channel_ops_duplicate_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|channel_ops_duplicate_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|channel_ops_duplicate_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|channel_ops_duplicate_invoker (Argument * args)
name|channel_ops_duplicate_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|,
modifier|*
name|new_gimage
decl_stmt|;
name|new_gimage
operator|=
name|NULL
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
operator|(
name|new_gimage
operator|=
name|duplicate
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|channel_ops_duplicate_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|new_gimage
operator|->
name|ID
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_function
name|void
DECL|function|channel_ops_duplicate (void * gimage_ptr)
name|channel_ops_duplicate
parameter_list|(
name|void
modifier|*
name|gimage_ptr
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GImage
modifier|*
name|new_gimage
decl_stmt|;
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|gimage_ptr
expr_stmt|;
name|new_gimage
operator|=
name|duplicate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gdisplay_new
argument_list|(
name|new_gimage
argument_list|,
literal|0x0101
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

