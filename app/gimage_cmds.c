begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"channel.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_decl_stmt
DECL|variable|list_images_proc
specifier|static
name|ProcRecord
name|list_images_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_proc
specifier|static
name|ProcRecord
name|image_new_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_proc
specifier|static
name|ProcRecord
name|image_resize_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_scale_proc
specifier|static
name|ProcRecord
name|image_scale_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_delete_proc
specifier|static
name|ProcRecord
name|image_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_free_shadow_proc
specifier|static
name|ProcRecord
name|image_free_shadow_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_proc
specifier|static
name|ProcRecord
name|image_get_layers_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_proc
specifier|static
name|ProcRecord
name|image_get_channels_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_unset_active_channel_proc
specifier|static
name|ProcRecord
name|image_unset_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_proc
specifier|static
name|ProcRecord
name|image_pick_correlate_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_proc
specifier|static
name|ProcRecord
name|image_raise_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_proc
specifier|static
name|ProcRecord
name|image_lower_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_proc
specifier|static
name|ProcRecord
name|image_raise_layer_to_top_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_proc
specifier|static
name|ProcRecord
name|image_lower_layer_to_bottom_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_proc
specifier|static
name|ProcRecord
name|image_merge_visible_layers_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_proc
specifier|static
name|ProcRecord
name|image_merge_down_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_proc
specifier|static
name|ProcRecord
name|image_flatten_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_proc
specifier|static
name|ProcRecord
name|image_add_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_proc
specifier|static
name|ProcRecord
name|image_remove_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_mask_proc
specifier|static
name|ProcRecord
name|image_add_layer_mask_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_mask_proc
specifier|static
name|ProcRecord
name|image_remove_layer_mask_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_channel_proc
specifier|static
name|ProcRecord
name|image_raise_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_channel_proc
specifier|static
name|ProcRecord
name|image_lower_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_channel_proc
specifier|static
name|ProcRecord
name|image_add_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_channel_proc
specifier|static
name|ProcRecord
name|image_remove_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_active_drawable_proc
specifier|static
name|ProcRecord
name|image_active_drawable_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_proc
specifier|static
name|ProcRecord
name|image_base_type_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_cmap_proc
specifier|static
name|ProcRecord
name|image_get_cmap_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_cmap_proc
specifier|static
name|ProcRecord
name|image_set_cmap_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_enable_undo_proc
specifier|static
name|ProcRecord
name|image_enable_undo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_disable_undo_proc
specifier|static
name|ProcRecord
name|image_disable_undo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_clean_all_proc
specifier|static
name|ProcRecord
name|image_clean_all_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_selection_proc
specifier|static
name|ProcRecord
name|image_floating_selection_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_proc
specifier|static
name|ProcRecord
name|image_floating_sel_attached_to_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_proc
specifier|static
name|ProcRecord
name|image_width_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_proc
specifier|static
name|ProcRecord
name|image_height_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_proc
specifier|static
name|ProcRecord
name|image_get_active_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_layer_proc
specifier|static
name|ProcRecord
name|image_set_active_layer_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_proc
specifier|static
name|ProcRecord
name|image_get_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_channel_proc
specifier|static
name|ProcRecord
name|image_set_active_channel_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_proc
specifier|static
name|ProcRecord
name|image_get_selection_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_proc
specifier|static
name|ProcRecord
name|image_get_component_active_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_active_proc
specifier|static
name|ProcRecord
name|image_set_component_active_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_proc
specifier|static
name|ProcRecord
name|image_get_component_visible_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_visible_proc
specifier|static
name|ProcRecord
name|image_set_component_visible_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_proc
specifier|static
name|ProcRecord
name|image_get_filename_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_filename_proc
specifier|static
name|ProcRecord
name|image_set_filename_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_proc
specifier|static
name|ProcRecord
name|image_get_resolution_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_resolution_proc
specifier|static
name|ProcRecord
name|image_set_resolution_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_proc
specifier|static
name|ProcRecord
name|image_get_unit_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_unit_proc
specifier|static
name|ProcRecord
name|image_set_unit_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_layer_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_channel_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_gimage_procs (void)
name|register_gimage_procs
parameter_list|(
name|void
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
operator|&
name|list_images_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_new_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_resize_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_scale_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_free_shadow_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_layers_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_channels_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_unset_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_pick_correlate_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_raise_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_lower_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_raise_layer_to_top_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_lower_layer_to_bottom_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_merge_visible_layers_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_merge_down_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_flatten_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_add_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_remove_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_add_layer_mask_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_remove_layer_mask_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_raise_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_lower_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_add_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_remove_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_active_drawable_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_base_type_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_cmap_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_cmap_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_enable_undo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_disable_undo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_clean_all_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_floating_selection_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_floating_sel_attached_to_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_width_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_height_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_active_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_active_layer_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_active_channel_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_selection_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_component_active_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_component_active_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_component_visible_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_component_visible_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_filename_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_filename_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_resolution_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_resolution_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_unit_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_set_unit_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_layer_by_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|image_get_channel_by_tattoo_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Yuup, this is somewhat unsmooth, to say the least */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimlist_cb (gpointer im,gpointer data)
name|gimlist_cb
parameter_list|(
name|gpointer
name|im
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|GSList
modifier|*
modifier|*
name|l
init|=
operator|(
name|GSList
operator|*
operator|*
operator|)
name|data
decl_stmt|;
operator|*
name|l
operator|=
name|g_slist_prepend
argument_list|(
operator|*
name|l
argument_list|,
name|im
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|list_images_invoker (Argument * args)
name|list_images_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gint32
name|num_images
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|image_ids
init|=
name|NULL
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gimage_foreach
argument_list|(
name|gimlist_cb
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|num_images
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_images
condition|)
block|{
name|image_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_images
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_images
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|list
operator|->
name|next
control|)
name|image_ids
index|[
name|i
index|]
operator|=
name|pdb_image_to_id
argument_list|(
name|GIMP_IMAGE
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|list_images_proc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_images
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|image_ids
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|list_images_outargs
specifier|static
name|ProcArg
name|list_images_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_images"
block|,
literal|"The number of images currently open"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"image_ids"
block|,
literal|"The list of images currently open"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|list_images_proc
specifier|static
name|ProcRecord
name|list_images_proc
init|=
block|{
literal|"gimp_list_images"
block|,
literal|"Returns the list of images currently open."
block|,
literal|"This procedure returns the list of images currently open in the GIMP."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|0
block|,
name|NULL
block|,
literal|2
block|,
name|list_images_outargs
block|,
block|{
block|{
name|list_images_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_new_invoker (Argument * args)
name|image_new_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gint32
name|width
decl_stmt|;
name|gint32
name|height
decl_stmt|;
name|gint32
name|type
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
init|=
name|NULL
decl_stmt|;
name|width
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|height
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|RGB
operator|||
name|type
operator|>
name|INDEXED
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|gimage
operator|=
name|gimage_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_new_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pdb_image_to_id
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_new_inargs
specifier|static
name|ProcArg
name|image_new_inargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"width"
block|,
literal|"The width of the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"height"
block|,
literal|"The height of the image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"type"
block|,
literal|"The type of image: { RGB (0), GRAY (1), INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_outargs
specifier|static
name|ProcArg
name|image_new_outargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the newly created image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_new_proc
specifier|static
name|ProcRecord
name|image_new_proc
init|=
block|{
literal|"gimp_image_new"
block|,
literal|"Creates a new image with the specified width, height, and type."
block|,
literal|"Creates a new image, undisplayed with the specified extents and type. A layer should be created and added before this image is displayed, or subsequent calls to 'gimp_display_new' with this image as an argument will fail. Layers can be created using the 'gimp_layer_new' commands. They can be added to an image using the 'gimp_image_add_layer' command."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_new_inargs
block|,
literal|1
block|,
name|image_new_outargs
block|,
block|{
block|{
name|image_new_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_resize_invoker (Argument * args)
name|image_resize_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gint32
name|offx
decl_stmt|;
name|gint32
name|offy
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offx
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|offy
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_add_busy_cursors_until_idle
argument_list|()
expr_stmt|;
name|gimage_resize
argument_list|(
name|gimage
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_resize_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_resize_inargs
specifier|static
name|ProcArg
name|image_resize_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_width"
block|,
literal|"New image width: 0< new_width"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_height"
block|,
literal|"New image height: 0< new_height"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offx"
block|,
literal|"x offset between upper left corner of old and new images: (new - old)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offy"
block|,
literal|"y offset between upper left corner of old and new images: (new - old)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_resize_proc
specifier|static
name|ProcRecord
name|image_resize_proc
init|=
block|{
literal|"gimp_image_resize"
block|,
literal|"Resize the image to the specified extents."
block|,
literal|"This procedure resizes the image so that it's new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. No bounds checking is currently provided, so don't supply parameters that are out of bounds. All channels within the image are resized according to the specified parameters; this includes the image selection mask. All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|image_resize_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_resize_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_scale_invoker (Argument * args)
name|image_scale_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimp_add_busy_cursors_until_idle
argument_list|()
expr_stmt|;
name|gimage_scale
argument_list|(
name|gimage
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_scale_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_scale_inargs
specifier|static
name|ProcArg
name|image_scale_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_width"
block|,
literal|"New image width: 0< new_width"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_height"
block|,
literal|"New image height: 0< new_height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_scale_proc
specifier|static
name|ProcRecord
name|image_scale_proc
init|=
block|{
literal|"gimp_image_scale"
block|,
literal|"Scale the image to the specified extents."
block|,
literal|"This procedure scales the image so that it's new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. No bounds checking is currently provided, so don't supply parameters that are out of bounds. All channels within the image are scaled according to the specified parameters; this includes the image selection mask. All layers within the image are repositioned according to the specified offsets."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_scale_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_scale_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_delete_invoker (Argument * args)
name|image_delete_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_delete
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_delete_inargs
specifier|static
name|ProcArg
name|image_delete_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_delete_proc
specifier|static
name|ProcRecord
name|image_delete_proc
init|=
block|{
literal|"gimp_image_delete"
block|,
literal|"Delete the specified image."
block|,
literal|"If there are no other references to this image it will be deleted. Other references are possible when more than one view to an image exists."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_free_shadow_invoker (Argument * args)
name|image_free_shadow_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_free_shadow_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_free_shadow_inargs
specifier|static
name|ProcArg
name|image_free_shadow_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_free_shadow_proc
specifier|static
name|ProcRecord
name|image_free_shadow_proc
init|=
block|{
literal|"gimp_image_free_shadow"
block|,
literal|"Free the specified image's shadow data (if it exists)."
block|,
literal|"This procedure is intended as a memory saving device. If any shadow memory has been allocated, it will be freed automatically on a call to 'gimp_image_delete'."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_free_shadow_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_free_shadow_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_layers_invoker (Argument * args)
name|image_get_layers_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_layers
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|layer_ids
init|=
name|NULL
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|num_layers
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_layers
condition|)
block|{
name|layer_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_layers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_layers
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|list
operator|->
name|next
control|)
name|layer_ids
index|[
name|i
index|]
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_layers
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|layer_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_layers_inargs
specifier|static
name|ProcArg
name|image_get_layers_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_outargs
specifier|static
name|ProcArg
name|image_get_layers_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_layers"
block|,
literal|"The number of layers contained in the image"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"layer_ids"
block|,
literal|"The list of layers contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layers_proc
specifier|static
name|ProcRecord
name|image_get_layers_proc
init|=
block|{
literal|"gimp_image_get_layers"
block|,
literal|"Returns the list of layers contained in the specified image."
block|,
literal|"This procedure returns the list of layers contained in the specified image. The order of layers is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_layers_inargs
block|,
literal|2
block|,
name|image_get_layers_outargs
block|,
block|{
block|{
name|image_get_layers_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_channels_invoker (Argument * args)
name|image_get_channels_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_channels
init|=
literal|0
decl_stmt|;
name|gint32
modifier|*
name|channel_ids
init|=
name|NULL
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|num_channels
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_channels
condition|)
block|{
name|channel_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
operator|,
name|list
operator|=
name|list
operator|->
name|next
control|)
name|channel_ids
index|[
name|i
index|]
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|list
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_channels_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_channels
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|channel_ids
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_channels_inargs
specifier|static
name|ProcArg
name|image_get_channels_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_outargs
specifier|static
name|ProcArg
name|image_get_channels_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_channels"
block|,
literal|"The number of channels contained in the image"
block|}
block|,
block|{
name|PDB_INT32ARRAY
block|,
literal|"channel_ids"
block|,
literal|"The list of channels contained in the image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channels_proc
specifier|static
name|ProcRecord
name|image_get_channels_proc
init|=
block|{
literal|"gimp_image_get_channels"
block|,
literal|"Returns the list of channels contained in the specified image."
block|,
literal|"This procedure returns the list of channels contained in the specified image. This does not include the selection mask, or layer masks. The order is from topmost to bottommost."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_channels_inargs
block|,
literal|2
block|,
name|image_get_channels_outargs
block|,
block|{
block|{
name|image_get_channels_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_unset_active_channel_invoker (Argument * args)
name|image_unset_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_unset_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_unset_active_channel_inargs
specifier|static
name|ProcArg
name|image_unset_active_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_unset_active_channel_proc
specifier|static
name|ProcRecord
name|image_unset_active_channel_proc
init|=
block|{
literal|"gimp_image_unset_active_channel"
block|,
literal|"Unsets the active channel in the specified image."
block|,
literal|"If an active channel exists, it is unset. There then exists no active channel, and if desired, one can be set through a call to 'Set Active Channel'. No error is returned in the case of no existing active channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_unset_active_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_unset_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_pick_correlate_layer_invoker (Argument * args)
name|image_pick_correlate_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|x
decl_stmt|;
name|gint32
name|y
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|layer
operator|=
name|gimage_pick_correlate_layer
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_pick_correlate_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_inargs
specifier|static
name|ProcArg
name|image_pick_correlate_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"x"
block|,
literal|"The x coordinate for the pick"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"y"
block|,
literal|"The y coordinate for the pick"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_outargs
specifier|static
name|ProcArg
name|image_pick_correlate_layer_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer found at the specified coordinates"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_pick_correlate_layer_proc
specifier|static
name|ProcRecord
name|image_pick_correlate_layer_proc
init|=
block|{
literal|"gimp_image_pick_correlate_layer"
block|,
literal|"Find the layer visible at the specified coordinates."
block|,
literal|"This procedure finds the layer which is visible at the specified coordinates. Layers which do not qualify are those whose extents do not pass within the specified coordinates, or which are transparent at the specified coordinates. This procedure will return -1 if no layer is found."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_pick_correlate_layer_inargs
block|,
literal|1
block|,
name|image_pick_correlate_layer_outargs
block|,
block|{
block|{
name|image_pick_correlate_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_layer_invoker (Argument * args)
name|image_raise_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_raise_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_layer_inargs
specifier|static
name|ProcArg
name|image_raise_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_proc
specifier|static
name|ProcRecord
name|image_raise_layer_proc
init|=
block|{
literal|"gimp_image_raise_layer"
block|,
literal|"Raise the specified layer in the image's layer stack"
block|,
literal|"This procedure raises the specified layer one step in the existing layer stack. It will not move the layer if there is no layer above it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_raise_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_layer_invoker (Argument * args)
name|image_lower_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_lower_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_layer_inargs
specifier|static
name|ProcArg
name|image_lower_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_proc
specifier|static
name|ProcRecord
name|image_lower_layer_proc
init|=
block|{
literal|"gimp_image_lower_layer"
block|,
literal|"Lower the specified layer in the image's layer stack"
block|,
literal|"This procedure lowers the specified layer one step in the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_lower_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_layer_to_top_invoker (Argument * args)
name|image_raise_layer_to_top_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_raise_layer_to_top
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_layer_to_top_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_inargs
specifier|static
name|ProcArg
name|image_raise_layer_to_top_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to raise to top"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_layer_to_top_proc
specifier|static
name|ProcRecord
name|image_raise_layer_to_top_proc
init|=
block|{
literal|"gimp_image_raise_layer_to_top"
block|,
literal|"Raise the specified layer in the image's layer stack to top of stack"
block|,
literal|"This procedure raises the specified layer to top of the existing layer stack. It will not move the layer if there is no layer above it, or the layer has no alpha channel."
block|,
literal|"Wolfgang Hofer, Sven Neumann"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_raise_layer_to_top_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_layer_to_top_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_layer_to_bottom_invoker (Argument * args)
name|image_lower_layer_to_bottom_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_lower_layer_to_bottom
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_layer_to_bottom_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_inargs
specifier|static
name|ProcArg
name|image_lower_layer_to_bottom_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower to bottom"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_layer_to_bottom_proc
specifier|static
name|ProcRecord
name|image_lower_layer_to_bottom_proc
init|=
block|{
literal|"gimp_image_lower_layer_to_bottom"
block|,
literal|"Lower the specified layer in the image's layer stack to bottom of stack"
block|,
literal|"This procedure lowers the specified layer to bottom of the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Wolfgang Hofer, Sven Neumann"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_lower_layer_to_bottom_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_layer_to_bottom_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_merge_visible_layers_invoker (Argument * args)
name|image_merge_visible_layers_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|merge_type
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|merge_type
operator|<
name|EXPAND_AS_NECESSARY
operator|||
name|merge_type
operator|>
name|CLIP_TO_BOTTOM_LAYER
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimage_merge_visible_layers
argument_list|(
name|gimage
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_merge_visible_layers_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_merge_visible_layers_inargs
specifier|static
name|ProcArg
name|image_merge_visible_layers_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"merge_type"
block|,
literal|"The type of merge: { EXPAND_AS_NECESSARY (0), CLIP_TO_IMAGE (1), CLIP_TO_BOTTOM_LAYER (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_outargs
specifier|static
name|ProcArg
name|image_merge_visible_layers_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_visible_layers_proc
specifier|static
name|ProcRecord
name|image_merge_visible_layers_proc
init|=
block|{
literal|"gimp_image_merge_visible_layers"
block|,
literal|"Merge the visible image layers into one."
block|,
literal|"This procedure combines the visible layers into a single layer using the specified merge type. A merge type of EXPAND_AS_NECESSARY expands the final layer to encompass the areas of the visible layers. A merge type of CLIP_TO_IMAGE clips the final layer to the extents of the image. A merge type of CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the bottommost layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_merge_visible_layers_inargs
block|,
literal|1
block|,
name|image_merge_visible_layers_outargs
block|,
block|{
block|{
name|image_merge_visible_layers_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_merge_down_invoker (Argument * args)
name|image_merge_down_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|merge_layer
decl_stmt|;
name|gint32
name|merge_type
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|merge_type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|merge_type
operator|<
name|EXPAND_AS_NECESSARY
operator|||
name|merge_type
operator|>
name|CLIP_TO_BOTTOM_LAYER
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_image_merge_down
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_merge_down_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_merge_down_inargs
specifier|static
name|ProcArg
name|image_merge_down_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"merge_layer"
block|,
literal|"The layer to merge down from"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"merge_type"
block|,
literal|"The type of merge: { EXPAND_AS_NECESSARY (0), CLIP_TO_IMAGE (1), CLIP_TO_BOTTOM_LAYER (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_outargs
specifier|static
name|ProcArg
name|image_merge_down_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_merge_down_proc
specifier|static
name|ProcRecord
name|image_merge_down_proc
init|=
block|{
literal|"gimp_image_merge_down"
block|,
literal|"Merge the layer passed and the first visible layer below."
block|,
literal|"This procedure combines the passed layer and the first visible layer below it using the specified merge type. A merge type of EXPAND_AS_NECESSARY expands the final layer to encompass the areas of the visible layers. A merge type of CLIP_TO_IMAGE clips the final layer to the extents of the image. A merge type of CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the bottommost layer."
block|,
literal|"Larry Ewing"
block|,
literal|"Larry Ewing"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_merge_down_inargs
block|,
literal|1
block|,
name|image_merge_down_outargs
block|,
block|{
block|{
name|image_merge_down_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_flatten_invoker (Argument * args)
name|image_flatten_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|layer
operator|=
name|gimage_flatten
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_flatten_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_flatten_inargs
specifier|static
name|ProcArg
name|image_flatten_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_outargs
specifier|static
name|ProcArg
name|image_flatten_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The resulting layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_flatten_proc
specifier|static
name|ProcRecord
name|image_flatten_proc
init|=
block|{
literal|"gimp_image_flatten"
block|,
literal|"Flatten all visible layers into a single layer. Discard all invisible layers."
block|,
literal|"This procedure combines the visible layers in a manner analogous to merging with the CLIP_TO_IMAGE merge type. Non-visible layers are discarded, and the resulting image is stripped of its alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_flatten_inargs
block|,
literal|1
block|,
name|image_flatten_outargs
block|,
block|{
block|{
name|image_flatten_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_layer_invoker (Argument * args)
name|image_add_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|position
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|(
name|drawable_color
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|RGB
operator|)
operator|||
operator|(
name|drawable_gray
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|GRAY
operator|)
operator|||
operator|(
name|drawable_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|!=
name|INDEXED
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|success
operator|=
name|gimage_add_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|MAX
argument_list|(
name|position
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_layer_inargs
specifier|static
name|ProcArg
name|image_add_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"position"
block|,
literal|"The layer position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_proc
specifier|static
name|ProcRecord
name|image_add_layer_proc
init|=
block|{
literal|"gimp_image_add_layer"
block|,
literal|"Add the specified layer to the image."
block|,
literal|"This procedure adds the specified layer to the gimage at the given position. If the position is specified as -1, then the layer is inserted at the top of the layer stack. If the layer to be added has no alpha channel, it must be added at position 0. The layer type must be compatible with the image base type."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_add_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_layer_invoker (Argument * args)
name|image_remove_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_layer_inargs
specifier|static
name|ProcArg
name|image_remove_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_proc
specifier|static
name|ProcRecord
name|image_remove_layer_proc
init|=
block|{
literal|"gimp_image_remove_layer"
block|,
literal|"Remove the specified layer from the image."
block|,
literal|"This procedure removes the specified layer from the image. If the layer doesn't exist, an error is returned. If there are no layers left in the image, this call will fail. If this layer is the last layer remaining, the image will become empty and have no active layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_remove_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_layer_mask_invoker (Argument * args)
name|image_add_layer_mask_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|LayerMask
modifier|*
name|mask
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|mask
operator|=
name|layer_mask_get_ID
argument_list|(
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_add_layer_mask
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|mask
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_layer_mask_inargs
specifier|static
name|ProcArg
name|image_add_layer_mask_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to receive the mask"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"mask"
block|,
literal|"The mask to add to the layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_layer_mask_proc
specifier|static
name|ProcRecord
name|image_add_layer_mask_proc
init|=
block|{
literal|"gimp_image_add_layer_mask"
block|,
literal|"Add a layer mask to the specified layer."
block|,
literal|"This procedure adds a layer mask to the specified layer. Layer masks serve as an additional alpha channel for a layer. This procedure will fail if a number of prerequisites aren't met. The layer cannot already have a layer mask. The specified mask must exist and have the same dimensions as the layer. Both the mask and the layer must have been created for use with the specified image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_add_layer_mask_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_layer_mask_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_layer_mask_invoker (Argument * args)
name|image_remove_layer_mask_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint32
name|mode
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|mode
operator|<
name|APPLY
operator|||
name|mode
operator|>
name|DISCARD
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_remove_layer_mask
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_layer_mask_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_layer_mask_inargs
specifier|static
name|ProcArg
name|image_remove_layer_mask_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer from which to remove mask"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"mode"
block|,
literal|"Removal mode: { APPLY (0), DISCARD (1) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_layer_mask_proc
specifier|static
name|ProcRecord
name|image_remove_layer_mask_proc
init|=
block|{
literal|"gimp_image_remove_layer_mask"
block|,
literal|"Remove the specified layer mask from the layer."
block|,
literal|"This procedure removes the specified layer mask from the layer. If the mask doesn't exist, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_remove_layer_mask_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_layer_mask_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_raise_channel_invoker (Argument * args)
name|image_raise_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_raise_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_raise_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_raise_channel_inargs
specifier|static
name|ProcArg
name|image_raise_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel to raise"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_raise_channel_proc
specifier|static
name|ProcRecord
name|image_raise_channel_proc
init|=
block|{
literal|"gimp_image_raise_channel"
block|,
literal|"Raise the specified channel in the image's channel stack"
block|,
literal|"This procedure raises the specified channel one step in the existing channel stack. It will not move the channel if there is no channel above it."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_raise_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_raise_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_lower_channel_invoker (Argument * args)
name|image_lower_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_lower_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_lower_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_lower_channel_inargs
specifier|static
name|ProcArg
name|image_lower_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer to lower"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_lower_channel_proc
specifier|static
name|ProcRecord
name|image_lower_channel_proc
init|=
block|{
literal|"gimp_image_lower_channel"
block|,
literal|"Lower the specified layer in the image's layer stack"
block|,
literal|"This procedure lowers the specified layer one step in the existing layer stack. It will not move the layer if there is no layer below it, or the layer has no alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_lower_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_lower_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_add_channel_invoker (Argument * args)
name|image_add_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|position
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_add_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
name|MAX
argument_list|(
name|position
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_add_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_add_channel_inargs
specifier|static
name|ProcArg
name|image_add_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"position"
block|,
literal|"The channel position"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_add_channel_proc
specifier|static
name|ProcRecord
name|image_add_channel_proc
init|=
block|{
literal|"gimp_image_add_channel"
block|,
literal|"Add the specified channel to the image."
block|,
literal|"This procedure adds the specified channel to the image. The position channel is not currently used, so the channel is always inserted at the top of the channel stack."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_add_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_add_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_remove_channel_invoker (Argument * args)
name|image_remove_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|=
name|channel_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_remove_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_remove_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_remove_channel_inargs
specifier|static
name|ProcArg
name|image_remove_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_remove_channel_proc
specifier|static
name|ProcRecord
name|image_remove_channel_proc
init|=
block|{
literal|"gimp_image_remove_channel"
block|,
literal|"Remove the specified channel from the image."
block|,
literal|"This procedure removes the specified channel from the image. If the channel doesn't exist, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_remove_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_remove_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_active_drawable_invoker (Argument * args)
name|image_active_drawable_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_active_drawable_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_active_drawable_inargs
specifier|static
name|ProcArg
name|image_active_drawable_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_active_drawable_outargs
specifier|static
name|ProcArg
name|image_active_drawable_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The active drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_active_drawable_proc
specifier|static
name|ProcRecord
name|image_active_drawable_proc
init|=
block|{
literal|"gimp_image_active_drawable"
block|,
literal|"Get the image's active drawable"
block|,
literal|"This procedure returns the ID of the image's active drawable. This can be either a layer, a channel, or a layer mask. The active drawable is specified by the active image channel. If that is -1, then by the active image layer. If the active image layer has a layer mask and the layer mask is in edit mode, then the layer mask is the active drawable."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_active_drawable_inargs
block|,
literal|1
block|,
name|image_active_drawable_outargs
block|,
block|{
block|{
name|image_active_drawable_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_base_type_invoker (Argument * args)
name|image_base_type_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|base_type
init|=
literal|0
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|base_type
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_base_type_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|base_type
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_base_type_inargs
specifier|static
name|ProcArg
name|image_base_type_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_outargs
specifier|static
name|ProcArg
name|image_base_type_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"base_type"
block|,
literal|"The image's base type: { RGB (0), GRAY (1), INDEXED (2) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_base_type_proc
specifier|static
name|ProcRecord
name|image_base_type_proc
init|=
block|{
literal|"gimp_image_base_type"
block|,
literal|"Get the base type of the image."
block|,
literal|"This procedure returns the image's base type. Layers in the image must be of this subtype, but can have an optional alpha channel."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_base_type_inargs
block|,
literal|1
block|,
name|image_base_type_outargs
block|,
block|{
block|{
name|image_base_type_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_cmap_invoker (Argument * args)
name|image_get_cmap_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_bytes
init|=
literal|0
decl_stmt|;
name|gint8
modifier|*
name|cmap
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|num_bytes
operator|=
name|gimage
operator|->
name|num_cols
operator|*
literal|3
expr_stmt|;
name|cmap
operator|=
name|g_new
argument_list|(
name|gint8
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cmap
argument_list|,
name|gimage_cmap
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_cmap_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_bytes
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|cmap
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_cmap_inargs
specifier|static
name|ProcArg
name|image_get_cmap_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_cmap_outargs
specifier|static
name|ProcArg
name|image_get_cmap_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_bytes"
block|,
literal|"Number of bytes in the colormap array: 0< num_bytes"
block|}
block|,
block|{
name|PDB_INT8ARRAY
block|,
literal|"cmap"
block|,
literal|"The image's colormap"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_cmap_proc
specifier|static
name|ProcRecord
name|image_get_cmap_proc
init|=
block|{
literal|"gimp_image_get_cmap"
block|,
literal|"Returns the image's colormap"
block|,
literal|"This procedure returns an actual pointer to the image's colormap, as well as the number of bytes contained in the colormap. The actual number of colors in the transmitted colormap will be \"num_bytes\" / 3. If the image is not of base type INDEXED, this pointer will be NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_cmap_inargs
block|,
literal|2
block|,
name|image_get_cmap_outargs
block|,
block|{
block|{
name|image_get_cmap_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_cmap_invoker (Argument * args)
name|image_set_cmap_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_bytes
decl_stmt|;
name|gint8
modifier|*
name|cmap
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_bytes
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|num_bytes
operator|<
literal|0
operator|||
name|num_bytes
operator|>
literal|768
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|cmap
operator|=
operator|(
name|gint8
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|num_cols
operator|&&
name|gimage
operator|->
name|cmap
condition|)
block|{
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|num_bytes
condition|)
block|{
name|gimage
operator|->
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|cmap
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|num_cols
operator|=
name|num_bytes
operator|/
literal|3
expr_stmt|;
comment|/* A colormap alteration affects the whole image */
name|gdisplays_update_area
argument_list|(
name|gimage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_cmap_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_cmap_inargs
specifier|static
name|ProcArg
name|image_set_cmap_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_bytes"
block|,
literal|"Number of bytes in the colormap array: 0<= num_bytes<= 768"
block|}
block|,
block|{
name|PDB_INT8ARRAY
block|,
literal|"cmap"
block|,
literal|"The new colormap values"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_cmap_proc
specifier|static
name|ProcRecord
name|image_set_cmap_proc
init|=
block|{
literal|"gimp_image_set_cmap"
block|,
literal|"Sets the entries in the image's colormap."
block|,
literal|"This procedure sets the entries in the specified image's colormap. The number of entries is specified by the \"num_bytes\" parameter and corresponds to the number of INT8 triples that must be contained in the \"cmap\" array. The actual number of colors in the transmitted colormap is \"num_bytes\" / 3."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_set_cmap_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_cmap_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_enable_undo_invoker (Argument * args)
name|image_enable_undo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_enable_undo
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_enable_undo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|success
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_enable_undo_inargs
specifier|static
name|ProcArg
name|image_enable_undo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_enable_undo_outargs
specifier|static
name|ProcArg
name|image_enable_undo_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"enabled"
block|,
literal|"True if the image undo has been enabled"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_enable_undo_proc
specifier|static
name|ProcRecord
name|image_enable_undo_proc
init|=
block|{
literal|"gimp_image_enable_undo"
block|,
literal|"Enable the image's undo stack."
block|,
literal|"This procedure enables the image's undo stack, allowing subsequent operations to store their undo steps. This is generally called in conjunction with 'gimp_image_disable_undo' to temporarily disable an image undo stack."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_enable_undo_inargs
block|,
literal|1
block|,
name|image_enable_undo_outargs
block|,
block|{
block|{
name|image_enable_undo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_disable_undo_invoker (Argument * args)
name|image_disable_undo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|gimage_disable_undo
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_disable_undo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|success
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_disable_undo_inargs
specifier|static
name|ProcArg
name|image_disable_undo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_disable_undo_outargs
specifier|static
name|ProcArg
name|image_disable_undo_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"disabled"
block|,
literal|"True if the image undo has been disabled"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_disable_undo_proc
specifier|static
name|ProcRecord
name|image_disable_undo_proc
init|=
block|{
literal|"gimp_image_disable_undo"
block|,
literal|"Disable the image's undo stack."
block|,
literal|"This procedure disables the image's undo stack, allowing subsequent operations to ignore their undo steps. This is generally called in conjunction with 'gimp_image_enable_undo' to temporarily disable an image undo stack. This is advantageous because saving undo steps can be time and memory intensive."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_disable_undo_inargs
block|,
literal|1
block|,
name|image_disable_undo_outargs
block|,
block|{
block|{
name|image_disable_undo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_clean_all_invoker (Argument * args)
name|image_clean_all_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_clean_all
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_clean_all_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_clean_all_inargs
specifier|static
name|ProcArg
name|image_clean_all_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_clean_all_proc
specifier|static
name|ProcRecord
name|image_clean_all_proc
init|=
block|{
literal|"gimp_image_clean_all"
block|,
literal|"Set the image dirty count to 0."
block|,
literal|"This procedure sets the specified image's dirty count to 0, allowing operations to occur without having a 'dirtied' image. This is especially useful for cre ating and loading images which should not initially be considered dirty, even though layers must be created, filled, and installed in the image."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_clean_all_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_clean_all_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_floating_selection_invoker (Argument * args)
name|image_floating_selection_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_sel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|floating_sel
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_floating_selection_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|floating_sel
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|floating_sel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_floating_selection_inargs
specifier|static
name|ProcArg
name|image_floating_selection_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_selection_outargs
specifier|static
name|ProcArg
name|image_floating_selection_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"floating_sel"
block|,
literal|"The image's floating selection"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_selection_proc
specifier|static
name|ProcRecord
name|image_floating_selection_proc
init|=
block|{
literal|"gimp_image_floating_selection"
block|,
literal|"Return the floating selection of the image."
block|,
literal|"This procedure returns the image's floating_sel, if it exists. If it doesn't exist, -1 is returned as the layer ID."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_floating_selection_inargs
block|,
literal|1
block|,
name|image_floating_selection_outargs
block|,
block|{
block|{
name|image_floating_selection_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_floating_sel_attached_to_invoker (Argument * args)
name|image_floating_sel_attached_to_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|floating_sel
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|GIMP_LAYER
argument_list|(
name|floating_sel
argument_list|)
operator|->
name|fs
operator|.
name|drawable
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_floating_sel_attached_to_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_inargs
specifier|static
name|ProcArg
name|image_floating_sel_attached_to_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_outargs
specifier|static
name|ProcArg
name|image_floating_sel_attached_to_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The drawable the floating selection is attached to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_floating_sel_attached_to_proc
specifier|static
name|ProcRecord
name|image_floating_sel_attached_to_proc
init|=
block|{
literal|"gimp_image_floating_sel_attached_to"
block|,
literal|"Return the drawable the floating selection is attached to."
block|,
literal|"This procedure returns the drawable the image's floating selection is attached to, if it exists. If it doesn't exist, -1 is returned as the drawable ID."
block|,
literal|"Wolfgang Hofer"
block|,
literal|"Wolfgang Hofer"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_floating_sel_attached_to_inargs
block|,
literal|1
block|,
name|image_floating_sel_attached_to_outargs
block|,
block|{
block|{
name|image_floating_sel_attached_to_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_width_invoker (Argument * args)
name|image_width_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_width_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_width_inargs
specifier|static
name|ProcArg
name|image_width_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_outargs
specifier|static
name|ProcArg
name|image_width_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"width"
block|,
literal|"The image's width"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_width_proc
specifier|static
name|ProcRecord
name|image_width_proc
init|=
block|{
literal|"gimp_image_width"
block|,
literal|"Return the width of the image"
block|,
literal|"This procedure returns the image's width. This value is independent of any of the layers in this image. This is the \"canvas\" width."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_width_inargs
block|,
literal|1
block|,
name|image_width_outargs
block|,
block|{
block|{
name|image_width_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_height_invoker (Argument * args)
name|image_height_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_height_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_height_inargs
specifier|static
name|ProcArg
name|image_height_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_outargs
specifier|static
name|ProcArg
name|image_height_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"height"
block|,
literal|"The image's height"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_height_proc
specifier|static
name|ProcRecord
name|image_height_proc
init|=
block|{
literal|"gimp_image_height"
block|,
literal|"Return the height of the image"
block|,
literal|"This procedure returns the image's width. This value is independent of any of the layers in this image. This is the \"canvas\" height."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_height_inargs
block|,
literal|1
block|,
name|image_height_outargs
block|,
block|{
block|{
name|image_height_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_active_layer_invoker (Argument * args)
name|image_get_active_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|active_layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|active_layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_active_layer_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|active_layer
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|active_layer
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_active_layer_inargs
specifier|static
name|ProcArg
name|image_get_active_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_outargs
specifier|static
name|ProcArg
name|image_get_active_layer_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"active_layer"
block|,
literal|"The active layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_layer_proc
specifier|static
name|ProcRecord
name|image_get_active_layer_proc
init|=
block|{
literal|"gimp_image_get_active_layer"
block|,
literal|"Returns the active layer of the specified image."
block|,
literal|"If there is an active layer, its ID will be returned, otherwise, -1. If a channel is currently active, then no layer will be. If a layer mask is active, then this will return the associated layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_active_layer_inargs
block|,
literal|1
block|,
name|image_get_active_layer_outargs
block|,
block|{
block|{
name|image_get_active_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_active_layer_invoker (Argument * args)
name|image_set_active_layer_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|active_layer
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active_layer
operator|=
name|layer_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_layer
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|active_layer
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_active_layer_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_active_layer_inargs
specifier|static
name|ProcArg
name|image_set_active_layer_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_LAYER
block|,
literal|"active_layer"
block|,
literal|"The new image active layer"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_layer_proc
specifier|static
name|ProcRecord
name|image_set_active_layer_proc
init|=
block|{
literal|"gimp_image_set_active_layer"
block|,
literal|"Set the active layer of the specified image."
block|,
literal|"If the layer exists, it is set as the active layer in the image. Any previous active layer or channel is set to inactive. An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_set_active_layer_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_active_layer_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_active_channel_invoker (Argument * args)
name|image_get_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|active_channel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|active_channel
operator|=
name|gimage_get_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_active_channel_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|active_channel
condition|?
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|active_channel
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_active_channel_inargs
specifier|static
name|ProcArg
name|image_get_active_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_outargs
specifier|static
name|ProcArg
name|image_get_active_channel_outargs
index|[]
init|=
block|{
block|{
name|PDB_CHANNEL
block|,
literal|"active_channel"
block|,
literal|"The active channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_active_channel_proc
specifier|static
name|ProcRecord
name|image_get_active_channel_proc
init|=
block|{
literal|"gimp_image_get_active_channel"
block|,
literal|"Returns the active channel of the specified image."
block|,
literal|"If there is an active channel, this will return the channel ID, otherwise, -1."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_active_channel_inargs
block|,
literal|1
block|,
name|image_get_active_channel_outargs
block|,
block|{
block|{
name|image_get_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_active_channel_invoker (Argument * args)
name|image_set_active_channel_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|active_channel
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active_channel
operator|=
name|channel_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_channel
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|active_channel
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_active_channel_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_active_channel_inargs
specifier|static
name|ProcArg
name|image_set_active_channel_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_CHANNEL
block|,
literal|"active_channel"
block|,
literal|"The new image active channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_active_channel_proc
specifier|static
name|ProcRecord
name|image_set_active_channel_proc
init|=
block|{
literal|"gimp_image_set_active_channel"
block|,
literal|"Set the active channel of the specified image."
block|,
literal|"If the channel exists, it is set as the active channel in the image. Any previous active channel or channel is set to inactive. An exception is a previously existing floating selection, in which case this procedure will return an execution error."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_set_active_channel_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_active_channel_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_selection_invoker (Argument * args)
name|image_get_selection_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|selection
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
operator|(
name|selection
operator|=
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_selection_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|selection
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_selection_inargs
specifier|static
name|ProcArg
name|image_get_selection_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_outargs
specifier|static
name|ProcArg
name|image_get_selection_outargs
index|[]
init|=
block|{
block|{
name|PDB_SELECTION
block|,
literal|"selection"
block|,
literal|"The selection channel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_selection_proc
specifier|static
name|ProcRecord
name|image_get_selection_proc
init|=
block|{
literal|"gimp_image_get_selection"
block|,
literal|"Returns the selection of the specified image."
block|,
literal|"This will always return a valid ID for a selection--which is represented as a channel internally."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_selection_inargs
block|,
literal|1
block|,
name|image_get_selection_outargs
block|,
block|{
block|{
name|image_get_selection_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_component_active_invoker (Argument * args)
name|image_get_component_active_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|RED_CHANNEL
operator|||
name|component
operator|>
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_component_active_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage_get_component_active
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_component_active_inargs
specifier|static
name|ProcArg
name|image_get_component_active_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED_CHANNEL (0), GREEN_CHANNEL (1), BLUE_CHANNEL (2), GRAY_CHANNEL (3), INDEXED_CHANNEL (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_outargs
specifier|static
name|ProcArg
name|image_get_component_active_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"active"
block|,
literal|"Component is active (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_active_proc
specifier|static
name|ProcRecord
name|image_get_component_active_proc
init|=
block|{
literal|"gimp_image_get_component_active"
block|,
literal|"Returns the image component is active of the specified image."
block|,
literal|"This procedure returns the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is active or inactive--whether or not it can be modified. If the specified component is not valid for the image type, and error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_get_component_active_inargs
block|,
literal|1
block|,
name|image_get_component_active_outargs
block|,
block|{
block|{
name|image_get_component_active_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_component_active_invoker (Argument * args)
name|image_set_component_active_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gboolean
name|active
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|RED_CHANNEL
operator|||
name|component
operator|>
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|active
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_component_active
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_component_active_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_component_active_inargs
specifier|static
name|ProcArg
name|image_set_component_active_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED_CHANNEL (0), GREEN_CHANNEL (1), BLUE_CHANNEL (2), GRAY_CHANNEL (3), INDEXED_CHANNEL (4) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"active"
block|,
literal|"Component is active (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_active_proc
specifier|static
name|ProcRecord
name|image_set_component_active_proc
init|=
block|{
literal|"gimp_image_set_component_active"
block|,
literal|"Set the image component is active of the specified image."
block|,
literal|"This procedure sets the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is active or inactive--whether or not it can be modified. If the specified component is not valid for the image type, and error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_set_component_active_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_component_active_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_component_visible_invoker (Argument * args)
name|image_get_component_visible_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|RED_CHANNEL
operator|||
name|component
operator|>
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_component_visible_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_component_visible_inargs
specifier|static
name|ProcArg
name|image_get_component_visible_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED_CHANNEL (0), GREEN_CHANNEL (1), BLUE_CHANNEL (2), GRAY_CHANNEL (3), INDEXED_CHANNEL (4) }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_outargs
specifier|static
name|ProcArg
name|image_get_component_visible_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"visible"
block|,
literal|"Component is visible (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_component_visible_proc
specifier|static
name|ProcRecord
name|image_get_component_visible_proc
init|=
block|{
literal|"gimp_image_get_component_visible"
block|,
literal|"Returns the image component is visible of the specified image."
block|,
literal|"This procedure returns the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is visible or invisible--whether or not it can be seen. If the specified component is not valid for the image type, and error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_get_component_visible_inargs
block|,
literal|1
block|,
name|image_get_component_visible_outargs
block|,
block|{
block|{
name|image_get_component_visible_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_component_visible_invoker (Argument * args)
name|image_set_component_visible_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|component
decl_stmt|;
name|gboolean
name|visible
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|component
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|RED_CHANNEL
operator|||
name|component
operator|>
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|visible
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|component
operator|==
name|GRAY_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|component
operator|==
name|INDEXED_CHANNEL
condition|)
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|INDEXED
expr_stmt|;
else|else
name|success
operator|=
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
operator|==
name|RGB
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_component_visible
argument_list|(
name|gimage
argument_list|,
name|component
argument_list|,
name|visible
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_component_visible_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_component_visible_inargs
specifier|static
name|ProcArg
name|image_set_component_visible_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"component"
block|,
literal|"The image component: { RED_CHANNEL (0), GREEN_CHANNEL (1), BLUE_CHANNEL (2), GRAY_CHANNEL (3), INDEXED_CHANNEL (4) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"visible"
block|,
literal|"Component is visible (TRUE or FALSE)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_component_visible_proc
specifier|static
name|ProcRecord
name|image_set_component_visible_proc
init|=
block|{
literal|"gimp_image_set_component_visible"
block|,
literal|"Set the image component is visible of the specified image."
block|,
literal|"This procedure sets the specified image's image component (i.e. Red, Green, Blue intensity channels in an RGB image) is visible or invisible--whether or not it can be seen. If the specified component is not valid for the image type, and error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_set_component_visible_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_component_visible_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_filename_invoker (Argument * args)
name|image_get_filename_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_filename_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_filename_inargs
specifier|static
name|ProcArg
name|image_get_filename_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_outargs
specifier|static
name|ProcArg
name|image_get_filename_outargs
index|[]
init|=
block|{
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_filename_proc
specifier|static
name|ProcRecord
name|image_get_filename_proc
init|=
block|{
literal|"gimp_image_get_filename"
block|,
literal|"Returns the filename of the specified image."
block|,
literal|"This procedure returns the specified image's filename--if it was loaded or has since been saved. Otherwise, returns NULL."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_filename_inargs
block|,
literal|1
block|,
name|image_get_filename_outargs
block|,
block|{
block|{
name|image_get_filename_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_filename_invoker (Argument * args)
name|image_set_filename_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|filename
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage_set_filename
argument_list|(
name|gimage
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_filename_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_filename_inargs
specifier|static
name|ProcArg
name|image_set_filename_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The new image filename"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_filename_proc
specifier|static
name|ProcRecord
name|image_set_filename_proc
init|=
block|{
literal|"gimp_image_set_filename"
block|,
literal|"Set the filename of the specified image."
block|,
literal|"This procedure sets the specified image's filename."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_set_filename_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_filename_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_resolution_invoker (Argument * args)
name|image_get_resolution_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_resolution_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_resolution_inargs
specifier|static
name|ProcArg
name|image_get_resolution_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_outargs
specifier|static
name|ProcArg
name|image_get_resolution_outargs
index|[]
init|=
block|{
block|{
name|PDB_FLOAT
block|,
literal|"xresolution"
block|,
literal|"The resolutionin the x-axis, in dots per inch"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"yresolution"
block|,
literal|"The resolutionin the y-axis, in dots per inch"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_resolution_proc
specifier|static
name|ProcRecord
name|image_get_resolution_proc
init|=
block|{
literal|"gimp_image_get_resolution"
block|,
literal|"Returns the resolution of the specified image."
block|,
literal|"This procedure returns the specified image's resolution in dots per inch. This value is independent of any of the layers in this image."
block|,
literal|"Austin Donnelly"
block|,
literal|"Austin Donnelly"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_resolution_inargs
block|,
literal|2
block|,
name|image_get_resolution_outargs
block|,
block|{
block|{
name|image_get_resolution_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_resolution_invoker (Argument * args)
name|image_set_resolution_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_resolution_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_resolution_inargs
specifier|static
name|ProcArg
name|image_set_resolution_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"xresolution"
block|,
literal|"The new image resolution (xresolution)in the x-axis, in dots per inch"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"yresolution"
block|,
literal|"The new image resolution (yresolution)in the y-axis, in dots per inch"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_resolution_proc
specifier|static
name|ProcRecord
name|image_set_resolution_proc
init|=
block|{
literal|"gimp_image_set_resolution"
block|,
literal|"Set the resolution of the specified image."
block|,
literal|"This procedure sets the specified image's resolution in dots per inch. This value is independent of any of the layers in this image. No scaling or resizing is performed."
block|,
literal|"Austin Donnelly"
block|,
literal|"Austin Donnelly"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|image_set_resolution_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_resolution_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_unit_invoker (Argument * args)
name|image_get_unit_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_unit_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|gimage
operator|->
name|unit
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_unit_inargs
specifier|static
name|ProcArg
name|image_get_unit_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_outargs
specifier|static
name|ProcArg
name|image_get_unit_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"unit"
block|,
literal|"The unit"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_unit_proc
specifier|static
name|ProcRecord
name|image_get_unit_proc
init|=
block|{
literal|"gimp_image_get_unit"
block|,
literal|"Returns the unit of the specified image."
block|,
literal|"This procedure returns the specified image's unit. This value is independent of any of the layers in this image. See the gimp_unit_* procedure definitions for the valid range of unit IDs and a description of the unit system."
block|,
literal|"Michael Naterrer"
block|,
literal|"Michael Naterrer"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|image_get_unit_inargs
block|,
literal|1
block|,
name|image_get_unit_outargs
block|,
block|{
block|{
name|image_get_unit_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_set_unit_invoker (Argument * args)
name|image_set_unit_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GUnit
name|unit
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|unit
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|unit
operator|<
name|UNIT_INCH
operator|||
name|unit
operator|>=
name|gimp_unit_get_number_of_units
argument_list|()
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|image_set_unit_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_set_unit_inargs
specifier|static
name|ProcArg
name|image_set_unit_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"unit"
block|,
literal|"The new image unit"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_set_unit_proc
specifier|static
name|ProcRecord
name|image_set_unit_proc
init|=
block|{
literal|"gimp_image_set_unit"
block|,
literal|"Set the unit of the specified image."
block|,
literal|"This procedure sets the specified image's unit. No scaling or resizing is performed. This value is independent of any of the layers in this image. See the gimp_unit_* procedure definitions for the valid range of unit IDs and a description of the unit system."
block|,
literal|"Michael Naterrer"
block|,
literal|"Michael Naterrer"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_set_unit_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|image_set_unit_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_layer_by_tattoo_invoker (Argument * args)
name|image_get_layer_by_tattoo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|tattoo
operator|==
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|layer
operator|=
name|gimp_image_get_layer_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_layer_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_inargs
specifier|static
name|ProcArg
name|image_get_layer_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the layer to find"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_outargs
specifier|static
name|ProcArg
name|image_get_layer_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|PDB_LAYER
block|,
literal|"layer"
block|,
literal|"The layer with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_layer_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_layer_by_tattoo_proc
init|=
block|{
literal|"gimp_image_get_layer_by_tattoo"
block|,
literal|"Find a layer with a given tattoo in an image."
block|,
literal|"This procedure returns the layer with the given tattoo in the specified image."
block|,
literal|"Jay Cox"
block|,
literal|"Jay Cox"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_get_layer_by_tattoo_inargs
block|,
literal|1
block|,
name|image_get_layer_by_tattoo_outargs
block|,
block|{
block|{
name|image_get_layer_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|image_get_channel_by_tattoo_invoker (Argument * args)
name|image_get_channel_by_tattoo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|Channel
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|tattoo
operator|==
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|channel
operator|=
name|gimp_image_get_channel_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
expr_stmt|;
name|success
operator|=
name|channel
operator|!=
name|NULL
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|image_get_channel_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_inargs
specifier|static
name|ProcArg
name|image_get_channel_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the channel to find"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_outargs
specifier|static
name|ProcArg
name|image_get_channel_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|PDB_CHANNEL
block|,
literal|"channel"
block|,
literal|"The channel with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_get_channel_by_tattoo_proc
specifier|static
name|ProcRecord
name|image_get_channel_by_tattoo_proc
init|=
block|{
literal|"gimp_image_get_channel_by_tattoo"
block|,
literal|"Find a channel with a given tattoo in an image."
block|,
literal|"This procedure returns the channel with the given tattoo in the specified image."
block|,
literal|"Jay Cox"
block|,
literal|"Jay Cox"
block|,
literal|"1998"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|image_get_channel_by_tattoo_inargs
block|,
literal|1
block|,
name|image_get_channel_by_tattoo_outargs
block|,
block|{
block|{
name|image_get_channel_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

