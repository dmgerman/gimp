begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"bezier_select.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_define
DECL|macro|BEZIER_START
define|#
directive|define
name|BEZIER_START
value|1
end_define

begin_define
DECL|macro|BEZIER_ADD
define|#
directive|define
name|BEZIER_ADD
value|2
end_define

begin_define
DECL|macro|BEZIER_EDIT
define|#
directive|define
name|BEZIER_EDIT
value|4
end_define

begin_define
DECL|macro|BEZIER_DRAG
define|#
directive|define
name|BEZIER_DRAG
value|8
end_define

begin_define
DECL|macro|BEZIER_DRAW_CURVE
define|#
directive|define
name|BEZIER_DRAW_CURVE
value|1
end_define

begin_define
DECL|macro|BEZIER_DRAW_CURRENT
define|#
directive|define
name|BEZIER_DRAW_CURRENT
value|2
end_define

begin_define
DECL|macro|BEZIER_DRAW_HANDLES
define|#
directive|define
name|BEZIER_DRAW_HANDLES
value|4
end_define

begin_define
DECL|macro|BEZIER_DRAW_ALL
define|#
directive|define
name|BEZIER_DRAW_ALL
value|(BEZIER_DRAW_CURVE | BEZIER_DRAW_HANDLES)
end_define

begin_define
DECL|macro|BEZIER_WIDTH
define|#
directive|define
name|BEZIER_WIDTH
value|8
end_define

begin_define
DECL|macro|BEZIER_HALFWIDTH
define|#
directive|define
name|BEZIER_HALFWIDTH
value|4
end_define

begin_define
DECL|macro|SUBDIVIDE
define|#
directive|define
name|SUBDIVIDE
value|1000
end_define

begin_define
DECL|macro|IMAGE_COORDS
define|#
directive|define
name|IMAGE_COORDS
value|1
end_define

begin_define
DECL|macro|AA_IMAGE_COORDS
define|#
directive|define
name|AA_IMAGE_COORDS
value|2
end_define

begin_define
DECL|macro|SCREEN_COORDS
define|#
directive|define
name|SCREEN_COORDS
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE2
define|#
directive|define
name|SUPERSAMPLE2
value|9
end_define

begin_define
DECL|macro|NO
define|#
directive|define
name|NO
value|0
end_define

begin_define
DECL|macro|YES
define|#
directive|define
name|YES
value|1
end_define

begin_comment
comment|/*  bezier select type definitions */
end_comment

begin_typedef
DECL|typedef|BezierSelect
typedef|typedef
name|struct
name|_bezier_select
name|BezierSelect
typedef|;
end_typedef

begin_typedef
DECL|typedef|BezierMatrix
typedef|typedef
name|double
name|BezierMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_typedef
DECL|typedef|BezierPointsFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|BezierPointsFunc
function_decl|)
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_struct
DECL|struct|_bezier_select
struct|struct
name|_bezier_select
block|{
DECL|member|state
name|int
name|state
decl_stmt|;
comment|/* start, add, edit or drag          */
DECL|member|draw
name|int
name|draw
decl_stmt|;
comment|/* all or part                       */
DECL|member|closed
name|int
name|closed
decl_stmt|;
comment|/* is the curve closed               */
DECL|member|core
name|DrawCore
modifier|*
name|core
decl_stmt|;
comment|/* Core drawing object               */
DECL|member|points
name|BezierPoint
modifier|*
name|points
decl_stmt|;
comment|/* the curve                         */
DECL|member|cur_anchor
name|BezierPoint
modifier|*
name|cur_anchor
decl_stmt|;
comment|/* the current active anchor point   */
DECL|member|cur_control
name|BezierPoint
modifier|*
name|cur_control
decl_stmt|;
comment|/* the current active control point  */
DECL|member|last_point
name|BezierPoint
modifier|*
name|last_point
decl_stmt|;
comment|/* the last point on the curve       */
DECL|member|num_points
name|int
name|num_points
decl_stmt|;
comment|/* number of points in the curve     */
DECL|member|mask
name|Channel
modifier|*
name|mask
decl_stmt|;
comment|/* null if the curve is open         */
DECL|member|scanlines
name|GSList
modifier|*
modifier|*
name|scanlines
decl_stmt|;
comment|/* used in converting a curve        */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|bezier_select_reset
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_add_point
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_curve
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|BezierPointsFunc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_compose
parameter_list|(
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|basis
specifier|static
name|BezierMatrix
name|basis
init|=
block|{
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
operator|-
literal|6
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bezier_options
specifier|static
name|SelectionOptions
modifier|*
name|bezier_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|Tool
modifier|*
DECL|function|tools_new_bezier_select ()
name|tools_new_bezier_select
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
comment|/*  The tool options  */
if|if
condition|(
operator|!
name|bezier_options
condition|)
name|bezier_options
operator|=
name|create_selection_options
argument_list|(
name|BEZIER_SELECT
argument_list|)
expr_stmt|;
name|tool
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierSelect
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|bezier_select_draw
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|BEZIER_SELECT
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|1
expr_stmt|;
comment|/*  Do not allow scrolling  */
name|tool
operator|->
name|auto_snap_to
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|bezier_sel
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|bezier_select_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|bezier_select_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|bezier_select_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|rect_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|bezier_select_control
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|FALSE
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_bezier_select (Tool * tool)
name|tools_free_bezier_select
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|bezier_select_load (void * gdisp_ptr,BezierPoint * pts,int num_pts,int closed)
name|bezier_select_load
parameter_list|(
name|void
modifier|*
name|gdisp_ptr
parameter_list|,
name|BezierPoint
modifier|*
name|pts
parameter_list|,
name|int
name|num_pts
parameter_list|,
name|int
name|closed
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
comment|/*  select the bezier tool  */
name|gtk_widget_activate
argument_list|(
name|tool_widgets
index|[
name|tool_info
index|[
name|BEZIER_SELECT
index|]
operator|.
name|toolbar_position
index|]
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
operator|(
name|BezierSelect
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|pts
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|pts
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
name|num_pts
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_reset (BezierSelect * bezier_sel)
name|bezier_select_reset
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|temp_pt
decl_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
operator|(
name|bezier_sel
operator|->
name|closed
operator|)
condition|?
operator|(
name|bezier_sel
operator|->
name|points
operator|)
else|:
operator|(
name|NULL
operator|)
expr_stmt|;
do|do
block|{
name|temp_pt
operator|=
name|points
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|temp_pt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
comment|/* we are starting the curve */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* draw everything by default */
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* the curve is initally open */
name|bezier_sel
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/* initially there are no points */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
comment|/* intially there are no points */
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/* empty mask */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_press (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|int
name|grab_pointer
decl_stmt|;
name|int
name|op
decl_stmt|,
name|replace
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|grab_pointer
operator|=
literal|0
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp_ptr
operator|!=
name|tool
operator|->
name|gdisp_ptr
condition|)
block|{
name|printf
argument_list|(
literal|"Reset!\n"
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
switch|switch
condition|(
name|bezier_sel
operator|->
name|state
condition|)
block|{
case|case
name|BEZIER_START
case|:
name|grab_pointer
operator|=
literal|1
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskTranslate
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|layer_is_floating_sel
argument_list|(
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|)
operator|)
operator|&&
name|gdisplay_mask_value
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|)
operator|>
name|HALF_WAY
condition|)
block|{
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskToLayerTranslate
argument_list|)
expr_stmt|;
break|break;
block|}
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER_ADD
case|:
name|grab_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|points
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_EDIT
case|:
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
literal|"tried to edit on open bezier curve"
argument_list|)
expr_stmt|;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
comment|/* find if the button press occurred on a point */
do|do
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
comment|/* set the current anchor and control points */
switch|switch
condition|(
name|points
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
break|break;
block|}
name|grab_pointer
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
if|if
condition|(
operator|!
name|grab_pointer
operator|&&
name|channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
comment|/*  If we're antialiased, then recompute the 	   *  mask... 	   */
if|if
condition|(
name|bezier_options
operator|->
name|antialias
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|ADD
expr_stmt|;
name|replace
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|feather
condition|)
name|channel_feather
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_sel
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/*  show selection on all views  */
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* draw the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|&=
operator|~
operator|(
name|BEZIER_DRAG
operator|)
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
specifier|static
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|anchor
decl_stmt|;
name|BezierPoint
modifier|*
name|opposite_control
decl_stmt|;
name|int
name|offsetx
decl_stmt|;
name|int
name|offsety
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
return|return;
name|gdisp
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|cur_anchor
operator|||
operator|!
name|bezier_sel
operator|->
name|cur_control
condition|)
return|return;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the first point then change the state and "remember" the point.    */
if|if
condition|(
operator|!
operator|(
name|bezier_sel
operator|->
name|state
operator|&
name|BEZIER_DRAG
operator|)
condition|)
block|{
name|bezier_sel
operator|->
name|state
operator||=
name|BEZIER_DRAG
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
condition|)
block|{
comment|/* the control key is down ... move the current anchor point */
comment|/* we must also move the neighboring control points appropriately */
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the control key is not down ... we move the current control point */
name|offsetx
operator|=
name|x
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_control
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
comment|/* if the shift key is not down then we align the opposite control */
comment|/* point...ie the opposite control point acts like a mirror of the */
comment|/* current control point */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|anchor
operator|=
name|NULL
expr_stmt|;
name|opposite_control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|fatal_error
argument_list|(
literal|"Encountered orphaned bezier control point"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opposite_control
condition|)
block|{
name|offsetx
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
operator|-
name|anchor
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
operator|-
name|anchor
operator|->
name|y
expr_stmt|;
name|opposite_control
operator|->
name|x
operator|=
name|anchor
operator|->
name|x
operator|-
name|offsetx
expr_stmt|;
name|opposite_control
operator|->
name|y
operator|=
name|anchor
operator|->
name|y
operator|-
name|offsety
expr_stmt|;
block|}
block|}
block|}
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_control (Tool * tool,int action,gpointer gdisp_ptr)
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|int
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_draw (Tool * tool)
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|int
name|draw_curve
decl_stmt|;
name|int
name|draw_handles
decl_stmt|;
name|int
name|draw_current
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|draw
condition|)
return|return;
name|draw_curve
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_current
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|draw_handles
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_HANDLES
expr_stmt|;
comment|/* reset to the default drawing state of drawing the curve and handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|points
operator|->
name|x
argument_list|,
name|points
operator|->
name|y
argument_list|,
operator|&
name|points
operator|->
name|sx
argument_list|,
operator|&
name|points
operator|->
name|sy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|draw_curve
condition|)
name|bezier_draw_curve
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|draw_handles
condition|)
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|draw_current
condition|)
name|bezier_draw_current
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_add_point (BezierSelect * bezier_sel,int type,int x,int y)
name|bezier_add_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|newpt
decl_stmt|;
name|newpt
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
name|newpt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|newpt
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|newpt
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|newpt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|newpt
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|points
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|newpt
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|newpt
expr_stmt|;
break|break;
block|}
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_offset_point (BezierPoint * pt,int x,int y)
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|x
operator|+=
name|x
expr_stmt|;
name|pt
operator|->
name|y
operator|+=
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bezier_check_point (BezierPoint * pt,int x,int y,int halfwidth)
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|l
operator|=
name|pt
operator|->
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|pt
operator|->
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|pt
operator|->
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|pt
operator|->
name|y
operator|+
name|halfwidth
expr_stmt|;
return|return
operator|(
operator|(
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|y
operator|<=
name|b
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_curve (BezierSelect * bezier_sel)
name|bezier_draw_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
block|}
else|else
block|{
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|num_points
operator|>=
literal|4
condition|)
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_handles (BezierSelect * bezier_sel)
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|<=
literal|0
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|points
operator|==
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|next
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|num_points
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_current (BezierSelect * bezier_sel)
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_point (BezierSelect * bezier_sel,BezierPoint * pt,int fill)
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|fill
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
switch|switch
condition|(
name|pt
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_CONTROL
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_line (BezierSelect * bezier_sel,BezierPoint * pt1,BezierPoint * pt2)
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt1
parameter_list|,
name|BezierPoint
modifier|*
name|pt2
parameter_list|)
block|{
if|if
condition|(
name|pt1
operator|&&
name|pt2
condition|)
block|{
name|gdk_draw_line
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|pt1
operator|->
name|sx
argument_list|,
name|pt1
operator|->
name|sy
argument_list|,
name|pt2
operator|->
name|sx
argument_list|,
name|pt2
operator|->
name|sy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment (BezierSelect * bezier_sel,BezierPoint * points,int subdivisions,int space,BezierPointsFunc points_func)
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|space
parameter_list|,
name|BezierPointsFunc
name|points_func
parameter_list|)
block|{
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
specifier|static
name|GdkPoint
name|gdk_points
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|npoints
init|=
literal|256
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|fatal_error
argument_list|(
literal|"bad bezier segment"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|fatal_error
argument_list|(
literal|"unknown coordinate space: %d"
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|lastx
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|lasty
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then draw it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
comment|/* add the point to the point buffer */
name|gdk_points
index|[
name|index
index|]
operator|.
name|x
operator|=
name|newx
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|y
operator|=
name|newy
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* if the point buffer is full put it to the screen and zero it out */
if|if
condition|(
name|index
operator|>=
name|npoints
condition|)
block|{
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* if there are points in the buffer, then put them on the screen */
if|if
condition|(
name|index
condition|)
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints)
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|gdk_draw_points
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|points
argument_list|,
name|npoints
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_compose (BezierMatrix a,BezierMatrix b,BezierMatrix ab)
name|bezier_compose
parameter_list|(
name|BezierMatrix
name|a
parameter_list|,
name|BezierMatrix
name|b
parameter_list|,
name|BezierMatrix
name|ab
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ab
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|a
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|b
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|b
index|[
literal|1
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|b
index|[
literal|2
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|3
index|]
operator|*
name|b
index|[
literal|3
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
DECL|variable|start_convert
specifier|static
name|int
name|start_convert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|width
DECL|variable|height
specifier|static
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lastx
specifier|static
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lasty
specifier|static
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|bezier_convert (BezierSelect * bezier_sel,GDisplay * gdisp,int subdivisions,int antialias)
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|antialias
parameter_list|)
block|{
name|PixelRegion
name|maskPR
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|draw_type
decl_stmt|;
name|int
modifier|*
name|vals
decl_stmt|,
name|val
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|x
decl_stmt|,
name|x2
decl_stmt|,
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
literal|"tried to convert an open bezier curve"
argument_list|)
expr_stmt|;
comment|/* destroy previous mask */
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
block|{
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get the new mask's maximum extents */
if|if
condition|(
name|antialias
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|draw_type
operator|=
name|AA_IMAGE_COORDS
expr_stmt|;
comment|/* allocate value array  */
name|vals
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
expr_stmt|;
name|draw_type
operator|=
name|IMAGE_COORDS
expr_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new mask */
name|bezier_sel
operator|->
name|mask
operator|=
name|channel_ref
argument_list|(
name|channel_new_mask
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|ID
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate room for the scanlines */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GSList
operator|*
argument_list|)
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* zero out the scanlines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* scan convert the curve */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_convert
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|subdivisions
argument_list|,
name|draw_type
argument_list|,
name|bezier_convert_points
argument_list|)
expr_stmt|;
comment|/*  advance to the next segment  */
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
if|if
condition|(
name|antialias
condition|)
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|x
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|y
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|=
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
expr_stmt|;
comment|/*  zero the vals array  */
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
name|i
operator|%
name|SUPERSAMPLE
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|x
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|warning
argument_list|(
literal|"cannot properly scanline convert bezier curve: %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*  bounds checking  */
name|x
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
operator|(
name|long
operator|)
name|list
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|w
operator|=
name|x2
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|antialias
condition|)
name|channel_add_segment
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|i
argument_list|,
name|w
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
name|vals
index|[
name|j
operator|+
name|x
index|]
operator|+=
literal|255
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|SUPERSAMPLE
operator|)
condition|)
block|{
name|b
operator|=
name|buf
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|width
expr_stmt|;
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|+=
name|SUPERSAMPLE
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SUPERSAMPLE
condition|;
name|x
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
operator|*
name|b
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|/
name|SUPERSAMPLE2
argument_list|)
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|maskPR
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|/
name|SUPERSAMPLE
operator|)
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
block|{
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
name|channel_invalidate_bounds
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints)
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|start_convert
condition|)
name|start_convert
operator|=
literal|0
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|npoints
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_line (GSList ** scanlines,int x1,int y1,int x2,int y2)
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|error
decl_stmt|,
name|inc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|float
name|slope
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y2
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
operator|+
operator|(
literal|0
operator|-
name|y2
operator|)
operator|/
name|slope
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y2
operator|>=
name|height
condition|)
block|{
if|if
condition|(
name|y1
operator|>=
name|height
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y2
operator|=
name|height
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
operator|(
name|height
operator|-
name|y1
operator|)
operator|/
name|slope
expr_stmt|;
name|y2
operator|=
name|height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|scanlines
operator|=
operator|&
name|scanlines
index|[
name|y1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|dx
else|:
name|dx
operator|)
operator|>
operator|(
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
operator|)
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|dx
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|x1
operator|!=
name|x2
condition|)
block|{
name|error
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dx
expr_stmt|;
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
block|}
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
operator|-
name|dy
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|y1
operator|++
operator|<
name|y2
condition|)
block|{
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
name|error
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dy
expr_stmt|;
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|bezier_insert_in_list (GSList * list,int x)
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|GSList
modifier|*
name|orig
init|=
name|list
decl_stmt|;
name|GSList
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
return|;
while|while
condition|(
name|list
condition|)
block|{
name|rest
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|long
operator|)
name|list
operator|->
name|data
condition|)
block|{
name|rest
operator|=
name|g_slist_prepend
argument_list|(
name|rest
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|list
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
expr_stmt|;
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rest
condition|)
block|{
name|g_slist_append
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|orig
return|;
block|}
end_function

end_unit

