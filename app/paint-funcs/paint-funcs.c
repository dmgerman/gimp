begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-processor.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/temp-buf.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"composite/gimp-composite.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs-generic.h"
end_include

begin_define
DECL|macro|RANDOM_SEED
define|#
directive|define
name|RANDOM_SEED
value|314159265
end_define

begin_define
DECL|macro|EPSILON
define|#
directive|define
name|EPSILON
value|0.0001
end_define

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2b64a1e10103
block|{
DECL|enumerator|MinifyX_MinifyY
name|MinifyX_MinifyY
block|,
DECL|enumerator|MinifyX_MagnifyY
name|MinifyX_MagnifyY
block|,
DECL|enumerator|MagnifyX_MinifyY
name|MagnifyX_MinifyY
block|,
DECL|enumerator|MagnifyX_MagnifyY
name|MagnifyX_MagnifyY
DECL|typedef|ScaleType
block|}
name|ScaleType
typedef|;
end_typedef

begin_comment
comment|/*  Layer modes information  */
end_comment

begin_typedef
DECL|typedef|LayerMode
typedef|typedef
name|struct
name|_LayerMode
name|LayerMode
typedef|;
end_typedef

begin_struct
DECL|struct|_LayerMode
struct|struct
name|_LayerMode
block|{
DECL|member|affect_alpha
name|guint
name|affect_alpha
range|:
literal|1
decl_stmt|;
comment|/*  does the layer mode affect the alpha channel  */
DECL|member|increase_opacity
name|guint
name|increase_opacity
range|:
literal|1
decl_stmt|;
comment|/*  layer mode can increase opacity */
DECL|member|decrease_opacity
name|guint
name|decrease_opacity
range|:
literal|1
decl_stmt|;
comment|/*  layer mode can decrease opacity */
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|layer_modes
specifier|static
specifier|const
name|LayerMode
name|layer_modes
index|[]
init|=
comment|/* This must obviously be in the same                                 * order as the corresponding values                                  * in the GimpLayerModeEffects enumeration.                                 */
block|{
block|{
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_NORMAL_MODE        */
block|{
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_DISSOLVE_MODE      */
block|{
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_BEHIND_MODE        */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_MULTIPLY_MODE      */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_SCREEN_MODE        */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_OVERLAY_MODE       */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_DIFFERENCE_MODE    */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_ADDITION_MODE      */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_SUBTRACT_MODE      */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_DARKEN_ONLY_MODE   */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_LIGHTEN_ONLY_MODE  */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_HUE_MODE           */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_SATURATION_MODE    */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_COLOR_MODE         */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_VALUE_MODE         */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_DIVIDE_MODE        */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_DODGE_MODE         */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_BURN_MODE          */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_HARDLIGHT_MODE     */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_SOFTLIGHT_MODE     */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_GRAIN_EXTRACT_MODE */
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
block|,
comment|/*  GIMP_GRAIN_MERGE_MODE   */
block|{
name|TRUE
block|,
name|FALSE
block|,
name|TRUE
block|,  }
block|,
comment|/*  GIMP_COLOR_ERASE_MODE   */
block|{
name|TRUE
block|,
name|FALSE
block|,
name|TRUE
block|,  }
block|,
comment|/*  GIMP_ERASE_MODE         */
block|{
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,  }
block|,
comment|/*  GIMP_REPLACE_MODE       */
block|{
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|, }
comment|/*  GIMP_ANTI_ERASE_MODE    */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|typedef|LayerModeFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|LayerModeFunc
function_decl|)
parameter_list|(
name|struct
name|apply_layer_mode_struct
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
DECL|variable|layer_mode_funcs
specifier|static
name|LayerModeFunc
name|layer_mode_funcs
index|[]
init|=
block|{
name|layer_normal_mode
block|,
name|layer_dissolve_mode
block|,
name|layer_behind_mode
block|,
name|layer_multiply_mode
block|,
name|layer_screen_mode
block|,
name|layer_overlay_mode
block|,
name|layer_difference_mode
block|,
name|layer_addition_mode
block|,
name|layer_subtract_mode
block|,
name|layer_darken_only_mode
block|,
name|layer_lighten_only_mode
block|,
name|layer_hue_mode
block|,
name|layer_saturation_mode
block|,
name|layer_color_mode
block|,
name|layer_value_mode
block|,
name|layer_divide_mode
block|,
name|layer_dodge_mode
block|,
name|layer_burn_mode
block|,
name|layer_hardlight_mode
block|,
name|layer_softlight_mode
block|,
name|layer_grain_extract_mode
block|,
name|layer_grain_merge_mode
block|,
name|layer_color_erase_mode
block|,
name|layer_erase_mode
block|,
name|layer_replace_mode
block|,
name|layer_anti_erase_mode
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|no_mask
specifier|static
specifier|const
name|guchar
name|no_mask
init|=
name|OPAQUE_OPACITY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gint
modifier|*
name|make_curve
parameter_list|(
name|gdouble
name|sigma
parameter_list|,
name|guint
modifier|*
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_layer_mode_replace
parameter_list|(
name|guchar
modifier|*
name|src1
parameter_list|,
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|guchar
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|rotate_pointers
parameter_list|(
name|guchar
modifier|*
modifier|*
name|p
parameter_list|,
name|guint32
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
DECL|function|update_tile_rowhints (Tile * tile,gint ymin,gint ymax)
name|update_tile_rowhints
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|ymin
parameter_list|,
name|gint
name|ymax
parameter_list|)
block|{
name|gint
name|bpp
decl_stmt|,
name|ewidth
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guchar
modifier|*
name|ptr
decl_stmt|;
name|guchar
name|alpha
decl_stmt|;
name|TileRowHint
name|thishint
decl_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tile_sanitize_rowhints
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|ewidth
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
operator|||
name|bpp
operator|==
literal|3
condition|)
block|{
for|for
control|(
name|y
operator|=
name|ymin
init|;
name|y
operator|<=
name|ymax
condition|;
name|y
operator|++
control|)
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bpp
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
name|ymin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|y
operator|=
name|ymin
init|;
name|y
operator|<=
name|ymax
condition|;
name|y
operator|++
control|)
block|{
name|thishint
operator|=
name|tile_get_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_BROKEN
condition|)
name|g_error
argument_list|(
literal|"BROKEN y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_OUTOFRANGE
condition|)
name|g_error
argument_list|(
literal|"OOR y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_UNDEFINED
condition|)
name|g_error
argument_list|(
literal|"UNDEFINED y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_TRANSPARENT
operator|||
name|thishint
operator|==
name|TILEROWHINT_MIXED
operator|||
name|thishint
operator|==
name|TILEROWHINT_OPAQUE
condition|)
block|{
goto|goto
name|next_row4
goto|;
block|}
if|if
condition|(
name|thishint
operator|!=
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|g_error
argument_list|(
literal|"MEGABOGUS y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|alpha
operator|=
name|ptr
index|[
literal|3
index|]
expr_stmt|;
comment|/* row is all-opaque or all-transparent? */
if|if
condition|(
name|alpha
operator|==
literal|0
operator|||
name|alpha
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|ewidth
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|ewidth
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|x
operator|*
literal|4
operator|+
literal|3
index|]
operator|!=
name|alpha
condition|)
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
goto|goto
name|next_row4
goto|;
block|}
block|}
block|}
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
operator|(
name|alpha
operator|==
literal|0
operator|)
condition|?
name|TILEROWHINT_TRANSPARENT
else|:
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
block|}
block|}
name|next_row4
label|:
name|ptr
operator|+=
literal|4
operator|*
name|ewidth
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bpp
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|tile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
name|ymin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
name|g_assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|y
operator|=
name|ymin
init|;
name|y
operator|<=
name|ymax
condition|;
name|y
operator|++
control|)
block|{
name|thishint
operator|=
name|tile_get_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_BROKEN
condition|)
name|g_error
argument_list|(
literal|"BROKEN y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_OUTOFRANGE
condition|)
name|g_error
argument_list|(
literal|"OOR y=%d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_UNDEFINED
condition|)
name|g_error
argument_list|(
literal|"UNDEFINED y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_TRANSPARENT
operator|||
name|thishint
operator|==
name|TILEROWHINT_MIXED
operator|||
name|thishint
operator|==
name|TILEROWHINT_OPAQUE
condition|)
block|{
goto|goto
name|next_row2
goto|;
block|}
if|if
condition|(
name|thishint
operator|!=
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|g_error
argument_list|(
literal|"MEGABOGUS y=%d - bpp=%d ew=%d eh=%d"
argument_list|,
name|y
argument_list|,
name|bpp
argument_list|,
name|ewidth
argument_list|,
name|eheight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|thishint
operator|==
name|TILEROWHINT_UNKNOWN
condition|)
block|{
name|alpha
operator|=
name|ptr
index|[
literal|1
index|]
expr_stmt|;
comment|/* row is all-opaque or all-transparent? */
if|if
condition|(
name|alpha
operator|==
literal|0
operator|||
name|alpha
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|ewidth
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|ewidth
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|!=
name|alpha
condition|)
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
goto|goto
name|next_row2
goto|;
block|}
block|}
block|}
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
operator|(
name|alpha
operator|==
literal|0
operator|)
condition|?
name|TILEROWHINT_TRANSPARENT
else|:
name|TILEROWHINT_OPAQUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile_set_rowhint
argument_list|(
name|tile
argument_list|,
name|y
argument_list|,
name|TILEROWHINT_MIXED
argument_list|)
expr_stmt|;
block|}
block|}
name|next_row2
label|:
name|ptr
operator|+=
literal|2
operator|*
name|ewidth
expr_stmt|;
block|}
return|return;
block|}
name|g_warning
argument_list|(
literal|"update_tile_rowhints: Don't know about tiles with bpp==%d"
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The equations: g(r) = exp (- r^2 / (2 * sigma^2))  *                   r = sqrt (x^2 + y ^2)  */
end_comment

begin_function
specifier|static
name|gint
modifier|*
DECL|function|make_curve (gdouble sigma,guint * length)
name|make_curve
parameter_list|(
name|gdouble
name|sigma
parameter_list|,
name|guint
modifier|*
name|length
parameter_list|)
block|{
name|gint
modifier|*
name|curve
decl_stmt|;
name|gdouble
name|sigma2
decl_stmt|;
name|gdouble
name|l
decl_stmt|;
name|gint
name|temp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|n
decl_stmt|;
name|sigma2
operator|=
literal|2
operator|*
name|sigma
operator|*
name|sigma
expr_stmt|;
name|l
operator|=
name|sqrt
argument_list|(
operator|-
name|sigma2
operator|*
name|log
argument_list|(
literal|1.0
operator|/
literal|255.0
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|ceil
argument_list|(
name|l
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
name|n
operator|+=
literal|1
expr_stmt|;
name|curve
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|n
operator|/
literal|2
expr_stmt|;
name|curve
operator|+=
operator|*
name|length
expr_stmt|;
name|curve
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|*
name|length
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
call|(
name|gint
call|)
argument_list|(
name|exp
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
name|sigma2
argument_list|)
operator|*
literal|255
argument_list|)
expr_stmt|;
name|curve
index|[
operator|-
name|i
index|]
operator|=
name|temp
expr_stmt|;
name|curve
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|curve
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|run_length_encode (const guchar * src,guint * dest,guint w,guint bytes)
name|run_length_encode
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
name|guint
modifier|*
name|dest
parameter_list|,
name|guint
name|w
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|guint
name|start
decl_stmt|;
name|guint
name|i
decl_stmt|;
name|guint
name|j
decl_stmt|;
name|guchar
name|last
decl_stmt|;
name|last
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|+=
name|bytes
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
name|last
condition|)
block|{
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|(
name|i
operator|-
name|j
operator|)
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|last
expr_stmt|;
block|}
name|start
operator|=
name|i
expr_stmt|;
name|last
operator|=
operator|*
name|src
expr_stmt|;
block|}
name|src
operator|+=
name|bytes
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|(
name|i
operator|-
name|j
operator|)
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Note: cubic function no longer clips result */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|cubic (gdouble dx,gint jm1,gint j,gint jp1,gint jp2)
name|cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
block|{
comment|/* Catmull-Rom - not bad */
return|return
call|(
name|gdouble
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
argument_list|)
operator|/
literal|2.0
return|;
block|}
end_function

begin_comment
comment|/*********************/
end_comment

begin_comment
comment|/*  FUNCTIONS        */
end_comment

begin_comment
comment|/*********************/
end_comment

begin_function
name|void
DECL|function|paint_funcs_setup (void)
name|paint_funcs_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|GRand
modifier|*
name|gr
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/*  generate a table of random seeds  */
name|gr
operator|=
name|g_rand_new_with_seed
argument_list|(
name|RANDOM_SEED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RANDOM_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|random_table
index|[
name|i
index|]
operator|=
name|g_rand_int
argument_list|(
name|gr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|256
init|;
name|i
operator|<=
literal|510
condition|;
name|i
operator|++
control|)
name|add_lut
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
name|g_rand_free
argument_list|(
name|gr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|paint_funcs_free (void)
name|paint_funcs_free
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
DECL|function|combine_indexed_and_indexed_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|combine_indexed_and_indexed_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|b
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|opacity
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_indexed_and_indexed_a_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|combine_indexed_and_indexed_a_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|b
decl_stmt|,
name|alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|gint
name|src2_bytes
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|alpha
operator|=
literal|1
expr_stmt|;
name|src2_bytes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_indexed_a_and_indexed_a_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|combine_indexed_a_and_indexed_a_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
name|alpha
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|&&
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_inten_a_and_indexed_a_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,const guchar * cmap,guint opacity,guint length,guint bytes)
name|combine_inten_a_and_indexed_a_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
specifier|const
name|guchar
modifier|*
name|cmap
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|b
decl_stmt|,
name|alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|gint
name|src2_bytes
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|alpha
operator|=
literal|1
expr_stmt|;
name|src2_bytes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|index
operator|=
name|src2
index|[
literal|0
index|]
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|-
literal|1
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|cmap
index|[
name|index
operator|+
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
comment|/*  alpha channel is opaque  */
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|index
operator|=
name|src2
index|[
literal|0
index|]
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|-
literal|1
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|cmap
index|[
name|index
operator|+
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|new_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
comment|/*  alpha channel is opaque  */
comment|/* m++; /Per */
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_inten_and_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|combine_inten_and_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|new_alpha
argument_list|,
name|tmp
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_inten_and_inten_a_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|combine_inten_and_inten_a_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|src2_bytes
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
specifier|register
name|glong
name|t1
decl_stmt|;
name|alpha
operator|=
name|bytes
expr_stmt|;
name|src2_bytes
operator|=
name|bytes
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|t1
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|new_alpha
argument_list|,
name|t1
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bytes
operator|==
literal|3
operator|&&
name|affect
index|[
literal|0
index|]
operator|&&
name|affect
index|[
literal|1
index|]
operator|&&
name|affect
index|[
literal|2
index|]
condition|)
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|INT_BLEND
argument_list|(
name|src2
index|[
literal|0
index|]
argument_list|,
name|src1
index|[
literal|0
index|]
argument_list|,
name|new_alpha
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|INT_BLEND
argument_list|(
name|src2
index|[
literal|1
index|]
argument_list|,
name|src1
index|[
literal|1
index|]
argument_list|,
name|new_alpha
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|INT_BLEND
argument_list|(
name|src2
index|[
literal|2
index|]
argument_list|,
name|src1
index|[
literal|2
index|]
argument_list|,
name|new_alpha
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|new_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|t1
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|new_alpha
argument_list|,
name|t1
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*orig #define alphify(src2_alpha,new_alpha) \         if (new_alpha == 0 || src2_alpha == 0)                                                        \           {                                                                                        \             for (b = 0; b< alpha; b++)                                                                \               dest[b] = src1 [b];                                                                \           }                                                                                        \         else if (src2_alpha == new_alpha){                                                        \           for (b = 0; b< alpha; b++)                                                                \             dest [b] = affect [b] ? src2 [b] : src1 [b];                                        \         } else {                                                                                \           ratio = (float) src2_alpha / new_alpha;                                                \           compl_ratio = 1.0 - ratio;                                                                \                                                                                                   \           for (b = 0; b< alpha; b++)                                                                \             dest[b] = affect[b] ?                                                                \               (guchar) (src2[b] * ratio + src1[b] * compl_ratio + EPSILON) : src1[b];        \         }*/
end_comment

begin_comment
comment|/*shortened #define alphify(src2_alpha,new_alpha) \         if (src2_alpha != 0&& new_alpha != 0)                                                        \           {                                                                                        \             if (src2_alpha == new_alpha){                                                        \               for (b = 0; b< alpha; b++)                                                        \               dest [b] = affect [b] ? src2 [b] : src1 [b];                                        \             } else {                                                                                \               ratio = (float) src2_alpha / new_alpha;                                                \               compl_ratio = 1.0 - ratio;                                                        \                                                                                                   \               for (b = 0; b< alpha; b++)                                                        \                 dest[b] = affect[b] ?                                                                \                   (guchar) (src2[b] * ratio + src1[b] * compl_ratio + EPSILON) : src1[b];\             }                                                                                   \           }*/
end_comment

begin_define
DECL|macro|alphify (src2_alpha,new_alpha)
define|#
directive|define
name|alphify
parameter_list|(
name|src2_alpha
parameter_list|,
name|new_alpha
parameter_list|)
define|\
value|if (src2_alpha != 0&& new_alpha != 0)                                                        \           {                                                                                        \             b = alpha; \             if (src2_alpha == new_alpha){                                                        \               do { \               b--; dest [b] = affect [b] ? src2 [b] : src1 [b];} while (b);        \             } else {                                                                                \               ratio = (float) src2_alpha / new_alpha;                                                \               compl_ratio = 1.0 - ratio;                                                        \                                                                                                   \               do { b--; \                 dest[b] = affect[b] ?                                                                \                   (guchar) (src2[b] * ratio + src1[b] * compl_ratio + EPSILON) : src1[b];\                    } while (b); \             }    \           }
end_define

begin_comment
comment|/*special #define alphify4(src2_alpha,new_alpha) \         if (src2_alpha != 0&& new_alpha != 0)                                                        \           {                                                                                        \             if (src2_alpha == new_alpha){                                                        \               dest [0] = affect [0] ? src2 [0] : src1 [0];                                        \               dest [1] = affect [1] ? src2 [1] : src1 [1];                                        \               dest [2] = affect [2] ? src2 [2] : src1 [2];                                        \             } else {                                                                                \               ratio = (float) src2_alpha / new_alpha;                                                \               compl_ratio = 1.0 - ratio;                                                        \                                                                                                   \               dest[0] = affect[0] ?                                                                \                 (guchar) (src2[0] * ratio + src1[0] * compl_ratio + EPSILON) : src1[0];  \               dest[1] = affect[1] ?                                                                \                 (guchar) (src2[1] * ratio + src1[1] * compl_ratio + EPSILON) : src1[1];  \               dest[2] = affect[2] ?                                                                \                 (guchar) (src2[2] * ratio + src1[2] * compl_ratio + EPSILON) : src1[2];  \             }                                                                                   \           }*/
end_comment

begin_function
name|void
DECL|function|combine_inten_a_and_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,gboolean mode_affect,guint length,guint bytes)
name|combine_inten_a_and_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|gboolean
name|mode_affect
parameter_list|,
comment|/*  how does the combination mode affect alpha?  */
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
comment|/*  4 or 2 depending on RGBA or GRAYA  */
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|src2_bytes
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gfloat
name|ratio
decl_stmt|,
name|compl_ratio
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
name|src2_bytes
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|opacity
operator|==
name|OPAQUE_OPACITY
condition|)
comment|/* HAS MASK, FULL OPACITY */
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src2_alpha
operator|=
operator|*
name|m
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
comment|/* HAS MASK, SEMI-OPACITY */
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src2_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* NO MASK */
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src2_alpha
operator|=
name|opacity
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
else|else
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|src2_bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_inten_a_and_inten_a_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,gboolean mode_affect,guint length,guint bytes)
name|combine_inten_a_and_inten_a_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|gboolean
name|mode_affect
parameter_list|,
comment|/*  how does the combination mode affect alpha?  */
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
comment|/*  4 or 2 depending on RGBA or GRAYA  */
block|{
name|guint
name|b
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|gfloat
name|ratio
decl_stmt|,
name|compl_ratio
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
specifier|const
name|guint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
specifier|const
name|guchar
modifier|*
name|m
init|=
name|mask
decl_stmt|;
if|if
condition|(
name|opacity
operator|==
name|OPAQUE_OPACITY
condition|)
comment|/* HAS MASK, FULL OPACITY */
block|{
specifier|const
name|gint
modifier|*
name|mask_ip
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|length
operator|>=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* HEAD */
name|i
operator|=
operator|(
name|GPOINTER_TO_INT
argument_list|(
name|m
argument_list|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
name|i
expr_stmt|;
name|length
operator|-=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
comment|/* BODY */
name|mask_ip
operator|=
operator|(
specifier|const
name|gint
operator|*
operator|)
name|m
expr_stmt|;
name|i
operator|=
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|length
operator|%=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|mask_ip
condition|)
block|{
name|m
operator|=
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|mask_ip
expr_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
else|else
block|{
name|j
operator|=
name|bytes
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|src2
operator|+=
name|j
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
operator|*
operator|(
name|dest
operator|++
operator|)
operator|=
operator|*
operator|(
name|src1
operator|++
operator|)
expr_stmt|;
block|}
block|}
name|mask_ip
operator|++
expr_stmt|;
block|}
name|m
operator|=
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|mask_ip
expr_stmt|;
block|}
comment|/* TAIL */
while|while
condition|(
name|length
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
else|else
comment|/* HAS MASK, SEMI-OPACITY */
block|{
specifier|const
name|gint
modifier|*
name|mask_ip
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|length
operator|>=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* HEAD */
name|i
operator|=
operator|(
name|GPOINTER_TO_INT
argument_list|(
name|m
argument_list|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
name|i
expr_stmt|;
name|length
operator|-=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
comment|/* BODY */
name|mask_ip
operator|=
operator|(
specifier|const
name|gint
operator|*
operator|)
name|m
expr_stmt|;
name|i
operator|=
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|length
operator|%=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|mask_ip
condition|)
block|{
name|m
operator|=
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|mask_ip
expr_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
else|else
block|{
name|j
operator|=
name|bytes
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|src2
operator|+=
name|j
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
operator|*
operator|(
name|dest
operator|++
operator|)
operator|=
operator|*
operator|(
name|src1
operator|++
operator|)
expr_stmt|;
block|}
block|}
name|mask_ip
operator|++
expr_stmt|;
block|}
name|m
operator|=
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|mask_ip
expr_stmt|;
block|}
comment|/* TAIL */
while|while
condition|(
name|length
operator|--
condition|)
block|{
comment|/* GUTS */
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
comment|/* GUTS END */
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|opacity
operator|==
name|OPAQUE_OPACITY
condition|)
comment|/* NO MASK, FULL OPACITY */
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src2_alpha
operator|=
name|src2
index|[
name|alpha
index|]
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
comment|/* NO MASK, SEMI OPACITY */
block|{
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src2_alpha
operator|=
name|INT_MULT
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|alphify
argument_list|(
name|src2_alpha
argument_list|,
name|new_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_affect
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src1
index|[
name|alpha
index|]
operator|)
condition|?
name|src1
index|[
name|alpha
index|]
else|:
operator|(
name|affect
index|[
name|alpha
index|]
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
operator|)
expr_stmt|;
block|}
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|alphify
end_undef

begin_function
name|void
DECL|function|combine_inten_a_and_channel_mask_pixels (const guchar * src,const guchar * channel,guchar * dest,const guchar * col,guint opacity,guint length,guint bytes)
name|combine_inten_a_and_channel_mask_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
specifier|const
name|guchar
modifier|*
name|channel
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|col
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|guchar
name|channel_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|guchar
name|compl_alpha
decl_stmt|;
name|gint
name|t
decl_stmt|,
name|s
decl_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|channel_alpha
operator|=
name|INT_MULT
argument_list|(
literal|255
operator|-
operator|*
name|channel
argument_list|,
name|opacity
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_alpha
condition|)
block|{
name|new_alpha
operator|=
name|src
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src
index|[
name|alpha
index|]
operator|)
argument_list|,
name|channel_alpha
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_alpha
operator|!=
literal|255
condition|)
name|channel_alpha
operator|=
operator|(
name|channel_alpha
operator|*
literal|255
operator|)
operator|/
name|new_alpha
expr_stmt|;
name|compl_alpha
operator|=
literal|255
operator|-
name|channel_alpha
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|col
index|[
name|b
index|]
argument_list|,
name|channel_alpha
argument_list|,
name|t
argument_list|)
operator|+
name|INT_MULT
argument_list|(
name|src
index|[
name|b
index|]
argument_list|,
name|compl_alpha
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|new_alpha
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/*  advance pointers  */
name|src
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
name|channel
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_inten_a_and_channel_selection_pixels (const guchar * src,const guchar * channel,guchar * dest,const guchar * col,guint opacity,guint length,guint bytes)
name|combine_inten_a_and_channel_selection_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src
parameter_list|,
specifier|const
name|guchar
modifier|*
name|channel
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|col
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|guchar
name|channel_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
name|guchar
name|compl_alpha
decl_stmt|;
name|gint
name|t
decl_stmt|,
name|s
decl_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|channel_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|channel
argument_list|,
name|opacity
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_alpha
condition|)
block|{
name|new_alpha
operator|=
name|src
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src
index|[
name|alpha
index|]
operator|)
argument_list|,
name|channel_alpha
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_alpha
operator|!=
literal|255
condition|)
name|channel_alpha
operator|=
operator|(
name|channel_alpha
operator|*
literal|255
operator|)
operator|/
name|new_alpha
expr_stmt|;
name|compl_alpha
operator|=
literal|255
operator|-
name|channel_alpha
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|INT_MULT
argument_list|(
name|col
index|[
name|b
index|]
argument_list|,
name|channel_alpha
argument_list|,
name|t
argument_list|)
operator|+
name|INT_MULT
argument_list|(
name|src
index|[
name|b
index|]
argument_list|,
name|compl_alpha
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dest
index|[
name|b
index|]
operator|=
name|new_alpha
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/*  advance pointers  */
name|src
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
name|channel
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  paint "behind" the existing pixel row.  *  This is similar in appearance to painting on a layer below  *  the existing pixels.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|behind_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes1,guint bytes2)
name|behind_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|)
block|{
comment|/* FIXME: Is this supposed to be different than in the other functions? */
specifier|const
name|guint
name|alpha
init|=
name|bytes1
operator|-
literal|1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|src1_alpha
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gfloat
name|ratio
decl_stmt|,
name|compl_ratio
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src1_alpha
operator|=
name|src1
index|[
name|alpha
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
name|src2_alpha
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src2_alpha
operator|)
argument_list|,
name|src1_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_alpha
condition|)
name|ratio
operator|=
operator|(
name|float
operator|)
name|src1_alpha
operator|/
name|new_alpha
expr_stmt|;
else|else
name|ratio
operator|=
literal|0.0
expr_stmt|;
name|compl_ratio
operator|=
literal|1.0
operator|-
name|ratio
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
call|(
name|guchar
call|)
argument_list|(
name|src1
index|[
name|b
index|]
operator|*
name|ratio
operator|+
name|src2
index|[
name|b
index|]
operator|*
name|compl_ratio
operator|+
name|EPSILON
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|affect
index|[
name|alpha
index|]
operator|)
condition|?
name|new_alpha
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  paint "behind" the existing pixel row (for indexed images).  *  This is similar in appearance to painting on a layer below  *  the existing pixels.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|behind_indexed_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes1,guint bytes2)
name|behind_indexed_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|)
block|{
specifier|const
name|guint
name|alpha
init|=
name|bytes1
operator|-
literal|1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|src1_alpha
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|guchar
name|new_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
comment|/*  the alpha channel  */
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|src1_alpha
operator|=
name|src1
index|[
name|alpha
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|new_alpha
operator|=
operator|(
name|src2_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|TRANSPARENT_OPACITY
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes1
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|new_alpha
operator|==
name|OPAQUE_OPACITY
operator|&&
operator|(
name|src1_alpha
operator|>
literal|127
operator|)
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  replace the contents of one pixel row with the other  *  The operation is still bounded by mask/opacity constraints  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|replace_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes1,guint bytes2)
name|replace_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|)
block|{
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|bytes
init|=
name|MIN
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|guchar
name|mask_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
init|=
name|mask
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|mask_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|mask_alpha
argument_list|,
name|tmp
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
operator|!
name|has_alpha2
condition|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes1
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|guchar
name|mask_alpha
init|=
name|OPAQUE_OPACITY
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|)
condition|?
name|INT_BLEND
argument_list|(
name|src2
index|[
name|b
index|]
argument_list|,
name|src1
index|[
name|b
index|]
argument_list|,
name|mask_alpha
argument_list|,
name|tmp
argument_list|)
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
operator|!
name|has_alpha2
condition|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  replace the contents of one pixel row with the other  *  The operation is still bounded by mask/opacity constraints  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|replace_indexed_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes1,guint bytes2)
name|replace_indexed_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|)
block|{
specifier|const
name|guint
name|has_alpha1
init|=
name|HAS_ALPHA
argument_list|(
name|bytes1
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|has_alpha2
init|=
name|HAS_ALPHA
argument_list|(
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guint
name|bytes
init|=
name|MIN
argument_list|(
name|bytes1
argument_list|,
name|bytes2
argument_list|)
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|mask_alpha
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|mask_alpha
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
name|affect
index|[
name|b
index|]
operator|&&
name|mask_alpha
operator|)
condition|?
name|src2
index|[
name|b
index|]
else|:
name|src1
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha1
operator|&&
operator|!
name|has_alpha2
condition|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes1
expr_stmt|;
name|src2
operator|+=
name|bytes2
expr_stmt|;
name|dest
operator|+=
name|bytes1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  apply source 2 to source 1, but in a non-additive way,  *  multiplying alpha channels  (works for intensity)  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|erase_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|erase_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
specifier|const
name|guint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
specifier|const
name|guchar
modifier|*
name|m
init|=
name|mask
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|src1
index|[
name|alpha
index|]
operator|-
name|INT_MULT
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|guchar
modifier|*
name|m
init|=
operator|&
name|no_mask
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|src1
index|[
name|alpha
index|]
operator|-
name|INT_MULT
argument_list|(
name|src1
index|[
name|alpha
index|]
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  apply source 2 to source 1, but in a non-additive way,  *  multiplying alpha channels  (works for indexed)  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|erase_indexed_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|erase_indexed_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
specifier|const
name|guint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
name|guint
name|b
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src2_alpha
operator|>
literal|127
operator|)
condition|?
name|TRANSPARENT_OPACITY
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|anti_erase_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|anti_erase_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
name|src1
index|[
name|alpha
index|]
operator|+
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
name|src1
index|[
name|alpha
index|]
operator|)
argument_list|,
name|src2_alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|anti_erase_indexed_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|anti_erase_indexed_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|gint
name|alpha
decl_stmt|,
name|b
decl_stmt|;
name|guchar
name|src2_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src1
index|[
name|b
index|]
expr_stmt|;
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
name|alpha
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dest
index|[
name|alpha
index|]
operator|=
operator|(
name|src2_alpha
operator|>
literal|127
operator|)
condition|?
name|OPAQUE_OPACITY
else|:
name|src1
index|[
name|alpha
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|color_erase_helper (GimpRGB * src,const GimpRGB * color)
name|color_erase_helper
parameter_list|(
name|GimpRGB
modifier|*
name|src
parameter_list|,
specifier|const
name|GimpRGB
modifier|*
name|color
parameter_list|)
block|{
name|GimpRGB
name|alpha
decl_stmt|;
name|alpha
operator|.
name|a
operator|=
name|src
operator|->
name|a
expr_stmt|;
if|if
condition|(
name|color
operator|->
name|r
operator|<
literal|0.0001
condition|)
name|alpha
operator|.
name|r
operator|=
name|src
operator|->
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|r
operator|>
name|color
operator|->
name|r
condition|)
name|alpha
operator|.
name|r
operator|=
operator|(
name|src
operator|->
name|r
operator|-
name|color
operator|->
name|r
operator|)
operator|/
operator|(
literal|1.0
operator|-
name|color
operator|->
name|r
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|r
operator|<
name|color
operator|->
name|r
condition|)
name|alpha
operator|.
name|r
operator|=
operator|(
name|color
operator|->
name|r
operator|-
name|src
operator|->
name|r
operator|)
operator|/
name|color
operator|->
name|r
expr_stmt|;
else|else
name|alpha
operator|.
name|r
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|color
operator|->
name|g
operator|<
literal|0.0001
condition|)
name|alpha
operator|.
name|g
operator|=
name|src
operator|->
name|g
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|g
operator|>
name|color
operator|->
name|g
condition|)
name|alpha
operator|.
name|g
operator|=
operator|(
name|src
operator|->
name|g
operator|-
name|color
operator|->
name|g
operator|)
operator|/
operator|(
literal|1.0
operator|-
name|color
operator|->
name|g
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|g
operator|<
name|color
operator|->
name|g
condition|)
name|alpha
operator|.
name|g
operator|=
operator|(
name|color
operator|->
name|g
operator|-
name|src
operator|->
name|g
operator|)
operator|/
operator|(
name|color
operator|->
name|g
operator|)
expr_stmt|;
else|else
name|alpha
operator|.
name|g
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|color
operator|->
name|b
operator|<
literal|0.0001
condition|)
name|alpha
operator|.
name|b
operator|=
name|src
operator|->
name|b
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|b
operator|>
name|color
operator|->
name|b
condition|)
name|alpha
operator|.
name|b
operator|=
operator|(
name|src
operator|->
name|b
operator|-
name|color
operator|->
name|b
operator|)
operator|/
operator|(
literal|1.0
operator|-
name|color
operator|->
name|b
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|b
operator|<
name|color
operator|->
name|b
condition|)
name|alpha
operator|.
name|b
operator|=
operator|(
name|color
operator|->
name|b
operator|-
name|src
operator|->
name|b
operator|)
operator|/
operator|(
name|color
operator|->
name|b
operator|)
expr_stmt|;
else|else
name|alpha
operator|.
name|b
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|alpha
operator|.
name|r
operator|>
name|alpha
operator|.
name|g
condition|)
block|{
if|if
condition|(
name|alpha
operator|.
name|r
operator|>
name|alpha
operator|.
name|b
condition|)
block|{
name|src
operator|->
name|a
operator|=
name|alpha
operator|.
name|r
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|a
operator|=
name|alpha
operator|.
name|b
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|alpha
operator|.
name|g
operator|>
name|alpha
operator|.
name|b
condition|)
block|{
name|src
operator|->
name|a
operator|=
name|alpha
operator|.
name|g
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|a
operator|=
name|alpha
operator|.
name|b
expr_stmt|;
block|}
name|src
operator|->
name|a
operator|=
operator|(
literal|1.0
operator|-
name|color
operator|->
name|a
operator|)
operator|+
operator|(
name|src
operator|->
name|a
operator|*
name|color
operator|->
name|a
operator|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|a
operator|<
literal|0.0001
condition|)
return|return;
name|src
operator|->
name|r
operator|=
operator|(
name|src
operator|->
name|r
operator|-
name|color
operator|->
name|r
operator|)
operator|/
name|src
operator|->
name|a
operator|+
name|color
operator|->
name|r
expr_stmt|;
name|src
operator|->
name|g
operator|=
operator|(
name|src
operator|->
name|g
operator|-
name|color
operator|->
name|g
operator|)
operator|/
name|src
operator|->
name|a
operator|+
name|color
operator|->
name|g
expr_stmt|;
name|src
operator|->
name|b
operator|=
operator|(
name|src
operator|->
name|b
operator|-
name|color
operator|->
name|b
operator|)
operator|/
name|src
operator|->
name|a
operator|+
name|color
operator|->
name|b
expr_stmt|;
name|src
operator|->
name|a
operator|*=
name|alpha
operator|.
name|a
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|color_erase_inten_pixels (const guchar * src1,const guchar * src2,guchar * dest,const guchar * mask,guint opacity,const gboolean * affect,guint length,guint bytes)
name|color_erase_inten_pixels
parameter_list|(
specifier|const
name|guchar
modifier|*
name|src1
parameter_list|,
specifier|const
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|)
block|{
name|guchar
name|src2_alpha
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|glong
name|tmp
decl_stmt|;
name|GimpRGB
name|bgcolor
decl_stmt|,
name|color
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|2
case|:
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
literal|1
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|gimp_rgba_set_uchar
argument_list|(
operator|&
name|color
argument_list|,
name|src1
index|[
literal|0
index|]
argument_list|,
name|src1
index|[
literal|0
index|]
argument_list|,
name|src1
index|[
literal|0
index|]
argument_list|,
name|src1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gimp_rgba_set_uchar
argument_list|(
operator|&
name|bgcolor
argument_list|,
name|src2
index|[
literal|0
index|]
argument_list|,
name|src2
index|[
literal|0
index|]
argument_list|,
name|src2
index|[
literal|0
index|]
argument_list|,
name|src2_alpha
argument_list|)
expr_stmt|;
name|color_erase_helper
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|bgcolor
argument_list|)
expr_stmt|;
name|gimp_rgba_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dest
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|src2_alpha
operator|=
name|INT_MULT3
argument_list|(
name|src2
index|[
literal|3
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|opacity
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|gimp_rgba_set_uchar
argument_list|(
operator|&
name|color
argument_list|,
name|src1
index|[
literal|0
index|]
argument_list|,
name|src1
index|[
literal|1
index|]
argument_list|,
name|src1
index|[
literal|2
index|]
argument_list|,
name|src1
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gimp_rgba_set_uchar
argument_list|(
operator|&
name|bgcolor
argument_list|,
name|src2
index|[
literal|0
index|]
argument_list|,
name|src2
index|[
literal|1
index|]
argument_list|,
name|src2
index|[
literal|2
index|]
argument_list|,
name|src2_alpha
argument_list|)
expr_stmt|;
name|color_erase_helper
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|bgcolor
argument_list|)
expr_stmt|;
name|gimp_rgba_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
name|dest
argument_list|,
name|dest
operator|+
literal|1
argument_list|,
name|dest
operator|+
literal|2
argument_list|,
name|dest
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src1
operator|+=
name|bytes
expr_stmt|;
name|src2
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|extract_from_inten_pixels (guchar * src,guchar * dest,const guchar * mask,const guchar * bg,gboolean cut,guint length,guint bytes,gboolean has_alpha)
name|extract_from_inten_pixels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg
parameter_list|,
name|gboolean
name|cut
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|)
block|{
name|gint
name|b
decl_stmt|,
name|alpha
decl_stmt|;
name|gint
name|dest_bytes
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
name|alpha
operator|=
operator|(
name|has_alpha
operator|)
condition|?
name|bytes
operator|-
literal|1
else|:
name|bytes
expr_stmt|;
name|dest_bytes
operator|=
operator|(
name|has_alpha
operator|)
condition|?
name|bytes
else|:
name|bytes
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|src
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
name|dest
index|[
name|alpha
index|]
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|src
index|[
name|alpha
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut
condition|)
name|src
index|[
name|alpha
index|]
operator|=
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
operator|*
name|m
operator|)
argument_list|,
name|src
index|[
name|alpha
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|alpha
index|]
operator|=
operator|*
name|m
expr_stmt|;
if|if
condition|(
name|cut
condition|)
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|src
index|[
name|b
index|]
operator|=
name|INT_BLEND
argument_list|(
name|bg
index|[
name|b
index|]
argument_list|,
name|src
index|[
name|b
index|]
argument_list|,
operator|*
name|m
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
name|dest_bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|extract_from_indexed_pixels (guchar * src,guchar * dest,const guchar * mask,const guchar * cmap,const guchar * bg,gboolean cut,guint length,guint bytes,gboolean has_alpha)
name|extract_from_indexed_pixels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|mask
parameter_list|,
specifier|const
name|guchar
modifier|*
name|cmap
parameter_list|,
specifier|const
name|guchar
modifier|*
name|bg
parameter_list|,
name|gboolean
name|cut
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|)
block|{
name|gint
name|b
decl_stmt|;
name|gint
name|index
decl_stmt|;
specifier|const
name|guchar
modifier|*
name|m
decl_stmt|;
name|gint
name|t
decl_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
expr_stmt|;
else|else
name|m
operator|=
operator|&
name|no_mask
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|index
operator|=
name|src
index|[
literal|0
index|]
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|3
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|cmap
index|[
name|index
operator|+
name|b
index|]
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
block|{
name|dest
index|[
literal|3
index|]
operator|=
name|INT_MULT
argument_list|(
operator|*
name|m
argument_list|,
name|src
index|[
literal|1
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut
condition|)
name|src
index|[
literal|1
index|]
operator|=
name|INT_MULT
argument_list|(
operator|(
literal|255
operator|-
operator|*
name|m
operator|)
argument_list|,
name|src
index|[
literal|1
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
literal|3
index|]
operator|=
operator|*
name|m
expr_stmt|;
if|if
condition|(
name|cut
condition|)
name|src
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|m
operator|>
literal|127
operator|)
condition|?
name|bg
index|[
literal|0
index|]
else|:
name|src
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mask
condition|)
name|m
operator|++
expr_stmt|;
name|src
operator|+=
name|bytes
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************/
end_comment

begin_comment
comment|/*    REGION FUNCTIONS                            */
end_comment

begin_comment
comment|/**************************************************/
end_comment

begin_function
name|void
DECL|function|color_region (PixelRegion * dest,const guchar * col)
name|color_region
parameter_list|(
name|PixelRegion
modifier|*
name|dest
parameter_list|,
specifier|const
name|guchar
modifier|*
name|col
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|h
operator|=
name|dest
operator|->
name|h
expr_stmt|;
name|s
operator|=
name|dest
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
operator|==
name|dest
operator|->
name|rowstride
condition|)
block|{
comment|/* do it all in one function call if we can            * this hasn't been tested to see if it is a            * signifigant speed gain yet            */
name|color_pixels
argument_list|(
name|s
argument_list|,
name|col
argument_list|,
name|dest
operator|->
name|w
operator|*
name|h
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|color_pixels
argument_list|(
name|s
argument_list|,
name|col
argument_list|,
name|dest
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|color_region_mask (PixelRegion * dest,PixelRegion * mask,const guchar * col)
name|color_region_mask
parameter_list|(
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
specifier|const
name|guchar
modifier|*
name|col
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|h
operator|=
name|dest
operator|->
name|h
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
operator|==
name|dest
operator|->
name|rowstride
operator|&&
name|mask
operator|->
name|w
operator|*
name|mask
operator|->
name|bytes
operator|==
name|mask
operator|->
name|rowstride
condition|)
block|{
comment|/* do it all in one function call if we can            * this hasn't been tested to see if it is a            * signifigant speed gain yet            */
name|color_pixels_mask
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|col
argument_list|,
name|dest
operator|->
name|w
operator|*
name|h
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|color_pixels_mask
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|col
argument_list|,
name|dest
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|pattern_region (PixelRegion * dest,PixelRegion * mask,TempBuf * pattern,gint off_x,gint off_y)
name|pattern_region
parameter_list|(
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|TempBuf
modifier|*
name|pattern
parameter_list|,
name|gint
name|off_x
parameter_list|,
name|gint
name|off_y
parameter_list|)
block|{
name|gint
name|y
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dest
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|pattern_pixels_mask
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|pattern
argument_list|,
name|dest
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|,
name|off_x
operator|+
name|dest
operator|->
name|x
argument_list|,
name|off_y
operator|+
name|dest
operator|->
name|y
operator|+
name|y
argument_list|)
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|blend_region (PixelRegion * src1,PixelRegion * src2,PixelRegion * dest,guchar blend)
name|blend_region
parameter_list|(
name|PixelRegion
modifier|*
name|src1
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|guchar
name|blend
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|3
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s1
operator|=
name|src1
operator|->
name|data
expr_stmt|;
name|s2
operator|=
name|src2
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src1
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|blend_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|blend
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|src1
operator|->
name|rowstride
expr_stmt|;
name|s2
operator|+=
name|src2
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|shade_region (PixelRegion * src,PixelRegion * dest,guchar * color,guchar blend)
name|shade_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|guchar
modifier|*
name|color
parameter_list|,
name|guchar
name|blend
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
comment|/*      blend_pixels (s, d, col, blend, src->w, src->bytes);*/
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|copy_region (PixelRegion * src,PixelRegion * dest)
name|copy_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|gint
name|pixelwidth
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
ifdef|#
directive|ifdef
name|COWSHOW
name|fputc
argument_list|(
literal|'['
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
if|if
condition|(
name|src
operator|->
name|tiles
operator|&&
name|dest
operator|->
name|tiles
operator|&&
name|src
operator|->
name|curtile
operator|&&
name|dest
operator|->
name|curtile
operator|&&
name|src
operator|->
name|offx
operator|==
literal|0
operator|&&
name|dest
operator|->
name|offx
operator|==
literal|0
operator|&&
name|src
operator|->
name|offy
operator|==
literal|0
operator|&&
name|dest
operator|->
name|offy
operator|==
literal|0
operator|&&
name|src
operator|->
name|w
operator|==
name|tile_ewidth
argument_list|(
name|src
operator|->
name|curtile
argument_list|)
operator|&&
name|dest
operator|->
name|w
operator|==
name|tile_ewidth
argument_list|(
name|dest
operator|->
name|curtile
argument_list|)
operator|&&
name|src
operator|->
name|h
operator|==
name|tile_eheight
argument_list|(
name|src
operator|->
name|curtile
argument_list|)
operator|&&
name|dest
operator|->
name|h
operator|==
name|tile_eheight
argument_list|(
name|dest
operator|->
name|curtile
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COWSHOW
name|fputc
argument_list|(
literal|'!'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tile_manager_map_over_tile
argument_list|(
name|dest
operator|->
name|tiles
argument_list|,
name|dest
operator|->
name|curtile
argument_list|,
name|src
operator|->
name|curtile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|COWSHOW
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pixelwidth
operator|=
name|src
operator|->
name|w
operator|*
name|src
operator|->
name|bytes
expr_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|pixelwidth
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|COWSHOW
name|fputc
argument_list|(
literal|']'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|copy_region_nocow (PixelRegion * src,PixelRegion * dest)
name|copy_region_nocow
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|gint
name|pixelwidth
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|pixelwidth
operator|=
name|src
operator|->
name|w
operator|*
name|src
operator|->
name|bytes
expr_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|pixelwidth
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|add_alpha_region (PixelRegion * src,PixelRegion * dest)
name|add_alpha_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|add_alpha_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|flatten_region (PixelRegion * src,PixelRegion * dest,guchar * bg)
name|flatten_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|flatten_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|bg
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|extract_alpha_region (PixelRegion * src,PixelRegion * mask,PixelRegion * dest)
name|extract_alpha_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|3
argument_list|,
name|src
argument_list|,
name|mask
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
else|else
name|m
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|extract_alpha_pixels
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|d
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|extract_from_region (PixelRegion * src,PixelRegion * dest,PixelRegion * mask,guchar * cmap,guchar * bg,gint type,gboolean has_alpha,gboolean cut)
name|extract_from_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|,
name|gint
name|type
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|,
name|gboolean
name|cut
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|3
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|m
operator|=
operator|(
name|mask
operator|)
condition|?
name|mask
operator|->
name|data
else|:
name|NULL
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/*  RGB      */
case|case
literal|1
case|:
comment|/*  GRAY     */
name|extract_from_inten_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|bg
argument_list|,
name|cut
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*  INDEXED  */
name|extract_from_indexed_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|cmap
argument_list|,
name|bg
argument_list|,
name|cut
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|convolve_region (PixelRegion * srcR,PixelRegion * destR,gfloat * matrix,gint size,gdouble divisor,GimpConvolutionType mode,gboolean alpha_weighting)
name|convolve_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcR
parameter_list|,
name|PixelRegion
modifier|*
name|destR
parameter_list|,
name|gfloat
modifier|*
name|matrix
parameter_list|,
name|gint
name|size
parameter_list|,
name|gdouble
name|divisor
parameter_list|,
name|GimpConvolutionType
name|mode
parameter_list|,
name|gboolean
name|alpha_weighting
parameter_list|)
block|{
comment|/*  Convolve the src image using the convolution matrix, writing to dest  */
comment|/*  Convolve is not tile-enabled--use accordingly  */
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s_row
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|gfloat
modifier|*
name|m
decl_stmt|;
name|gdouble
name|total
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|bytes
decl_stmt|;
name|gint
name|alpha
decl_stmt|,
name|a_byte
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|wraparound
decl_stmt|;
name|gint
name|margin
decl_stmt|;
comment|/*  margin imposed by size of conv. matrix  */
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|offset
decl_stmt|;
name|gdouble
name|matrixsum
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|weighted_divisor
decl_stmt|,
name|mult_alpha
decl_stmt|;
comment|/*  If the mode is NEGATIVE_CONVOL, the offset should be 128  */
if|if
condition|(
name|mode
operator|==
name|GIMP_NEGATIVE_CONVOL
condition|)
block|{
name|offset
operator|=
literal|128
expr_stmt|;
name|mode
operator|=
name|GIMP_NORMAL_CONVOL
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
comment|/*  check for the boundary cases  */
if|if
condition|(
name|srcR
operator|->
name|w
operator|<
operator|(
name|size
operator|-
literal|1
operator|)
operator|||
name|srcR
operator|->
name|h
operator|<
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
return|return;
comment|/*  Initialize some values  */
name|bytes
operator|=
name|srcR
operator|->
name|bytes
expr_stmt|;
name|a_byte
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
name|length
operator|=
name|bytes
operator|*
name|srcR
operator|->
name|w
expr_stmt|;
name|margin
operator|=
name|size
operator|/
literal|2
expr_stmt|;
name|src
operator|=
name|srcR
operator|->
name|data
expr_stmt|;
name|dest
operator|=
name|destR
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|alpha_weighting
condition|)
block|{
name|m
operator|=
name|matrix
expr_stmt|;
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|j
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
name|matrixsum
operator|+=
operator|*
name|m
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|matrixsum
operator|==
literal|0.0
condition|)
name|matrixsum
operator|=
literal|1.0
expr_stmt|;
block|}
comment|/*  calculate the source wraparound value  */
name|wraparound
operator|=
name|srcR
operator|->
name|rowstride
operator|-
name|size
operator|*
name|bytes
expr_stmt|;
comment|/* copy the first (size / 2) scanlines of the src image... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|margin
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|src
operator|+=
name|srcR
operator|->
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destR
operator|->
name|rowstride
expr_stmt|;
block|}
name|src
operator|=
name|srcR
operator|->
name|data
expr_stmt|;
for|for
control|(
name|y
operator|=
name|margin
init|;
name|y
operator|<
name|srcR
operator|->
name|h
operator|-
name|margin
condition|;
name|y
operator|++
control|)
block|{
name|s_row
operator|=
name|src
expr_stmt|;
name|s
operator|=
name|s_row
operator|+
name|srcR
operator|->
name|rowstride
operator|*
name|margin
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
comment|/* handle the first margin pixels... */
name|b
operator|=
name|bytes
operator|*
name|margin
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* now, handle the center pixels */
name|x
operator|=
name|srcR
operator|->
name|w
operator|-
name|margin
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|alpha_weighting
condition|)
while|while
condition|(
name|x
operator|--
condition|)
block|{
name|s
operator|=
name|s_row
expr_stmt|;
name|m
operator|=
name|matrix
expr_stmt|;
name|total
index|[
literal|0
index|]
operator|=
name|total
index|[
literal|1
index|]
operator|=
name|total
index|[
literal|2
index|]
operator|=
name|total
index|[
literal|3
index|]
operator|=
literal|0.0
expr_stmt|;
name|weighted_divisor
operator|=
literal|0.0
expr_stmt|;
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|j
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|alpha
operator|=
name|s
index|[
name|a_byte
index|]
expr_stmt|;
if|if
condition|(
name|alpha
operator|&&
operator|*
name|m
condition|)
block|{
name|mult_alpha
operator|=
operator|*
name|m
operator|*
name|alpha
expr_stmt|;
name|weighted_divisor
operator|+=
name|mult_alpha
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|a_byte
condition|;
name|b
operator|++
control|)
name|total
index|[
name|b
index|]
operator|+=
name|mult_alpha
operator|*
operator|*
name|s
operator|++
expr_stmt|;
name|total
index|[
name|a_byte
index|]
operator|+=
operator|*
name|m
operator|*
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|+=
name|bytes
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
name|s
operator|+=
name|wraparound
expr_stmt|;
block|}
if|if
condition|(
name|weighted_divisor
operator|==
literal|0.0
condition|)
name|weighted_divisor
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
name|total
index|[
name|b
index|]
operator|/=
name|divisor
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|a_byte
condition|)
name|total
index|[
name|b
index|]
operator|=
name|total
index|[
name|b
index|]
operator|*
name|matrixsum
operator|/
name|weighted_divisor
expr_stmt|;
name|total
index|[
name|b
index|]
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|total
index|[
name|b
index|]
operator|<
literal|0.0
operator|&&
name|mode
operator|!=
name|GIMP_NORMAL_CONVOL
condition|)
name|total
index|[
name|b
index|]
operator|=
operator|-
name|total
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|total
index|[
name|b
index|]
operator|<
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|d
operator|++
operator|=
operator|(
name|total
index|[
name|b
index|]
operator|>
literal|255.0
operator|)
condition|?
literal|255
else|:
operator|(
name|guchar
operator|)
name|total
index|[
name|b
index|]
expr_stmt|;
block|}
name|s_row
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
while|while
condition|(
name|x
operator|--
condition|)
block|{
name|s
operator|=
name|s_row
expr_stmt|;
name|m
operator|=
name|matrix
expr_stmt|;
name|total
index|[
literal|0
index|]
operator|=
name|total
index|[
literal|1
index|]
operator|=
name|total
index|[
literal|2
index|]
operator|=
name|total
index|[
literal|3
index|]
operator|=
literal|0.0
expr_stmt|;
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|j
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|m
condition|)
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|total
index|[
name|b
index|]
operator|+=
operator|*
name|m
operator|*
operator|*
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|+=
name|bytes
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
name|s
operator|+=
name|wraparound
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
name|total
index|[
name|b
index|]
operator|=
name|total
index|[
name|b
index|]
operator|/
name|divisor
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|total
index|[
name|b
index|]
operator|<
literal|0.0
operator|&&
name|mode
operator|!=
name|GIMP_NORMAL_CONVOL
condition|)
name|total
index|[
name|b
index|]
operator|=
operator|-
name|total
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|total
index|[
name|b
index|]
operator|<
literal|0.0
condition|)
operator|*
name|d
operator|++
operator|=
literal|0.0
expr_stmt|;
else|else
operator|*
name|d
operator|++
operator|=
operator|(
name|total
index|[
name|b
index|]
operator|>
literal|255.0
operator|)
condition|?
literal|255
else|:
operator|(
name|guchar
operator|)
name|total
index|[
name|b
index|]
expr_stmt|;
block|}
name|s_row
operator|+=
name|bytes
expr_stmt|;
block|}
comment|/* handle the last pixel... */
name|s
operator|=
name|s_row
operator|+
operator|(
name|srcR
operator|->
name|rowstride
operator|+
name|bytes
operator|)
operator|*
name|margin
expr_stmt|;
name|b
operator|=
name|bytes
operator|*
name|margin
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* set the memory pointers */
name|src
operator|+=
name|srcR
operator|->
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destR
operator|->
name|rowstride
expr_stmt|;
block|}
name|src
operator|+=
name|srcR
operator|->
name|rowstride
operator|*
name|margin
expr_stmt|;
comment|/* copy the last (margin) scanlines of the src image... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|margin
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|src
operator|+=
name|srcR
operator|->
name|rowstride
expr_stmt|;
name|dest
operator|+=
name|destR
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert from separated alpha to premultiplied alpha. Only works on    non-tiled regions! */
end_comment

begin_function
name|void
DECL|function|multiply_alpha_region (PixelRegion * srcR)
name|multiply_alpha_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcR
parameter_list|)
block|{
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|bytes
decl_stmt|;
name|gdouble
name|alpha_val
decl_stmt|;
name|width
operator|=
name|srcR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|srcR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|srcR
operator|->
name|bytes
expr_stmt|;
name|src
operator|=
name|srcR
operator|->
name|data
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|alpha_val
operator|=
name|s
index|[
name|bytes
operator|-
literal|1
index|]
operator|*
operator|(
literal|1.0
operator|/
literal|255.0
operator|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|-
literal|1
condition|;
name|b
operator|++
control|)
name|s
index|[
name|b
index|]
operator|=
literal|0.5
operator|+
name|s
index|[
name|b
index|]
operator|*
name|alpha_val
expr_stmt|;
name|s
operator|+=
name|bytes
expr_stmt|;
block|}
name|src
operator|+=
name|srcR
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert from premultiplied alpha to separated alpha. Only works on    non-tiled regions! */
end_comment

begin_function
name|void
DECL|function|separate_alpha_region (PixelRegion * srcR)
name|separate_alpha_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcR
parameter_list|)
block|{
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|bytes
decl_stmt|;
name|gdouble
name|alpha_recip
decl_stmt|;
name|gint
name|new_val
decl_stmt|;
name|width
operator|=
name|srcR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|srcR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|srcR
operator|->
name|bytes
expr_stmt|;
name|src
operator|=
name|srcR
operator|->
name|data
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|s
operator|=
name|src
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* predicate is equivalent to:              (((s[bytes - 1] - 1)& 255) + 2)& 256              */
if|if
condition|(
name|s
index|[
name|bytes
operator|-
literal|1
index|]
operator|!=
literal|0
operator|&&
name|s
index|[
name|bytes
operator|-
literal|1
index|]
operator|!=
literal|255
condition|)
block|{
name|alpha_recip
operator|=
literal|255.0
operator|/
name|s
index|[
name|bytes
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|-
literal|1
condition|;
name|b
operator|++
control|)
block|{
name|new_val
operator|=
literal|0.5
operator|+
name|s
index|[
name|b
index|]
operator|*
name|alpha_recip
expr_stmt|;
name|new_val
operator|=
name|MIN
argument_list|(
name|new_val
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|s
index|[
name|b
index|]
operator|=
name|new_val
expr_stmt|;
block|}
block|}
name|s
operator|+=
name|bytes
expr_stmt|;
block|}
name|src
operator|+=
name|srcR
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gaussian_blur_region (PixelRegion * srcR,gdouble radius_x,gdouble radius_y)
name|gaussian_blur_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcR
parameter_list|,
name|gdouble
name|radius_x
parameter_list|,
name|gdouble
name|radius_y
parameter_list|)
block|{
name|gdouble
name|std_dev
decl_stmt|;
name|glong
name|width
decl_stmt|,
name|height
decl_stmt|;
name|guint
name|bytes
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|gint
name|pixels
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|start
decl_stmt|,
name|end
decl_stmt|;
name|gint
modifier|*
name|curve
decl_stmt|;
name|gint
modifier|*
name|sum
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|initial_p
decl_stmt|,
name|initial_m
decl_stmt|;
if|if
condition|(
name|radius_x
operator|==
literal|0.0
operator|&&
name|radius_y
operator|==
literal|0.0
condition|)
return|return;
comment|/* zero blur is a no-op */
comment|/*  allocate the result buffer  */
name|length
operator|=
name|MAX
argument_list|(
name|srcR
operator|->
name|w
argument_list|,
name|srcR
operator|->
name|h
argument_list|)
operator|*
name|srcR
operator|->
name|bytes
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|src
operator|=
name|data
expr_stmt|;
name|dest
operator|=
name|data
operator|+
name|length
expr_stmt|;
name|width
operator|=
name|srcR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|srcR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|srcR
operator|->
name|bytes
expr_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|MAX
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|radius_y
operator|!=
literal|0.0
condition|)
block|{
name|std_dev
operator|=
name|sqrt
argument_list|(
operator|-
operator|(
name|radius_y
operator|*
name|radius_y
operator|)
operator|/
operator|(
literal|2
operator|*
name|log
argument_list|(
literal|1.0
operator|/
literal|255.0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|curve
operator|=
name|make_curve
argument_list|(
name|std_dev
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|sum
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
literal|2
operator|*
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|sum
index|[
name|i
index|]
operator|=
name|curve
index|[
name|i
operator|-
name|length
operator|-
literal|1
index|]
operator|+
name|sum
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sum
operator|+=
name|length
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|pixel_region_get_col
argument_list|(
name|srcR
argument_list|,
name|col
operator|+
name|srcR
operator|->
name|x
argument_list|,
name|srcR
operator|->
name|y
argument_list|,
name|height
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|src
operator|+
name|alpha
expr_stmt|;
name|initial_p
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|initial_m
operator|=
name|sp
index|[
operator|(
name|height
operator|-
literal|1
operator|)
operator|*
name|bytes
index|]
expr_stmt|;
comment|/*  Determine a run-length encoded version of the column  */
name|run_length_encode
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|start
operator|=
operator|(
name|row
operator|<
name|length
operator|)
condition|?
operator|-
name|row
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
name|height
operator|<=
operator|(
name|row
operator|+
name|length
operator|)
operator|)
condition|?
operator|(
name|height
operator|-
name|row
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
name|b
operator|=
name|buf
operator|+
operator|(
name|row
operator|+
name|i
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
name|pixels
operator|=
name|b
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|+=
name|pixels
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|end
condition|)
name|i
operator|=
name|end
expr_stmt|;
name|val
operator|+=
name|b
index|[
literal|1
index|]
operator|*
operator|(
name|sum
index|[
name|i
index|]
operator|-
name|sum
index|[
name|start
index|]
operator|)
expr_stmt|;
name|b
operator|+=
operator|(
name|pixels
operator|*
literal|2
operator|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
index|]
operator|)
expr_stmt|;
name|sp
index|[
name|row
operator|*
name|bytes
index|]
operator|=
name|val
operator|/
name|total
expr_stmt|;
block|}
name|pixel_region_set_col
argument_list|(
name|srcR
argument_list|,
name|col
operator|+
name|srcR
operator|->
name|x
argument_list|,
name|srcR
operator|->
name|y
argument_list|,
name|height
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|sum
operator|-
name|length
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|curve
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|radius_x
operator|!=
literal|0.0
condition|)
block|{
name|std_dev
operator|=
name|sqrt
argument_list|(
operator|-
operator|(
name|radius_x
operator|*
name|radius_x
operator|)
operator|/
operator|(
literal|2
operator|*
name|log
argument_list|(
literal|1.0
operator|/
literal|255.0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|curve
operator|=
name|make_curve
argument_list|(
name|std_dev
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|sum
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
literal|2
operator|*
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|sum
index|[
name|i
index|]
operator|=
name|curve
index|[
name|i
operator|-
name|length
operator|-
literal|1
index|]
operator|+
name|sum
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sum
operator|+=
name|length
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcR
argument_list|,
name|srcR
operator|->
name|x
argument_list|,
name|row
operator|+
name|srcR
operator|->
name|y
argument_list|,
name|width
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|src
operator|+
name|alpha
expr_stmt|;
name|dp
operator|=
name|dest
operator|+
name|alpha
expr_stmt|;
name|initial_p
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|initial_m
operator|=
name|sp
index|[
operator|(
name|width
operator|-
literal|1
operator|)
operator|*
name|bytes
index|]
expr_stmt|;
comment|/*  Determine a run-length encoded version of the row  */
name|run_length_encode
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|start
operator|=
operator|(
name|col
operator|<
name|length
operator|)
condition|?
operator|-
name|col
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
name|width
operator|<=
operator|(
name|col
operator|+
name|length
operator|)
operator|)
condition|?
operator|(
name|width
operator|-
name|col
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
name|b
operator|=
name|buf
operator|+
operator|(
name|col
operator|+
name|i
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
name|pixels
operator|=
name|b
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|+=
name|pixels
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|end
condition|)
name|i
operator|=
name|end
expr_stmt|;
name|val
operator|+=
name|b
index|[
literal|1
index|]
operator|*
operator|(
name|sum
index|[
name|i
index|]
operator|-
name|sum
index|[
name|start
index|]
operator|)
expr_stmt|;
name|b
operator|+=
operator|(
name|pixels
operator|*
literal|2
operator|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
index|]
operator|)
expr_stmt|;
name|val
operator|=
name|val
operator|/
name|total
expr_stmt|;
name|dp
index|[
name|col
operator|*
name|bytes
index|]
operator|=
name|val
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
name|srcR
argument_list|,
name|srcR
operator|->
name|x
argument_list|,
name|row
operator|+
name|srcR
operator|->
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|sum
operator|-
name|length
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|curve
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* non-interpolating scale_region.  [adam]  */
end_comment

begin_function
specifier|static
name|void
DECL|function|scale_region_no_resample (PixelRegion * srcPR,PixelRegion * destPR)
name|scale_region_no_resample
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|)
block|{
name|gint
modifier|*
name|x_src_offsets
decl_stmt|;
name|gint
modifier|*
name|y_src_offsets
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|last_src_y
decl_stmt|;
name|gint
name|row_bytes
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|b
decl_stmt|;
name|gchar
name|bytes
decl_stmt|;
name|orig_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|srcPR
operator|->
name|bytes
expr_stmt|;
comment|/*  the data pointers...  */
name|x_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|y_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  pre-calc the scale tables  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
name|x_src_offsets
index|[
name|b
operator|+
name|x
operator|*
name|bytes
index|]
operator|=
name|b
operator|+
name|bytes
operator|*
operator|(
operator|(
name|x
operator|*
name|orig_width
operator|+
name|orig_width
operator|/
literal|2
operator|)
operator|/
name|width
operator|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
name|y_src_offsets
index|[
name|y
index|]
operator|=
operator|(
name|y
operator|*
name|orig_height
operator|+
name|orig_height
operator|/
literal|2
operator|)
operator|/
name|height
expr_stmt|;
comment|/*  do the scaling  */
name|row_bytes
operator|=
name|width
operator|*
name|bytes
expr_stmt|;
name|last_src_y
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
comment|/* if the source of this line was the same as the source        *  of the last line, there's no point in re-rescaling.        */
if|if
condition|(
name|y_src_offsets
index|[
name|y
index|]
operator|!=
name|last_src_y
condition|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y_src_offsets
index|[
name|y
index|]
argument_list|,
name|orig_width
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|row_bytes
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
name|x
index|]
operator|=
name|src
index|[
name|x_src_offsets
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
name|last_src_y
operator|=
name|y_src_offsets
index|[
name|y
index|]
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|x_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|y_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_premultiplied_double_row (PixelRegion * srcPR,gint x,gint y,gint w,gdouble * row,guchar * tmp_src,gint n)
name|get_premultiplied_double_row
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|tmp_src
parameter_list|,
name|gint
name|n
parameter_list|)
block|{
name|gint
name|b
decl_stmt|;
name|gint
name|bytes
init|=
name|srcPR
operator|->
name|bytes
decl_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|tmp_src
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* premultiply the alpha into the double array */
name|gdouble
modifier|*
name|irow
init|=
name|row
decl_stmt|;
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gdouble
name|mod_alpha
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
name|mod_alpha
operator|=
name|tmp_src
index|[
name|alpha
index|]
operator|/
literal|255.0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|irow
index|[
name|b
index|]
operator|=
name|mod_alpha
operator|*
name|tmp_src
index|[
name|b
index|]
expr_stmt|;
name|irow
index|[
name|b
index|]
operator|=
name|tmp_src
index|[
name|alpha
index|]
expr_stmt|;
name|irow
operator|+=
name|bytes
expr_stmt|;
name|tmp_src
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
comment|/* no alpha */
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|row
index|[
name|x
index|]
operator|=
name|tmp_src
index|[
name|x
index|]
expr_stmt|;
block|}
comment|/* set the off edge pixels to their nearest neighbor */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|2
operator|*
name|bytes
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|-
literal|2
operator|*
name|bytes
index|]
operator|=
name|row
index|[
name|b
operator|%
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|*
literal|2
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|+
name|w
operator|*
name|bytes
index|]
operator|=
name|row
index|[
operator|(
name|w
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|b
operator|%
name|bytes
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|expand_line (gdouble * dest,gdouble * src,gint bytes,gint old_width,gint width,GimpInterpolationType interp)
name|expand_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
name|gdouble
name|ratio
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|src_col
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
name|gdouble
modifier|*
name|s
decl_stmt|;
name|ratio
operator|=
name|old_width
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
comment|/* we can overflow src's boundaries, so we expect our caller to have      allocated extra space for us to do so safely (see scale_region ()) */
comment|/* this could be optimized much more by precalculating the coefficients for      each x */
switch|switch
condition|(
name|interp
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|src_col
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x
operator|*
name|ratio
operator|+
literal|2.0
operator|-
literal|0.5
argument_list|)
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* +2, -2 is there because (int) rounds towards 0 and we need              to round down */
name|frac
operator|=
operator|(
name|x
operator|*
name|ratio
operator|-
literal|0.5
operator|)
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|cubic
argument_list|(
name|frac
argument_list|,
name|s
index|[
name|b
operator|-
name|bytes
index|]
argument_list|,
name|s
index|[
name|b
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bytes
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bytes
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|src_col
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x
operator|*
name|ratio
operator|+
literal|2.0
operator|-
literal|0.5
argument_list|)
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* +2, -2 is there because (int) rounds towards 0 and we need              to round down */
name|frac
operator|=
operator|(
name|x
operator|*
name|ratio
operator|-
literal|0.5
operator|)
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
operator|(
name|s
index|[
name|b
operator|+
name|bytes
index|]
operator|-
name|s
index|[
name|b
index|]
operator|)
operator|*
name|frac
operator|+
name|s
index|[
name|b
index|]
operator|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shrink_line (gdouble * dest,gdouble * src,gint bytes,gint old_width,gint width,GimpInterpolationType interp)
name|shrink_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
name|gint
name|x
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gdouble
modifier|*
name|srcp
decl_stmt|;
name|gdouble
modifier|*
name|destp
decl_stmt|;
name|gdouble
name|accum
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|slice
decl_stmt|;
specifier|const
name|gdouble
name|avg_ratio
init|=
operator|(
name|gdouble
operator|)
name|width
operator|/
name|old_width
decl_stmt|;
specifier|const
name|gdouble
name|inv_width
init|=
literal|1.0
operator|/
name|width
decl_stmt|;
name|gint
name|slicepos
decl_stmt|;
comment|/* slice position relative to width */
if|#
directive|if
literal|0
block|g_printerr ("shrink_line bytes=%d old_width=%d width=%d interp=%d "               "avg_ratio=%f\n",               bytes, old_width, width, interp, avg_ratio);
endif|#
directive|endif
name|g_return_if_fail
argument_list|(
name|bytes
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* This algorithm calculates the weighted average of pixel data that      each output pixel must receive, taking into account that it always      scales down, i.e. there's always more than one input pixel per each      output pixel.  */
name|srcp
operator|=
name|src
expr_stmt|;
name|destp
operator|=
name|dest
expr_stmt|;
name|slicepos
operator|=
literal|0
expr_stmt|;
comment|/* Initialize accum to the first pixel slice.  As there is no partial      pixel at start, that value is 0.  The source data is interleaved, so      we maintain BYTES accumulators at the same time to deal with that      many channels simultaneously.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* Accumulate whole pixels.  */
do|do
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|+=
operator|*
name|srcp
operator|++
expr_stmt|;
name|slicepos
operator|+=
name|width
expr_stmt|;
block|}
do|while
condition|(
name|slicepos
operator|<
name|old_width
condition|)
do|;
name|slicepos
operator|-=
name|old_width
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slicepos
operator|<
name|width
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (slicepos< width) failed. Please report."
argument_list|)
expr_stmt|;
if|if
condition|(
name|slicepos
operator|==
literal|0
condition|)
block|{
comment|/* Simplest case: we have reached a whole pixel boundary.  Store              the average value per channel and reset the accumulators for              the next round.               The main reason to treat this case separately is to avoid an              access to out-of-bounds memory for the first pixel.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
operator|*
name|destp
operator|++
operator|=
name|accum
index|[
name|b
index|]
operator|*
name|avg_ratio
expr_stmt|;
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
comment|/* We have accumulated a whole pixel per channel where just a                  slice of it was needed.  Subtract now the previous pixel's                  extra slice.  */
name|slice
operator|=
name|srcp
index|[
operator|-
name|bytes
operator|+
name|b
index|]
operator|*
name|slicepos
operator|*
name|inv_width
expr_stmt|;
operator|*
name|destp
operator|++
operator|=
operator|(
name|accum
index|[
name|b
index|]
operator|-
name|slice
operator|)
operator|*
name|avg_ratio
expr_stmt|;
comment|/* That slice is the initial value for the next round.  */
name|accum
index|[
name|b
index|]
operator|=
name|slice
expr_stmt|;
block|}
block|}
block|}
comment|/* Sanity check: srcp should point to the next-to-last position, and      slicepos should be zero.  */
if|if
condition|(
operator|!
operator|(
name|srcp
operator|-
name|src
operator|==
name|old_width
operator|*
name|bytes
operator|&&
name|slicepos
operator|==
literal|0
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (srcp - src == old_width * bytes&& slicepos == 0)"
literal|" failed. Please report."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|rotate_pointers (guchar ** p,guint32 n)
name|rotate_pointers
parameter_list|(
name|guchar
modifier|*
modifier|*
name|p
parameter_list|,
name|guint32
name|n
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
name|guchar
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|p
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_scaled_row (gdouble ** src,gint y,gint new_width,PixelRegion * srcPR,gdouble * row,guchar * src_tmp,GimpInterpolationType interpolation_type)
name|get_scaled_row
parameter_list|(
name|gdouble
modifier|*
modifier|*
name|src
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|src_tmp
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|)
block|{
comment|/* get the necesary lines from the source image, scale them,      and put them into src[] */
name|rotate_pointers
argument_list|(
operator|(
name|gpointer
operator|)
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|srcPR
operator|->
name|h
condition|)
block|{
name|get_premultiplied_double_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_width
operator|>
name|srcPR
operator|->
name|w
condition|)
name|expand_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|srcPR
operator|->
name|w
operator|>
name|new_width
condition|)
name|shrink_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
else|else
comment|/* no scailing needed */
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|src
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|scale_region (PixelRegion * srcPR,PixelRegion * destPR,GimpInterpolationType interpolation,GimpProgressFunc progress_callback,gpointer progress_data)
name|scale_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|GimpInterpolationType
name|interpolation
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|gdouble
modifier|*
name|src
index|[
literal|4
index|]
decl_stmt|;
name|guchar
modifier|*
name|src_tmp
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|accum
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gdouble
name|y_rat
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|old_y
init|=
operator|-
literal|4
decl_stmt|;
name|gint
name|new_y
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|interpolation
operator|==
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|scale_region_no_resample
argument_list|(
name|srcPR
argument_list|,
name|destPR
argument_list|)
expr_stmt|;
return|return;
block|}
name|orig_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("scale_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  find the ratios of old y to new y  */
name|y_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
comment|/*  the data pointers...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|src
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|src_tmp
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/* offset the row pointer by 2*bytes so the range of the array      is [-2*bytes] to [(orig_width + 2)*bytes] */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
operator|(
name|orig_width
operator|+
literal|2
operator|*
literal|2
operator|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|row
operator|+=
name|bytes
operator|*
literal|2
expr_stmt|;
name|accum
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress_callback
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
literal|0
argument_list|,
name|height
argument_list|,
name|y
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|height
operator|<
name|orig_height
condition|)
block|{
name|gint
name|max
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
specifier|const
name|gdouble
name|inv_ratio
init|=
literal|1.0
operator|/
name|y_rat
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
comment|/* load the first row if this is the first time through */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|new_y
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|*
name|y_rat
argument_list|)
expr_stmt|;
name|frac
operator|=
literal|1.0
operator|-
operator|(
name|y
operator|*
name|y_rat
operator|-
name|new_y
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|*
name|frac
expr_stmt|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
argument_list|)
operator|-
name|new_y
operator|-
literal|1
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|+=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|max
operator|--
expr_stmt|;
block|}
name|frac
operator|=
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
block|{
name|accum
index|[
name|x
index|]
operator|+=
name|frac
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|accum
index|[
name|x
index|]
operator|*=
name|inv_ratio
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|height
operator|>
name|orig_height
condition|)
block|{
name|new_y
operator|=
name|floor
argument_list|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_y
operator|<=
name|new_y
condition|)
block|{
comment|/* get the necesary lines from the source image, scale them,                  and put them into src[] */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|old_y
operator|+
literal|2
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|old_y
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|interpolation
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
block|{
name|gdouble
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|gdouble
name|dy
init|=
operator|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|p0
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p1
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p3
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
operator|(
name|p0
operator|*
name|src
index|[
literal|0
index|]
index|[
name|x
index|]
operator|+
name|p1
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|p2
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
operator|+
name|p3
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
block|{
name|gdouble
name|idy
init|=
operator|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|gdouble
name|dy
init|=
literal|1.0
operator|-
name|idy
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|dy
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|idy
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* height == orig_height */
block|{
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|accum
argument_list|,
name|src
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* unmultiply the alpha */
name|gdouble
name|inv_alpha
decl_stmt|;
name|gdouble
modifier|*
name|p
init|=
name|accum
decl_stmt|;
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gint
name|result
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|alpha
index|]
operator|>
literal|0.001
condition|)
block|{
name|inv_alpha
operator|=
literal|255.0
operator|/
name|p
index|[
name|alpha
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|result
operator|=
name|RINT
argument_list|(
name|inv_alpha
operator|*
name|p
index|[
name|b
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|b
index|]
operator|=
name|result
expr_stmt|;
block|}
name|result
operator|=
name|RINT
argument_list|(
name|p
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|alpha
index|]
operator|=
name|result
expr_stmt|;
block|}
else|else
comment|/* alpha<= 0 */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<=
name|alpha
condition|;
name|b
operator|++
control|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|+=
name|bytes
expr_stmt|;
name|p
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|gint
name|w
init|=
name|width
operator|*
name|bytes
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|<
literal|0.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|>
literal|255.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|dest
index|[
name|x
index|]
operator|=
name|RINT
argument_list|(
name|accum
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src_tmp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|row
operator|-=
literal|2
operator|*
name|bytes
expr_stmt|;
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|subsample_region (PixelRegion * srcPR,PixelRegion * destPR,gint subsample)
name|subsample_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|subsample
parameter_list|)
block|{
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|gint
name|destwidth
decl_stmt|;
name|gint
name|src_row
decl_stmt|,
name|src_col
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gdouble
name|x_rat
decl_stmt|,
name|y_rat
decl_stmt|;
name|gdouble
name|x_cum
decl_stmt|,
name|y_cum
decl_stmt|;
name|gdouble
name|x_last
decl_stmt|,
name|y_last
decl_stmt|;
name|gdouble
modifier|*
name|x_frac
decl_stmt|,
name|y_frac
decl_stmt|,
name|tot_frac
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|frac
decl_stmt|;
name|gint
name|advance_dest
decl_stmt|;
name|orig_width
operator|=
name|srcPR
operator|->
name|w
operator|/
name|subsample
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
operator|/
name|subsample
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("subsample_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  Some calculations...  */
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
name|destwidth
operator|=
name|destPR
operator|->
name|rowstride
expr_stmt|;
comment|/*  the data pointers...  */
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|destPR
operator|->
name|data
expr_stmt|;
comment|/*  find the ratios of old x to new x and old y to new y  */
name|x_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_width
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|y_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
comment|/*  allocate an array to help with the calculations  */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|x_frac
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|+
name|orig_width
argument_list|)
expr_stmt|;
comment|/*  initialize the pre-calculated pixel fraction array  */
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
name|x_last
operator|=
name|x_cum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|+
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x_cum
operator|+
name|x_rat
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|x_cum
operator|+=
name|x_rat
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|x_cum
operator|-
name|x_last
expr_stmt|;
block|}
else|else
block|{
name|src_col
operator|++
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|src_col
operator|-
name|x_last
expr_stmt|;
block|}
name|x_last
operator|+=
name|x_frac
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  counters...  */
name|src_row
operator|=
literal|0
expr_stmt|;
name|y_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_row
expr_stmt|;
name|y_last
operator|=
name|y_cum
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
control|)
block|{
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
comment|/* determine the fraction of the src pixel we are using for y */
if|if
condition|(
name|y_cum
operator|+
name|y_rat
operator|<=
operator|(
name|src_row
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|y_cum
operator|+=
name|y_rat
expr_stmt|;
name|y_frac
operator|=
name|y_cum
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|src_row
operator|++
expr_stmt|;
name|y_frac
operator|=
name|src_row
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|FALSE
expr_stmt|;
block|}
name|y_last
operator|+=
name|y_frac
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|frac
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
condition|)
block|{
name|tot_frac
operator|=
name|x_frac
index|[
name|frac
operator|++
index|]
operator|*
name|y_frac
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|r
index|[
name|b
index|]
operator|+=
name|s
index|[
name|b
index|]
operator|*
name|tot_frac
expr_stmt|;
comment|/*  increment the destination  */
if|if
condition|(
name|x_cum
operator|+
name|x_rat
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|r
operator|+=
name|bytes
expr_stmt|;
name|x_cum
operator|+=
name|x_rat
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* increment the source */
else|else
block|{
name|s
operator|+=
name|bytes
expr_stmt|;
name|src_col
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advance_dest
condition|)
block|{
name|tot_frac
operator|=
literal|1.0
operator|/
operator|(
name|x_rat
operator|*
name|y_rat
operator|)
expr_stmt|;
comment|/*  copy "row" to "dest"  */
name|d
operator|=
name|dest
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|b
operator|=
name|bytes
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|*
name|r
operator|++
operator|*
name|tot_frac
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
name|dest
operator|+=
name|destwidth
expr_stmt|;
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|destwidth
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|x_frac
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gfloat
DECL|function|shapeburst_region (PixelRegion * srcPR,PixelRegion * distPR,GimpProgressFunc progress_callback,gpointer progress_data)
name|shapeburst_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|distPR
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|guchar
modifier|*
name|tile_data
decl_stmt|;
name|gfloat
name|max_iterations
init|=
literal|0.0
decl_stmt|;
name|gfloat
modifier|*
name|distp_cur
decl_stmt|;
name|gfloat
modifier|*
name|distp_prev
decl_stmt|;
name|gfloat
modifier|*
name|memory
decl_stmt|;
name|gfloat
modifier|*
name|tmp
decl_stmt|;
name|gfloat
name|min_prev
decl_stmt|;
name|gfloat
name|float_tmp
decl_stmt|;
name|gint
name|min
decl_stmt|;
name|gint
name|min_left
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|fraction
decl_stmt|;
name|gint
name|prev_frac
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|end
decl_stmt|;
name|gint
name|boundary
decl_stmt|;
name|gint
name|inc
decl_stmt|;
name|gint
name|src
init|=
literal|0
decl_stmt|;
name|gint
name|max_progress
init|=
name|srcPR
operator|->
name|w
operator|*
name|srcPR
operator|->
name|h
decl_stmt|;
name|gint
name|progress
init|=
literal|0
decl_stmt|;
name|length
operator|=
name|distPR
operator|->
name|w
operator|+
literal|1
expr_stmt|;
name|memory
operator|=
name|g_new
argument_list|(
name|gfloat
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|distp_prev
operator|=
name|memory
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|distp_prev
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
name|distp_prev
operator|+=
literal|1
expr_stmt|;
name|distp_cur
operator|=
name|distp_prev
operator|+
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srcPR
operator|->
name|h
condition|;
name|i
operator|++
control|)
block|{
comment|/*  set the current dist row to 0's  */
name|memset
argument_list|(
name|distp_cur
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
operator|*
operator|(
name|length
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srcPR
operator|->
name|w
condition|;
name|j
operator|++
control|)
block|{
name|min_prev
operator|=
name|MIN
argument_list|(
name|distp_cur
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
name|distp_prev
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|min_left
operator|=
name|MIN
argument_list|(
operator|(
name|srcPR
operator|->
name|w
operator|-
name|j
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|srcPR
operator|->
name|h
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|min
operator|=
operator|(
name|gint
operator|)
name|MIN
argument_list|(
name|min_left
argument_list|,
name|min_prev
argument_list|)
expr_stmt|;
name|fraction
operator|=
literal|255
expr_stmt|;
comment|/*  This might need to be changed to 0               instead of k = (min) ? (min - 1) : 0  */
for|for
control|(
name|k
operator|=
operator|(
name|min
operator|)
condition|?
operator|(
name|min
operator|-
literal|1
operator|)
else|:
literal|0
init|;
name|k
operator|<=
name|min
condition|;
name|k
operator|++
control|)
block|{
name|x
operator|=
name|j
expr_stmt|;
name|y
operator|=
name|i
operator|+
name|k
expr_stmt|;
name|end
operator|=
name|y
operator|-
name|k
expr_stmt|;
while|while
condition|(
name|y
operator|>=
name|end
condition|)
block|{
name|gint
name|width
decl_stmt|;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|srcPR
operator|->
name|tiles
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile_data
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|width
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|MIN
argument_list|(
name|y
operator|%
name|TILE_HEIGHT
argument_list|,
name|width
operator|-
operator|(
name|x
operator|%
name|TILE_WIDTH
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|MIN
argument_list|(
name|boundary
argument_list|,
name|y
operator|-
name|end
argument_list|)
operator|+
literal|1
expr_stmt|;
name|inc
operator|=
literal|1
operator|-
name|width
expr_stmt|;
while|while
condition|(
name|boundary
operator|--
condition|)
block|{
name|src
operator|=
operator|*
name|tile_data
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
block|{
name|min
operator|=
name|k
expr_stmt|;
name|y
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src
operator|<
name|fraction
condition|)
name|fraction
operator|=
name|src
expr_stmt|;
name|x
operator|++
expr_stmt|;
name|y
operator|--
expr_stmt|;
name|tile_data
operator|+=
name|inc
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src
operator|!=
literal|0
condition|)
block|{
comment|/*  If min_left != min_prev use the previous fraction                *   if it is less than the one found                */
if|if
condition|(
name|min_left
operator|!=
name|min
condition|)
block|{
name|prev_frac
operator|=
call|(
name|int
call|)
argument_list|(
literal|255
operator|*
operator|(
name|min_prev
operator|-
name|min
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_frac
operator|==
literal|255
condition|)
name|prev_frac
operator|=
literal|0
expr_stmt|;
name|fraction
operator|=
name|MIN
argument_list|(
name|fraction
argument_list|,
name|prev_frac
argument_list|)
expr_stmt|;
block|}
name|min
operator|++
expr_stmt|;
block|}
name|float_tmp
operator|=
name|distp_cur
index|[
name|j
index|]
operator|=
name|min
operator|+
name|fraction
operator|/
literal|256.0
expr_stmt|;
if|if
condition|(
name|float_tmp
operator|>
name|max_iterations
condition|)
name|max_iterations
operator|=
name|float_tmp
expr_stmt|;
block|}
comment|/*  set the dist row  */
name|pixel_region_set_row
argument_list|(
name|distPR
argument_list|,
name|distPR
operator|->
name|x
argument_list|,
name|distPR
operator|->
name|y
operator|+
name|i
argument_list|,
name|distPR
operator|->
name|w
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|distp_cur
argument_list|)
expr_stmt|;
comment|/*  swap pointers around  */
name|tmp
operator|=
name|distp_prev
expr_stmt|;
name|distp_prev
operator|=
name|distp_cur
expr_stmt|;
name|distp_cur
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|progress_callback
condition|)
block|{
name|progress
operator|+=
name|srcPR
operator|->
name|h
expr_stmt|;
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
literal|0
argument_list|,
name|max_progress
argument_list|,
name|progress
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|memory
argument_list|)
expr_stmt|;
return|return
name|max_iterations
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_border (gint16 * circ,guint16 xradius,guint16 yradius)
name|compute_border
parameter_list|(
name|gint16
modifier|*
name|circ
parameter_list|,
name|guint16
name|xradius
parameter_list|,
name|guint16
name|yradius
parameter_list|)
block|{
name|gint32
name|i
decl_stmt|;
name|gint32
name|diameter
init|=
name|xradius
operator|*
literal|2
operator|+
literal|1
decl_stmt|;
name|gdouble
name|tmp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diameter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|xradius
condition|)
name|tmp
operator|=
operator|(
name|i
operator|-
name|xradius
operator|)
operator|-
literal|0.5
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|xradius
condition|)
name|tmp
operator|=
operator|(
name|xradius
operator|-
name|i
operator|)
operator|-
literal|0.5
expr_stmt|;
else|else
name|tmp
operator|=
literal|0.0
expr_stmt|;
name|circ
index|[
name|i
index|]
operator|=
name|RINT
argument_list|(
name|yradius
operator|/
operator|(
name|gdouble
operator|)
name|xradius
operator|*
name|sqrt
argument_list|(
name|xradius
operator|*
name|xradius
operator|-
name|tmp
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|fatten_region (PixelRegion * src,gint16 xradius,gint16 yradius)
name|fatten_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|gint16
name|xradius
parameter_list|,
name|gint16
name|yradius
parameter_list|)
block|{
comment|/*      Any bugs in this fuction are probably also in thin_region      Blame all bugs in this function on jaycox@gimp.org   */
specifier|register
name|gint32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* caches the region's pixel data */
name|guchar
modifier|*
name|out
decl_stmt|;
comment|/* holds the new scan line we are computing */
name|guchar
modifier|*
modifier|*
name|max
decl_stmt|;
comment|/* caches the largest values for each column */
name|gint16
modifier|*
name|circ
decl_stmt|;
comment|/* holds the y coords of the filter's mask */
name|gint16
name|last_max
decl_stmt|,
name|last_index
decl_stmt|;
name|guchar
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|xradius
operator|<=
literal|0
operator|||
name|yradius
operator|<=
literal|0
condition|)
return|return;
name|max
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
operator|(
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
operator|)
operator|*
operator|(
name|yradius
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|xradius
condition|)
name|max
index|[
name|i
index|]
operator|=
name|buffer
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|src
operator|->
name|w
operator|+
name|xradius
condition|)
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|i
operator|-
name|xradius
operator|)
index|]
expr_stmt|;
else|else
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|src
operator|->
name|w
operator|+
name|xradius
operator|-
literal|1
operator|)
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|xradius
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|max
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* offset the max pointer by xradius so the range of the array      is [-xradius] to [src->w + xradius] */
name|max
operator|+=
name|xradius
expr_stmt|;
name|out
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|circ
operator|=
name|g_new
argument_list|(
name|gint16
argument_list|,
literal|2
operator|*
name|xradius
operator|+
literal|1
argument_list|)
expr_stmt|;
name|compute_border
argument_list|(
name|circ
argument_list|,
name|xradius
argument_list|,
name|yradius
argument_list|)
expr_stmt|;
comment|/* offset the circ pointer by xradius so the range of the array      is [-xradius] to [xradius] */
name|circ
operator|+=
name|xradius
expr_stmt|;
name|memset
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|&&
name|i
operator|<
name|src
operator|->
name|h
condition|;
name|i
operator|++
control|)
comment|/* load top of image */
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|i
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* set up max for top of image */
block|{
name|max
index|[
name|x
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* buf[0][x] is always 0 */
name|max
index|[
name|x
index|]
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
index|[
name|x
index|]
expr_stmt|;
comment|/* MAX (buf[1][x], max[x][0]) always = buf[1][x]*/
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|yradius
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|max
index|[
name|x
index|]
index|[
name|j
index|]
operator|=
name|MAX
argument_list|(
name|buf
index|[
name|j
index|]
index|[
name|x
index|]
argument_list|,
name|max
index|[
name|x
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|rotate_pointers
argument_list|(
name|buf
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|src
operator|->
name|h
operator|-
operator|(
name|yradius
operator|)
condition|)
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
operator|+
name|yradius
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
name|yradius
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|buf
index|[
name|yradius
index|]
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* update max array */
block|{
for|for
control|(
name|i
operator|=
name|yradius
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|max
index|[
name|x
index|]
index|[
name|i
index|]
operator|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|max
index|[
name|x
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|buf
index|[
name|i
operator|-
literal|1
index|]
index|[
name|x
index|]
argument_list|)
argument_list|,
name|buf
index|[
name|i
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|max
index|[
name|x
index|]
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
name|last_max
operator|=
name|max
index|[
literal|0
index|]
index|[
name|circ
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|last_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* render scan line */
block|{
name|last_index
operator|--
expr_stmt|;
if|if
condition|(
name|last_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|last_max
operator|==
literal|255
condition|)
name|out
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
block|{
name|last_max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|last_max
operator|<
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
condition|)
block|{
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_index
operator|=
name|xradius
expr_stmt|;
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|xradius
index|]
index|[
name|circ
index|[
name|xradius
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
operator|-
literal|1
init|;
name|i
operator|>=
operator|-
name|xradius
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|last_max
operator|<
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
condition|)
block|{
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* undo the offsets to the pointers so we can free the malloced memmory */
name|circ
operator|-=
name|xradius
expr_stmt|;
name|max
operator|-=
name|xradius
expr_stmt|;
name|g_free
argument_list|(
name|circ
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|thin_region (PixelRegion * src,gint16 xradius,gint16 yradius,gboolean edge_lock)
name|thin_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|gint16
name|xradius
parameter_list|,
name|gint16
name|yradius
parameter_list|,
name|gboolean
name|edge_lock
parameter_list|)
block|{
comment|/*      pretty much the same as fatten_region only different      blame all bugs in this function on jaycox@gimp.org   */
comment|/* If edge_lock is true  we assume that pixels outside the region      we are passed are identical to the edge pixels.      If edge_lock is false, we assume that pixels outside the region are 0   */
specifier|register
name|gint32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* caches the the region's pixels */
name|guchar
modifier|*
name|out
decl_stmt|;
comment|/* holds the new scan line we are computing */
name|guchar
modifier|*
modifier|*
name|max
decl_stmt|;
comment|/* caches the smallest values for each column */
name|gint16
modifier|*
name|circ
decl_stmt|;
comment|/* holds the y coords of the filter's mask */
name|gint16
name|last_max
decl_stmt|,
name|last_index
decl_stmt|;
name|guchar
modifier|*
name|buffer
decl_stmt|;
name|gint
name|buffer_size
decl_stmt|;
if|if
condition|(
name|xradius
operator|<=
literal|0
operator|||
name|yradius
operator|<=
literal|0
condition|)
return|return;
name|max
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
argument_list|)
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
name|buffer_size
operator|=
operator|(
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|yradius
operator|+
literal|1
operator|)
expr_stmt|;
name|buffer
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_lock
condition|)
name|memset
argument_list|(
name|buffer
argument_list|,
literal|255
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|xradius
condition|)
if|if
condition|(
name|edge_lock
condition|)
name|max
index|[
name|i
index|]
operator|=
name|buffer
expr_stmt|;
else|else
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|src
operator|->
name|w
operator|+
name|xradius
operator|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|src
operator|->
name|w
operator|+
name|xradius
condition|)
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|i
operator|-
name|xradius
operator|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|edge_lock
condition|)
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|src
operator|->
name|w
operator|+
name|xradius
operator|-
literal|1
operator|)
index|]
expr_stmt|;
else|else
name|max
index|[
name|i
index|]
operator|=
operator|&
name|buffer
index|[
operator|(
name|yradius
operator|+
literal|1
operator|)
operator|*
operator|(
name|src
operator|->
name|w
operator|+
name|xradius
operator|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edge_lock
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|xradius
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|max
index|[
literal|0
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* offset the max pointer by xradius so the range of the array      is [-xradius] to [src->w + xradius] */
name|max
operator|+=
name|xradius
expr_stmt|;
name|out
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|circ
operator|=
name|g_new
argument_list|(
name|gint16
argument_list|,
literal|2
operator|*
name|xradius
operator|+
literal|1
argument_list|)
expr_stmt|;
name|compute_border
argument_list|(
name|circ
argument_list|,
name|xradius
argument_list|,
name|yradius
argument_list|)
expr_stmt|;
comment|/* offset the circ pointer by xradius so the range of the array     is [-xradius] to [xradius] */
name|circ
operator|+=
name|xradius
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|&&
name|i
operator|<
name|src
operator|->
name|h
condition|;
name|i
operator|++
control|)
comment|/* load top of image */
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|i
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_lock
condition|)
name|memcpy
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* set up max for top of image */
block|{
name|max
index|[
name|x
index|]
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|yradius
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|max
index|[
name|x
index|]
index|[
name|j
index|]
operator|=
name|MIN
argument_list|(
name|buf
index|[
name|j
index|]
index|[
name|x
index|]
argument_list|,
name|max
index|[
name|x
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|rotate_pointers
argument_list|(
name|buf
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|src
operator|->
name|h
operator|-
name|yradius
condition|)
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
operator|+
name|yradius
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
name|yradius
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edge_lock
condition|)
name|memcpy
argument_list|(
name|buf
index|[
name|yradius
index|]
argument_list|,
name|buf
index|[
name|yradius
operator|-
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|buf
index|[
name|yradius
index|]
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* update max array */
block|{
for|for
control|(
name|i
operator|=
name|yradius
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|max
index|[
name|x
index|]
index|[
name|i
index|]
operator|=
name|MIN
argument_list|(
name|MIN
argument_list|(
name|max
index|[
name|x
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|buf
index|[
name|i
operator|-
literal|1
index|]
index|[
name|x
index|]
argument_list|)
argument_list|,
name|buf
index|[
name|i
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|max
index|[
name|x
index|]
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
name|last_max
operator|=
name|max
index|[
literal|0
index|]
index|[
name|circ
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|last_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* render scan line */
block|{
name|last_index
operator|--
expr_stmt|;
if|if
condition|(
name|last_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|last_max
operator|==
literal|0
condition|)
name|out
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|last_max
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|last_max
operator|>
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
condition|)
block|{
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_index
operator|=
name|xradius
expr_stmt|;
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|xradius
index|]
index|[
name|circ
index|[
name|xradius
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
operator|-
literal|1
init|;
name|i
operator|>=
operator|-
name|xradius
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|last_max
operator|>
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
condition|)
block|{
name|last_max
operator|=
name|max
index|[
name|x
operator|+
name|i
index|]
index|[
name|circ
index|[
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* undo the offsets to the pointers so we can free the malloced memmory */
name|circ
operator|-=
name|xradius
expr_stmt|;
name|max
operator|-=
name|xradius
expr_stmt|;
comment|/* free the memmory */
name|g_free
argument_list|(
name|circ
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_transition (guchar * transition,guchar ** buf,gint32 width)
name|compute_transition
parameter_list|(
name|guchar
modifier|*
name|transition
parameter_list|,
name|guchar
modifier|*
modifier|*
name|buf
parameter_list|,
name|gint32
name|width
parameter_list|)
block|{
specifier|register
name|gint32
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|1
index|]
index|[
name|x
index|]
operator|>
literal|127
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|)
condition|)
name|transition
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
index|[
name|x
index|]
operator|>
literal|127
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|0
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|1
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
condition|)
name|transition
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|width
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
literal|1
index|]
index|[
name|x
index|]
operator|>=
literal|128
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|0
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|1
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|1
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|<
literal|128
condition|)
name|transition
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
index|[
name|x
index|]
operator|>=
literal|128
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|0
index|]
index|[
name|x
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|1
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
operator|-
literal|1
index|]
operator|<
literal|128
operator|||
name|buf
index|[
literal|2
index|]
index|[
name|x
index|]
operator|<
literal|128
condition|)
name|transition
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|transition
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|border_region (PixelRegion * src,gint16 xradius,gint16 yradius)
name|border_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|gint16
name|xradius
parameter_list|,
name|gint16
name|yradius
parameter_list|)
block|{
comment|/*      This function has no bugs, but if you imagine some you can      blame them on jaycox@gimp.org   */
specifier|register
name|gint32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guchar
modifier|*
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|guchar
modifier|*
name|out
decl_stmt|;
name|gint16
modifier|*
name|max
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|density
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|transition
decl_stmt|;
name|guchar
name|last_max
decl_stmt|;
name|gint16
name|last_index
decl_stmt|;
if|if
condition|(
name|xradius
operator|<
literal|0
operator|||
name|yradius
operator|<
literal|0
condition|)
block|{
name|g_warning
argument_list|(
literal|"border_region: negative radius specified."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xradius
operator|==
literal|0
operator|||
name|yradius
operator|==
literal|0
condition|)
block|{
name|guchar
name|color
index|[]
init|=
literal|"\0\0\0\0"
decl_stmt|;
name|color_region
argument_list|(
name|src
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xradius
operator|==
literal|1
operator|&&
name|yradius
operator|==
literal|1
condition|)
comment|/* optimize this case specifically */
block|{
name|guchar
modifier|*
name|transition
decl_stmt|;
name|guchar
modifier|*
name|source
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|source
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|transition
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|source
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|source
index|[
literal|1
index|]
argument_list|,
name|source
index|[
literal|0
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|h
operator|>
literal|1
condition|)
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
literal|1
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|source
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|source
index|[
literal|2
index|]
argument_list|,
name|source
index|[
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|compute_transition
argument_list|(
name|transition
argument_list|,
name|source
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|pixel_region_set_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|transition
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<
name|src
operator|->
name|h
condition|;
name|y
operator|++
control|)
block|{
name|rotate_pointers
argument_list|(
name|source
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|+
literal|1
operator|<
name|src
operator|->
name|h
condition|)
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
operator|+
literal|1
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|source
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|source
index|[
literal|2
index|]
argument_list|,
name|source
index|[
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|compute_transition
argument_list|(
name|transition
argument_list|,
name|source
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|pixel_region_set_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|transition
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|source
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|transition
argument_list|)
expr_stmt|;
return|return;
block|}
name|max
operator|=
name|g_new
argument_list|(
name|gint16
argument_list|,
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
operator|)
condition|;
name|i
operator|++
control|)
name|max
index|[
name|i
index|]
operator|=
name|yradius
operator|+
literal|2
expr_stmt|;
name|max
operator|+=
name|xradius
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|transition
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|transition
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|transition
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|w
operator|+
literal|2
operator|*
name|xradius
argument_list|)
expr_stmt|;
name|transition
index|[
name|i
index|]
operator|+=
name|xradius
expr_stmt|;
block|}
name|out
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|density
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
literal|2
operator|*
name|xradius
operator|+
literal|1
argument_list|)
expr_stmt|;
name|density
operator|+=
name|xradius
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|xradius
operator|+
literal|1
operator|)
condition|;
name|x
operator|++
control|)
comment|/* allocate density[][] */
block|{
name|density
index|[
name|x
index|]
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
literal|2
operator|*
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
name|density
index|[
name|x
index|]
operator|+=
name|yradius
expr_stmt|;
name|density
index|[
operator|-
name|x
index|]
operator|=
name|density
index|[
name|x
index|]
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|xradius
operator|+
literal|1
operator|)
condition|;
name|x
operator|++
control|)
comment|/* compute density[][] */
block|{
specifier|register
name|gdouble
name|tmpx
decl_stmt|,
name|tmpy
decl_stmt|,
name|dist
decl_stmt|;
name|guchar
name|a
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|0
condition|)
name|tmpx
operator|=
name|x
operator|-
literal|0.5
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|tmpx
operator|=
name|x
operator|+
literal|0.5
expr_stmt|;
else|else
name|tmpx
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
operator|(
name|yradius
operator|+
literal|1
operator|)
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|tmpy
operator|=
name|y
operator|-
literal|0.5
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|tmpy
operator|=
name|y
operator|+
literal|0.5
expr_stmt|;
else|else
name|tmpy
operator|=
literal|0.0
expr_stmt|;
name|dist
operator|=
operator|(
operator|(
name|tmpy
operator|*
name|tmpy
operator|)
operator|/
operator|(
name|yradius
operator|*
name|yradius
operator|)
operator|+
operator|(
name|tmpx
operator|*
name|tmpx
operator|)
operator|/
operator|(
name|xradius
operator|*
name|xradius
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|1.0
condition|)
name|a
operator|=
literal|255
operator|*
operator|(
literal|1.0
operator|-
name|sqrt
argument_list|(
name|dist
argument_list|)
operator|)
expr_stmt|;
else|else
name|a
operator|=
literal|0
expr_stmt|;
name|density
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|a
expr_stmt|;
name|density
index|[
name|x
index|]
index|[
operator|-
name|y
index|]
operator|=
name|a
expr_stmt|;
name|density
index|[
operator|-
name|x
index|]
index|[
name|y
index|]
operator|=
name|a
expr_stmt|;
name|density
index|[
operator|-
name|x
index|]
index|[
operator|-
name|y
index|]
operator|=
name|a
expr_stmt|;
block|}
block|}
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
literal|0
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|h
operator|>
literal|1
condition|)
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
literal|1
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
name|compute_transition
argument_list|(
name|transition
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<
name|yradius
operator|&&
name|y
operator|+
literal|1
operator|<
name|src
operator|->
name|h
condition|;
name|y
operator|++
control|)
comment|/* set up top of image */
block|{
name|rotate_pointers
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
operator|+
literal|1
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compute_transition
argument_list|(
name|transition
index|[
name|y
operator|+
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* set up max[] for top of image */
block|{
name|max
index|[
name|x
index|]
operator|=
operator|-
operator|(
name|yradius
operator|+
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|yradius
operator|+
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|transition
index|[
name|j
index|]
index|[
name|x
index|]
condition|)
block|{
name|max
index|[
name|x
index|]
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|h
condition|;
name|y
operator|++
control|)
comment|/* main calculation loop */
block|{
name|rotate_pointers
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rotate_pointers
argument_list|(
name|transition
argument_list|,
name|yradius
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|src
operator|->
name|h
operator|-
operator|(
name|yradius
operator|+
literal|1
operator|)
condition|)
block|{
name|pixel_region_get_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
operator|+
name|yradius
operator|+
literal|1
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compute_transition
argument_list|(
name|transition
index|[
name|yradius
index|]
argument_list|,
name|buf
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|transition
index|[
name|yradius
index|]
argument_list|,
name|transition
index|[
name|yradius
operator|-
literal|1
index|]
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* update max array */
block|{
if|if
condition|(
name|max
index|[
name|x
index|]
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|max
index|[
name|x
index|]
operator|<=
operator|-
name|yradius
condition|)
block|{
if|if
condition|(
name|transition
index|[
name|yradius
index|]
index|[
name|x
index|]
condition|)
name|max
index|[
name|x
index|]
operator|=
name|yradius
expr_stmt|;
else|else
name|max
index|[
name|x
index|]
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|transition
index|[
operator|-
name|max
index|[
name|x
index|]
index|]
index|[
name|x
index|]
condition|)
name|max
index|[
name|x
index|]
operator|=
operator|-
name|max
index|[
name|x
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|transition
index|[
operator|-
name|max
index|[
name|x
index|]
operator|+
literal|1
index|]
index|[
name|x
index|]
condition|)
name|max
index|[
name|x
index|]
operator|=
operator|-
name|max
index|[
name|x
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|max
index|[
name|x
index|]
operator|--
expr_stmt|;
block|}
else|else
name|max
index|[
name|x
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|max
index|[
name|x
index|]
operator|<
operator|-
name|yradius
operator|-
literal|1
condition|)
name|max
index|[
name|x
index|]
operator|=
operator|-
name|yradius
operator|-
literal|1
expr_stmt|;
block|}
name|last_max
operator|=
name|max
index|[
literal|0
index|]
index|[
name|density
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|last_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|w
condition|;
name|x
operator|++
control|)
comment|/* render scan line */
block|{
name|last_index
operator|--
expr_stmt|;
if|if
condition|(
name|last_index
operator|>=
literal|0
condition|)
block|{
name|last_max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|max
index|[
name|x
operator|+
name|i
index|]
operator|<=
name|yradius
operator|&&
name|max
index|[
name|x
operator|+
name|i
index|]
operator|>=
operator|-
name|yradius
operator|&&
name|density
index|[
name|i
index|]
index|[
name|max
index|[
name|x
operator|+
name|i
index|]
index|]
operator|>
name|last_max
condition|)
block|{
name|last_max
operator|=
name|density
index|[
name|i
index|]
index|[
name|max
index|[
name|x
operator|+
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
else|else
block|{
name|last_max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xradius
init|;
name|i
operator|>=
operator|-
name|xradius
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|max
index|[
name|x
operator|+
name|i
index|]
operator|<=
name|yradius
operator|&&
name|max
index|[
name|x
operator|+
name|i
index|]
operator|>=
operator|-
name|yradius
operator|&&
name|density
index|[
name|i
index|]
index|[
name|max
index|[
name|x
operator|+
name|i
index|]
index|]
operator|>
name|last_max
condition|)
block|{
name|last_max
operator|=
name|density
index|[
name|i
index|]
index|[
name|max
index|[
name|x
operator|+
name|i
index|]
index|]
expr_stmt|;
name|last_index
operator|=
name|i
expr_stmt|;
block|}
name|out
index|[
name|x
index|]
operator|=
name|last_max
expr_stmt|;
block|}
if|if
condition|(
name|last_max
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|x
operator|+
literal|1
init|;
name|i
operator|<
name|src
operator|->
name|w
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max
index|[
name|i
index|]
operator|>=
operator|-
name|yradius
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|-
name|x
operator|>
name|xradius
condition|)
block|{
for|for
control|(
init|;
name|x
operator|<
name|i
operator|-
name|xradius
condition|;
name|x
operator|++
control|)
name|out
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
name|last_index
operator|=
name|xradius
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|y
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|max
operator|-=
name|xradius
expr_stmt|;
name|g_free
argument_list|(
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|transition
index|[
name|i
index|]
operator|-=
name|xradius
expr_stmt|;
name|g_free
argument_list|(
name|transition
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|transition
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xradius
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|density
index|[
name|i
index|]
operator|-=
name|yradius
expr_stmt|;
name|g_free
argument_list|(
name|density
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|density
operator|-=
name|xradius
expr_stmt|;
name|g_free
argument_list|(
name|density
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|swap_region (PixelRegion * src,PixelRegion * dest)
name|swap_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|length
operator|=
name|src
operator|->
name|w
operator|*
name|src
operator|->
name|bytes
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|swap_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|apply_mask_to_sub_region (gint * opacityp,PixelRegion * src,PixelRegion * mask)
name|apply_mask_to_sub_region
parameter_list|(
name|gint
modifier|*
name|opacityp
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|guint
name|opacity
init|=
operator|*
name|opacityp
decl_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|apply_mask_to_alpha_channel
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|apply_mask_to_region (PixelRegion * src,PixelRegion * mask,guint opacity)
name|apply_mask_to_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|)
block|{
name|pixel_regions_process_parallel
argument_list|(
operator|(
name|p_func
operator|)
name|apply_mask_to_sub_region
argument_list|,
operator|&
name|opacity
argument_list|,
literal|2
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|combine_mask_and_sub_region_stipple (gint * opacityp,PixelRegion * src,PixelRegion * mask)
name|combine_mask_and_sub_region_stipple
parameter_list|(
name|gint
modifier|*
name|opacityp
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|guint
name|opacity
init|=
operator|*
name|opacityp
decl_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|combine_mask_and_alpha_channel_stipple
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|combine_mask_and_sub_region_stroke (gint * opacityp,PixelRegion * src,PixelRegion * mask)
name|combine_mask_and_sub_region_stroke
parameter_list|(
name|gint
modifier|*
name|opacityp
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|guint
name|opacity
init|=
operator|*
name|opacityp
decl_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|combine_mask_and_alpha_channel_stroke
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_mask_and_region (PixelRegion * src,PixelRegion * mask,guint opacity,gboolean stipple)
name|combine_mask_and_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|gboolean
name|stipple
parameter_list|)
block|{
if|if
condition|(
name|stipple
condition|)
name|pixel_regions_process_parallel
argument_list|(
operator|(
name|p_func
operator|)
name|combine_mask_and_sub_region_stipple
argument_list|,
operator|&
name|opacity
argument_list|,
literal|2
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|pixel_regions_process_parallel
argument_list|(
operator|(
name|p_func
operator|)
name|combine_mask_and_sub_region_stroke
argument_list|,
operator|&
name|opacity
argument_list|,
literal|2
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|copy_gray_to_region (PixelRegion * src,PixelRegion * dest)
name|copy_gray_to_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|copy_gray_to_inten_a_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|copy_component (PixelRegion * src,PixelRegion * dest,guint pixel)
name|copy_component
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|guint
name|pixel
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|h
operator|=
name|src
operator|->
name|h
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|component_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|pixel
argument_list|)
expr_stmt|;
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_struct
DECL|struct|initial_regions_struct
struct|struct
name|initial_regions_struct
block|{
DECL|member|opacity
name|guint
name|opacity
decl_stmt|;
DECL|member|mode
name|GimpLayerModeEffects
name|mode
decl_stmt|;
DECL|member|affect
specifier|const
name|gboolean
modifier|*
name|affect
decl_stmt|;
DECL|member|type
name|InitialMode
name|type
decl_stmt|;
DECL|member|data
name|guchar
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
DECL|function|initial_sub_region (struct initial_regions_struct * st,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|initial_sub_region
parameter_list|(
name|struct
name|initial_regions_struct
modifier|*
name|st
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
name|gint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|guint
name|opacity
decl_stmt|;
name|GimpLayerModeEffects
name|mode
decl_stmt|;
specifier|const
name|gboolean
modifier|*
name|affect
decl_stmt|;
name|InitialMode
name|type
decl_stmt|;
comment|/* use src->bytes + 1 since DISSOLVE always needs a buffer with alpha */
name|buf
operator|=
name|g_alloca
argument_list|(
name|MAX
argument_list|(
name|src
operator|->
name|w
operator|*
operator|(
name|src
operator|->
name|bytes
operator|+
literal|1
operator|)
argument_list|,
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|st
operator|->
name|data
expr_stmt|;
name|opacity
operator|=
name|st
operator|->
name|opacity
expr_stmt|;
name|mode
operator|=
name|st
operator|->
name|mode
expr_stmt|;
name|affect
operator|=
name|st
operator|->
name|affect
expr_stmt|;
name|type
operator|=
name|st
operator|->
name|type
expr_stmt|;
name|s
operator|=
name|src
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
condition|?
name|mask
operator|->
name|data
else|:
name|NULL
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|src
operator|->
name|h
condition|;
name|h
operator|++
control|)
block|{
comment|/*  based on the type of the initial image...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INITIAL_CHANNEL_MASK
case|:
case|case
name|INITIAL_CHANNEL_SELECTION
case|:
name|initial_channel_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITIAL_INDEXED
case|:
name|initial_indexed_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITIAL_INDEXED_ALPHA
case|:
name|initial_indexed_a_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
operator|&
name|no_mask
argument_list|,
name|data
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITIAL_INTENSITY
case|:
if|if
condition|(
name|mode
operator|==
name|GIMP_DISSOLVE_MODE
condition|)
block|{
if|if
condition|(
name|gimp_composite_options
operator|.
name|bits
operator|&
name|GIMP_COMPOSITE_OPTION_USE
condition|)
block|{
name|GimpCompositeContext
name|ctx
decl_stmt|;
name|ctx
operator|.
name|A
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|pixelformat_A
operator|=
name|GIMP_PIXELFORMAT_RGBA8
expr_stmt|;
name|ctx
operator|.
name|B
operator|=
name|s
expr_stmt|;
name|ctx
operator|.
name|pixelformat_B
operator|=
operator|(
name|src
operator|->
name|bytes
operator|==
literal|1
condition|?
name|GIMP_PIXELFORMAT_V8
else|:
name|src
operator|->
name|bytes
operator|==
literal|2
condition|?
name|GIMP_PIXELFORMAT_VA8
else|:
name|src
operator|->
name|bytes
operator|==
literal|3
condition|?
name|GIMP_PIXELFORMAT_RGB8
else|:
name|src
operator|->
name|bytes
operator|==
literal|4
condition|?
name|GIMP_PIXELFORMAT_RGBA8
else|:
name|GIMP_PIXELFORMAT_ANY
operator|)
expr_stmt|;
name|ctx
operator|.
name|D
operator|=
name|buf
expr_stmt|;
name|ctx
operator|.
name|pixelformat_D
operator|=
name|ctx
operator|.
name|pixelformat_B
expr_stmt|;
name|ctx
operator|.
name|M
operator|=
name|m
expr_stmt|;
name|ctx
operator|.
name|n_pixels
operator|=
name|src
operator|->
name|w
expr_stmt|;
name|ctx
operator|.
name|op
operator|=
name|GIMP_COMPOSITE_DISSOLVE
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|x
operator|=
name|src
operator|->
name|x
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|y
operator|=
name|src
operator|->
name|y
operator|+
name|h
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|opacity
operator|=
name|opacity
expr_stmt|;
name|gimp_composite_dispatch
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dissolve_pixels
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|buf
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|h
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|src
operator|->
name|bytes
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|initial_inten_a_pixels
argument_list|(
name|buf
argument_list|,
name|d
argument_list|,
name|NULL
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|affect
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initial_inten_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
operator|&
name|no_mask
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INITIAL_INTENSITY_ALPHA
case|:
if|if
condition|(
name|mode
operator|==
name|GIMP_DISSOLVE_MODE
condition|)
block|{
if|if
condition|(
name|gimp_composite_options
operator|.
name|bits
operator|&
name|GIMP_COMPOSITE_OPTION_USE
condition|)
block|{
name|GimpCompositeContext
name|ctx
decl_stmt|;
name|ctx
operator|.
name|A
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|pixelformat_A
operator|=
name|GIMP_PIXELFORMAT_RGBA8
expr_stmt|;
name|ctx
operator|.
name|B
operator|=
name|s
expr_stmt|;
name|ctx
operator|.
name|pixelformat_B
operator|=
operator|(
name|src
operator|->
name|bytes
operator|==
literal|1
condition|?
name|GIMP_PIXELFORMAT_V8
else|:
name|src
operator|->
name|bytes
operator|==
literal|2
condition|?
name|GIMP_PIXELFORMAT_VA8
else|:
name|src
operator|->
name|bytes
operator|==
literal|3
condition|?
name|GIMP_PIXELFORMAT_RGB8
else|:
name|src
operator|->
name|bytes
operator|==
literal|4
condition|?
name|GIMP_PIXELFORMAT_RGBA8
else|:
name|GIMP_PIXELFORMAT_ANY
operator|)
expr_stmt|;
name|ctx
operator|.
name|D
operator|=
name|buf
expr_stmt|;
name|ctx
operator|.
name|pixelformat_D
operator|=
name|ctx
operator|.
name|pixelformat_B
expr_stmt|;
name|ctx
operator|.
name|M
operator|=
name|m
expr_stmt|;
name|ctx
operator|.
name|n_pixels
operator|=
name|src
operator|->
name|w
expr_stmt|;
name|ctx
operator|.
name|op
operator|=
name|GIMP_COMPOSITE_DISSOLVE
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|x
operator|=
name|src
operator|->
name|x
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|y
operator|=
name|src
operator|->
name|y
operator|+
name|h
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|opacity
operator|=
name|opacity
expr_stmt|;
name|gimp_composite_dispatch
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dissolve_pixels
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|buf
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
operator|+
name|h
argument_list|,
name|opacity
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|initial_inten_a_pixels
argument_list|(
name|buf
argument_list|,
name|d
argument_list|,
name|NULL
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|affect
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initial_inten_a_pixels
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|s
operator|+=
name|src
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|initial_region (PixelRegion * src,PixelRegion * dest,PixelRegion * mask,guchar * data,guint opacity,GimpLayerModeEffects mode,const gboolean * affect,InitialMode type)
name|initial_region
parameter_list|(
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guchar
modifier|*
name|data
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|GimpLayerModeEffects
name|mode
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|InitialMode
name|type
parameter_list|)
block|{
name|struct
name|initial_regions_struct
name|st
decl_stmt|;
name|st
operator|.
name|opacity
operator|=
name|opacity
expr_stmt|;
name|st
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|st
operator|.
name|affect
operator|=
name|affect
expr_stmt|;
name|st
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|st
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|pixel_regions_process_parallel
argument_list|(
operator|(
name|p_func
operator|)
name|initial_sub_region
argument_list|,
operator|&
name|st
argument_list|,
literal|3
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
DECL|struct|combine_regions_struct
struct|struct
name|combine_regions_struct
block|{
DECL|member|opacity
name|guint
name|opacity
decl_stmt|;
DECL|member|mode
name|GimpLayerModeEffects
name|mode
decl_stmt|;
DECL|member|affect
specifier|const
name|gboolean
modifier|*
name|affect
decl_stmt|;
DECL|member|type
name|CombinationMode
name|type
decl_stmt|;
DECL|member|data
name|guchar
modifier|*
name|data
decl_stmt|;
DECL|member|opacity_quickskip_possible
name|gboolean
name|opacity_quickskip_possible
decl_stmt|;
DECL|member|transparency_quickskip_possible
name|gboolean
name|transparency_quickskip_possible
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|CombinationMode
DECL|function|apply_indexed_layer_mode (guchar * src1,guchar * src2,guchar ** dest,GimpLayerModeEffects mode,CombinationMode cmode)
name|apply_indexed_layer_mode
parameter_list|(
name|guchar
modifier|*
name|src1
parameter_list|,
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
modifier|*
name|dest
parameter_list|,
name|GimpLayerModeEffects
name|mode
parameter_list|,
name|CombinationMode
name|cmode
parameter_list|)
block|{
comment|/*  assumes we're applying src2 TO src1  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GIMP_REPLACE_MODE
case|:
operator|*
name|dest
operator|=
name|src2
expr_stmt|;
name|cmode
operator|=
name|REPLACE_INDEXED
expr_stmt|;
break|break;
case|case
name|GIMP_BEHIND_MODE
case|:
operator|*
name|dest
operator|=
name|src2
expr_stmt|;
if|if
condition|(
name|cmode
operator|==
name|COMBINE_INDEXED_A_INDEXED_A
condition|)
name|cmode
operator|=
name|BEHIND_INDEXED
expr_stmt|;
else|else
name|cmode
operator|=
name|NO_COMBINATION
expr_stmt|;
break|break;
case|case
name|GIMP_ERASE_MODE
case|:
operator|*
name|dest
operator|=
name|src2
expr_stmt|;
comment|/*  If both sources have alpha channels, call erase function.        *  Otherwise, just combine in the normal manner        */
name|cmode
operator|=
operator|(
name|cmode
operator|==
name|COMBINE_INDEXED_A_INDEXED_A
operator|)
condition|?
name|ERASE_INDEXED
else|:
name|cmode
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|cmode
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|combine_sub_region (struct combine_regions_struct * st,PixelRegion * src1,PixelRegion * src2,PixelRegion * dest,PixelRegion * mask)
name|combine_sub_region
parameter_list|(
name|struct
name|combine_regions_struct
modifier|*
name|st
parameter_list|,
name|PixelRegion
modifier|*
name|src1
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|guint
name|opacity
decl_stmt|;
name|guint
name|layer_mode_opacity
decl_stmt|;
name|guchar
modifier|*
name|layer_mode_mask
decl_stmt|;
name|GimpLayerModeEffects
name|mode
decl_stmt|;
specifier|const
name|gboolean
modifier|*
name|affect
decl_stmt|;
name|guint
name|h
decl_stmt|;
name|CombinationMode
name|combine
init|=
name|NO_COMBINATION
decl_stmt|;
name|CombinationMode
name|type
decl_stmt|;
name|gboolean
name|mode_affect
init|=
name|FALSE
decl_stmt|;
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|gboolean
name|opacity_quickskip_possible
decl_stmt|;
name|gboolean
name|transparency_quickskip_possible
decl_stmt|;
name|TileRowHint
name|hint
decl_stmt|;
comment|/* use src2->bytes + 1 since DISSOLVE always needs a buffer with alpha */
name|buf
operator|=
name|g_alloca
argument_list|(
name|MAX
argument_list|(
name|MAX
argument_list|(
name|src1
operator|->
name|w
operator|*
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|w
operator|*
operator|(
name|src2
operator|->
name|bytes
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|opacity
operator|=
name|st
operator|->
name|opacity
expr_stmt|;
name|mode
operator|=
name|st
operator|->
name|mode
expr_stmt|;
name|affect
operator|=
name|st
operator|->
name|affect
expr_stmt|;
name|type
operator|=
name|st
operator|->
name|type
expr_stmt|;
name|data
operator|=
name|st
operator|->
name|data
expr_stmt|;
name|opacity_quickskip_possible
operator|=
operator|(
name|st
operator|->
name|opacity_quickskip_possible
operator|&&
name|src2
operator|->
name|tiles
operator|)
expr_stmt|;
name|transparency_quickskip_possible
operator|=
operator|(
name|st
operator|->
name|transparency_quickskip_possible
operator|&&
name|src2
operator|->
name|tiles
operator|)
expr_stmt|;
name|s1
operator|=
name|src1
operator|->
name|data
expr_stmt|;
name|s2
operator|=
name|src2
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
condition|?
name|mask
operator|->
name|data
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|transparency_quickskip_possible
operator|||
name|opacity_quickskip_possible
condition|)
block|{
ifdef|#
directive|ifdef
name|HINTS_SANITY
if|if
condition|(
name|src1
operator|->
name|h
operator|!=
name|src2
operator|->
name|h
condition|)
name|g_error
argument_list|(
literal|"HEIGHTS SUCK!!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|->
name|offy
operator|!=
name|dest
operator|->
name|offy
condition|)
name|g_error
argument_list|(
literal|"SRC1 OFFSET != DEST OFFSET"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|update_tile_rowhints
argument_list|(
name|src2
operator|->
name|curtile
argument_list|,
name|src2
operator|->
name|offy
argument_list|,
name|src2
operator|->
name|offy
operator|+
operator|(
name|src1
operator|->
name|h
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* else it's probably a brush-composite */
comment|/*  use separate variables for the combining opacity and the opacity    *  the layer mode is applied with since DISSLOVE_MODE "consumes"    *  all opacity and wants to be applied OPAQUE    */
name|layer_mode_opacity
operator|=
name|opacity
expr_stmt|;
name|layer_mode_mask
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GIMP_DISSOLVE_MODE
condition|)
block|{
name|opacity
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|src1
operator|->
name|h
condition|;
name|h
operator|++
control|)
block|{
name|hint
operator|=
name|TILEROWHINT_UNDEFINED
expr_stmt|;
if|if
condition|(
name|transparency_quickskip_possible
condition|)
block|{
name|hint
operator|=
name|tile_get_rowhint
argument_list|(
name|src2
operator|->
name|curtile
argument_list|,
operator|(
name|src2
operator|->
name|offy
operator|+
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|TILEROWHINT_TRANSPARENT
condition|)
block|{
goto|goto
name|next_row
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|opacity_quickskip_possible
condition|)
block|{
name|hint
operator|=
name|tile_get_rowhint
argument_list|(
name|src2
operator|->
name|curtile
argument_list|,
operator|(
name|src2
operator|->
name|offy
operator|+
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|buf
expr_stmt|;
comment|/*  apply the paint mode based on the combination type& mode  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|COMBINE_INTEN_A_INDEXED_A
case|:
case|case
name|COMBINE_INTEN_A_CHANNEL_MASK
case|:
case|case
name|COMBINE_INTEN_A_CHANNEL_SELECTION
case|:
name|combine
operator|=
name|type
expr_stmt|;
break|break;
case|case
name|COMBINE_INDEXED_INDEXED
case|:
case|case
name|COMBINE_INDEXED_INDEXED_A
case|:
case|case
name|COMBINE_INDEXED_A_INDEXED_A
case|:
comment|/*  Now, apply the paint mode--for indexed images  */
name|combine
operator|=
name|apply_indexed_layer_mode
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
operator|&
name|s
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_INTEN_A
case|:
case|case
name|COMBINE_INTEN_A_INTEN
case|:
case|case
name|COMBINE_INTEN_INTEN
case|:
case|case
name|COMBINE_INTEN_A_INTEN_A
case|:
block|{
comment|/*  Now, apply the paint mode  */
if|if
condition|(
name|gimp_composite_options
operator|.
name|bits
operator|&
name|GIMP_COMPOSITE_OPTION_USE
condition|)
block|{
name|GimpCompositeContext
name|ctx
decl_stmt|;
name|ctx
operator|.
name|A
operator|=
name|s1
expr_stmt|;
name|ctx
operator|.
name|pixelformat_A
operator|=
operator|(
name|src1
operator|->
name|bytes
operator|==
literal|1
condition|?
name|GIMP_PIXELFORMAT_V8
else|:
name|src1
operator|->
name|bytes
operator|==
literal|2
condition|?
name|GIMP_PIXELFORMAT_VA8
else|:
name|src1
operator|->
name|bytes
operator|==
literal|3
condition|?
name|GIMP_PIXELFORMAT_RGB8
else|:
name|src1
operator|->
name|bytes
operator|==
literal|4
condition|?
name|GIMP_PIXELFORMAT_RGBA8
else|:
name|GIMP_PIXELFORMAT_ANY
operator|)
expr_stmt|;
name|ctx
operator|.
name|B
operator|=
name|s2
expr_stmt|;
name|ctx
operator|.
name|pixelformat_B
operator|=
operator|(
name|src2
operator|->
name|bytes
operator|==
literal|1
condition|?
name|GIMP_PIXELFORMAT_V8
else|:
name|src2
operator|->
name|bytes
operator|==
literal|2
condition|?
name|GIMP_PIXELFORMAT_VA8
else|:
name|src2
operator|->
name|bytes
operator|==
literal|3
condition|?
name|GIMP_PIXELFORMAT_RGB8
else|:
name|src2
operator|->
name|bytes
operator|==
literal|4
condition|?
name|GIMP_PIXELFORMAT_RGBA8
else|:
name|GIMP_PIXELFORMAT_ANY
operator|)
expr_stmt|;
name|ctx
operator|.
name|D
operator|=
name|s
expr_stmt|;
name|ctx
operator|.
name|pixelformat_D
operator|=
name|ctx
operator|.
name|pixelformat_A
expr_stmt|;
name|ctx
operator|.
name|M
operator|=
name|layer_mode_mask
expr_stmt|;
name|ctx
operator|.
name|pixelformat_M
operator|=
name|GIMP_PIXELFORMAT_ANY
expr_stmt|;
name|ctx
operator|.
name|n_pixels
operator|=
name|src1
operator|->
name|w
expr_stmt|;
name|ctx
operator|.
name|combine
operator|=
name|combine
expr_stmt|;
name|ctx
operator|.
name|op
operator|=
name|mode
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|x
operator|=
name|src1
operator|->
name|x
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|y
operator|=
name|src1
operator|->
name|y
operator|+
name|h
expr_stmt|;
name|ctx
operator|.
name|dissolve
operator|.
name|opacity
operator|=
name|layer_mode_opacity
expr_stmt|;
name|mode_affect
operator|=
name|gimp_composite_operation_effects
index|[
name|mode
index|]
operator|.
name|affect_opacity
expr_stmt|;
name|gimp_composite_dispatch
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctx
operator|.
name|D
expr_stmt|;
name|combine
operator|=
operator|(
name|ctx
operator|.
name|combine
operator|==
name|NO_COMBINATION
operator|)
condition|?
name|type
else|:
name|ctx
operator|.
name|combine
expr_stmt|;
block|}
else|else
block|{
name|struct
name|apply_layer_mode_struct
name|alms
decl_stmt|;
name|alms
operator|.
name|src1
operator|=
name|s1
expr_stmt|;
name|alms
operator|.
name|src2
operator|=
name|s2
expr_stmt|;
name|alms
operator|.
name|mask
operator|=
name|layer_mode_mask
expr_stmt|;
name|alms
operator|.
name|dest
operator|=
operator|&
name|s
expr_stmt|;
name|alms
operator|.
name|x
operator|=
name|src1
operator|->
name|x
expr_stmt|;
name|alms
operator|.
name|y
operator|=
name|src1
operator|->
name|y
operator|+
name|h
expr_stmt|;
name|alms
operator|.
name|opacity
operator|=
name|layer_mode_opacity
expr_stmt|;
name|alms
operator|.
name|combine
operator|=
name|combine
expr_stmt|;
name|alms
operator|.
name|length
operator|=
name|src1
operator|->
name|w
expr_stmt|;
name|alms
operator|.
name|bytes1
operator|=
name|src1
operator|->
name|bytes
expr_stmt|;
name|alms
operator|.
name|bytes2
operator|=
name|src2
operator|->
name|bytes
expr_stmt|;
comment|/*  Determine whether the alpha channel of the destination                  *  can be affected by the specified mode. -- This keeps                  *  consistency with varying opacities.                  */
name|mode_affect
operator|=
name|layer_modes
index|[
name|mode
index|]
operator|.
name|affect_alpha
expr_stmt|;
name|layer_mode_funcs
index|[
name|mode
index|]
operator|(
operator|&
name|alms
operator|)
expr_stmt|;
name|combine
operator|=
operator|(
name|alms
operator|.
name|combine
operator|==
name|NO_COMBINATION
condition|?
name|type
else|:
name|alms
operator|.
name|combine
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|g_warning
argument_list|(
literal|"combine_sub_region: unhandled combine-type."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  based on the type of the initial image...  */
switch|switch
condition|(
name|combine
condition|)
block|{
case|case
name|COMBINE_INDEXED_INDEXED
case|:
name|combine_indexed_and_indexed_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INDEXED_INDEXED_A
case|:
name|combine_indexed_and_indexed_a_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INDEXED_A_INDEXED_A
case|:
name|combine_indexed_a_and_indexed_a_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_INDEXED_A
case|:
comment|/*  assume the data passed to this procedure is the            *  indexed layer's colormap            */
name|combine_inten_a_and_indexed_a_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|data
argument_list|,
name|opacity
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_CHANNEL_MASK
case|:
comment|/*  assume the data passed to this procedure is the            *  indexed layer's colormap            */
name|combine_inten_a_and_channel_mask_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|opacity
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_CHANNEL_SELECTION
case|:
name|combine_inten_a_and_channel_selection_pixels
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|opacity
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_INTEN
case|:
if|if
condition|(
operator|(
name|hint
operator|==
name|TILEROWHINT_OPAQUE
operator|)
operator|&&
name|opacity_quickskip_possible
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_inten_and_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_INTEN_A
case|:
name|combine_inten_and_inten_a_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_INTEN
case|:
name|combine_inten_a_and_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|mode_affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_INTEN_A
case|:
if|if
condition|(
operator|(
name|hint
operator|==
name|TILEROWHINT_OPAQUE
operator|)
operator|&&
name|opacity_quickskip_possible
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|dest
operator|->
name|w
operator|*
name|dest
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_inten_a_and_inten_a_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|mode_affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEHIND_INTEN
case|:
name|behind_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEHIND_INDEXED
case|:
name|behind_indexed_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLACE_INTEN
case|:
name|replace_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLACE_INDEXED
case|:
name|replace_indexed_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERASE_INTEN
case|:
name|erase_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERASE_INDEXED
case|:
name|erase_indexed_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANTI_ERASE_INTEN
case|:
name|anti_erase_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANTI_ERASE_INDEXED
case|:
name|anti_erase_indexed_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLOR_ERASE_INTEN
case|:
name|color_erase_inten_pixels
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_COMBINATION
case|:
name|g_warning
argument_list|(
literal|"NO_COMBINATION"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_warning
argument_list|(
literal|"UNKNOWN COMBINATION: %d"
argument_list|,
name|combine
argument_list|)
expr_stmt|;
break|break;
block|}
name|next_row
label|:
name|s1
operator|+=
name|src1
operator|->
name|rowstride
expr_stmt|;
name|s2
operator|+=
name|src2
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|layer_mode_mask
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|combine_regions (PixelRegion * src1,PixelRegion * src2,PixelRegion * dest,PixelRegion * mask,guchar * data,guint opacity,GimpLayerModeEffects mode,const gboolean * affect,CombinationMode type)
name|combine_regions
parameter_list|(
name|PixelRegion
modifier|*
name|src1
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guchar
modifier|*
name|data
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|GimpLayerModeEffects
name|mode
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|CombinationMode
name|type
parameter_list|)
block|{
name|gboolean
name|has_alpha1
decl_stmt|,
name|has_alpha2
decl_stmt|;
name|guint
name|i
decl_stmt|;
name|struct
name|combine_regions_struct
name|st
decl_stmt|;
comment|/*  Determine which sources have alpha channels  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|COMBINE_INTEN_INTEN
case|:
case|case
name|COMBINE_INDEXED_INDEXED
case|:
name|has_alpha1
operator|=
name|has_alpha2
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_INTEN
case|:
name|has_alpha1
operator|=
name|TRUE
expr_stmt|;
name|has_alpha2
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_INTEN_A
case|:
case|case
name|COMBINE_INDEXED_INDEXED_A
case|:
name|has_alpha1
operator|=
name|FALSE
expr_stmt|;
name|has_alpha2
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMBINE_INTEN_A_INTEN_A
case|:
case|case
name|COMBINE_INDEXED_A_INDEXED_A
case|:
name|has_alpha1
operator|=
name|has_alpha2
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|has_alpha1
operator|=
name|has_alpha2
operator|=
name|FALSE
expr_stmt|;
block|}
name|st
operator|.
name|opacity
operator|=
name|opacity
expr_stmt|;
name|st
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|st
operator|.
name|affect
operator|=
name|affect
expr_stmt|;
name|st
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|st
operator|.
name|data
operator|=
name|data
expr_stmt|;
comment|/* cheap and easy when the row of src2 is completely opaque/transparent      and the wind is otherwise blowing in the right direction.   */
comment|/* First check - we can't do an opacity quickskip if the drawable      has a mask, or non-full opacity, or the layer mode dictates      that we might gain transparency.   */
name|st
operator|.
name|opacity_quickskip_possible
operator|=
operator|(
operator|(
operator|!
name|mask
operator|)
operator|&&
operator|(
name|opacity
operator|==
literal|255
operator|)
operator|&&
operator|(
operator|!
name|layer_modes
index|[
name|mode
index|]
operator|.
name|decrease_opacity
operator|)
operator|&&
operator|(
name|layer_modes
index|[
name|mode
index|]
operator|.
name|affect_alpha
operator|&&
name|has_alpha1
operator|&&
name|affect
index|[
name|src1
operator|->
name|bytes
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
comment|/* Second check - if any single colour channel can't be affected,      we can't use the opacity quickskip.   */
if|if
condition|(
name|st
operator|.
name|opacity_quickskip_possible
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src1
operator|->
name|bytes
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|affect
index|[
name|i
index|]
condition|)
block|{
name|st
operator|.
name|opacity_quickskip_possible
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* transparency quickskip is only possible if the layer mode      dictates that we cannot possibly gain opacity, or the 'overall'      opacity of the layer is set to zero anyway.    */
name|st
operator|.
name|transparency_quickskip_possible
operator|=
operator|(
operator|(
operator|!
name|layer_modes
index|[
name|mode
index|]
operator|.
name|increase_opacity
operator|)
operator|||
operator|(
name|opacity
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Start the actual processing.    */
name|pixel_regions_process_parallel
argument_list|(
operator|(
name|p_func
operator|)
name|combine_sub_region
argument_list|,
operator|&
name|st
argument_list|,
literal|4
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|combine_regions_replace (PixelRegion * src1,PixelRegion * src2,PixelRegion * dest,PixelRegion * mask,guchar * data,guint opacity,const gboolean * affect,CombinationMode type)
name|combine_regions_replace
parameter_list|(
name|PixelRegion
modifier|*
name|src1
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|guchar
modifier|*
name|data
parameter_list|,
name|guint
name|opacity
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|,
name|CombinationMode
name|type
parameter_list|)
block|{
name|guint
name|h
decl_stmt|;
name|guchar
modifier|*
name|s1
decl_stmt|;
name|guchar
modifier|*
name|s2
decl_stmt|;
name|guchar
modifier|*
name|d
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|4
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s1
operator|=
name|src1
operator|->
name|data
expr_stmt|;
name|s2
operator|=
name|src2
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|mask
operator|->
name|data
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|src1
operator|->
name|h
condition|;
name|h
operator|++
control|)
block|{
comment|/*  Now, apply the paint mode  */
name|apply_layer_mode_replace
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d
argument_list|,
name|m
argument_list|,
name|src1
operator|->
name|x
argument_list|,
name|src1
operator|->
name|y
operator|+
name|h
argument_list|,
name|opacity
argument_list|,
name|src1
operator|->
name|w
argument_list|,
name|src1
operator|->
name|bytes
argument_list|,
name|src2
operator|->
name|bytes
argument_list|,
name|affect
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|src1
operator|->
name|rowstride
expr_stmt|;
name|s2
operator|+=
name|src2
operator|->
name|rowstride
expr_stmt|;
name|d
operator|+=
name|dest
operator|->
name|rowstride
expr_stmt|;
name|m
operator|+=
name|mask
operator|->
name|rowstride
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|apply_layer_mode_replace (guchar * src1,guchar * src2,guchar * dest,guchar * mask,gint x,gint y,guint opacity,guint length,guint bytes1,guint bytes2,const gboolean * affect)
name|apply_layer_mode_replace
parameter_list|(
name|guchar
modifier|*
name|src1
parameter_list|,
name|guchar
modifier|*
name|src2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|guchar
modifier|*
name|mask
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guint
name|opacity
parameter_list|,
name|guint
name|length
parameter_list|,
name|guint
name|bytes1
parameter_list|,
name|guint
name|bytes2
parameter_list|,
specifier|const
name|gboolean
modifier|*
name|affect
parameter_list|)
block|{
name|replace_pixels
argument_list|(
name|src1
argument_list|,
name|src2
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|length
argument_list|,
name|opacity
argument_list|,
name|affect
argument_list|,
name|bytes1
argument_list|,
name|bytes2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

