begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"scale-funcs.h"
end_include

begin_define
DECL|macro|EPSILON
define|#
directive|define
name|EPSILON
value|(0.0001)
end_define

begin_comment
DECL|macro|EPSILON
comment|/* arbitary small number for avoiding zero */
end_comment

begin_function_decl
specifier|static
name|void
name|scale_region_no_resample
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_region_lanczos
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|dstPR
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shrink_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Catmull-Rom spline - not bad   * basic intro http://www.mvps.org/directx/articles/catmull/   * This formula will calculate an interpolated point between pt1 and pt2   * dx=0 returns pt1; dx=1 returns pt2   */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|cubic_spline_fit (gdouble dx,gint pt0,gint pt1,gint pt2,gint pt3)
name|cubic_spline_fit
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|pt0
parameter_list|,
name|gint
name|pt1
parameter_list|,
name|gint
name|pt2
parameter_list|,
name|gint
name|pt3
parameter_list|)
block|{
return|return
call|(
name|gdouble
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|-
name|pt0
operator|+
literal|3
operator|*
name|pt1
operator|-
literal|3
operator|*
name|pt2
operator|+
name|pt3
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|pt0
operator|-
literal|5
operator|*
name|pt1
operator|+
literal|4
operator|*
name|pt2
operator|-
name|pt3
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|pt0
operator|+
name|pt2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|pt1
operator|+
name|pt1
operator|)
argument_list|)
operator|/
literal|2.0
return|;
block|}
end_function

begin_comment
comment|/*  * non-interpolating scale_region.  [adam]  */
end_comment

begin_function
specifier|static
name|void
DECL|function|scale_region_no_resample (PixelRegion * srcPR,PixelRegion * destPR)
name|scale_region_no_resample
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|)
block|{
specifier|const
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
specifier|const
name|gint
name|height
init|=
name|destPR
operator|->
name|h
decl_stmt|;
specifier|const
name|gint
name|orig_width
init|=
name|srcPR
operator|->
name|w
decl_stmt|;
specifier|const
name|gint
name|orig_height
init|=
name|srcPR
operator|->
name|h
decl_stmt|;
specifier|const
name|gint
name|bytes
init|=
name|srcPR
operator|->
name|bytes
decl_stmt|;
name|gint
modifier|*
name|x_src_offsets
decl_stmt|;
name|gint
modifier|*
name|y_src_offsets
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|last_src_y
decl_stmt|;
name|gint
name|row_bytes
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|b
decl_stmt|;
comment|/*  the data pointers...  */
name|x_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|y_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  pre-calc the scale tables  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
name|x_src_offsets
index|[
name|b
operator|+
name|x
operator|*
name|bytes
index|]
operator|=
name|b
operator|+
name|bytes
operator|*
operator|(
operator|(
name|x
operator|*
name|orig_width
operator|+
name|orig_width
operator|/
literal|2
operator|)
operator|/
name|width
operator|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
name|y_src_offsets
index|[
name|y
index|]
operator|=
operator|(
name|y
operator|*
name|orig_height
operator|+
name|orig_height
operator|/
literal|2
operator|)
operator|/
name|height
expr_stmt|;
comment|/*  do the scaling  */
name|row_bytes
operator|=
name|width
operator|*
name|bytes
expr_stmt|;
name|last_src_y
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
comment|/* if the source of this line was the same as the source        *  of the last line, there's no point in re-rescaling.        */
if|if
condition|(
name|y_src_offsets
index|[
name|y
index|]
operator|!=
name|last_src_y
condition|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y_src_offsets
index|[
name|y
index|]
argument_list|,
name|orig_width
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|row_bytes
condition|;
name|x
operator|++
control|)
name|dest
index|[
name|x
index|]
operator|=
name|src
index|[
name|x_src_offsets
index|[
name|x
index|]
index|]
expr_stmt|;
name|last_src_y
operator|=
name|y_src_offsets
index|[
name|y
index|]
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|x_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|y_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_premultiplied_double_row (PixelRegion * srcPR,gint x,gint y,gint w,gdouble * row,guchar * tmp_src,gint n)
name|get_premultiplied_double_row
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|tmp_src
parameter_list|,
name|gint
name|n
parameter_list|)
block|{
specifier|const
name|gint
name|bytes
init|=
name|srcPR
operator|->
name|bytes
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|tmp_src
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* premultiply the alpha into the double array */
specifier|const
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gdouble
modifier|*
name|irow
init|=
name|row
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
name|gdouble
name|mod_alpha
init|=
name|tmp_src
index|[
name|alpha
index|]
operator|/
literal|255.0
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|irow
index|[
name|b
index|]
operator|=
name|mod_alpha
operator|*
name|tmp_src
index|[
name|b
index|]
expr_stmt|;
name|irow
index|[
name|b
index|]
operator|=
name|tmp_src
index|[
name|alpha
index|]
expr_stmt|;
name|irow
operator|+=
name|bytes
expr_stmt|;
name|tmp_src
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
comment|/* no alpha */
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|row
index|[
name|x
index|]
operator|=
name|tmp_src
index|[
name|x
index|]
expr_stmt|;
block|}
comment|/* set the off edge pixels to their nearest neighbor */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|2
operator|*
name|bytes
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|-
literal|2
operator|*
name|bytes
index|]
operator|=
name|row
index|[
name|b
operator|%
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|2
operator|*
name|bytes
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|+
name|w
operator|*
name|bytes
index|]
operator|=
name|row
index|[
operator|(
name|w
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|b
operator|%
name|bytes
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|expand_line (gdouble * dest,const gdouble * src,gint bpp,gint old_width,gint width,GimpInterpolationType interp)
name|expand_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
specifier|const
name|gdouble
modifier|*
name|s
decl_stmt|;
specifier|const
name|gdouble
name|ratio
init|=
operator|(
name|gdouble
operator|)
name|old_width
operator|/
operator|(
name|gdouble
operator|)
name|width
decl_stmt|;
comment|/* ie reverse scaling_factor */
name|gint
name|x
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|src_col
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
comment|/* we can overflow src's boundaries, so we expect our caller to have   allocated extra space for us to do so safely (see scale_region ()) */
switch|switch
condition|(
name|interp
condition|)
block|{
comment|/* -0.5 is because cubic() interpolates a position between 2nd and 3rd data points        * we are assigning to 2nd in dest, hence mean shift of +0.5        * +1, -1 ensures we dont (int) a negative; first src col only.        */
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|gdouble
name|xr
init|=
name|x
operator|*
name|ratio
operator|-
literal|0.5
decl_stmt|;
if|if
condition|(
name|xr
operator|<
literal|0
condition|)
name|src_col
operator|=
call|(
name|gint
call|)
argument_list|(
name|xr
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|src_col
operator|=
operator|(
name|gint
operator|)
name|xr
expr_stmt|;
name|frac
operator|=
name|xr
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bpp
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bpp
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|cubic_spline_fit
argument_list|(
name|frac
argument_list|,
name|s
index|[
name|b
operator|-
name|bpp
index|]
argument_list|,
name|s
index|[
name|b
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bpp
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bpp
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bpp
expr_stmt|;
block|}
break|break;
comment|/* -0.5 corrects the drift from averaging between adjacent points and assigning to dest[b]        * +1, -1 ensures we dont (int) a negative; first src col only.        */
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|gdouble
name|xr
init|=
operator|(
name|x
operator|*
name|ratio
operator|+
literal|1
operator|-
literal|0.5
operator|)
operator|-
literal|1
decl_stmt|;
name|src_col
operator|=
operator|(
name|gint
operator|)
name|xr
expr_stmt|;
name|frac
operator|=
name|xr
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bpp
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bpp
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
operator|(
name|s
index|[
name|b
operator|+
name|bpp
index|]
operator|-
name|s
index|[
name|b
index|]
operator|)
operator|*
name|frac
operator|+
name|s
index|[
name|b
index|]
operator|)
expr_stmt|;
name|dest
operator|+=
name|bpp
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shrink_line (gdouble * dest,const gdouble * src,gint bytes,gint old_width,gint width,GimpInterpolationType interp)
name|shrink_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
specifier|const
name|gdouble
modifier|*
name|srcp
decl_stmt|;
name|gdouble
modifier|*
name|destp
decl_stmt|;
name|gdouble
name|accum
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|slice
decl_stmt|;
specifier|const
name|gdouble
name|avg_ratio
init|=
operator|(
name|gdouble
operator|)
name|width
operator|/
name|old_width
decl_stmt|;
specifier|const
name|gdouble
name|inv_width
init|=
literal|1.0
operator|/
name|width
decl_stmt|;
name|gint
name|slicepos
decl_stmt|;
comment|/* slice position relative to width */
name|gint
name|x
decl_stmt|;
name|gint
name|b
decl_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("shrink_line bytes=%d old_width=%d width=%d interp=%d "               "avg_ratio=%f\n",               bytes, old_width, width, interp, avg_ratio);
endif|#
directive|endif
name|g_return_if_fail
argument_list|(
name|bytes
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* This algorithm calculates the weighted average of pixel data that      each output pixel must receive, taking into account that it always      scales down, i.e. there's always more than one input pixel per each      output pixel.  */
name|srcp
operator|=
name|src
expr_stmt|;
name|destp
operator|=
name|dest
expr_stmt|;
name|slicepos
operator|=
literal|0
expr_stmt|;
comment|/* Initialize accum to the first pixel slice.  As there is no partial      pixel at start, that value is 0.  The source data is interleaved, so      we maintain BYTES accumulators at the same time to deal with that      many channels simultaneously.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* Accumulate whole pixels.  */
do|do
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|+=
operator|*
name|srcp
operator|++
expr_stmt|;
name|slicepos
operator|+=
name|width
expr_stmt|;
block|}
do|while
condition|(
name|slicepos
operator|<
name|old_width
condition|)
do|;
name|slicepos
operator|-=
name|old_width
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slicepos
operator|<
name|width
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (slicepos< width) failed. Please report."
argument_list|)
expr_stmt|;
if|if
condition|(
name|slicepos
operator|==
literal|0
condition|)
block|{
comment|/* Simplest case: we have reached a whole pixel boundary.  Store              the average value per channel and reset the accumulators for              the next round.               The main reason to treat this case separately is to avoid an              access to out-of-bounds memory for the first pixel.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
operator|*
name|destp
operator|++
operator|=
name|accum
index|[
name|b
index|]
operator|*
name|avg_ratio
expr_stmt|;
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
comment|/* We have accumulated a whole pixel per channel where just a                  slice of it was needed.  Subtract now the previous pixel's                  extra slice.  */
name|slice
operator|=
name|srcp
index|[
operator|-
name|bytes
operator|+
name|b
index|]
operator|*
name|slicepos
operator|*
name|inv_width
expr_stmt|;
operator|*
name|destp
operator|++
operator|=
operator|(
name|accum
index|[
name|b
index|]
operator|-
name|slice
operator|)
operator|*
name|avg_ratio
expr_stmt|;
comment|/* That slice is the initial value for the next round.  */
name|accum
index|[
name|b
index|]
operator|=
name|slice
expr_stmt|;
block|}
block|}
block|}
comment|/* Sanity check: srcp should point to the next-to-last position, and      slicepos should be zero.  */
if|if
condition|(
operator|!
operator|(
name|srcp
operator|-
name|src
operator|==
name|old_width
operator|*
name|bytes
operator|&&
name|slicepos
operator|==
literal|0
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (srcp - src == old_width * bytes&& slicepos == 0)"
literal|" failed. Please report."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|rotate_pointers (guchar ** p,guint32 n)
name|rotate_pointers
parameter_list|(
name|guchar
modifier|*
modifier|*
name|p
parameter_list|,
name|guint32
name|n
parameter_list|)
block|{
name|guchar
modifier|*
name|tmp
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
name|guint32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_scaled_row (gdouble ** src,gint y,gint new_width,PixelRegion * srcPR,gdouble * row,guchar * src_tmp,GimpInterpolationType interpolation_type)
name|get_scaled_row
parameter_list|(
name|gdouble
modifier|*
modifier|*
name|src
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|src_tmp
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|)
block|{
comment|/* get the necesary lines from the source image, scale them,      and put them into src[] */
name|rotate_pointers
argument_list|(
operator|(
name|gpointer
operator|)
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|srcPR
operator|->
name|h
condition|)
block|{
name|get_premultiplied_double_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_width
operator|>
name|srcPR
operator|->
name|w
condition|)
name|expand_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|srcPR
operator|->
name|w
operator|>
name|new_width
condition|)
name|shrink_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
else|else
comment|/* no scailing needed */
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|src
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|scale_region (PixelRegion * srcPR,PixelRegion * destPR,GimpInterpolationType interpolation,GimpProgressFunc progress_callback,gpointer progress_data)
name|scale_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|GimpInterpolationType
name|interpolation
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|gdouble
modifier|*
name|src
index|[
literal|4
index|]
decl_stmt|;
name|guchar
modifier|*
name|src_tmp
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|accum
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gdouble
name|y_ratio
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|old_y
init|=
operator|-
literal|4
decl_stmt|;
name|gint
name|new_y
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|interpolation
operator|==
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|scale_region_no_resample
argument_list|(
name|srcPR
argument_list|,
name|destPR
argument_list|)
expr_stmt|;
return|return;
block|}
name|orig_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|interpolation
operator|==
name|GIMP_INTERPOLATION_LANCZOS
operator|&&
name|orig_height
operator|<=
name|height
condition|)
block|{
name|scale_region_lanczos
argument_list|(
name|srcPR
argument_list|,
name|destPR
argument_list|,
name|progress_callback
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|g_printerr ("scale_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  find the ratios of old y to new y  */
name|y_ratio
operator|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
comment|/*  the data pointers...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|src
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|src_tmp
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/* offset the row pointer by 2*bytes so the range of the array      is [-2*bytes] to [(orig_width + 2)*bytes] */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
operator|(
name|orig_width
operator|+
literal|2
operator|*
literal|2
operator|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|row
operator|+=
name|bytes
operator|*
literal|2
expr_stmt|;
name|accum
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress_callback
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
literal|0
argument_list|,
name|height
argument_list|,
name|y
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|height
operator|<
name|orig_height
condition|)
block|{
specifier|const
name|gdouble
name|inv_ratio
init|=
literal|1.0
operator|/
name|y_ratio
decl_stmt|;
name|gint
name|max
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
comment|/* load the first row if this is the first time through */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|new_y
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|*
name|y_ratio
argument_list|)
expr_stmt|;
name|frac
operator|=
literal|1.0
operator|-
operator|(
name|y
operator|*
name|y_ratio
operator|-
name|new_y
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|*
name|frac
expr_stmt|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_ratio
argument_list|)
operator|-
name|new_y
operator|-
literal|1
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|+=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|max
operator|--
expr_stmt|;
block|}
name|frac
operator|=
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_ratio
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_ratio
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
block|{
name|accum
index|[
name|x
index|]
operator|+=
name|frac
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|accum
index|[
name|x
index|]
operator|*=
name|inv_ratio
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|height
operator|>
name|orig_height
condition|)
block|{
name|new_y
operator|=
name|floor
argument_list|(
name|y
operator|*
name|y_ratio
operator|-
literal|0.5
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_y
operator|<=
name|new_y
condition|)
block|{
comment|/* get the necesary lines from the source image, scale them,                  and put them into src[] */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|old_y
operator|+
literal|2
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|old_y
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|interpolation
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
block|{
name|gdouble
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|gdouble
name|dy
init|=
operator|(
name|y
operator|*
name|y_ratio
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|p0
operator|=
name|cubic_spline_fit
argument_list|(
name|dy
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p1
operator|=
name|cubic_spline_fit
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2
operator|=
name|cubic_spline_fit
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p3
operator|=
name|cubic_spline_fit
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
operator|(
name|p0
operator|*
name|src
index|[
literal|0
index|]
index|[
name|x
index|]
operator|+
name|p1
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|p2
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
operator|+
name|p3
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
block|{
name|gdouble
name|idy
init|=
operator|(
name|y
operator|*
name|y_ratio
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|gdouble
name|dy
init|=
literal|1.0
operator|-
name|idy
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|dy
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|idy
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* height == orig_height */
block|{
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|accum
argument_list|,
name|src
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* unmultiply the alpha */
name|gdouble
name|inv_alpha
decl_stmt|;
name|gdouble
modifier|*
name|p
init|=
name|accum
decl_stmt|;
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gint
name|result
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|alpha
index|]
operator|>
literal|0.001
condition|)
block|{
name|inv_alpha
operator|=
literal|255.0
operator|/
name|p
index|[
name|alpha
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|result
operator|=
name|RINT
argument_list|(
name|inv_alpha
operator|*
name|p
index|[
name|b
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|b
index|]
operator|=
name|result
expr_stmt|;
block|}
name|result
operator|=
name|RINT
argument_list|(
name|p
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|alpha
index|]
operator|=
name|result
expr_stmt|;
block|}
else|else
comment|/* alpha<= 0 */
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<=
name|alpha
condition|;
name|b
operator|++
control|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|+=
name|bytes
expr_stmt|;
name|p
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|gint
name|w
init|=
name|width
operator|*
name|bytes
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|<
literal|0.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|>
literal|255.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|dest
index|[
name|x
index|]
operator|=
name|RINT
argument_list|(
name|accum
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src_tmp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|row
operator|-=
literal|2
operator|*
name|bytes
expr_stmt|;
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|subsample_region (PixelRegion * srcPR,PixelRegion * destPR,gint subsample)
name|subsample_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|subsample
parameter_list|)
block|{
specifier|const
name|gint
name|width
init|=
name|destPR
operator|->
name|w
decl_stmt|;
specifier|const
name|gint
name|height
init|=
name|destPR
operator|->
name|h
decl_stmt|;
specifier|const
name|gint
name|orig_width
init|=
name|srcPR
operator|->
name|w
operator|/
name|subsample
decl_stmt|;
specifier|const
name|gint
name|orig_height
init|=
name|srcPR
operator|->
name|h
operator|/
name|subsample
decl_stmt|;
specifier|const
name|gdouble
name|x_ratio
init|=
operator|(
name|gdouble
operator|)
name|orig_width
operator|/
operator|(
name|gdouble
operator|)
name|width
decl_stmt|;
specifier|const
name|gdouble
name|y_ratio
init|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
decl_stmt|;
specifier|const
name|gint
name|bytes
init|=
name|destPR
operator|->
name|bytes
decl_stmt|;
specifier|const
name|gint
name|destwidth
init|=
name|destPR
operator|->
name|rowstride
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|gint
name|src_row
decl_stmt|,
name|src_col
decl_stmt|;
name|gdouble
name|x_sum
decl_stmt|,
name|y_sum
decl_stmt|;
name|gdouble
name|x_last
decl_stmt|,
name|y_last
decl_stmt|;
name|gdouble
modifier|*
name|x_frac
decl_stmt|,
name|y_frac
decl_stmt|,
name|tot_frac
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|frac
decl_stmt|;
name|gint
name|advance_dest
decl_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("subsample_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  the data pointers...  */
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|destPR
operator|->
name|data
expr_stmt|;
comment|/*  allocate an array to help with the calculations  */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|x_frac
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|+
name|orig_width
argument_list|)
expr_stmt|;
comment|/*  initialize the pre-calculated pixel fraction array  */
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_sum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
name|x_last
operator|=
name|x_sum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|+
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x_sum
operator|+
name|x_ratio
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|x_sum
operator|+=
name|x_ratio
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|x_sum
operator|-
name|x_last
expr_stmt|;
block|}
else|else
block|{
name|src_col
operator|++
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|src_col
operator|-
name|x_last
expr_stmt|;
block|}
name|x_last
operator|+=
name|x_frac
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  counters...  */
name|src_row
operator|=
literal|0
expr_stmt|;
name|y_sum
operator|=
operator|(
name|gdouble
operator|)
name|src_row
expr_stmt|;
name|y_last
operator|=
name|y_sum
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
name|srcPR
operator|->
name|x
argument_list|,
name|srcPR
operator|->
name|y
operator|+
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
control|)
block|{
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_sum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
comment|/* determine the fraction of the src pixel we are using for y */
if|if
condition|(
name|y_sum
operator|+
name|y_ratio
operator|<=
operator|(
name|src_row
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|y_sum
operator|+=
name|y_ratio
expr_stmt|;
name|y_frac
operator|=
name|y_sum
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|src_row
operator|++
expr_stmt|;
name|y_frac
operator|=
name|src_row
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|FALSE
expr_stmt|;
block|}
name|y_last
operator|+=
name|y_frac
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|frac
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
condition|)
block|{
name|tot_frac
operator|=
name|x_frac
index|[
name|frac
operator|++
index|]
operator|*
name|y_frac
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|r
index|[
name|b
index|]
operator|+=
name|s
index|[
name|b
index|]
operator|*
name|tot_frac
expr_stmt|;
comment|/*  increment the destination  */
if|if
condition|(
name|x_sum
operator|+
name|x_ratio
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|r
operator|+=
name|bytes
expr_stmt|;
name|x_sum
operator|+=
name|x_ratio
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* increment the source */
else|else
block|{
name|s
operator|+=
name|bytes
expr_stmt|;
name|src_col
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advance_dest
condition|)
block|{
name|tot_frac
operator|=
literal|1.0
operator|/
operator|(
name|x_ratio
operator|*
name|y_ratio
operator|)
expr_stmt|;
comment|/*  copy "row" to "dest"  */
name|d
operator|=
name|dest
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|b
operator|=
name|bytes
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|*
name|r
operator|++
operator|*
name|tot_frac
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
name|dest
operator|+=
name|destwidth
expr_stmt|;
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|destwidth
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
name|srcPR
operator|->
name|x
argument_list|,
name|srcPR
operator|->
name|y
operator|+
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|x_frac
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lanczos */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|sinc (gdouble x)
name|sinc
parameter_list|(
name|gdouble
name|x
parameter_list|)
block|{
name|gdouble
name|y
init|=
name|x
operator|*
name|G_PI
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|LANCZOS_MIN
condition|)
return|return
literal|1.0
return|;
return|return
name|sin
argument_list|(
name|y
argument_list|)
operator|/
name|y
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum (guchar * ptr,const gdouble * kernel,gint u,gint bytes,gint byte)
name|lanczos_sum
parameter_list|(
name|guchar
modifier|*
name|ptr
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|kernel
parameter_list|,
comment|/* 1-D kernel of transform coeffs */
name|gint
name|u
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|kernel
index|[
name|i
index|]
operator|*
name|ptr
index|[
operator|(
name|u
operator|+
name|i
operator|-
name|LANCZOS_WIDTH
operator|)
operator|*
name|bytes
operator|+
name|byte
index|]
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum_mul (guchar * ptr,const gdouble * kernel,gint u,gint bytes,gint byte,gint alpha)
name|lanczos_sum_mul
parameter_list|(
name|guchar
modifier|*
name|ptr
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|kernel
parameter_list|,
comment|/* 1-D kernel of transform coeffs */
name|gint
name|u
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|kernel
index|[
name|i
index|]
operator|*
name|ptr
index|[
operator|(
name|u
operator|+
name|i
operator|-
name|LANCZOS_WIDTH
operator|)
operator|*
name|bytes
operator|+
name|byte
index|]
operator|*
name|ptr
index|[
operator|(
name|u
operator|+
name|i
operator|-
name|LANCZOS_WIDTH
operator|)
operator|*
name|bytes
operator|+
name|alpha
index|]
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|inv_lin_trans (const gdouble * t,gdouble * it)
name|inv_lin_trans
parameter_list|(
specifier|const
name|gdouble
modifier|*
name|t
parameter_list|,
name|gdouble
modifier|*
name|it
parameter_list|)
block|{
name|gdouble
name|d
init|=
operator|(
name|t
index|[
literal|0
index|]
operator|*
name|t
index|[
literal|4
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|1
index|]
operator|*
name|t
index|[
literal|3
index|]
operator|)
decl_stmt|;
comment|/* determinant */
if|if
condition|(
name|fabs
argument_list|(
name|d
argument_list|)
operator|<
name|EPSILON
condition|)
return|return
name|FALSE
return|;
name|it
index|[
literal|0
index|]
operator|=
name|t
index|[
literal|4
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|1
index|]
operator|=
operator|-
name|t
index|[
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|t
index|[
literal|1
index|]
operator|*
name|t
index|[
literal|5
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|2
index|]
operator|*
name|t
index|[
literal|4
index|]
operator|)
operator|)
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|3
index|]
operator|=
operator|-
name|t
index|[
literal|3
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|4
index|]
operator|=
name|t
index|[
literal|0
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|t
index|[
literal|2
index|]
operator|*
name|t
index|[
literal|3
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|0
index|]
operator|*
name|t
index|[
literal|5
index|]
operator|)
operator|)
operator|/
name|d
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * allocate and fill lookup table of Lanczos windowed sinc function  * use gfloat since errors due to granularity of array far exceed data precision  */
end_comment

begin_function
name|gfloat
modifier|*
DECL|function|create_lanczos_lookup (void)
name|create_lanczos_lookup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|gdouble
name|dx
init|=
name|LANCZOS_WIDTH
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|LANCZOS_SAMPLES
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gfloat
modifier|*
name|lookup
init|=
name|g_new
argument_list|(
name|gfloat
argument_list|,
name|LANCZOS_SAMPLES
argument_list|)
decl_stmt|;
name|gdouble
name|x
init|=
literal|0.0
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_SAMPLES
condition|;
name|i
operator|++
control|)
block|{
name|lookup
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|LANCZOS_WIDTH
operator|)
condition|?
operator|(
name|sinc
argument_list|(
name|x
argument_list|)
operator|*
name|sinc
argument_list|(
name|x
operator|/
name|LANCZOS_WIDTH
argument_list|)
operator|)
else|:
literal|0.0
operator|)
expr_stmt|;
name|x
operator|+=
name|dx
expr_stmt|;
block|}
return|return
name|lookup
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|scale_region_lanczos (PixelRegion * srcPR,PixelRegion * dstPR,GimpProgressFunc progress_callback,gpointer progress_data)
name|scale_region_lanczos
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|dstPR
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|gfloat
modifier|*
name|kernel_lookup
init|=
name|NULL
decl_stmt|;
comment|/* Lanczos lookup table                */
name|gdouble
name|x_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|,
comment|/* 1-D kernels of Lanczos window coeffs */
name|y_kernel
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
name|gdouble
name|newval
decl_stmt|;
comment|/* new interpolated RGB value          */
name|guchar
modifier|*
name|win_buf
init|=
name|NULL
decl_stmt|;
comment|/* Sliding window buffer               */
name|guchar
modifier|*
name|win_ptr
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* Ponters to sliding window rows      */
name|guchar
modifier|*
name|dst_buf
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to destination image data   */
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Position in destination image       */
name|gint
name|i
decl_stmt|,
name|byte
decl_stmt|;
comment|/* loop vars  */
name|gint
name|row
decl_stmt|;
name|gdouble
name|trans
index|[
literal|6
index|]
decl_stmt|,
name|itrans
index|[
literal|6
index|]
decl_stmt|;
comment|/* Scale transformations               */
specifier|const
name|gint
name|dst_width
init|=
name|dstPR
operator|->
name|w
decl_stmt|;
specifier|const
name|gint
name|dst_height
init|=
name|dstPR
operator|->
name|h
decl_stmt|;
specifier|const
name|gint
name|bytes
init|=
name|dstPR
operator|->
name|bytes
decl_stmt|;
specifier|const
name|gint
name|src_width
init|=
name|srcPR
operator|->
name|w
decl_stmt|;
specifier|const
name|gint
name|src_height
init|=
name|srcPR
operator|->
name|h
decl_stmt|;
specifier|const
name|gint
name|src_row_span
init|=
name|src_width
operator|*
name|bytes
decl_stmt|;
specifier|const
name|gint
name|dst_row_span
init|=
name|dst_width
operator|*
name|bytes
decl_stmt|;
specifier|const
name|gint
name|win_row_span
init|=
operator|(
name|src_width
operator|+
name|LANCZOS_WIDTH2
operator|)
operator|*
name|bytes
decl_stmt|;
specifier|const
name|gdouble
name|scale_x
init|=
name|dst_width
operator|/
operator|(
name|gdouble
operator|)
name|src_width
decl_stmt|;
specifier|const
name|gdouble
name|scale_y
init|=
name|dst_height
operator|/
operator|(
name|gdouble
operator|)
name|src_height
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|trans
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
name|trans
index|[
literal|0
index|]
operator|=
name|scale_x
expr_stmt|;
name|trans
index|[
literal|4
index|]
operator|=
name|scale_y
expr_stmt|;
if|if
condition|(
operator|!
name|inv_lin_trans
argument_list|(
name|trans
argument_list|,
name|itrans
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"transformation matrix is not invertible"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* allocate buffer for destination row */
name|dst_buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|dst_row_span
argument_list|)
expr_stmt|;
comment|/* if no scaling needed copy data */
if|if
condition|(
name|dst_width
operator|==
name|src_width
operator|&&
name|dst_height
operator|==
name|src_height
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_height
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|src_width
argument_list|,
name|dst_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_region_set_row
argument_list|(
name|dstPR
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|dst_width
argument_list|,
name|dst_buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|dst_buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* allocate and fill kernel_lookup lookup table */
name|kernel_lookup
operator|=
name|create_lanczos_lookup
argument_list|()
expr_stmt|;
comment|/* allocate buffer for source rows */
name|win_buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|win_row_span
operator|*
name|LANCZOS_WIDTH2
argument_list|)
expr_stmt|;
comment|/* Set the window pointers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|win_ptr
index|[
name|i
index|]
operator|=
name|win_buf
operator|+
operator|(
name|win_row_span
operator|*
name|i
operator|)
operator|+
name|LANCZOS_WIDTH
operator|*
name|bytes
expr_stmt|;
comment|/* fill the data for the first loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LANCZOS_WIDTH
operator|&&
name|i
operator|<
name|src_height
condition|;
name|i
operator|++
control|)
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|src_width
argument_list|,
name|win_ptr
index|[
name|i
operator|+
name|LANCZOS_WIDTH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dst_height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress_callback
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
literal|0
argument_list|,
name|dst_height
argument_list|,
name|y
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|dstPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|dst_width
argument_list|,
name|dst_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
control|)
block|{
name|gdouble
name|dsrc_x
decl_stmt|,
name|dsrc_y
decl_stmt|;
comment|/* corresponding scaled position in source image */
name|gint
name|int_src_x
decl_stmt|,
name|int_src_y
decl_stmt|;
comment|/* integer part of coordinates in source image   */
name|gint
name|x_shift
decl_stmt|,
name|y_shift
decl_stmt|;
comment|/* index into Lanczos lookup                     */
name|gdouble
name|kx_sum
decl_stmt|,
name|ky_sum
decl_stmt|;
comment|/* sums of Lanczos kernel coeffs                 */
comment|/* -0.5 corrects image drift.due to average offset used in lookup */
name|dsrc_x
operator|=
name|x
operator|/
name|scale_x
operator|-
literal|0.5
expr_stmt|;
name|dsrc_y
operator|=
name|y
operator|/
name|scale_y
operator|-
literal|0.5
expr_stmt|;
comment|/* avoid (int) on negative*/
if|if
condition|(
name|dsrc_x
operator|>
literal|0
condition|)
name|int_src_x
operator|=
call|(
name|gint
call|)
argument_list|(
name|dsrc_x
argument_list|)
expr_stmt|;
else|else
name|int_src_x
operator|=
call|(
name|gint
call|)
argument_list|(
name|dsrc_x
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dsrc_y
operator|>
literal|0
condition|)
name|int_src_y
operator|=
call|(
name|gint
call|)
argument_list|(
name|dsrc_y
argument_list|)
expr_stmt|;
else|else
name|int_src_y
operator|=
call|(
name|gint
call|)
argument_list|(
name|dsrc_y
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* calc lookup offsets for non-interger remainders */
name|x_shift
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|dsrc_x
operator|-
name|int_src_x
operator|)
operator|*
name|LANCZOS_SPP
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|y_shift
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|dsrc_y
operator|-
name|int_src_y
operator|)
operator|*
name|LANCZOS_SPP
operator|+
literal|0.5
argument_list|)
expr_stmt|;
comment|/*  Fill x_kernel[] and y_kernel[] with lanczos coeffs            *            *  kernel_lookup = Is a lookup table that contains half of the symetrical windowed-sinc func.            *            *  x_shift, y_shift = shift from kernel center due to fractional part            *           of interpollation            *            *  The for-loop creates two 1-D kernels for convolution.            *    - If the center position +/- LANCZOS_WIDTH is out of            *      the source image coordinates set the value to 0.0            *      FIXME => partial kernel. Define a more rigourous border mode.            *    - If the kernel index is out of range set value to 0.0            *      ( caused by offset coeff. obselete??)            */
name|kx_sum
operator|=
name|ky_sum
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LANCZOS_WIDTH
init|;
name|i
operator|>=
operator|-
name|LANCZOS_WIDTH
condition|;
name|i
operator|--
control|)
block|{
name|gint
name|pos
init|=
name|i
operator|*
name|LANCZOS_SPP
decl_stmt|;
if|if
condition|(
name|int_src_x
operator|+
name|i
operator|>=
literal|0
operator|&&
name|int_src_x
operator|+
name|i
operator|<
name|src_width
condition|)
name|kx_sum
operator|+=
name|x_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|kernel_lookup
index|[
name|ABS
argument_list|(
name|x_shift
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
else|else
name|x_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|int_src_y
operator|+
name|i
operator|>=
literal|0
operator|&&
name|int_src_y
operator|+
name|i
operator|<
name|src_height
condition|)
name|ky_sum
operator|+=
name|y_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
name|kernel_lookup
index|[
name|ABS
argument_list|(
name|y_shift
operator|-
name|pos
argument_list|)
index|]
expr_stmt|;
else|else
name|y_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/* normalise the kernel arrays */
for|for
control|(
name|i
operator|=
operator|-
name|LANCZOS_WIDTH
init|;
name|i
operator|<=
name|LANCZOS_WIDTH
condition|;
name|i
operator|++
control|)
block|{
name|x_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|/=
name|kx_sum
expr_stmt|;
name|y_kernel
index|[
name|LANCZOS_WIDTH
operator|+
name|i
index|]
operator|/=
name|ky_sum
expr_stmt|;
block|}
comment|/*             Scaling up             New determined source row is> than last read row             rotate the pointers and get next source row from region.             If no more source rows are available fill buffer with 0             ( Probably not necessary because multipliers should be 0).           */
for|for
control|(
init|;
name|row
operator|<
name|int_src_y
condition|;
control|)
block|{
name|row
operator|++
expr_stmt|;
name|rotate_pointers
argument_list|(
name|win_ptr
argument_list|,
name|LANCZOS_WIDTH2
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|+
name|LANCZOS_WIDTH
operator|<
name|src_height
condition|)
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|row
operator|+
name|LANCZOS_WIDTH
argument_list|,
name|src_width
argument_list|,
name|win_ptr
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|win_ptr
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
name|src_row_span
argument_list|)
expr_stmt|;
block|}
comment|/*               Scaling down             */
for|for
control|(
init|;
name|row
operator|>
name|int_src_y
condition|;
control|)
block|{
name|row
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|rotate_pointers
argument_list|(
name|win_ptr
argument_list|,
name|LANCZOS_WIDTH2
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|src_width
argument_list|,
name|win_ptr
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|win_ptr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
name|src_row_span
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
specifier|const
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gint
name|byte
decl_stmt|;
name|gdouble
name|arecip
decl_stmt|;
name|gdouble
name|aval
decl_stmt|;
name|aval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|aval
operator|+=
name|y_kernel
index|[
name|i
index|]
operator|*
name|lanczos_sum
argument_list|(
name|win_ptr
index|[
name|i
index|]
argument_list|,
name|x_kernel
argument_list|,
name|int_src_x
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|aval
operator|<=
literal|0.0
condition|)
block|{
name|arecip
operator|=
literal|0.0
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aval
operator|>
literal|255.0
condition|)
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|aval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|alpha
condition|;
name|byte
operator|++
control|)
block|{
name|newval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|newval
operator|+=
name|y_kernel
index|[
name|i
index|]
operator|*
name|lanczos_sum_mul
argument_list|(
name|win_ptr
index|[
name|i
index|]
argument_list|,
name|x_kernel
argument_list|,
name|int_src_x
argument_list|,
name|bytes
argument_list|,
name|byte
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|newval
operator|*=
name|arecip
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|byte
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|bytes
condition|;
name|byte
operator|++
control|)
block|{
comment|/* Calculate new value */
name|newval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|newval
operator|+=
name|y_kernel
index|[
name|i
index|]
operator|*
name|lanczos_sum
argument_list|(
name|win_ptr
index|[
name|i
index|]
argument_list|,
name|x_kernel
argument_list|,
name|int_src_x
argument_list|,
name|bytes
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|byte
index|]
operator|=
name|CLAMP
argument_list|(
operator|(
name|gint
operator|)
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|dstPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|dst_width
argument_list|,
name|dst_buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|dst_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|win_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|kernel_lookup
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

