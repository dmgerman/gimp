begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"scale-funcs.h"
end_include

begin_function_decl
specifier|static
name|void
name|scale_region_no_resample
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_region_lanczos
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|dstPR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shrink_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Note: cubic function no longer clips result */
end_comment

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|cubic (gdouble dx,gint jm1,gint j,gint jp1,gint jp2)
name|cubic
parameter_list|(
name|gdouble
name|dx
parameter_list|,
name|gint
name|jm1
parameter_list|,
name|gint
name|j
parameter_list|,
name|gint
name|jp1
parameter_list|,
name|gint
name|jp2
parameter_list|)
block|{
comment|/* Catmull-Rom - not bad */
return|return
call|(
name|gdouble
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|-
name|jm1
operator|+
literal|3
operator|*
name|j
operator|-
literal|3
operator|*
name|jp1
operator|+
name|jp2
operator|)
operator|*
name|dx
operator|+
operator|(
literal|2
operator|*
name|jm1
operator|-
literal|5
operator|*
name|j
operator|+
literal|4
operator|*
name|jp1
operator|-
name|jp2
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
operator|-
name|jm1
operator|+
name|jp1
operator|)
operator|)
operator|*
name|dx
operator|+
operator|(
name|j
operator|+
name|j
operator|)
argument_list|)
operator|/
literal|2.0
return|;
block|}
end_function

begin_comment
comment|/*  * non-interpolating scale_region.  [adam]  */
end_comment

begin_function
specifier|static
name|void
DECL|function|scale_region_no_resample (PixelRegion * srcPR,PixelRegion * destPR)
name|scale_region_no_resample
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|)
block|{
name|gint
modifier|*
name|x_src_offsets
decl_stmt|;
name|gint
modifier|*
name|y_src_offsets
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gint
name|last_src_y
decl_stmt|;
name|gint
name|row_bytes
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|b
decl_stmt|;
name|gchar
name|bytes
decl_stmt|;
name|orig_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|srcPR
operator|->
name|bytes
expr_stmt|;
comment|/*  the data pointers...  */
name|x_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|y_src_offsets
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  pre-calc the scale tables  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
name|x_src_offsets
index|[
name|b
operator|+
name|x
operator|*
name|bytes
index|]
operator|=
name|b
operator|+
name|bytes
operator|*
operator|(
operator|(
name|x
operator|*
name|orig_width
operator|+
name|orig_width
operator|/
literal|2
operator|)
operator|/
name|width
operator|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
name|y_src_offsets
index|[
name|y
index|]
operator|=
operator|(
name|y
operator|*
name|orig_height
operator|+
name|orig_height
operator|/
literal|2
operator|)
operator|/
name|height
expr_stmt|;
comment|/*  do the scaling  */
name|row_bytes
operator|=
name|width
operator|*
name|bytes
expr_stmt|;
name|last_src_y
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
comment|/* if the source of this line was the same as the source        *  of the last line, there's no point in re-rescaling.        */
if|if
condition|(
name|y_src_offsets
index|[
name|y
index|]
operator|!=
name|last_src_y
condition|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y_src_offsets
index|[
name|y
index|]
argument_list|,
name|orig_width
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|row_bytes
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
name|x
index|]
operator|=
name|src
index|[
name|x_src_offsets
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
name|last_src_y
operator|=
name|y_src_offsets
index|[
name|y
index|]
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|x_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|y_src_offsets
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_premultiplied_double_row (PixelRegion * srcPR,gint x,gint y,gint w,gdouble * row,guchar * tmp_src,gint n)
name|get_premultiplied_double_row
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|w
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|tmp_src
parameter_list|,
name|gint
name|n
parameter_list|)
block|{
name|gint
name|b
decl_stmt|;
name|gint
name|bytes
init|=
name|srcPR
operator|->
name|bytes
decl_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|tmp_src
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* premultiply the alpha into the double array */
name|gdouble
modifier|*
name|irow
init|=
name|row
decl_stmt|;
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gdouble
name|mod_alpha
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
name|mod_alpha
operator|=
name|tmp_src
index|[
name|alpha
index|]
operator|/
literal|255.0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
name|irow
index|[
name|b
index|]
operator|=
name|mod_alpha
operator|*
name|tmp_src
index|[
name|b
index|]
expr_stmt|;
name|irow
index|[
name|b
index|]
operator|=
name|tmp_src
index|[
name|alpha
index|]
expr_stmt|;
name|irow
operator|+=
name|bytes
expr_stmt|;
name|tmp_src
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
comment|/* no alpha */
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|row
index|[
name|x
index|]
operator|=
name|tmp_src
index|[
name|x
index|]
expr_stmt|;
block|}
comment|/* set the off edge pixels to their nearest neighbor */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|2
operator|*
name|bytes
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|-
literal|2
operator|*
name|bytes
index|]
operator|=
name|row
index|[
name|b
operator|%
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
operator|*
literal|2
condition|;
name|b
operator|++
control|)
name|row
index|[
name|b
operator|+
name|w
operator|*
name|bytes
index|]
operator|=
name|row
index|[
operator|(
name|w
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|b
operator|%
name|bytes
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|expand_line (gdouble * dest,const gdouble * src,gint bytes,gint old_width,gint width,GimpInterpolationType interp)
name|expand_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
specifier|const
name|gdouble
modifier|*
name|s
decl_stmt|;
name|gdouble
name|ratio
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|src_col
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
name|ratio
operator|=
name|old_width
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
comment|/* we can overflow src's boundaries, so we expect our caller to have      allocated extra space for us to do so safely (see scale_region ()) */
comment|/* this could be optimized much more by precalculating the coefficients for      each x */
switch|switch
condition|(
name|interp
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|src_col
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x
operator|*
name|ratio
operator|+
literal|2.0
operator|-
literal|0.5
argument_list|)
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* +2, -2 is there because (int) rounds towards 0 and we need              to round down */
name|frac
operator|=
operator|(
name|x
operator|*
name|ratio
operator|-
literal|0.5
operator|)
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|cubic
argument_list|(
name|frac
argument_list|,
name|s
index|[
name|b
operator|-
name|bytes
index|]
argument_list|,
name|s
index|[
name|b
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bytes
index|]
argument_list|,
name|s
index|[
name|b
operator|+
name|bytes
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|src_col
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x
operator|*
name|ratio
operator|+
literal|2.0
operator|-
literal|0.5
argument_list|)
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* +2, -2 is there because (int) rounds towards 0 and we need              to round down */
name|frac
operator|=
operator|(
name|x
operator|*
name|ratio
operator|-
literal|0.5
operator|)
operator|-
name|src_col
expr_stmt|;
name|s
operator|=
operator|&
name|src
index|[
name|src_col
operator|*
name|bytes
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
operator|(
operator|(
name|s
index|[
name|b
operator|+
name|bytes
index|]
operator|-
name|s
index|[
name|b
index|]
operator|)
operator|*
name|frac
operator|+
name|s
index|[
name|b
index|]
operator|)
expr_stmt|;
name|dest
operator|+=
name|bytes
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shrink_line (gdouble * dest,const gdouble * src,gint bytes,gint old_width,gint width,GimpInterpolationType interp)
name|shrink_line
parameter_list|(
name|gdouble
modifier|*
name|dest
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|src
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|old_width
parameter_list|,
name|gint
name|width
parameter_list|,
name|GimpInterpolationType
name|interp
parameter_list|)
block|{
specifier|const
name|gdouble
modifier|*
name|srcp
decl_stmt|;
name|gdouble
modifier|*
name|destp
decl_stmt|;
name|gdouble
name|accum
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|slice
decl_stmt|;
specifier|const
name|gdouble
name|avg_ratio
init|=
operator|(
name|gdouble
operator|)
name|width
operator|/
name|old_width
decl_stmt|;
specifier|const
name|gdouble
name|inv_width
init|=
literal|1.0
operator|/
name|width
decl_stmt|;
name|gint
name|slicepos
decl_stmt|;
comment|/* slice position relative to width */
name|gint
name|x
decl_stmt|;
name|gint
name|b
decl_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("shrink_line bytes=%d old_width=%d width=%d interp=%d "               "avg_ratio=%f\n",               bytes, old_width, width, interp, avg_ratio);
endif|#
directive|endif
name|g_return_if_fail
argument_list|(
name|bytes
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* This algorithm calculates the weighted average of pixel data that      each output pixel must receive, taking into account that it always      scales down, i.e. there's always more than one input pixel per each      output pixel.  */
name|srcp
operator|=
name|src
expr_stmt|;
name|destp
operator|=
name|dest
expr_stmt|;
name|slicepos
operator|=
literal|0
expr_stmt|;
comment|/* Initialize accum to the first pixel slice.  As there is no partial      pixel at start, that value is 0.  The source data is interleaved, so      we maintain BYTES accumulators at the same time to deal with that      many channels simultaneously.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* Accumulate whole pixels.  */
do|do
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|accum
index|[
name|b
index|]
operator|+=
operator|*
name|srcp
operator|++
expr_stmt|;
name|slicepos
operator|+=
name|width
expr_stmt|;
block|}
do|while
condition|(
name|slicepos
operator|<
name|old_width
condition|)
do|;
name|slicepos
operator|-=
name|old_width
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slicepos
operator|<
name|width
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (slicepos< width) failed. Please report."
argument_list|)
expr_stmt|;
if|if
condition|(
name|slicepos
operator|==
literal|0
condition|)
block|{
comment|/* Simplest case: we have reached a whole pixel boundary.  Store              the average value per channel and reset the accumulators for              the next round.               The main reason to treat this case separately is to avoid an              access to out-of-bounds memory for the first pixel.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
operator|*
name|destp
operator|++
operator|=
name|accum
index|[
name|b
index|]
operator|*
name|avg_ratio
expr_stmt|;
name|accum
index|[
name|b
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
comment|/* We have accumulated a whole pixel per channel where just a                  slice of it was needed.  Subtract now the previous pixel's                  extra slice.  */
name|slice
operator|=
name|srcp
index|[
operator|-
name|bytes
operator|+
name|b
index|]
operator|*
name|slicepos
operator|*
name|inv_width
expr_stmt|;
operator|*
name|destp
operator|++
operator|=
operator|(
name|accum
index|[
name|b
index|]
operator|-
name|slice
operator|)
operator|*
name|avg_ratio
expr_stmt|;
comment|/* That slice is the initial value for the next round.  */
name|accum
index|[
name|b
index|]
operator|=
name|slice
expr_stmt|;
block|}
block|}
block|}
comment|/* Sanity check: srcp should point to the next-to-last position, and      slicepos should be zero.  */
if|if
condition|(
operator|!
operator|(
name|srcp
operator|-
name|src
operator|==
name|old_width
operator|*
name|bytes
operator|&&
name|slicepos
operator|==
literal|0
operator|)
condition|)
name|g_warning
argument_list|(
literal|"Assertion (srcp - src == old_width * bytes&& slicepos == 0)"
literal|" failed. Please report."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|rotate_pointers (guchar ** p,guint32 n)
name|rotate_pointers
parameter_list|(
name|guchar
modifier|*
modifier|*
name|p
parameter_list|,
name|guint32
name|n
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
name|guchar
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|p
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_scaled_row (gdouble ** src,gint y,gint new_width,PixelRegion * srcPR,gdouble * row,guchar * src_tmp,GimpInterpolationType interpolation_type)
name|get_scaled_row
parameter_list|(
name|gdouble
modifier|*
modifier|*
name|src
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|gdouble
modifier|*
name|row
parameter_list|,
name|guchar
modifier|*
name|src_tmp
parameter_list|,
name|GimpInterpolationType
name|interpolation_type
parameter_list|)
block|{
comment|/* get the necesary lines from the source image, scale them,      and put them into src[] */
name|rotate_pointers
argument_list|(
operator|(
name|gpointer
operator|)
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|srcPR
operator|->
name|h
condition|)
block|{
name|get_premultiplied_double_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_width
operator|>
name|srcPR
operator|->
name|w
condition|)
name|expand_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|srcPR
operator|->
name|w
operator|>
name|new_width
condition|)
name|shrink_line
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
name|srcPR
operator|->
name|bytes
argument_list|,
name|srcPR
operator|->
name|w
argument_list|,
name|new_width
argument_list|,
name|interpolation_type
argument_list|)
expr_stmt|;
else|else
comment|/* no scailing needed */
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|row
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|,
name|src
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|new_width
operator|*
name|srcPR
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|scale_region (PixelRegion * srcPR,PixelRegion * destPR,GimpInterpolationType interpolation,GimpProgressFunc progress_callback,gpointer progress_data)
name|scale_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|GimpInterpolationType
name|interpolation
parameter_list|,
name|GimpProgressFunc
name|progress_callback
parameter_list|,
name|gpointer
name|progress_data
parameter_list|)
block|{
name|gdouble
modifier|*
name|src
index|[
literal|4
index|]
decl_stmt|;
name|guchar
modifier|*
name|src_tmp
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|accum
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gdouble
name|y_rat
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|old_y
init|=
operator|-
literal|4
decl_stmt|;
name|gint
name|new_y
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|interpolation
operator|==
name|GIMP_INTERPOLATION_NONE
condition|)
block|{
name|scale_region_no_resample
argument_list|(
name|srcPR
argument_list|,
name|destPR
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|interpolation
operator|==
name|GIMP_INTERPOLATION_LANCZOS
condition|)
block|{
name|scale_region_lanczos
argument_list|(
name|srcPR
argument_list|,
name|destPR
argument_list|)
expr_stmt|;
return|return;
block|}
name|orig_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("scale_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  find the ratios of old y to new y  */
name|y_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
comment|/*  the data pointers...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|src
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|src_tmp
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/* offset the row pointer by 2*bytes so the range of the array      is [-2*bytes] to [(orig_width + 2)*bytes] */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
operator|(
name|orig_width
operator|+
literal|2
operator|*
literal|2
operator|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|row
operator|+=
name|bytes
operator|*
literal|2
expr_stmt|;
name|accum
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|progress_callback
operator|&&
operator|!
operator|(
name|y
operator|&
literal|0xf
operator|)
condition|)
call|(
modifier|*
name|progress_callback
call|)
argument_list|(
literal|0
argument_list|,
name|height
argument_list|,
name|y
argument_list|,
name|progress_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|height
operator|<
name|orig_height
condition|)
block|{
name|gint
name|max
decl_stmt|;
name|gdouble
name|frac
decl_stmt|;
specifier|const
name|gdouble
name|inv_ratio
init|=
literal|1.0
operator|/
name|y_rat
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
comment|/* load the first row if this is the first time through */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|new_y
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|*
name|y_rat
argument_list|)
expr_stmt|;
name|frac
operator|=
literal|1.0
operator|-
operator|(
name|y
operator|*
name|y_rat
operator|-
name|new_y
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|*
name|frac
expr_stmt|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
argument_list|)
operator|-
name|new_y
operator|-
literal|1
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|+=
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
operator|++
name|new_y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|max
operator|--
expr_stmt|;
block|}
name|frac
operator|=
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|y_rat
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
block|{
name|accum
index|[
name|x
index|]
operator|+=
name|frac
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
expr_stmt|;
name|accum
index|[
name|x
index|]
operator|*=
name|inv_ratio
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|height
operator|>
name|orig_height
condition|)
block|{
name|new_y
operator|=
name|floor
argument_list|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_y
operator|<=
name|new_y
condition|)
block|{
comment|/* get the necesary lines from the source image, scale them,                  and put them into src[] */
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|old_y
operator|+
literal|2
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|old_y
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|interpolation
condition|)
block|{
case|case
name|GIMP_INTERPOLATION_CUBIC
case|:
block|{
name|gdouble
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|gdouble
name|dy
init|=
operator|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|p0
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p1
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p3
operator|=
name|cubic
argument_list|(
name|dy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
operator|(
name|p0
operator|*
name|src
index|[
literal|0
index|]
index|[
name|x
index|]
operator|+
name|p1
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|p2
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
operator|+
name|p3
operator|*
name|src
index|[
literal|3
index|]
index|[
name|x
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_LINEAR
case|:
block|{
name|gdouble
name|idy
init|=
operator|(
name|y
operator|*
name|y_rat
operator|-
literal|0.5
operator|)
operator|-
name|new_y
decl_stmt|;
name|gdouble
name|dy
init|=
literal|1.0
operator|-
name|idy
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
operator|*
name|bytes
condition|;
name|x
operator|++
control|)
name|accum
index|[
name|x
index|]
operator|=
name|dy
operator|*
name|src
index|[
literal|1
index|]
index|[
name|x
index|]
operator|+
name|idy
operator|*
name|src
index|[
literal|2
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INTERPOLATION_NONE
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
case|case
name|GIMP_INTERPOLATION_LANCZOS
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* height == orig_height */
block|{
name|get_scaled_row
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|srcPR
argument_list|,
name|row
argument_list|,
name|src_tmp
argument_list|,
name|interpolation
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|accum
argument_list|,
name|src
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
comment|/* unmultiply the alpha */
name|gdouble
name|inv_alpha
decl_stmt|;
name|gdouble
modifier|*
name|p
init|=
name|accum
decl_stmt|;
name|gint
name|alpha
init|=
name|bytes
operator|-
literal|1
decl_stmt|;
name|gint
name|result
decl_stmt|;
name|guchar
modifier|*
name|d
init|=
name|dest
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|alpha
index|]
operator|>
literal|0.001
condition|)
block|{
name|inv_alpha
operator|=
literal|255.0
operator|/
name|p
index|[
name|alpha
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|alpha
condition|;
name|b
operator|++
control|)
block|{
name|result
operator|=
name|RINT
argument_list|(
name|inv_alpha
operator|*
name|p
index|[
name|b
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|b
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|b
index|]
operator|=
name|result
expr_stmt|;
block|}
name|result
operator|=
name|RINT
argument_list|(
name|p
index|[
name|alpha
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|255
condition|)
name|d
index|[
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|d
index|[
name|alpha
index|]
operator|=
name|result
expr_stmt|;
block|}
else|else
comment|/* alpha<= 0 */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<=
name|alpha
condition|;
name|b
operator|++
control|)
name|d
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|+=
name|bytes
expr_stmt|;
name|p
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|gint
name|w
init|=
name|width
operator|*
name|bytes
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|<
literal|0.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|accum
index|[
name|x
index|]
operator|>
literal|255.0
condition|)
name|dest
index|[
name|x
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|dest
index|[
name|x
index|]
operator|=
name|RINT
argument_list|(
name|accum
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|destPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src_tmp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|row
operator|-=
literal|2
operator|*
name|bytes
expr_stmt|;
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|subsample_region (PixelRegion * srcPR,PixelRegion * destPR,gint subsample)
name|subsample_region
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|destPR
parameter_list|,
name|gint
name|subsample
parameter_list|)
block|{
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|gdouble
modifier|*
name|row
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|gint
name|destwidth
decl_stmt|;
name|gint
name|src_row
decl_stmt|,
name|src_col
decl_stmt|;
name|gint
name|bytes
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|orig_width
decl_stmt|,
name|orig_height
decl_stmt|;
name|gdouble
name|x_rat
decl_stmt|,
name|y_rat
decl_stmt|;
name|gdouble
name|x_cum
decl_stmt|,
name|y_cum
decl_stmt|;
name|gdouble
name|x_last
decl_stmt|,
name|y_last
decl_stmt|;
name|gdouble
modifier|*
name|x_frac
decl_stmt|,
name|y_frac
decl_stmt|,
name|tot_frac
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|frac
decl_stmt|;
name|gint
name|advance_dest
decl_stmt|;
name|orig_width
operator|=
name|srcPR
operator|->
name|w
operator|/
name|subsample
expr_stmt|;
name|orig_height
operator|=
name|srcPR
operator|->
name|h
operator|/
name|subsample
expr_stmt|;
name|width
operator|=
name|destPR
operator|->
name|w
expr_stmt|;
name|height
operator|=
name|destPR
operator|->
name|h
expr_stmt|;
if|#
directive|if
literal|0
block|g_printerr ("subsample_region: (%d x %d) -> (%d x %d)\n",               orig_width, orig_height, width, height);
endif|#
directive|endif
comment|/*  Some calculations...  */
name|bytes
operator|=
name|destPR
operator|->
name|bytes
expr_stmt|;
name|destwidth
operator|=
name|destPR
operator|->
name|rowstride
expr_stmt|;
comment|/*  the data pointers...  */
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|orig_width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|=
name|destPR
operator|->
name|data
expr_stmt|;
comment|/*  find the ratios of old x to new x and old y to new y  */
name|x_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_width
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|y_rat
operator|=
operator|(
name|gdouble
operator|)
name|orig_height
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
comment|/*  allocate an array to help with the calculations  */
name|row
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|x_frac
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|width
operator|+
name|orig_width
argument_list|)
expr_stmt|;
comment|/*  initialize the pre-calculated pixel fraction array  */
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
name|x_last
operator|=
name|x_cum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|+
name|orig_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x_cum
operator|+
name|x_rat
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|x_cum
operator|+=
name|x_rat
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|x_cum
operator|-
name|x_last
expr_stmt|;
block|}
else|else
block|{
name|src_col
operator|++
expr_stmt|;
name|x_frac
index|[
name|i
index|]
operator|=
name|src_col
operator|-
name|x_last
expr_stmt|;
block|}
name|x_last
operator|+=
name|x_frac
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
comment|/*  counters...  */
name|src_row
operator|=
literal|0
expr_stmt|;
name|y_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_row
expr_stmt|;
name|y_last
operator|=
name|y_cum
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
comment|/*  Scale the selected region  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
control|)
block|{
name|src_col
operator|=
literal|0
expr_stmt|;
name|x_cum
operator|=
operator|(
name|gdouble
operator|)
name|src_col
expr_stmt|;
comment|/* determine the fraction of the src pixel we are using for y */
if|if
condition|(
name|y_cum
operator|+
name|y_rat
operator|<=
operator|(
name|src_row
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|y_cum
operator|+=
name|y_rat
expr_stmt|;
name|y_frac
operator|=
name|y_cum
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|src_row
operator|++
expr_stmt|;
name|y_frac
operator|=
name|src_row
operator|-
name|y_last
expr_stmt|;
name|advance_dest
operator|=
name|FALSE
expr_stmt|;
block|}
name|y_last
operator|+=
name|y_frac
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|frac
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
condition|)
block|{
name|tot_frac
operator|=
name|x_frac
index|[
name|frac
operator|++
index|]
operator|*
name|y_frac
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|r
index|[
name|b
index|]
operator|+=
name|s
index|[
name|b
index|]
operator|*
name|tot_frac
expr_stmt|;
comment|/*  increment the destination  */
if|if
condition|(
name|x_cum
operator|+
name|x_rat
operator|<=
operator|(
name|src_col
operator|+
literal|1
operator|+
name|EPSILON
operator|)
condition|)
block|{
name|r
operator|+=
name|bytes
expr_stmt|;
name|x_cum
operator|+=
name|x_rat
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* increment the source */
else|else
block|{
name|s
operator|+=
name|bytes
expr_stmt|;
name|src_col
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advance_dest
condition|)
block|{
name|tot_frac
operator|=
literal|1.0
operator|/
operator|(
name|x_rat
operator|*
name|y_rat
operator|)
expr_stmt|;
comment|/*  copy "row" to "dest"  */
name|d
operator|=
name|dest
expr_stmt|;
name|r
operator|=
name|row
expr_stmt|;
name|j
operator|=
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|b
operator|=
name|bytes
expr_stmt|;
while|while
condition|(
name|b
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|*
name|r
operator|++
operator|*
name|tot_frac
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
name|dest
operator|+=
name|destwidth
expr_stmt|;
comment|/*  clear the "row" array  */
name|memset
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|destwidth
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|src_row
operator|*
name|subsample
argument_list|,
name|orig_width
operator|*
name|subsample
argument_list|,
name|src
argument_list|,
name|subsample
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  free up temporary arrays  */
name|g_free
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|x_frac
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lanczos */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|mirror_edge (guchar * row,gint width,gint bytes)
name|mirror_edge
parameter_list|(
name|guchar
modifier|*
name|row
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|bytes
parameter_list|)
block|{
name|guchar
modifier|*
name|ptr
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ptr
operator|=
name|row
operator|-
name|LANCZOS_WIDTH
operator|*
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LANCZOS_WIDTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
operator|,
name|ptr
operator|++
control|)
operator|*
name|ptr
operator|=
name|row
index|[
name|i
operator|*
name|bytes
operator|+
name|k
index|]
expr_stmt|;
block|}
name|ptr
operator|=
name|row
operator|+
name|width
operator|*
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|LANCZOS_WIDTH
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
operator|,
name|ptr
operator|++
control|)
operator|*
name|ptr
operator|=
name|ptr
index|[
operator|-
name|i
operator|*
name|bytes
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|sinc (gdouble x)
name|sinc
parameter_list|(
name|gdouble
name|x
parameter_list|)
block|{
name|gdouble
name|y
init|=
name|x
operator|*
name|G_PI
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|EPSILON
condition|)
return|return
literal|1.0
return|;
return|return
name|sin
argument_list|(
name|y
argument_list|)
operator|/
name|y
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum (guchar ** src,const gdouble * l,gint row,gint col,gint bytes,gint byte)
name|lanczos_sum
parameter_list|(
name|guchar
modifier|*
modifier|*
name|src
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|l
parameter_list|,
name|gint
name|row
parameter_list|,
name|gint
name|col
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|guchar
modifier|*
name|ptr
decl_stmt|;
comment|/* LANCZOS_WIDTH = 2      l[*] = kernel coefficients                  / col =5      row = abc[defg]hij               |    \ col + LANCZOS_WIDTH               \ _____col - LANCZOS_WIDTH +1       sum = d.l[0] +e.l[1] + f.l[2] + g.l[3]   */
name|ptr
operator|=
name|src
index|[
name|row
index|]
operator|-
name|LANCZOS_WIDTH
operator|*
name|bytes
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|LANCZOS_WIDTH2
condition|;
name|k
operator|++
control|)
name|sum
operator|+=
name|l
index|[
name|k
index|]
operator|*
name|ptr
index|[
operator|(
name|k
operator|+
name|col
operator|)
operator|*
name|bytes
operator|+
name|byte
index|]
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|gdouble
DECL|function|lanczos_sum_mul (guchar ** src,const gdouble * l,gint row,gint col,gint bytes,gint byte,gint alpha)
name|lanczos_sum_mul
parameter_list|(
name|guchar
modifier|*
modifier|*
name|src
parameter_list|,
specifier|const
name|gdouble
modifier|*
name|l
parameter_list|,
name|gint
name|row
parameter_list|,
name|gint
name|col
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gint
name|byte
parameter_list|,
name|gint
name|alpha
parameter_list|)
block|{
name|gdouble
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|guchar
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|src
index|[
name|row
index|]
operator|-
name|LANCZOS_WIDTH
operator|*
name|bytes
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|LANCZOS_WIDTH2
condition|;
name|k
operator|++
control|)
name|sum
operator|+=
name|l
index|[
name|k
index|]
operator|*
name|ptr
index|[
operator|(
name|k
operator|+
name|col
operator|)
operator|*
name|bytes
operator|+
name|byte
index|]
operator|*
name|ptr
index|[
operator|(
name|k
operator|+
name|col
operator|)
operator|*
name|bytes
operator|+
name|alpha
index|]
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|inv_lin_trans (const gdouble * t,gdouble * it)
name|inv_lin_trans
parameter_list|(
specifier|const
name|gdouble
modifier|*
name|t
parameter_list|,
name|gdouble
modifier|*
name|it
parameter_list|)
block|{
name|gdouble
name|d
decl_stmt|;
comment|/* Determinant */
name|d
operator|=
operator|(
name|t
index|[
literal|0
index|]
operator|*
name|t
index|[
literal|4
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|1
index|]
operator|*
name|t
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|d
argument_list|)
operator|<
name|EPSILON
condition|)
return|return
name|FALSE
return|;
name|it
index|[
literal|0
index|]
operator|=
name|t
index|[
literal|4
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|1
index|]
operator|=
operator|-
name|t
index|[
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|t
index|[
literal|1
index|]
operator|*
name|t
index|[
literal|5
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|2
index|]
operator|*
name|t
index|[
literal|4
index|]
operator|)
operator|)
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|3
index|]
operator|=
operator|-
name|t
index|[
literal|3
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|4
index|]
operator|=
name|t
index|[
literal|0
index|]
operator|/
name|d
expr_stmt|;
name|it
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|t
index|[
literal|2
index|]
operator|*
name|t
index|[
literal|3
index|]
operator|)
operator|-
operator|(
name|t
index|[
literal|0
index|]
operator|*
name|t
index|[
literal|5
index|]
operator|)
operator|)
operator|/
name|d
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gdouble
modifier|*
DECL|function|kernel_lanczos (void)
name|kernel_lanczos
parameter_list|(
name|void
parameter_list|)
block|{
name|gdouble
modifier|*
name|kernel
decl_stmt|;
name|gdouble
name|x
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dx
init|=
operator|(
name|gdouble
operator|)
name|LANCZOS_WIDTH
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|LANCZOS_SAMPLES
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|kernel
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|LANCZOS_SAMPLES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_SAMPLES
condition|;
name|i
operator|++
control|)
block|{
name|kernel
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|ABS
argument_list|(
name|x
argument_list|)
operator|<
name|LANCZOS_WIDTH
operator|)
condition|?
operator|(
name|sinc
argument_list|(
name|x
argument_list|)
operator|*
name|sinc
argument_list|(
name|x
operator|/
name|LANCZOS_WIDTH
argument_list|)
operator|)
else|:
literal|0.0
operator|)
expr_stmt|;
name|x
operator|+=
name|dx
expr_stmt|;
block|}
return|return
name|kernel
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|scale_region_lanczos (PixelRegion * srcPR,PixelRegion * dstPR)
name|scale_region_lanczos
parameter_list|(
name|PixelRegion
modifier|*
name|srcPR
parameter_list|,
name|PixelRegion
modifier|*
name|dstPR
parameter_list|)
block|{
name|gdouble
modifier|*
name|kernel
init|=
name|NULL
decl_stmt|;
comment|/* Lanczos kernel                    */
name|gdouble
name|lu
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|,
comment|/* Lanczos sample value              */
name|lv
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* Lanczos sample value              */
name|gint
name|su
decl_stmt|,
name|sv
decl_stmt|;
comment|/* Lanczos kernel position           */
name|gdouble
name|lusum
decl_stmt|,
name|lvsum
decl_stmt|,
name|weight
decl_stmt|;
comment|/* Lanczos weighting vars            */
name|gint
name|bytes
decl_stmt|,
name|alpha
decl_stmt|,
name|row
decl_stmt|;
comment|/* Image properties                  */
name|gint
name|src_width
decl_stmt|,
name|src_height
decl_stmt|;
comment|/* Source width height               */
name|gint
name|src_rowstride
decl_stmt|;
comment|/* Source rowstride (= dest)         */
name|gint
name|srcrow
decl_stmt|;
comment|/* counter for read src rows         */
name|guchar
modifier|*
name|src_buf
init|=
name|NULL
decl_stmt|;
comment|/* Holds sliding window buffer       */
name|guchar
modifier|*
name|src
index|[
name|LANCZOS_WIDTH2
index|]
decl_stmt|;
comment|/* Array for sliding window pointers */
name|gint
name|dst_width
decl_stmt|,
name|dst_height
decl_stmt|;
comment|/* Destination width height          */
name|gint
name|dst_rowstride
decl_stmt|;
comment|/* Destination rowstride             */
name|guchar
modifier|*
name|dst_buf
init|=
name|NULL
decl_stmt|;
comment|/* Pointers to image data            */
name|gdouble
name|du
decl_stmt|,
name|dv
decl_stmt|;
comment|/* Pos in source image (double)      */
name|gint
name|u
decl_stmt|,
name|v
decl_stmt|;
comment|/* Pos in source image (integer part)*/
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Position in destination image     */
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|byte
decl_stmt|;
comment|/* loop vars to fill source window   */
name|gdouble
name|sx
decl_stmt|,
name|sy
decl_stmt|;
comment|/* Scalefactor                       */
name|gdouble
name|trans
index|[
literal|6
index|]
decl_stmt|,
name|itrans
index|[
literal|6
index|]
decl_stmt|;
comment|/* Scale transformations             */
name|gdouble
name|aval
decl_stmt|,
name|arecip
decl_stmt|;
comment|/* Handle alpha values               */
name|gdouble
name|newval
decl_stmt|;
comment|/* New interpolated RGB value        */
comment|/* Initialize variables */
name|dst_width
operator|=
name|dstPR
operator|->
name|w
expr_stmt|;
name|dst_height
operator|=
name|dstPR
operator|->
name|h
expr_stmt|;
name|bytes
operator|=
name|dstPR
operator|->
name|bytes
expr_stmt|;
name|src_width
operator|=
name|srcPR
operator|->
name|w
expr_stmt|;
name|src_height
operator|=
name|srcPR
operator|->
name|h
expr_stmt|;
comment|/* Pure scaling */
name|sx
operator|=
operator|(
name|gdouble
operator|)
name|dst_width
operator|/
operator|(
name|gdouble
operator|)
name|src_width
expr_stmt|;
name|sy
operator|=
operator|(
name|gdouble
operator|)
name|dst_height
operator|/
operator|(
name|gdouble
operator|)
name|src_height
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|trans
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
name|trans
index|[
literal|0
index|]
operator|=
name|sx
expr_stmt|;
name|trans
index|[
literal|4
index|]
operator|=
name|sy
expr_stmt|;
name|inv_lin_trans
argument_list|(
name|trans
argument_list|,
name|itrans
argument_list|)
expr_stmt|;
comment|/* Calculate kernel */
name|kernel
operator|=
name|kernel_lanczos
argument_list|()
expr_stmt|;
comment|/*      allocate buffer for width + 2 * LANCZOS_WIDTH      We need 2* LANCZOS_WIDTH lines for sliding window      buffer with edge mirror   */
name|src_rowstride
operator|=
operator|(
name|src_width
operator|+
name|LANCZOS_WIDTH2
operator|)
operator|*
name|bytes
expr_stmt|;
name|src_buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|LANCZOS_WIDTH2
operator|*
name|src_rowstride
argument_list|)
expr_stmt|;
comment|/*      fill src pointers with correct offset      offset is needed for pixel_region_get_row   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
name|src
index|[
name|i
index|]
operator|=
name|src_buf
operator|+
name|i
operator|*
name|src_rowstride
operator|+
name|LANCZOS_WIDTH
operator|*
name|bytes
expr_stmt|;
comment|/* allocate buffer for 1 destination row */
name|dst_rowstride
operator|=
name|dst_width
operator|*
name|bytes
expr_stmt|;
name|dst_buf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|dst_rowstride
argument_list|)
expr_stmt|;
comment|/* fill buffer with first lines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LANCZOS_WIDTH2
condition|;
name|i
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|ABS
argument_list|(
name|LANCZOS_WIDTH
operator|-
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|src_width
argument_list|,
name|src
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mirror_edge
argument_list|(
name|src
index|[
name|i
index|]
argument_list|,
name|src_width
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|srcrow
operator|=
literal|0
operator|,
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dst_height
condition|;
name|y
operator|++
control|)
block|{
name|pixel_region_get_row
argument_list|(
name|dstPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|dst_width
argument_list|,
name|dst_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
control|)
block|{
name|du
operator|=
name|itrans
index|[
literal|0
index|]
operator|*
operator|(
name|gdouble
operator|)
name|x
operator|+
name|itrans
index|[
literal|1
index|]
operator|*
operator|(
name|gdouble
operator|)
name|y
operator|+
name|itrans
index|[
literal|2
index|]
expr_stmt|;
name|dv
operator|=
name|itrans
index|[
literal|3
index|]
operator|*
operator|(
name|gdouble
operator|)
name|x
operator|+
name|itrans
index|[
literal|4
index|]
operator|*
operator|(
name|gdouble
operator|)
name|y
operator|+
name|itrans
index|[
literal|5
index|]
expr_stmt|;
name|u
operator|=
operator|(
name|gint
operator|)
name|du
expr_stmt|;
name|v
operator|=
operator|(
name|gint
operator|)
name|dv
expr_stmt|;
comment|/* make sure we have enough data available */
if|if
condition|(
name|srcrow
operator|!=
name|v
condition|)
block|{
if|if
condition|(
name|v
operator|>
name|srcrow
condition|)
block|{
for|for
control|(
init|;
name|srcrow
operator|<
name|v
condition|;
control|)
block|{
name|srcrow
operator|++
expr_stmt|;
name|row
operator|=
name|srcrow
operator|+
name|LANCZOS_WIDTH
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|src_height
condition|)
name|row
operator|=
name|src_height
operator|-
operator|(
name|row
operator|-
name|src_height
operator|+
literal|1
operator|)
expr_stmt|;
name|rotate_pointers
argument_list|(
name|src
argument_list|,
name|LANCZOS_WIDTH2
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|src_width
argument_list|,
name|src
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mirror_edge
argument_list|(
name|src
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
name|src_width
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
name|srcrow
operator|>
name|v
condition|;
control|)
block|{
name|rotate_pointers
argument_list|(
name|src
argument_list|,
name|LANCZOS_WIDTH2
argument_list|)
expr_stmt|;
name|pixel_region_get_row
argument_list|(
name|srcPR
argument_list|,
literal|0
argument_list|,
operator|--
name|srcrow
argument_list|,
name|src_width
argument_list|,
name|src
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mirror_edge
argument_list|(
name|src
index|[
name|LANCZOS_WIDTH2
operator|-
literal|1
index|]
argument_list|,
name|src_width
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* get weight for fractional error */
name|su
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|du
operator|-
name|u
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
name|sv
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|dv
operator|-
name|v
operator|)
operator|*
name|LANCZOS_SPP
argument_list|)
expr_stmt|;
for|for
control|(
name|lusum
operator|=
name|lvsum
operator|=
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|LANCZOS_WIDTH
operator|-
literal|1
init|;
name|j
operator|>=
operator|-
name|LANCZOS_WIDTH
condition|;
name|j
operator|--
operator|,
name|i
operator|++
control|)
block|{
name|lusum
operator|+=
name|lu
index|[
name|i
index|]
operator|=
name|kernel
index|[
name|ABS
argument_list|(
name|j
operator|*
name|LANCZOS_SPP
operator|+
name|su
argument_list|)
index|]
expr_stmt|;
name|lvsum
operator|+=
name|lv
index|[
name|i
index|]
operator|=
name|kernel
index|[
name|ABS
argument_list|(
name|j
operator|*
name|LANCZOS_SPP
operator|+
name|sv
argument_list|)
index|]
expr_stmt|;
block|}
name|weight
operator|=
operator|(
name|lusum
operator|*
name|lvsum
operator|)
expr_stmt|;
if|if
condition|(
name|pixel_region_has_alpha
argument_list|(
name|srcPR
argument_list|)
condition|)
block|{
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|aval
operator|=
literal|0
operator|,
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|LANCZOS_WIDTH2
condition|;
name|row
operator|++
control|)
name|aval
operator|+=
name|lv
index|[
name|row
index|]
operator|*
name|lanczos_sum
argument_list|(
name|src
argument_list|,
name|lu
argument_list|,
name|row
argument_list|,
name|u
argument_list|,
name|bytes
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
comment|/* calculate alpha of result */
name|aval
operator|/=
name|weight
expr_stmt|;
if|if
condition|(
name|aval
operator|<=
literal|0.0
condition|)
block|{
name|arecip
operator|=
literal|0.0
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aval
operator|>
literal|255.0
condition|)
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|arecip
operator|=
literal|1.0
operator|/
name|aval
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|alpha
index|]
operator|=
name|RINT
argument_list|(
name|aval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|alpha
condition|;
name|byte
operator|++
control|)
block|{
for|for
control|(
name|newval
operator|=
literal|0
operator|,
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|LANCZOS_WIDTH2
condition|;
name|row
operator|++
control|)
name|newval
operator|+=
name|lv
index|[
name|row
index|]
operator|*
name|lanczos_sum_mul
argument_list|(
name|src
argument_list|,
name|lu
argument_list|,
name|row
argument_list|,
name|u
argument_list|,
name|bytes
argument_list|,
name|byte
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|newval
operator|*=
name|arecip
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|byte
index|]
operator|=
name|CLAMP
argument_list|(
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|bytes
condition|;
name|byte
operator|++
control|)
block|{
for|for
control|(
name|newval
operator|=
literal|0
operator|,
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|LANCZOS_WIDTH2
condition|;
name|row
operator|++
control|)
name|newval
operator|+=
name|lv
index|[
name|row
index|]
operator|*
name|lanczos_sum
argument_list|(
name|src
argument_list|,
name|lu
argument_list|,
name|row
argument_list|,
name|u
argument_list|,
name|bytes
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|newval
operator|/=
name|weight
expr_stmt|;
name|dst_buf
index|[
name|x
operator|*
name|bytes
operator|+
name|byte
index|]
operator|=
name|CLAMP
argument_list|(
operator|(
name|gint
operator|)
name|newval
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pixel_region_set_row
argument_list|(
name|dstPR
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|dst_width
argument_list|,
name|dst_buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|src_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|kernel
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

