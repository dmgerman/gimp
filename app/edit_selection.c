begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"gdk/gdkkeysyms.h"
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"paths_dialogP.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_define
DECL|macro|EDIT_SELECT_SCROLL_LOCK
define|#
directive|define
name|EDIT_SELECT_SCROLL_LOCK
value|FALSE
end_define

begin_define
DECL|macro|ARROW_VELOCITY
define|#
directive|define
name|ARROW_VELOCITY
value|25
end_define

begin_define
DECL|macro|STATUSBAR_SIZE
define|#
directive|define
name|STATUSBAR_SIZE
value|128
end_define

begin_typedef
DECL|typedef|EditSelection
typedef|typedef
name|struct
name|_EditSelection
name|EditSelection
typedef|;
end_typedef

begin_struct
DECL|struct|_EditSelection
struct|struct
name|_EditSelection
block|{
DECL|member|origx
DECL|member|origy
name|int
name|origx
decl_stmt|,
name|origy
decl_stmt|;
comment|/*  last x and y coords             */
DECL|member|cumlx
DECL|member|cumly
name|int
name|cumlx
decl_stmt|,
name|cumly
decl_stmt|;
comment|/*  cumulative changes to x and yed */
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  current x and y coords          */
DECL|member|x1
DECL|member|y1
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
comment|/*  bounding box of selection mask  */
DECL|member|x2
DECL|member|y2
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
DECL|member|edit_type
name|EditType
name|edit_type
decl_stmt|;
comment|/*  translate the mask or layer?    */
DECL|member|core
name|DrawCore
modifier|*
name|core
decl_stmt|;
comment|/* selection core for drawing bounds*/
DECL|member|old_button_release
name|ButtonReleaseFunc
name|old_button_release
decl_stmt|;
comment|/*  old button press member func    */
DECL|member|old_motion
name|MotionFunc
name|old_motion
decl_stmt|;
comment|/*  old motion member function      */
DECL|member|old_control
name|ToolCtlFunc
name|old_control
decl_stmt|;
comment|/*  old control member function     */
DECL|member|old_cursor_update
name|CursorUpdateFunc
name|old_cursor_update
decl_stmt|;
comment|/*  old cursor update function      */
DECL|member|old_scroll_lock
name|gboolean
name|old_scroll_lock
decl_stmt|;
comment|/*  old value of scroll lock        */
DECL|member|old_auto_snap_to
name|gboolean
name|old_auto_snap_to
decl_stmt|;
comment|/*  old value of auto snap to       */
DECL|member|first_move
name|gboolean
name|first_move
decl_stmt|;
comment|/*  we undo_freeze after the first  */
DECL|member|context_id
name|guint
name|context_id
decl_stmt|;
comment|/*  for the statusbar               */
block|}
struct|;
end_struct

begin_comment
comment|/*  static EditSelection structure--there is ever only one present  */
end_comment

begin_decl_stmt
DECL|variable|edit_select
specifier|static
name|EditSelection
name|edit_select
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|edit_selection_snap (GDisplay * gdisp,int x,int y)
name|edit_selection_snap
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dx
operator|=
name|x
operator|-
name|edit_select
operator|.
name|origx
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|edit_select
operator|.
name|origy
expr_stmt|;
name|x1
operator|=
name|edit_select
operator|.
name|x1
operator|+
name|dx
expr_stmt|;
name|y1
operator|=
name|edit_select
operator|.
name|y1
operator|+
name|dy
expr_stmt|;
name|x2
operator|=
name|edit_select
operator|.
name|x2
operator|+
name|dx
expr_stmt|;
name|y2
operator|=
name|edit_select
operator|.
name|y2
operator|+
name|dy
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdisplay_snap_rectangle
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|x
operator|=
name|x1
operator|-
operator|(
name|edit_select
operator|.
name|x1
operator|-
name|edit_select
operator|.
name|origx
operator|)
expr_stmt|;
name|edit_select
operator|.
name|y
operator|=
name|y1
operator|-
operator|(
name|edit_select
operator|.
name|y1
operator|-
name|edit_select
operator|.
name|origy
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_edit_selection (Tool * tool,gpointer gdisp_ptr,GdkEventButton * bevent,EditType edit_type)
name|init_edit_selection
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|EditType
name|edit_type
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|LAYER_DISPLACE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Move the (x, y) point from screen to image space  */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|x
operator|=
name|edit_select
operator|.
name|origx
operator|=
name|x
expr_stmt|;
name|edit_select
operator|.
name|y
operator|=
name|edit_select
operator|.
name|origy
operator|=
name|y
expr_stmt|;
name|edit_select
operator|.
name|cumlx
operator|=
literal|0
expr_stmt|;
name|edit_select
operator|.
name|cumly
operator|=
literal|0
expr_stmt|;
comment|/*  Make a check to see if it should be a floating selection translation  */
if|if
condition|(
name|edit_type
operator|==
name|MaskToLayerTranslate
operator|&&
name|gimage_floating_sel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
condition|)
name|edit_type
operator|=
name|FloatingSelTranslate
expr_stmt|;
if|if
condition|(
name|edit_type
operator|==
name|LayerTranslate
condition|)
block|{
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|edit_type
operator|=
name|FloatingSelTranslate
expr_stmt|;
block|}
name|edit_select
operator|.
name|edit_type
operator|=
name|edit_type
expr_stmt|;
name|edit_select
operator|.
name|old_button_release
operator|=
name|tool
operator|->
name|button_release_func
expr_stmt|;
name|edit_select
operator|.
name|old_motion
operator|=
name|tool
operator|->
name|motion_func
expr_stmt|;
name|edit_select
operator|.
name|old_control
operator|=
name|tool
operator|->
name|control_func
expr_stmt|;
name|edit_select
operator|.
name|old_cursor_update
operator|=
name|tool
operator|->
name|cursor_update_func
expr_stmt|;
name|edit_select
operator|.
name|old_scroll_lock
operator|=
name|tool
operator|->
name|scroll_lock
expr_stmt|;
name|edit_select
operator|.
name|old_auto_snap_to
operator|=
name|tool
operator|->
name|auto_snap_to
expr_stmt|;
name|edit_select
operator|.
name|first_move
operator|=
name|TRUE
expr_stmt|;
comment|/*  find the bounding box of the selection mask -    *  this is used for the case of a MaskToLayerTranslate,    *  where the translation will result in floating the selection    *  mask and translating the resulting layer    */
name|drawable_mask_bounds
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|&
name|edit_select
operator|.
name|x1
argument_list|,
operator|&
name|edit_select
operator|.
name|y1
argument_list|,
operator|&
name|edit_select
operator|.
name|x2
argument_list|,
operator|&
name|edit_select
operator|.
name|y2
argument_list|)
expr_stmt|;
name|edit_selection_snap
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/*  reset the function pointers on the selection tool  */
name|tool
operator|->
name|button_release_func
operator|=
name|edit_selection_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|edit_selection_motion
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|edit_selection_control
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|edit_selection_cursor_update
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
name|EDIT_SELECT_SCROLL_LOCK
expr_stmt|;
name|tool
operator|->
name|auto_snap_to
operator|=
name|FALSE
expr_stmt|;
comment|/*  pause the current selection  */
name|selection_pause
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
comment|/* initialize the statusbar display */
name|edit_select
operator|.
name|context_id
operator|=
name|gtk_statusbar_get_context_id
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
literal|"edit_select"
argument_list|)
expr_stmt|;
name|gtk_statusbar_push
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|edit_select
operator|.
name|context_id
argument_list|,
name|_
argument_list|(
literal|"Move: 0, 0"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Create and start the selection core  */
name|edit_select
operator|.
name|core
operator|=
name|draw_core_new
argument_list|(
name|edit_selection_draw
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|edit_selection_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|edit_selection_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
comment|/* don't remove these unused vars yet --adam */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
comment|/*  resume the current selection and ungrab the pointer  */
name|selection_resume
argument_list|(
name|gdisp
operator|->
name|select
argument_list|)
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
name|gtk_statusbar_pop
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|edit_select
operator|.
name|context_id
argument_list|)
expr_stmt|;
comment|/*  Stop and free the selection core  */
name|draw_core_stop
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|edit_select
operator|.
name|core
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|core
operator|=
name|NULL
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|edit_select
operator|.
name|old_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|edit_select
operator|.
name|old_motion
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|edit_select
operator|.
name|old_control
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|edit_select
operator|.
name|old_cursor_update
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
name|edit_select
operator|.
name|old_scroll_lock
expr_stmt|;
name|tool
operator|->
name|auto_snap_to
operator|=
name|edit_select
operator|.
name|old_auto_snap_to
expr_stmt|;
comment|/* MaskTranslate is performed here at movement end, not 'live' like    *  the other translation types.    */
if|if
condition|(
name|edit_select
operator|.
name|edit_type
operator|==
name|MaskTranslate
condition|)
block|{
name|edit_selection_snap
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|edit_select
operator|.
name|x
expr_stmt|;
name|y
operator|=
name|edit_select
operator|.
name|y
expr_stmt|;
comment|/* move the selection -- whether there has been net movement or not!      * (to ensure that there's something on the undo stack)      */
name|gimage_mask_translate
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|edit_select
operator|.
name|cumlx
argument_list|,
name|edit_select
operator|.
name|cumly
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|first_move
condition|)
block|{
name|gimp_image_undo_freeze
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|first_move
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/********************************************************************a.d.m.**/
comment|/****************************************************************************/
comment|/*  This work is all done in the motion handler now - will be removed soon  */
comment|/****************************************************************************/
comment|/*************************************************& this time I mean it. ***/
comment|/*  If the cancel button is down...Do nothing  */
block|if (! (bevent->state& GDK_BUTTON3_MASK))     {       edit_selection_snap (gdisp, bevent->x, bevent->y);       x = edit_select.x;       y = edit_select.y;
comment|/* if there has been movement, move the selection  */
block|if (edit_select.origx != x || edit_select.origy != y) 	{ 	  switch (edit_select.edit_type) 	    { 	    case MaskTranslate:
comment|/*  translate the selection  */
block|gimage_mask_translate (gdisp->gimage, (x - edit_select.origx), 				     (y - edit_select.origy)); 	      break;  	    case MaskToLayerTranslate: 	      gimage_mask_float (gdisp->gimage, gimage_active_drawable (gdisp->gimage), 				 (x - edit_select.origx), 				 (y - edit_select.origy)); 	      break;  	    case LayerTranslate: 	      if ((floating_layer = gimage_floating_sel (gdisp->gimage))) 		floating_sel_relax (floating_layer, TRUE);
comment|/*  translate the layer--and any "linked" layers as well  */
block|layer_list = gdisp->gimage->layers; 	      while (layer_list) 		{ 		  layer = (Layer *) layer_list->data; 		  if (layer == gdisp->gimage->active_layer ||  		      layer_linked (layer)) 		    { 		      layer_translate (layer, (x - edit_select.origx), (y - edit_select.origy)); 		    } 		  layer_list = g_slist_next (layer_list); 		}  	      if (floating_layer) 		floating_sel_rigor (floating_layer, TRUE);  	      break;  	    case FloatingSelTranslate: 	      layer = gimage_get_active_layer (gdisp->gimage);  	      floating_sel_relax (layer, TRUE); 	      layer_translate (layer, (x - edit_select.origx), (y - edit_select.origy)); 	      floating_sel_rigor (layer, TRUE);  	      break; 	    }  	}
comment|/*  if no movement has occured, clear the current selection  */
block|else if ((edit_select.edit_type == MaskTranslate) || 	       (edit_select.edit_type == MaskToLayerTranslate)) 	gimage_mask_clear (gdisp->gimage);
comment|/*  if no movement occured and the type is LayerTranslate,        *  check if the layer is a floating selection.  If so, anchor.        */
block|else if (edit_select.edit_type == FloatingSelTranslate) 	{ 	  layer = gimage_get_active_layer (gdisp->gimage); 	  if (layer_is_floating_sel (layer)) 	    floating_sel_anchor (layer); 	}     }    undo_push_group_end (gdisp->gimage);
else|#
directive|else
comment|/* thaw the undo again */
name|gimp_image_undo_thaw
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|cumlx
operator|==
literal|0
operator|&&
name|edit_select
operator|.
name|cumly
operator|==
literal|0
condition|)
block|{
comment|/* The user either didn't actually move the selection, 	 or moved it around and eventually just put it back in 	 exactly the same spot. */
if|if
condition|(
operator|(
name|edit_select
operator|.
name|edit_type
operator|==
name|MaskTranslate
operator|)
operator|||
operator|(
name|edit_select
operator|.
name|edit_type
operator|==
name|MaskToLayerTranslate
operator|)
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
comment|/*  if no movement occured and the type is LayerTranslate, 	  check if the layer is a floating selection.  If so, anchor. */
elseif|else
if|if
condition|(
name|edit_select
operator|.
name|edit_type
operator|==
name|FloatingSelTranslate
condition|)
block|{
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|floating_sel_anchor
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|paths_transform_xy
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|edit_select
operator|.
name|cumlx
argument_list|,
name|edit_select
operator|.
name|cumly
argument_list|)
expr_stmt|;
block|}
name|undo_push_group_end
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_BUTTON3_MASK
condition|)
comment|/* OPERATION CANCELLED */
block|{
comment|/* Operation cancelled - undo the undo-group! */
name|undo_pop
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|edit_selection_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|edit_selection_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gchar
name|offset
index|[
name|STATUSBAR_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
block|{
name|g_warning
argument_list|(
literal|"Tracking motion while !ACTIVE"
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
name|draw_core_pause
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|edit_selection_snap
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/**********************************************adam hack*************/
comment|/********************************************************************/
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|edit_selection_snap
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|edit_select
operator|.
name|x
expr_stmt|;
name|y
operator|=
name|edit_select
operator|.
name|y
expr_stmt|;
comment|/* if there has been movement, move the selection  */
if|if
condition|(
name|edit_select
operator|.
name|origx
operator|!=
name|x
operator|||
name|edit_select
operator|.
name|origy
operator|!=
name|y
condition|)
block|{
name|gint
name|xoffset
decl_stmt|,
name|yoffset
decl_stmt|;
name|xoffset
operator|=
name|x
operator|-
name|edit_select
operator|.
name|origx
expr_stmt|;
name|yoffset
operator|=
name|y
operator|-
name|edit_select
operator|.
name|origy
expr_stmt|;
name|edit_select
operator|.
name|cumlx
operator|+=
name|xoffset
expr_stmt|;
name|edit_select
operator|.
name|cumly
operator|+=
name|yoffset
expr_stmt|;
switch|switch
condition|(
name|edit_select
operator|.
name|edit_type
condition|)
block|{
case|case
name|MaskTranslate
case|:
comment|/*  translate the selection  */
comment|/*	    gimage_mask_translate (gdisp->gimage, xoffset, yoffset); 	    g_warning("%d,%d  %d,%d  %d,%d  %d,%d  %d,%d  %d,%d", 		      edit_select.origx,edit_select.origy, 		      edit_select.cumlx,edit_select.cumly, 		      xoffset,yoffset, 		      x,y, 		      edit_select.x1,edit_select.y1, 		      edit_select.x2,edit_select.y2);*/
comment|/* 	    if (edit_select.first_move) 	      { 		gimp_image_undo_freeze (gdisp->gimage); 		edit_select.first_move = FALSE; 	      } 	    */
name|edit_select
operator|.
name|origx
operator|=
name|x
expr_stmt|;
name|edit_select
operator|.
name|origy
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|LayerTranslate
case|:
if|if
condition|(
operator|(
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  translate the layer--and any "linked" layers as well  */
name|layer_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
operator|||
name|layer_linked
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|)
expr_stmt|;
block|}
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|first_move
condition|)
block|{
name|gimp_image_undo_freeze
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|first_move
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|MaskToLayerTranslate
case|:
name|gimage_mask_float
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|first_move
condition|)
block|{
name|gimp_image_undo_freeze
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|first_move
operator|=
name|FALSE
expr_stmt|;
block|}
name|edit_select
operator|.
name|edit_type
operator|=
name|FloatingSelTranslate
expr_stmt|;
name|edit_select
operator|.
name|origx
operator|-=
name|edit_select
operator|.
name|x1
expr_stmt|;
name|edit_select
operator|.
name|origy
operator|-=
name|edit_select
operator|.
name|y1
expr_stmt|;
break|break;
case|case
name|FloatingSelTranslate
case|:
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|floating_sel_relax
argument_list|(
name|layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|)
expr_stmt|;
name|floating_sel_rigor
argument_list|(
name|layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|first_move
condition|)
block|{
name|gimp_image_undo_freeze
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|edit_select
operator|.
name|first_move
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|g_warning
argument_list|(
literal|"esm / BAD FALLTHROUGH"
argument_list|)
expr_stmt|;
block|}
block|}
name|gdisplay_flush
argument_list|(
name|gdisp
argument_list|)
expr_stmt|;
block|}
comment|/********************************************************************/
comment|/********************************************************************/
name|gtk_statusbar_pop
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|edit_select
operator|.
name|context_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
operator|->
name|dot_for_dot
condition|)
block|{
name|g_snprintf
argument_list|(
name|offset
argument_list|,
name|STATUSBAR_SIZE
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
name|_
argument_list|(
literal|"Move: "
argument_list|)
argument_list|,
name|edit_select
operator|.
name|cumlx
argument_list|,
literal|", "
argument_list|,
name|edit_select
operator|.
name|cumly
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* show real world units */
block|{
name|gdouble
name|unit_factor
init|=
name|gimp_unit_get_factor
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|unit
argument_list|)
decl_stmt|;
name|g_snprintf
argument_list|(
name|offset
argument_list|,
name|STATUSBAR_SIZE
argument_list|,
name|gdisp
operator|->
name|cursor_format_str
argument_list|,
name|_
argument_list|(
literal|"Move: "
argument_list|)
argument_list|,
operator|(
name|edit_select
operator|.
name|cumlx
operator|)
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|xresolution
argument_list|,
literal|", "
argument_list|,
operator|(
name|edit_select
operator|.
name|cumly
operator|)
operator|*
name|unit_factor
operator|/
name|gdisp
operator|->
name|gimage
operator|->
name|yresolution
argument_list|)
expr_stmt|;
block|}
name|gtk_statusbar_push
argument_list|(
name|GTK_STATUSBAR
argument_list|(
name|gdisp
operator|->
name|statusbar
argument_list|)
argument_list|,
name|edit_select
operator|.
name|context_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|edit_selection_draw (Tool * tool)
name|edit_selection_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|diff_x
decl_stmt|,
name|diff_y
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GdkSegment
modifier|*
name|seg
decl_stmt|;
name|Selection
modifier|*
name|select
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|int
name|floating_sel
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|select
operator|=
name|gdisp
operator|->
name|select
expr_stmt|;
if|if
condition|(
name|edit_select
operator|.
name|edit_type
operator|==
name|FloatingSelTranslate
operator|||
name|edit_select
operator|.
name|edit_type
operator|==
name|MaskTranslate
condition|)
block|{
name|diff_x
operator|=
name|SCALEX
argument_list|(
name|gdisp
argument_list|,
name|edit_select
operator|.
name|cumlx
argument_list|)
expr_stmt|;
name|diff_y
operator|=
name|SCALEY
argument_list|(
name|gdisp
argument_list|,
name|edit_select
operator|.
name|cumly
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diff_x
operator|=
literal|0
expr_stmt|;
name|diff_y
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|edit_select
operator|.
name|edit_type
condition|)
block|{
case|case
name|MaskTranslate
case|:
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|floating_sel
operator|=
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  offset the current selection  */
name|seg
operator|=
name|select
operator|->
name|segs_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_in
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|seg
operator|=
name|select
operator|->
name|segs_out
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_out
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|floating_sel
condition|)
name|gdk_draw_segments
argument_list|(
name|edit_select
operator|.
name|core
operator|->
name|win
argument_list|,
name|edit_select
operator|.
name|core
operator|->
name|gc
argument_list|,
name|select
operator|->
name|segs_in
argument_list|,
name|select
operator|->
name|num_segs_in
argument_list|)
expr_stmt|;
name|gdk_draw_segments
argument_list|(
name|edit_select
operator|.
name|core
operator|->
name|win
argument_list|,
name|edit_select
operator|.
name|core
operator|->
name|gc
argument_list|,
name|select
operator|->
name|segs_out
argument_list|,
name|select
operator|->
name|num_segs_out
argument_list|)
expr_stmt|;
comment|/*  reset the current selection  */
name|seg
operator|=
name|select
operator|->
name|segs_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_in
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|seg
operator|=
name|select
operator|->
name|segs_out
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_out
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|MaskToLayerTranslate
case|:
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|edit_select
operator|.
name|x1
argument_list|,
name|edit_select
operator|.
name|y1
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|edit_select
operator|.
name|x2
argument_list|,
name|edit_select
operator|.
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdk_draw_rectangle
argument_list|(
name|edit_select
operator|.
name|core
operator|->
name|win
argument_list|,
name|edit_select
operator|.
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|x1
operator|+
name|diff_x
argument_list|,
name|y1
operator|+
name|diff_y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LayerTranslate
case|:
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
argument_list|)
argument_list|)
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Now, expand the rectangle to include all linked layers as well  */
name|layer_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|layer
operator|)
operator|!=
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
operator|)
operator|&&
name|layer_linked
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
operator|&
name|x3
argument_list|,
operator|&
name|y3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|&
name|x4
argument_list|,
operator|&
name|y4
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x3
operator|<
name|x1
condition|)
name|x1
operator|=
name|x3
expr_stmt|;
if|if
condition|(
name|y3
operator|<
name|y1
condition|)
name|y1
operator|=
name|y3
expr_stmt|;
if|if
condition|(
name|x4
operator|>
name|x2
condition|)
name|x2
operator|=
name|x4
expr_stmt|;
if|if
condition|(
name|y4
operator|>
name|y2
condition|)
name|y2
operator|=
name|y4
expr_stmt|;
block|}
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|gdk_draw_rectangle
argument_list|(
name|edit_select
operator|.
name|core
operator|->
name|win
argument_list|,
name|edit_select
operator|.
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|x1
operator|+
name|diff_x
argument_list|,
name|y1
operator|+
name|diff_y
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FloatingSelTranslate
case|:
name|seg
operator|=
name|select
operator|->
name|segs_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_in
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|+=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|+=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
comment|/*  Draw the items  */
name|gdk_draw_segments
argument_list|(
name|edit_select
operator|.
name|core
operator|->
name|win
argument_list|,
name|edit_select
operator|.
name|core
operator|->
name|gc
argument_list|,
name|select
operator|->
name|segs_in
argument_list|,
name|select
operator|->
name|num_segs_in
argument_list|)
expr_stmt|;
comment|/*  reset the the current selection  */
name|seg
operator|=
name|select
operator|->
name|segs_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|select
operator|->
name|num_segs_in
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|->
name|x1
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|x2
operator|-=
name|diff_x
expr_stmt|;
name|seg
operator|->
name|y1
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|->
name|y2
operator|-=
name|diff_y
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|edit_selection_control (Tool * tool,ToolAction action,gpointer gdisp_ptr)
name|edit_selection_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|ToolAction
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|edit_select
operator|.
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|edit_select
operator|.
name|core
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|edit_selection_cursor_update (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|edit_selection_cursor_update
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GDK_FLEUR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|process_event_queue_keys (GdkEventKey * kevent,...)
name|process_event_queue_keys
parameter_list|(
name|GdkEventKey
modifier|*
name|kevent
parameter_list|,
modifier|...
parameter_list|)
comment|/* GdkKeyType, GdkModifierType, value ... 0   * could move this function to a more central location so it can be used  * by other tools? */
block|{
DECL|macro|FILTER_MAX_KEYS
define|#
directive|define
name|FILTER_MAX_KEYS
value|50
name|va_list
name|argp
decl_stmt|;
name|GdkEvent
modifier|*
name|event
decl_stmt|;
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|guint
name|keys
index|[
name|FILTER_MAX_KEYS
index|]
decl_stmt|;
name|GdkModifierType
name|modifiers
index|[
name|FILTER_MAX_KEYS
index|]
decl_stmt|;
name|int
name|values
index|[
name|FILTER_MAX_KEYS
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|nkeys
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|discard_event
decl_stmt|;
name|GtkWidget
modifier|*
name|orig_widget
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|kevent
argument_list|)
expr_stmt|;
while|while
condition|(
name|nkeys
operator|<
name|FILTER_MAX_KEYS
operator|&&
operator|(
name|keys
index|[
name|nkeys
index|]
operator|=
name|va_arg
argument_list|(
name|argp
argument_list|,
name|guint
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|modifiers
index|[
name|nkeys
index|]
operator|=
name|va_arg
argument_list|(
name|argp
argument_list|,
name|GdkModifierType
argument_list|)
expr_stmt|;
name|values
index|[
name|nkeys
index|]
operator|=
name|va_arg
argument_list|(
name|argp
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|nkeys
operator|++
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|kevent
operator|->
name|keyval
operator|==
name|keys
index|[
name|i
index|]
operator|&&
name|kevent
operator|->
name|state
operator|==
name|modifiers
index|[
name|i
index|]
condition|)
name|value
operator|+=
name|values
index|[
name|i
index|]
expr_stmt|;
name|orig_widget
operator|=
name|gtk_get_event_widget
argument_list|(
operator|(
name|GdkEvent
operator|*
operator|)
name|kevent
argument_list|)
expr_stmt|;
while|while
condition|(
name|gdk_events_pending
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|done
condition|)
block|{
name|discard_event
operator|=
literal|0
expr_stmt|;
name|event
operator|=
name|gdk_event_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig_widget
operator|!=
name|gtk_get_event_widget
argument_list|(
name|event
argument_list|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|event
operator|->
name|any
operator|.
name|type
operator|==
name|GDK_KEY_PRESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|event
operator|->
name|key
operator|.
name|keyval
operator|==
name|keys
index|[
name|i
index|]
operator|&&
name|event
operator|->
name|key
operator|.
name|state
operator|==
name|modifiers
index|[
name|i
index|]
condition|)
block|{
name|discard_event
operator|=
literal|1
expr_stmt|;
name|value
operator|+=
name|values
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|discard_event
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* should there be more types here? */
elseif|else
if|if
condition|(
name|event
operator|->
name|any
operator|.
name|type
operator|!=
name|GDK_KEY_RELEASE
operator|&&
name|event
operator|->
name|any
operator|.
name|type
operator|!=
name|GDK_MOTION_NOTIFY
operator|&&
name|event
operator|->
name|any
operator|.
name|type
operator|!=
name|GDK_EXPOSE
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|discard_event
condition|)
name|list
operator|=
name|g_list_prepend
argument_list|(
name|list
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|gdk_event_free
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list
condition|)
comment|/* unget the unused events and free the list */
block|{
name|gdk_event_put
argument_list|(
operator|(
name|GdkEvent
operator|*
operator|)
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|gdk_event_free
argument_list|(
operator|(
name|GdkEvent
operator|*
operator|)
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_list_remove_link
argument_list|(
name|list
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
undef|#
directive|undef
name|FILTER_MAX_KEYS
block|}
end_function

begin_function
name|void
DECL|function|edit_sel_arrow_keys_func (Tool * tool,GdkEventKey * kevent,gpointer gdisp_ptr)
name|edit_sel_arrow_keys_func
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventKey
modifier|*
name|kevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|int
name|inc_x
decl_stmt|,
name|inc_y
decl_stmt|,
name|mask_inc_x
decl_stmt|,
name|mask_inc_y
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|EditType
name|edit_type
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|inc_x
operator|=
name|process_event_queue_keys
argument_list|(
name|kevent
argument_list|,
name|GDK_Left
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|GDK_Left
argument_list|,
name|GDK_SHIFT_MASK
argument_list|,
operator|-
literal|1
operator|*
name|ARROW_VELOCITY
argument_list|,
name|GDK_Right
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GDK_Right
argument_list|,
name|GDK_SHIFT_MASK
argument_list|,
name|ARROW_VELOCITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inc_y
operator|=
name|process_event_queue_keys
argument_list|(
name|kevent
argument_list|,
name|GDK_Up
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|GDK_Up
argument_list|,
name|GDK_SHIFT_MASK
argument_list|,
operator|-
literal|1
operator|*
name|ARROW_VELOCITY
argument_list|,
name|GDK_Down
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GDK_Down
argument_list|,
name|GDK_SHIFT_MASK
argument_list|,
name|ARROW_VELOCITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask_inc_x
operator|=
name|process_event_queue_keys
argument_list|(
name|kevent
argument_list|,
name|GDK_Left
argument_list|,
name|GDK_MOD1_MASK
argument_list|,
operator|-
literal|1
argument_list|,
name|GDK_Left
argument_list|,
operator|(
name|GDK_MOD1_MASK
operator||
name|GDK_SHIFT_MASK
operator|)
argument_list|,
operator|-
literal|1
operator|*
name|ARROW_VELOCITY
argument_list|,
name|GDK_Right
argument_list|,
name|GDK_MOD1_MASK
argument_list|,
literal|1
argument_list|,
name|GDK_Right
argument_list|,
operator|(
name|GDK_MOD1_MASK
operator||
name|GDK_SHIFT_MASK
operator|)
argument_list|,
name|ARROW_VELOCITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask_inc_y
operator|=
name|process_event_queue_keys
argument_list|(
name|kevent
argument_list|,
name|GDK_Up
argument_list|,
name|GDK_MOD1_MASK
argument_list|,
operator|-
literal|1
argument_list|,
name|GDK_Up
argument_list|,
operator|(
name|GDK_MOD1_MASK
operator||
name|GDK_SHIFT_MASK
operator|)
argument_list|,
operator|-
literal|1
operator|*
name|ARROW_VELOCITY
argument_list|,
name|GDK_Down
argument_list|,
name|GDK_MOD1_MASK
argument_list|,
literal|1
argument_list|,
name|GDK_Down
argument_list|,
operator|(
name|GDK_MOD1_MASK
operator||
name|GDK_SHIFT_MASK
operator|)
argument_list|,
name|ARROW_VELOCITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_x
operator|==
literal|0
operator|&&
name|inc_y
operator|==
literal|0
operator|&&
name|mask_inc_x
operator|==
literal|0
operator|&&
name|mask_inc_y
operator|==
literal|0
condition|)
return|return;
name|undo_push_group_start
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|LAYER_DISPLACE_UNDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask_inc_x
operator|!=
literal|0
operator|||
name|mask_inc_y
operator|!=
literal|0
condition|)
name|gimage_mask_translate
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|mask_inc_x
argument_list|,
name|mask_inc_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_x
operator|!=
literal|0
operator|||
name|inc_y
operator|!=
literal|0
condition|)
block|{
name|layer
operator|=
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
condition|)
name|edit_type
operator|=
name|FloatingSelTranslate
expr_stmt|;
else|else
name|edit_type
operator|=
name|LayerTranslate
expr_stmt|;
switch|switch
condition|(
name|edit_type
condition|)
block|{
case|case
name|MaskToLayerTranslate
case|:
name|gimage_mask_float
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|inc_x
argument_list|,
name|inc_y
argument_list|)
expr_stmt|;
break|break;
case|case
name|LayerTranslate
case|:
if|if
condition|(
operator|(
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  translate the layer--and any "linked" layers as well  */
name|layer_list
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|layer
operator|)
operator|==
name|gdisp
operator|->
name|gimage
operator|->
name|active_layer
operator|)
operator|||
name|layer_linked
argument_list|(
name|layer
argument_list|)
condition|)
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|inc_x
argument_list|,
name|inc_y
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FloatingSelTranslate
case|:
name|floating_sel_relax
argument_list|(
name|layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|inc_x
argument_list|,
name|inc_y
argument_list|)
expr_stmt|;
name|floating_sel_rigor
argument_list|(
name|layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*  this won't occur  */
break|break;
block|}
block|}
name|undo_push_group_end
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

