begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"plug_in.h"
end_include

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_comment
comment|/* #include "tile_swap.h"*/
end_comment

begin_include
include|#
directive|include
file|"xcf.h"
end_include

begin_include
include|#
directive|include
file|"frac.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_include
include|#
directive|include
file|"drawable_pvt.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_include
include|#
directive|include
file|"channel_pvt.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager_pvt.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_comment
comment|/* ick. */
end_comment

begin_include
include|#
directive|include
file|<libgimp/parasiteP.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/parasite.h>
end_include

begin_include
include|#
directive|include
file|"parasitelist.h"
end_include

begin_comment
comment|/* #define SWAP_FROM_FILE */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27fe413a0103
block|{
DECL|enumerator|PROP_END
name|PROP_END
init|=
literal|0
block|,
DECL|enumerator|PROP_COLORMAP
name|PROP_COLORMAP
init|=
literal|1
block|,
DECL|enumerator|PROP_ACTIVE_LAYER
name|PROP_ACTIVE_LAYER
init|=
literal|2
block|,
DECL|enumerator|PROP_ACTIVE_CHANNEL
name|PROP_ACTIVE_CHANNEL
init|=
literal|3
block|,
DECL|enumerator|PROP_SELECTION
name|PROP_SELECTION
init|=
literal|4
block|,
DECL|enumerator|PROP_FLOATING_SELECTION
name|PROP_FLOATING_SELECTION
init|=
literal|5
block|,
DECL|enumerator|PROP_OPACITY
name|PROP_OPACITY
init|=
literal|6
block|,
DECL|enumerator|PROP_MODE
name|PROP_MODE
init|=
literal|7
block|,
DECL|enumerator|PROP_VISIBLE
name|PROP_VISIBLE
init|=
literal|8
block|,
DECL|enumerator|PROP_LINKED
name|PROP_LINKED
init|=
literal|9
block|,
DECL|enumerator|PROP_PRESERVE_TRANSPARENCY
name|PROP_PRESERVE_TRANSPARENCY
init|=
literal|10
block|,
DECL|enumerator|PROP_APPLY_MASK
name|PROP_APPLY_MASK
init|=
literal|11
block|,
DECL|enumerator|PROP_EDIT_MASK
name|PROP_EDIT_MASK
init|=
literal|12
block|,
DECL|enumerator|PROP_SHOW_MASK
name|PROP_SHOW_MASK
init|=
literal|13
block|,
DECL|enumerator|PROP_SHOW_MASKED
name|PROP_SHOW_MASKED
init|=
literal|14
block|,
DECL|enumerator|PROP_OFFSETS
name|PROP_OFFSETS
init|=
literal|15
block|,
DECL|enumerator|PROP_COLOR
name|PROP_COLOR
init|=
literal|16
block|,
DECL|enumerator|PROP_COMPRESSION
name|PROP_COMPRESSION
init|=
literal|17
block|,
DECL|enumerator|PROP_GUIDES
name|PROP_GUIDES
init|=
literal|18
block|,
DECL|enumerator|PROP_RESOLUTION
name|PROP_RESOLUTION
init|=
literal|19
block|,
DECL|enumerator|PROP_TATTOO
name|PROP_TATTOO
init|=
literal|20
block|,
DECL|enumerator|PROP_PARASITES
name|PROP_PARASITES
init|=
literal|21
DECL|typedef|PropType
block|}
name|PropType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27fe413a0203
block|{
DECL|enumerator|COMPRESS_NONE
name|COMPRESS_NONE
init|=
literal|0
block|,
DECL|enumerator|COMPRESS_RLE
name|COMPRESS_RLE
init|=
literal|1
block|,
DECL|enumerator|COMPRESS_ZLIB
name|COMPRESS_ZLIB
init|=
literal|2
block|,
DECL|enumerator|COMPRESS_FRACTAL
name|COMPRESS_FRACTAL
init|=
literal|3
DECL|typedef|CompressionType
block|}
name|CompressionType
typedef|;
end_typedef

begin_typedef
DECL|typedef|info
typedef|typedef
name|GImage
modifier|*
name|XcfLoader
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|Argument
modifier|*
name|xcf_load_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|xcf_save_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_save_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_choose_format
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GImage
modifier|*
name|xcf_load_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Layer
modifier|*
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Channel
modifier|*
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LayerMask
modifier|*
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
end_ifdef

begin_function_decl
specifier|static
name|int
name|xcf_swap_func
parameter_list|(
name|int
name|fd
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|int
name|cmd
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|xcf_seek_pos
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|guint
name|pos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_seek_end
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|xcf_load_args
specifier|static
name|ProcArg
name|xcf_load_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"dummy_param"
block|,
literal|"dummy parameter"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_load_return_vals
specifier|static
name|ProcArg
name|xcf_load_return_vals
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_plug_in_load_proc
specifier|static
name|PlugInProcDef
name|xcf_plug_in_load_proc
init|=
block|{
literal|"gimp_xcf_load"
block|,
literal|"<Load>/XCF"
block|,
name|NULL
block|,
literal|"xcf"
block|,
literal|""
block|,
literal|"0,string,gimp\\040xcf\\040"
block|,
name|NULL
block|,
comment|/* ignored for load */
literal|0
block|,
comment|/* ignored for load */
block|{
literal|"gimp_xcf_load"
block|,
literal|"loads file saved in the .xcf file format"
block|,
literal|"The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will load the specified file."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|xcf_load_args
block|,
literal|1
block|,
name|xcf_load_return_vals
block|,
block|{
block|{
name|xcf_load_invoker
block|}
block|}
block|,   }
block|,
name|NULL
block|,
comment|/* fill me in at runtime */
name|NULL
comment|/* fill me in at runtime */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_save_args
specifier|static
name|ProcArg
name|xcf_save_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"dummy_param"
block|,
literal|"dummy parameter"
block|}
block|,
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Active drawable of input image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_plug_in_save_proc
specifier|static
name|PlugInProcDef
name|xcf_plug_in_save_proc
init|=
block|{
literal|"gimp_xcf_save"
block|,
literal|"<Save>/XCF"
block|,
name|NULL
block|,
literal|"xcf"
block|,
literal|""
block|,
name|NULL
block|,
literal|"RGB*, GRAY*, INDEXED*"
block|,
literal|0
block|,
comment|/* fill me in at runtime */
block|{
literal|"gimp_xcf_save"
block|,
literal|"saves file in the .xcf file format"
block|,
literal|"The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will save the specified image in the xcf file format."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|xcf_save_args
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|xcf_save_invoker
block|}
block|}
block|,   }
block|,
name|NULL
block|,
comment|/* fill me in at runtime */
name|NULL
comment|/* fill me in at runtime */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_loaders
specifier|static
name|XcfLoader
modifier|*
name|xcf_loaders
index|[]
init|=
block|{
name|xcf_load_image
block|,
comment|/* version 0 */
name|xcf_load_image
comment|/* version 1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|N_xcf_loaders
specifier|static
name|int
name|N_xcf_loaders
init|=
operator|(
sizeof|sizeof
argument_list|(
name|xcf_loaders
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcf_loaders
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|xcf_init ()
name|xcf_init
parameter_list|()
block|{
comment|/* So this is sort of a hack, but its better than it was before.  To do this    * right there would be a file load-save handler type and the whole interface    * would change but there isn't, and currently the plug-in structure contains    * all the load-save info, so it makes sense to use that for the XCF load/save    * handlers, even though they are internal.  The only thing it requires is    * using a PlugInProcDef struct.  -josh */
name|procedural_db_register
argument_list|(
operator|&
name|xcf_plug_in_save_proc
operator|.
name|db_info
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|xcf_plug_in_load_proc
operator|.
name|db_info
argument_list|)
expr_stmt|;
name|xcf_plug_in_save_proc
operator|.
name|image_types_val
operator|=
name|plug_in_image_types_parse
argument_list|(
name|xcf_plug_in_save_proc
operator|.
name|image_types
argument_list|)
expr_stmt|;
name|xcf_plug_in_load_proc
operator|.
name|image_types_val
operator|=
name|plug_in_image_types_parse
argument_list|(
name|xcf_plug_in_load_proc
operator|.
name|image_types
argument_list|)
expr_stmt|;
name|plug_in_add_internal
argument_list|(
operator|&
name|xcf_plug_in_save_proc
argument_list|)
expr_stmt|;
name|plug_in_add_internal
argument_list|(
operator|&
name|xcf_plug_in_load_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|xcf_load_invoker (Argument * args)
name|xcf_load_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|XcfInfo
name|info
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|success
decl_stmt|;
name|char
name|id
index|[
literal|14
index|]
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
name|filename
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|info
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|fp
condition|)
block|{
name|info
operator|.
name|cp
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|info
operator|.
name|active_layer
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|active_channel
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|floating_sel_drawable
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|swap_num
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|ref_count
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|compression
operator|=
name|COMPRESS_NONE
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|info
operator|.
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|.
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|id
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|id
argument_list|,
literal|"gimp xcf "
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|id
operator|+
literal|9
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|file_version
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
index|[
literal|9
index|]
operator|==
literal|'v'
condition|)
block|{
name|info
operator|.
name|file_version
operator|=
name|atoi
argument_list|(
name|id
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|file_version
operator|<
name|N_xcf_loaders
condition|)
block|{
name|gimage
operator|=
operator|(
operator|*
operator|(
name|xcf_loaders
index|[
name|info
operator|.
name|file_version
index|]
operator|)
operator|)
operator|(
operator|&
name|info
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimage
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"XCF error: unsupported XCF file version %d encountered"
argument_list|)
argument_list|,
name|info
operator|.
name|file_version
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|info
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|xcf_plug_in_load_proc
operator|.
name|db_info
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pdb_image_to_id
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|xcf_save_invoker (Argument * args)
name|xcf_save_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|XcfInfo
name|info
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|success
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
name|filename
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|info
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|fp
condition|)
block|{
name|info
operator|.
name|cp
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|info
operator|.
name|active_layer
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|active_channel
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|floating_sel_drawable
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|swap_num
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|ref_count
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|compression
operator|=
name|COMPRESS_RLE
expr_stmt|;
name|xcf_save_choose_format
argument_list|(
operator|&
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|success
operator|=
name|xcf_save_image
argument_list|(
operator|&
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|info
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"open failed on %s: %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|xcf_plug_in_save_proc
operator|.
name|db_info
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_choose_format (XcfInfo * info,GImage * gimage)
name|xcf_save_choose_format
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|int
name|save_version
init|=
literal|0
decl_stmt|;
comment|/* default to oldest */
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|save_version
operator|=
literal|1
expr_stmt|;
comment|/* need version 1 for colormaps */
name|info
operator|->
name|file_version
operator|=
name|save_version
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_save_image (XcfInfo * info,GImage * gimage)
name|xcf_save_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint
name|nlayers
decl_stmt|;
name|guint
name|nchannels
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|have_selection
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|char
name|version_tag
index|[
literal|14
index|]
decl_stmt|;
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* write out the tag information for the image */
if|if
condition|(
name|info
operator|->
name|file_version
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf v%03d"
argument_list|,
name|info
operator|->
name|file_version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf file"
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|version_tag
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* write out the width, height and image type information for the image */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|base_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* determine the number of layers and channels in the image */
name|nlayers
operator|=
operator|(
name|guint
operator|)
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|nchannels
operator|=
operator|(
name|guint
operator|)
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
comment|/* check and see if we have to save out the selection */
name|have_selection
operator|=
name|gimage_mask_bounds
argument_list|(
name|gimage
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t3
argument_list|,
operator|&
name|t4
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_selection
condition|)
name|nchannels
operator|+=
literal|1
expr_stmt|;
comment|/* write the property information for the image.    */
name|xcf_save_image_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/* save the current file position as it is the start of where    *  we place the layer offset information.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* Initialize the fractal compression saving routines    */
if|if
condition|(
name|info
operator|->
name|compression
operator|==
name|COMPRESS_FRACTAL
condition|)
name|xcf_save_compress_frac_init
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* seek to after the offset lists */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|nlayers
operator|+
name|nchannels
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/* save the start offset of where we are writing        *  out the next layer.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_save_layer
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  layer offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next layer.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the layer offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
operator|||
name|have_selection
condition|)
block|{
if|if
condition|(
name|list
condition|)
block|{
name|channel
operator|=
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|=
name|gimage
operator|->
name|selection_mask
expr_stmt|;
name|have_selection
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* save the start offset of where we are writing        *  out the next channel.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  channel offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next channel.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the channel offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|!
name|ferror
argument_list|(
name|info
operator|->
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_image_props (XcfInfo * info,GImage * gimage)
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/* check and see if we should save the colormap property */
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COLORMAP
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|compression
operator|!=
name|COMPRESS_NONE
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COMPRESSION
argument_list|,
name|info
operator|->
name|compression
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|guides
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_GUIDES
argument_list|,
name|gimage
operator|->
name|guides
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_RESOLUTION
argument_list|,
name|gimage
operator|->
name|xresolution
argument_list|,
name|gimage
operator|->
name|yresolution
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|gimage
operator|->
name|tattoo_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|gimage
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_layer_props (XcfInfo * info,GImage * gimage,Layer * layer)
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
if|if
condition|(
name|layer
operator|==
name|gimage
operator|->
name|active_layer
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_ACTIVE_LAYER
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|info
operator|->
name|floating_sel_drawable
operator|=
name|layer
operator|->
name|fs
operator|.
name|drawable
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_FLOATING_SELECTION
argument_list|)
expr_stmt|;
block|}
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OPACITY
argument_list|,
name|layer
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|visible
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_LINKED
argument_list|,
name|layer
operator|->
name|linked
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PRESERVE_TRANSPARENCY
argument_list|,
name|layer
operator|->
name|preserve_trans
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
name|layer
operator|->
name|apply_mask
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
name|layer
operator|->
name|edit_mask
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
name|layer
operator|->
name|show_mask
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OFFSETS
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_MODE
argument_list|,
name|layer
operator|->
name|mode
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tattoo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_channel_props (XcfInfo * info,GImage * gimage,Channel * channel)
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
if|if
condition|(
name|channel
operator|==
name|gimage
operator|->
name|active_channel
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_ACTIVE_CHANNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimage
operator|->
name|selection_mask
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SELECTION
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OPACITY
argument_list|,
name|channel
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|visible
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SHOW_MASKED
argument_list|,
name|channel
operator|->
name|show_masked
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COLOR
argument_list|,
name|channel
operator|->
name|col
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tattoo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|write_a_parasite (char * key,Parasite * p,XcfInfo * info)
specifier|static
name|void
name|write_a_parasite
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|Parasite
modifier|*
name|p
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|PARASITE_PERSISTENT
operator|)
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|read_a_parasite (XcfInfo * info)
specifier|static
name|Parasite
modifier|*
name|read_a_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|Parasite
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|g_new
argument_list|(
name|Parasite
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|g_new
argument_list|(
name|char
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_prop (XcfInfo * info,PropType prop_type,...)
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
modifier|...
parameter_list|)
block|{
name|guint32
name|size
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_COLORMAP
case|:
block|{
name|guint32
name|ncolors
decl_stmt|;
name|guchar
modifier|*
name|colors
decl_stmt|;
name|ncolors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|colors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|+
name|ncolors
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|ncolors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|colors
argument_list|,
name|ncolors
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_ACTIVE_LAYER
case|:
case|case
name|PROP_ACTIVE_CHANNEL
case|:
case|case
name|PROP_SELECTION
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
block|{
name|guint32
name|dummy
decl_stmt|;
name|dummy
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|floating_sel_offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|gint32
name|opacity
decl_stmt|;
name|opacity
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_MODE
case|:
block|{
name|gint32
name|mode
decl_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|guint32
name|visible
decl_stmt|;
name|visible
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
block|{
name|guint32
name|linked
decl_stmt|;
name|linked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PRESERVE_TRANSPARENCY
case|:
block|{
name|guint32
name|preserve_trans
decl_stmt|;
name|preserve_trans
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|preserve_trans
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_APPLY_MASK
case|:
block|{
name|guint32
name|apply_mask
decl_stmt|;
name|apply_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_EDIT_MASK
case|:
block|{
name|guint32
name|edit_mask
decl_stmt|;
name|edit_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASK
case|:
block|{
name|guint32
name|show_mask
decl_stmt|;
name|show_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
block|{
name|guint32
name|show_masked
decl_stmt|;
name|show_masked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OFFSETS
case|:
block|{
name|gint32
name|offsets
index|[
literal|2
index|]
decl_stmt|;
name|offsets
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|offsets
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COLOR
case|:
block|{
name|guchar
modifier|*
name|color
decl_stmt|;
name|color
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|color
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|compression
operator|=
operator|(
name|guint8
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|GList
modifier|*
name|guides
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
name|int
name|nguides
decl_stmt|;
name|guides
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GList
operator|*
argument_list|)
expr_stmt|;
name|nguides
operator|=
name|g_list_length
argument_list|(
name|guides
argument_list|)
expr_stmt|;
name|size
operator|=
name|nguides
operator|*
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|guides
condition|)
block|{
name|guide
operator|=
name|guides
operator|->
name|data
expr_stmt|;
name|guides
operator|=
name|guides
operator|->
name|next
expr_stmt|;
name|position
operator|=
name|guide
operator|->
name|position
expr_stmt|;
name|orientation
operator|=
name|guide
operator|->
name|orientation
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|float
name|xresolution
decl_stmt|,
name|yresolution
decl_stmt|;
comment|/* we pass in floats, but they are promoted to double by the compiler */
name|xresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|yresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|*
literal|2
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|xresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|yresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|guint32
name|tattoo
decl_stmt|;
name|tattoo
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|ParasiteList
modifier|*
name|list
decl_stmt|;
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|list
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|ParasiteList
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_persistent_length
argument_list|(
name|list
argument_list|)
operator|>
literal|0
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the parasite list will take 	     we save the file position and write the length later */
name|pos
operator|=
name|ftell
argument_list|(
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|parasite_list_foreach
argument_list|(
name|list
argument_list|,
operator|(
name|GHFunc
operator|)
name|write_a_parasite
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_layer (XcfInfo * info,GImage * gimage,Layer * layer)
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|saved_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width, height and image type information for the layer */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|compression
operator|==
name|COMPRESS_FRACTAL
condition|)
name|xcf_compress_frac_info
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* write out the layers name */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the layer properties */
name|xcf_save_layer_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer tile hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer mask */
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_channel (XcfInfo * info,GImage * gimage,Channel * channel)
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|info
operator|->
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width and height information for the channel */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channels name */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channel properties */
name|xcf_save_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the channel tile hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tiles
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|xcf_calc_levels (int size,int tile_size)
name|xcf_calc_levels
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|tile_size
parameter_list|)
block|{
name|int
name|levels
decl_stmt|;
name|levels
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|tile_size
condition|)
block|{
name|size
operator|/=
literal|2
expr_stmt|;
name|levels
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|levels
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_hierarchy (XcfInfo * info,TileManager * tiles)
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nlevels
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|int
name|h
decl_stmt|,
name|w
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tiles
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tiles
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tiles
operator|->
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|tmp1
operator|=
name|xcf_calc_levels
argument_list|(
name|tiles
operator|->
name|width
argument_list|,
name|TILE_WIDTH
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|xcf_calc_levels
argument_list|(
name|tiles
operator|->
name|height
argument_list|,
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|MAX
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
literal|1
operator|+
name|nlevels
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* write out the level. */
name|xcf_save_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|)
expr_stmt|;
name|w
operator|=
name|tiles
operator|->
name|width
expr_stmt|;
name|h
operator|=
name|tiles
operator|->
name|height
expr_stmt|;
block|}
else|else
block|{
comment|/* fake an empty level */
name|tmp1
operator|=
literal|0
expr_stmt|;
name|w
operator|/=
literal|2
expr_stmt|;
name|h
operator|/=
literal|2
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tmp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* seek back to where we are to write out the next        *  level offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next level.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_level (XcfInfo * info,TileManager * level)
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|level
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|int
name|i
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|level
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|level
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|tiles
condition|)
block|{
name|ntiles
operator|=
name|level
operator|->
name|ntile_rows
operator|*
name|level
operator|->
name|ntile_cols
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|ntiles
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
comment|/* save the start offset of where we are writing 	   *  out the next tile. 	   */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the tile. */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
name|xcf_save_tile
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
name|xcf_save_tile_rle
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
name|_
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|xcf_save_frac_compressed_tile
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* seek back to where we are to write out the next 	   *  tile offset and write it out. 	   */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the 	   *  next offset. 	   */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where 	   *  we will write out the next tile. 	   */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_tile (XcfInfo * info,Tile * tile)
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_tile_rle (XcfInfo * info,Tile * tile)
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|guchar
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|bpp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* in state 0 we try to find a long sequence of 	       *  matching values. 	       */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
operator|)
condition|)
block|{
name|count
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|127
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
name|last
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
literal|0
index|]
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
name|last
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
condition|)
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* in state 1 we try and find a long sequence of 	       *  non-matching values. 	       */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|last
operator|==
operator|*
name|data
operator|)
operator|)
condition|)
block|{
name|count
operator|+=
name|length
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|255
operator|-
literal|127
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
name|k
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
block|}
name|t
operator|=
name|data
operator|-
name|length
operator|*
name|bpp
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
name|buffer
index|[
name|k
operator|++
index|]
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|+=
name|bpp
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|1024
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|length
operator|+=
literal|1
expr_stmt|;
name|last
operator|=
operator|*
name|data
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
operator|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
condition|)
name|g_print
argument_list|(
name|_
argument_list|(
literal|"xcf: uh oh! xcf rle tile saving error: %d\n"
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GImage
modifier|*
DECL|function|xcf_load_image (XcfInfo * info)
name|xcf_load_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|image_type
decl_stmt|;
comment|/* read in the image width, height and type */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|image_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new gimage */
name|gimage
operator|=
name|gimage_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimage
condition|)
return|return
name|NULL
return|;
comment|/* read the image properties */
if|if
condition|(
operator|!
name|xcf_load_image_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|info
operator|->
name|compression
operator|==
name|COMPRESS_FRACTAL
condition|)
name|xcf_load_compress_frac_init
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* read in the offset of the next layer */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the layer list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next layer offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the layer offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the layer */
name|layer
operator|=
name|xcf_load_layer
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|info
operator|->
name|compression
operator|==
name|COMPRESS_FRACTAL
condition|)
name|xcf_compress_frac_info
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* add the layer to the image if its not the floating selection */
if|if
condition|(
name|layer
operator|!=
name|info
operator|->
name|floating_sel
condition|)
name|gimage_add_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* read in the offset of the next channel */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the channel list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next channel offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the channel offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the layer */
name|channel
operator|=
name|xcf_load_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
goto|goto
name|error
goto|;
comment|/* add the channel to the image if its not the selection */
if|if
condition|(
name|channel
operator|!=
name|gimage
operator|->
name|selection_mask
condition|)
name|gimage_add_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|active_layer
condition|)
name|gimage_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|info
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|active_channel
condition|)
name|gimage_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|info
operator|->
name|active_channel
argument_list|)
expr_stmt|;
name|gimage_set_filename
argument_list|(
name|gimage
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
name|error
label|:
name|gimage_delete
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_image_props (XcfInfo * info,GImage * gimage)
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_COLORMAP
case|:
if|if
condition|(
name|info
operator|->
name|file_version
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|g_message
argument_list|(
name|_
argument_list|(
literal|"XCF warning: version 0 of XCF file format\n"
literal|"did not save indexed colormaps correctly.\n"
literal|"Substituting grayscale map."
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|num_cols
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
name|gimage
operator|->
name|num_cols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gimage
operator|->
name|num_cols
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|num_cols
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compression
operator|!=
name|COMPRESS_NONE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_RLE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_ZLIB
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_FRACTAL
operator|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"unknown compression type: %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|compression
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|->
name|compression
operator|=
name|compression
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nguides
decl_stmt|;
name|nguides
operator|=
name|prop_size
operator|/
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nguides
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|orientation
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|guides
operator|=
name|g_list_reverse
argument_list|(
name|gimage
operator|->
name|guides
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|gimage
operator|->
name|xresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|gimage
operator|->
name|yresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|xresolution
operator|<
literal|1e-5
operator|||
name|gimage
operator|->
name|xresolution
operator|>
literal|1e+5
operator|||
name|gimage
operator|->
name|yresolution
operator|<
literal|1e-5
operator|||
name|gimage
operator|->
name|yresolution
operator|>
literal|1e+5
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Warning, resolution out of range in XCF file"
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
literal|72.0
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
literal|72.0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|gimage
operator|->
name|tattoo_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|long
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|Parasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|gimage
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Error detected while loading an image's parasites"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"unexpected/unknown image property: %d (skipping)"
argument_list|)
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_layer_props (XcfInfo * info,GImage * gimage,Layer * layer)
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_LAYER
case|:
name|info
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
name|info
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|info
operator|->
name|floating_sel_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_LINKED
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PRESERVE_TRANSPARENCY
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|preserve_trans
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_APPLY_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_EDIT_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_MODE
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|long
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|Parasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_drawable_attach_parasite
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
literal|"Error detected while loading a layer's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"unexpected/unknown layer property: %d (skipping)"
argument_list|)
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_channel_props (XcfInfo * info,GImage * gimage,Channel * channel)
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_CHANNEL
case|:
name|info
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
break|break;
case|case
name|PROP_SELECTION
case|:
name|channel_delete
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|selection_mask
operator|=
name|channel
expr_stmt|;
name|channel
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|channel
operator|->
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|channel
operator|->
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_COLOR
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|channel
operator|->
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|long
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|Parasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|info
operator|->
name|cp
operator|-
name|base
operator|)
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_drawable_attach_parasite
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
literal|"Error detected while loading a channel's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"unexpected/unknown channel property: %d (skipping)"
argument_list|)
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_prop (XcfInfo * info,PropType * prop_type,guint32 * prop_size)
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|Layer
modifier|*
DECL|function|xcf_load_layer (XcfInfo * info,GImage * gimage)
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|LayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|guint32
name|layer_mask_offset
decl_stmt|;
name|int
name|apply_mask
decl_stmt|;
name|int
name|edit_mask
decl_stmt|;
name|int
name|show_mask
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|add_floating_sel
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height, type and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer */
name|layer
operator|=
name|layer_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
literal|255
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
block|{
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* read in the layer properties */
if|if
condition|(
operator|!
name|xcf_load_layer_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|info
operator|->
name|compression
operator|==
name|COMPRESS_FRACTAL
condition|)
name|xcf_compress_frac_info
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|layer_mask_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read in the layer mask */
if|if
condition|(
name|layer_mask_offset
operator|!=
literal|0
condition|)
block|{
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|layer_mask_offset
argument_list|)
expr_stmt|;
name|layer_mask
operator|=
name|xcf_load_layer_mask
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
goto|goto
name|error
goto|;
comment|/* set the offsets of the layer_mask */
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|offset_x
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|offset_y
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
expr_stmt|;
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|layer_add_mask
argument_list|(
name|layer
argument_list|,
name|layer_mask
argument_list|)
expr_stmt|;
name|layer
operator|->
name|apply_mask
operator|=
name|apply_mask
expr_stmt|;
name|layer
operator|->
name|edit_mask
operator|=
name|edit_mask
expr_stmt|;
name|layer
operator|->
name|show_mask
operator|=
name|show_mask
expr_stmt|;
block|}
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|layer
return|;
name|error
label|:
name|layer_delete
argument_list|(
name|layer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
DECL|function|xcf_load_channel (XcfInfo * info,GImage * gimage)
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|add_floating_sel
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|guchar
name|color
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new channel */
name|channel
operator|=
name|channel_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
literal|255
argument_list|,
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* read in the channel properties */
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|channel
return|;
name|error
label|:
name|channel_delete
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|LayerMask
modifier|*
DECL|function|xcf_load_layer_mask (XcfInfo * info,GImage * gimage)
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|LayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|add_floating_sel
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|guchar
name|color
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer mask */
name|layer_mask
operator|=
name|layer_mask_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
literal|255
argument_list|,
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
block|{
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* read in the layer_mask properties */
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|Layer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|layer_mask
return|;
name|error
label|:
name|layer_mask_delete
argument_list|(
name|layer_mask
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_hierarchy (XcfInfo * info,TileManager * tiles)
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|junk
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|bpp
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure the values in the file correspond to the values    *  calculated when the TileManager was created.    */
if|if
condition|(
operator|(
name|width
operator|!=
name|tiles
operator|->
name|width
operator|)
operator|||
operator|(
name|height
operator|!=
name|tiles
operator|->
name|height
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tiles
operator|->
name|bpp
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* load in the levels...we make sure that the number of levels    *  calculated when the TileManager was created is the same    *  as the number of levels found in the file.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* top level */
comment|/* discard offsets for layers below first, if any.    */
do|do
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|junk
operator|!=
literal|0
condition|)
do|;
comment|/* save the current position as it is where the    *  next level offset is stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the level offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the level */
if|if
condition|(
operator|!
name|xcf_load_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* restore the saved position so we'll be ready to    *  read the next offset.    */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_level (XcfInfo * info,TileManager * tiles)
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|Tile
modifier|*
name|previous
decl_stmt|;
name|Tile
modifier|*
name|tile
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|!=
name|tiles
operator|->
name|width
operator|)
operator|||
operator|(
name|height
operator|!=
name|tiles
operator|->
name|height
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* read in the first tile offset.    *  if it is '0', then this tile level is empty    *  and we can simply return.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Initialise the reference for the in-memory tile-compression    */
name|previous
operator|=
name|NULL
expr_stmt|;
name|ntiles
operator|=
name|tiles
operator|->
name|ntile_rows
operator|*
name|tiles
operator|->
name|ntile_cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
name|fail
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"not enough tiles found in level"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* save the current position as it is where the        *  next tile offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the tile offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* get the tile from the tile manager */
name|tile
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* read in the tile */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile
argument_list|(
name|info
argument_list|,
name|tile
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile_rle
argument_list|(
name|info
argument_list|,
name|tile
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
name|_
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|g_error
argument_list|(
name|_
argument_list|(
literal|"xcf: fractal compression unimplemented"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* To potentially save memory, we compare the        *  newly-fetched tile against the last one, and        *  if they're the same we copy-on-write mirror one against        *  the other.        */
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
name|tile_lock
argument_list|(
name|previous
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_ewidth
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_eheight
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_bpp
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_bpp
argument_list|(
name|previous
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_data_pointer
argument_list|(
name|previous
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|tile_manager_map
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|previous
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|previous
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
comment|/* read in the offset of the next tile */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"encountered garbage after reading level: %d"
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_tile (XcfInfo * info,Tile * tile)
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
if|if
condition|(
operator|!
name|info
operator|->
name|swap_num
condition|)
block|{
name|info
operator|->
name|ref_count
operator|=
name|g_new
argument_list|(
name|int
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|swap_num
operator|=
name|tile_swap_add
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|xcf_swap_func
argument_list|,
name|info
operator|->
name|ref_count
argument_list|)
expr_stmt|;
block|}
name|tile
operator|->
name|swap_num
operator|=
name|info
operator|->
name|swap_num
expr_stmt|;
name|tile
operator|->
name|swap_offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
operator|*
name|info
operator|->
name|ref_count
operator|+=
literal|1
expr_stmt|;
else|#
directive|else
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_load_tile_rle (XcfInfo * info,Tile * tile)
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|guchar
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|bpp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|data
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
expr_stmt|;
name|size
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|length
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|MIN
argument_list|(
name|length
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|length
operator|-=
name|tmp
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tmp
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|data
operator|=
name|buffer
index|[
name|j
index|]
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"xcf: uh oh! xcf rle tile loading error: %d"
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|data
operator|=
name|val
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
end_ifdef

begin_function
specifier|static
name|int
DECL|function|xcf_swap_func (int fd,Tile * tile,int cmd,gpointer user_data)
name|xcf_swap_func
parameter_list|(
name|int
name|fd
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|int
name|cmd
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|int
modifier|*
name|ref_count
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SWAP_IN
case|:
name|lseek
argument_list|(
name|fd
argument_list|,
name|tile
operator|->
name|swap_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|tile_size
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|tile_alloc
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|bytes
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|err
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tile
operator|->
name|data
operator|+
name|bytes
operator|-
name|nleft
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|err
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
operator|||
operator|(
name|errno
operator|==
name|EINTR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"unable to read tile data from xcf file: %d ( %d ) bytes read"
argument_list|)
argument_list|,
name|err
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|nleft
operator|-=
name|err
expr_stmt|;
block|}
break|break;
case|case
name|SWAP_OUT
case|:
case|case
name|SWAP_DELETE
case|:
case|case
name|SWAP_COMPRESS
case|:
name|ref_count
operator|=
name|user_data
expr_stmt|;
operator|*
name|ref_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ref_count
operator|==
literal|0
condition|)
block|{
name|tile_swap_remove
argument_list|(
name|tile
operator|->
name|swap_num
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ref_count
argument_list|)
expr_stmt|;
block|}
name|tile
operator|->
name|swap_num
operator|=
literal|1
expr_stmt|;
name|tile
operator|->
name|swap_offset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|xcf_seek_pos (XcfInfo * info,guint pos)
name|xcf_seek_pos
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|guint
name|pos
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|cp
operator|!=
name|pos
condition|)
block|{
name|info
operator|->
name|cp
operator|=
name|pos
expr_stmt|;
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|info
operator|->
name|cp
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_seek_end (XcfInfo * info)
name|xcf_seek_end
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|=
name|ftell
argument_list|(
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_int32 (FILE * fp,guint32 * data,gint count)
name|xcf_read_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|xcf_read_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
argument_list|,
name|count
operator|*
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
name|data
operator|=
name|g_ntohl
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
return|return
name|total
operator|*
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_float (FILE * fp,gfloat * data,gint count)
name|xcf_read_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
return|return
operator|(
name|xcf_read_int32
argument_list|(
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|data
operator|)
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_int8 (FILE * fp,guint8 * data,gint count)
name|xcf_read_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bytes
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
comment|/* something bad happened */
break|break;
name|count
operator|-=
name|bytes
expr_stmt|;
name|data
operator|+=
name|bytes
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_string (FILE * fp,gchar ** data,gint count)
name|xcf_read_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|guint
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|xcf_read_int32
argument_list|(
name|fp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|total
operator|+=
name|xcf_read_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_int32 (FILE * fp,guint32 * data,gint count)
name|xcf_write_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|g_htonl
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xcf_write_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
operator|*
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_float (FILE * fp,gfloat * data,gint count)
name|xcf_write_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
return|return
operator|(
name|xcf_write_int32
argument_list|(
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|data
operator|)
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_int8 (FILE * fp,guint8 * data,gint count)
name|xcf_write_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bytes
operator|=
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|count
operator|-=
name|bytes
expr_stmt|;
name|data
operator|+=
name|bytes
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_string (FILE * fp,gchar ** data,gint count)
name|xcf_write_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|guint
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
condition|)
name|tmp
operator|=
name|strlen
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|tmp
operator|=
literal|0
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|fp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
name|xcf_write_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|total
operator|+=
literal|4
operator|+
name|tmp
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

end_unit

