begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"apptypes.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpcontainer.h"
end_include

begin_include
include|#
directive|include
file|"gimpdrawable.h"
end_include

begin_include
include|#
directive|include
file|"gimplayer.h"
end_include

begin_include
include|#
directive|include
file|"gimplayermask.h"
end_include

begin_include
include|#
directive|include
file|"gimplist.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"plug_in.h"
end_include

begin_include
include|#
directive|include
file|"parasitelist.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"pathP.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager_pvt.h"
end_include

begin_include
include|#
directive|include
file|"xcf.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimplimits.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpparasite.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_comment
comment|/* #define SWAP_FROM_FILE */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon296491a40103
block|{
DECL|enumerator|PROP_END
name|PROP_END
init|=
literal|0
block|,
DECL|enumerator|PROP_COLORMAP
name|PROP_COLORMAP
init|=
literal|1
block|,
DECL|enumerator|PROP_ACTIVE_LAYER
name|PROP_ACTIVE_LAYER
init|=
literal|2
block|,
DECL|enumerator|PROP_ACTIVE_CHANNEL
name|PROP_ACTIVE_CHANNEL
init|=
literal|3
block|,
DECL|enumerator|PROP_SELECTION
name|PROP_SELECTION
init|=
literal|4
block|,
DECL|enumerator|PROP_FLOATING_SELECTION
name|PROP_FLOATING_SELECTION
init|=
literal|5
block|,
DECL|enumerator|PROP_OPACITY
name|PROP_OPACITY
init|=
literal|6
block|,
DECL|enumerator|PROP_MODE
name|PROP_MODE
init|=
literal|7
block|,
DECL|enumerator|PROP_VISIBLE
name|PROP_VISIBLE
init|=
literal|8
block|,
DECL|enumerator|PROP_LINKED
name|PROP_LINKED
init|=
literal|9
block|,
DECL|enumerator|PROP_PRESERVE_TRANSPARENCY
name|PROP_PRESERVE_TRANSPARENCY
init|=
literal|10
block|,
DECL|enumerator|PROP_APPLY_MASK
name|PROP_APPLY_MASK
init|=
literal|11
block|,
DECL|enumerator|PROP_EDIT_MASK
name|PROP_EDIT_MASK
init|=
literal|12
block|,
DECL|enumerator|PROP_SHOW_MASK
name|PROP_SHOW_MASK
init|=
literal|13
block|,
DECL|enumerator|PROP_SHOW_MASKED
name|PROP_SHOW_MASKED
init|=
literal|14
block|,
DECL|enumerator|PROP_OFFSETS
name|PROP_OFFSETS
init|=
literal|15
block|,
DECL|enumerator|PROP_COLOR
name|PROP_COLOR
init|=
literal|16
block|,
DECL|enumerator|PROP_COMPRESSION
name|PROP_COMPRESSION
init|=
literal|17
block|,
DECL|enumerator|PROP_GUIDES
name|PROP_GUIDES
init|=
literal|18
block|,
DECL|enumerator|PROP_RESOLUTION
name|PROP_RESOLUTION
init|=
literal|19
block|,
DECL|enumerator|PROP_TATTOO
name|PROP_TATTOO
init|=
literal|20
block|,
DECL|enumerator|PROP_PARASITES
name|PROP_PARASITES
init|=
literal|21
block|,
DECL|enumerator|PROP_UNIT
name|PROP_UNIT
init|=
literal|22
block|,
DECL|enumerator|PROP_PATHS
name|PROP_PATHS
init|=
literal|23
block|,
DECL|enumerator|PROP_USER_UNIT
name|PROP_USER_UNIT
init|=
literal|24
DECL|typedef|PropType
block|}
name|PropType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon296491a40203
block|{
DECL|enumerator|COMPRESS_NONE
name|COMPRESS_NONE
init|=
literal|0
block|,
DECL|enumerator|COMPRESS_RLE
name|COMPRESS_RLE
init|=
literal|1
block|,
DECL|enumerator|COMPRESS_ZLIB
name|COMPRESS_ZLIB
init|=
literal|2
block|,
DECL|enumerator|COMPRESS_FRACTAL
name|COMPRESS_FRACTAL
init|=
literal|3
comment|/* Unused. */
DECL|typedef|CompressionType
block|}
name|CompressionType
typedef|;
end_typedef

begin_typedef
DECL|typedef|info
typedef|typedef
name|GImage
modifier|*
name|XcfLoader
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|Argument
modifier|*
name|xcf_load_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|xcf_save_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|xcf_save_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_choose_format
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|guchar
modifier|*
name|rlebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|xcf_load_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gboolean
modifier|*
name|apply_mask
parameter_list|,
name|gboolean
modifier|*
name|edit_mask
parameter_list|,
name|gboolean
modifier|*
name|show_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpLayer
modifier|*
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpChannel
modifier|*
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpLayerMask
modifier|*
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|data_length
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
end_ifdef

begin_function_decl
specifier|static
name|gboolean
name|xcf_swap_func
parameter_list|(
name|gint
name|fd
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|cmd
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|xcf_seek_pos
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|guint
name|pos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcf_seek_end
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_read_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint
name|xcf_write_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|xcf_load_args
specifier|static
name|ProcArg
name|xcf_load_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"dummy_param"
block|,
literal|"dummy parameter"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_load_return_vals
specifier|static
name|ProcArg
name|xcf_load_return_vals
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_plug_in_load_proc
specifier|static
name|PlugInProcDef
name|xcf_plug_in_load_proc
init|=
block|{
literal|"gimp_xcf_load"
block|,
literal|"<Load>/XCF (GIMP)"
block|,
name|NULL
block|,
literal|"xcf"
block|,
literal|""
block|,
literal|"0,string,gimp\\040xcf\\040"
block|,
name|NULL
block|,
comment|/* ignored for load */
literal|0
block|,
comment|/* ignored for load */
block|{
literal|"gimp_xcf_load"
block|,
literal|"loads file saved in the .xcf file format"
block|,
literal|"The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will load the specified file."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|xcf_load_args
block|,
literal|1
block|,
name|xcf_load_return_vals
block|,
block|{
block|{
name|xcf_load_invoker
block|}
block|}
block|,   }
block|,
name|NULL
block|,
comment|/* fill me in at runtime */
name|NULL
comment|/* fill me in at runtime */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_save_args
specifier|static
name|ProcArg
name|xcf_save_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"dummy_param"
block|,
literal|"dummy parameter"
block|}
block|,
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Active drawable of input image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_plug_in_save_proc
specifier|static
name|PlugInProcDef
name|xcf_plug_in_save_proc
init|=
block|{
literal|"gimp_xcf_save"
block|,
literal|"<Save>/XCF (GIMP)"
block|,
name|NULL
block|,
literal|"xcf"
block|,
literal|""
block|,
name|NULL
block|,
literal|"RGB*, GRAY*, INDEXED*"
block|,
literal|0
block|,
comment|/* fill me in at runtime */
block|{
literal|"gimp_xcf_save"
block|,
literal|"saves file in the .xcf file format"
block|,
literal|"The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will save the specified image in the xcf file format."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|xcf_save_args
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|xcf_save_invoker
block|}
block|}
block|,   }
block|,
name|NULL
block|,
comment|/* fill me in at runtime */
name|NULL
comment|/* fill me in at runtime */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xcf_loaders
specifier|static
name|XcfLoader
modifier|*
name|xcf_loaders
index|[]
init|=
block|{
name|xcf_load_image
block|,
comment|/* version 0 */
name|xcf_load_image
comment|/* version 1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|N_xcf_loaders
specifier|static
name|gint
name|N_xcf_loaders
init|=
operator|(
sizeof|sizeof
argument_list|(
name|xcf_loaders
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcf_loaders
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|xcf_init (void)
name|xcf_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* So this is sort of a hack, but its better than it was before.  To do this    * right there would be a file load-save handler type and the whole interface    * would change but there isn't, and currently the plug-in structure contains    * all the load-save info, so it makes sense to use that for the XCF load/save    * handlers, even though they are internal.  The only thing it requires is    * using a PlugInProcDef struct.  -josh */
name|procedural_db_register
argument_list|(
operator|&
name|xcf_plug_in_save_proc
operator|.
name|db_info
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|xcf_plug_in_load_proc
operator|.
name|db_info
argument_list|)
expr_stmt|;
name|xcf_plug_in_save_proc
operator|.
name|image_types_val
operator|=
name|plug_in_image_types_parse
argument_list|(
name|xcf_plug_in_save_proc
operator|.
name|image_types
argument_list|)
expr_stmt|;
name|xcf_plug_in_load_proc
operator|.
name|image_types_val
operator|=
name|plug_in_image_types_parse
argument_list|(
name|xcf_plug_in_load_proc
operator|.
name|image_types
argument_list|)
expr_stmt|;
name|plug_in_add_internal
argument_list|(
operator|&
name|xcf_plug_in_save_proc
argument_list|)
expr_stmt|;
name|plug_in_add_internal
argument_list|(
operator|&
name|xcf_plug_in_load_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|xcf_load_invoker (Argument * args)
name|xcf_load_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|XcfInfo
name|info
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|gchar
name|id
index|[
literal|14
index|]
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
name|filename
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|info
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|fp
condition|)
block|{
name|info
operator|.
name|cp
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|info
operator|.
name|active_layer
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|active_channel
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|floating_sel_drawable
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|swap_num
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|ref_count
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|compression
operator|=
name|COMPRESS_NONE
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|info
operator|.
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|.
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|id
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|id
argument_list|,
literal|"gimp xcf "
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|id
operator|+
literal|9
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|file_version
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
index|[
literal|9
index|]
operator|==
literal|'v'
condition|)
block|{
name|info
operator|.
name|file_version
operator|=
name|atoi
argument_list|(
name|id
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|file_version
operator|<
name|N_xcf_loaders
condition|)
block|{
name|gimage
operator|=
operator|(
operator|*
operator|(
name|xcf_loaders
index|[
name|info
operator|.
name|file_version
index|]
operator|)
operator|)
operator|(
operator|&
name|info
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimage
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"XCF error: unsupported XCF file version %d encountered"
argument_list|)
argument_list|,
name|info
operator|.
name|file_version
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|info
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|xcf_plug_in_load_proc
operator|.
name|db_info
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pdb_image_to_id
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|xcf_save_invoker (Argument * args)
name|xcf_save_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|XcfInfo
name|info
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
name|filename
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|info
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|fp
condition|)
block|{
name|info
operator|.
name|cp
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|info
operator|.
name|active_layer
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|active_channel
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|floating_sel_drawable
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|floating_sel_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|swap_num
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|ref_count
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|compression
operator|=
name|COMPRESS_RLE
expr_stmt|;
name|xcf_save_choose_format
argument_list|(
operator|&
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|success
operator|=
name|xcf_save_image
argument_list|(
operator|&
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|info
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"open failed on %s: %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|xcf_plug_in_save_proc
operator|.
name|db_info
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_choose_format (XcfInfo * info,GImage * gimage)
name|xcf_save_choose_format
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gint
name|save_version
init|=
literal|0
decl_stmt|;
comment|/* default to oldest */
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|save_version
operator|=
literal|1
expr_stmt|;
comment|/* need version 1 for colormaps */
name|info
operator|->
name|file_version
operator|=
name|save_version
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_save_image (XcfInfo * info,GImage * gimage)
name|xcf_save_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayer
modifier|*
name|floating_layer
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint
name|nlayers
decl_stmt|;
name|guint
name|nchannels
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|gboolean
name|have_selection
decl_stmt|;
name|gint
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|gchar
name|version_tag
index|[
literal|14
index|]
decl_stmt|;
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* write out the tag information for the image */
if|if
condition|(
name|info
operator|->
name|file_version
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf v%03d"
argument_list|,
name|info
operator|->
name|file_version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|version_tag
argument_list|,
literal|"gimp xcf file"
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|version_tag
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* write out the width, height and image type information for the image */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|base_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* determine the number of layers and channels in the image */
name|nlayers
operator|=
operator|(
name|guint
operator|)
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|nchannels
operator|=
operator|(
name|guint
operator|)
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
comment|/* check and see if we have to save out the selection */
name|have_selection
operator|=
name|gimage_mask_bounds
argument_list|(
name|gimage
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t3
argument_list|,
operator|&
name|t4
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_selection
condition|)
name|nchannels
operator|+=
literal|1
expr_stmt|;
comment|/* write the property information for the image.    */
name|xcf_save_image_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/* save the current file position as it is the start of where    *  we place the layer offset information.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to after the offset lists */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|nlayers
operator|+
name|nchannels
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|->
name|list
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|layer
operator|=
operator|(
name|GimpLayer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/* save the start offset of where we are writing        *  out the next layer.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_save_layer
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  layer offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next layer.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the layer offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|list
operator|=
name|GIMP_LIST
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
operator|->
name|list
expr_stmt|;
while|while
condition|(
name|list
operator|||
name|have_selection
condition|)
block|{
if|if
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|GimpChannel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|=
name|gimage
operator|->
name|selection_mask
expr_stmt|;
name|have_selection
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* save the start offset of where we are writing        *  out the next channel.        */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer. */
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* seek back to where we are to write out the next        *  channel offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next channel.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the channel offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|!
name|ferror
argument_list|(
name|info
operator|->
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_image_props (XcfInfo * info,GImage * gimage)
name|xcf_save_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/* check and see if we should save the colormap property */
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COLORMAP
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|compression
operator|!=
name|COMPRESS_NONE
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COMPRESSION
argument_list|,
name|info
operator|->
name|compression
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|guides
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_GUIDES
argument_list|,
name|gimage
operator|->
name|guides
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_RESOLUTION
argument_list|,
name|gimage
operator|->
name|xresolution
argument_list|,
name|gimage
operator|->
name|yresolution
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|gimage
operator|->
name|tattoo_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|gimage
operator|->
name|parasites
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|unit
operator|<
name|gimp_unit_get_number_of_built_in_units
argument_list|()
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_UNIT
argument_list|,
name|gimage
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PATHS
argument_list|,
name|gimage
operator|->
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|unit
operator|>=
name|gimp_unit_get_number_of_built_in_units
argument_list|()
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_USER_UNIT
argument_list|,
name|gimage
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_layer_props (XcfInfo * info,GImage * gimage,GimpLayer * layer)
name|xcf_save_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
if|if
condition|(
name|layer
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|gimage
argument_list|)
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_ACTIVE_LAYER
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
name|info
operator|->
name|floating_sel_drawable
operator|=
name|layer
operator|->
name|fs
operator|.
name|drawable
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_FLOATING_SELECTION
argument_list|)
expr_stmt|;
block|}
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OPACITY
argument_list|,
name|layer
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|gimp_drawable_get_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_LINKED
argument_list|,
name|layer
operator|->
name|linked
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PRESERVE_TRANSPARENCY
argument_list|,
name|layer
operator|->
name|preserve_trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
name|layer
operator|->
name|mask
operator|->
name|apply_mask
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
name|layer
operator|->
name|mask
operator|->
name|edit_mask
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
name|layer
operator|->
name|mask
operator|->
name|show_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OFFSETS
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_MODE
argument_list|,
name|layer
operator|->
name|mode
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tattoo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_channel_props (XcfInfo * info,GImage * gimage,GimpChannel * channel)
name|xcf_save_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|gimage
argument_list|)
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_ACTIVE_CHANNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|gimage
operator|->
name|selection_mask
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SELECTION
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_OPACITY
argument_list|,
call|(
name|gint
call|)
argument_list|(
name|channel
operator|->
name|color
operator|.
name|a
operator|*
literal|255.999
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_VISIBLE
argument_list|,
name|gimp_drawable_get_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_SHOW_MASKED
argument_list|,
name|channel
operator|->
name|show_masked
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|channel
operator|->
name|color
argument_list|,
operator|&
name|col
index|[
literal|0
index|]
argument_list|,
operator|&
name|col
index|[
literal|1
index|]
argument_list|,
operator|&
name|col
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_COLOR
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_TATTOO
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tattoo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_length
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
operator|>
literal|0
condition|)
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_PARASITES
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|parasites
argument_list|)
expr_stmt|;
name|xcf_save_prop
argument_list|(
name|info
argument_list|,
name|PROP_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_a_parasite (gchar * key,GimpParasite * p,XcfInfo * info)
name|write_a_parasite
parameter_list|(
name|gchar
modifier|*
name|key
parameter_list|,
name|GimpParasite
modifier|*
name|p
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|GIMP_PARASITE_PERSISTENT
operator|)
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|GimpParasite
modifier|*
DECL|function|read_a_parasite (XcfInfo * info)
name|read_a_parasite
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|g_new
argument_list|(
name|GimpParasite
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|p
operator|->
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_bz_point (gpointer pptr,gpointer iptr)
name|write_bz_point
parameter_list|(
name|gpointer
name|pptr
parameter_list|,
name|gpointer
name|iptr
parameter_list|)
block|{
name|PathPoint
modifier|*
name|bpt
init|=
operator|(
name|PathPoint
operator|*
operator|)
name|pptr
decl_stmt|;
name|XcfInfo
modifier|*
name|info
init|=
operator|(
name|XcfInfo
operator|*
operator|)
name|iptr
decl_stmt|;
name|gfloat
name|xfloat
init|=
operator|(
name|gfloat
operator|)
name|bpt
operator|->
name|x
decl_stmt|;
name|gfloat
name|yfloat
init|=
operator|(
name|gfloat
operator|)
name|bpt
operator|->
name|y
decl_stmt|;
comment|/* (all gint)    * type    * x    * y    */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|bpt
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|xfloat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|yfloat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PathPoint
modifier|*
DECL|function|v1read_bz_point (XcfInfo * info)
name|v1read_bz_point
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|PathPoint
modifier|*
name|ptr
decl_stmt|;
name|guint32
name|type
decl_stmt|;
name|gint32
name|x
decl_stmt|;
name|gint32
name|y
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|path_point_new
argument_list|(
name|type
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PathPoint
modifier|*
DECL|function|read_bz_point (XcfInfo * info)
name|read_bz_point
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|PathPoint
modifier|*
name|ptr
decl_stmt|;
name|guint32
name|type
decl_stmt|;
name|gfloat
name|x
decl_stmt|;
name|gfloat
name|y
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|path_point_new
argument_list|(
name|type
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_one_path (gpointer pptr,gpointer iptr)
name|write_one_path
parameter_list|(
name|gpointer
name|pptr
parameter_list|,
name|gpointer
name|iptr
parameter_list|)
block|{
name|Path
modifier|*
name|bzp
init|=
operator|(
name|Path
operator|*
operator|)
name|pptr
decl_stmt|;
name|XcfInfo
modifier|*
name|info
init|=
operator|(
name|XcfInfo
operator|*
operator|)
name|iptr
decl_stmt|;
name|guint8
name|state
init|=
operator|(
name|gchar
operator|)
name|bzp
operator|->
name|state
decl_stmt|;
name|guint32
name|num_points
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|guint32
name|version
decl_stmt|;
comment|/*    * name (string)    * locked (gint)    * state (gchar)    * closed (gint)    * number points (gint)    * number paths (gint unused)    * then each point.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|bzp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|bzp
operator|->
name|locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|closed
operator|=
name|bzp
operator|->
name|closed
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num_points
operator|=
name|g_slist_length
argument_list|(
name|bzp
operator|->
name|path_details
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|version
operator|=
literal|3
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|bzp
operator|->
name|pathtype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|bzp
operator|->
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|g_slist_foreach
argument_list|(
name|bzp
operator|->
name|path_details
argument_list|,
name|write_bz_point
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Path
modifier|*
DECL|function|read_one_path (GImage * gimage,XcfInfo * info)
name|read_one_path
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|Path
modifier|*
name|bzp
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|guint32
name|locked
decl_stmt|;
name|guint8
name|state
decl_stmt|;
name|guint32
name|closed
decl_stmt|;
name|guint32
name|num_points
decl_stmt|;
name|guint32
name|version
decl_stmt|;
comment|/* changed from num_paths */
name|Tattoo
name|tattoo
init|=
literal|0
decl_stmt|;
name|GSList
modifier|*
name|pts_list
init|=
name|NULL
decl_stmt|;
name|PathType
name|ptype
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|closed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|ptype
operator|=
name|BEZIER
expr_stmt|;
while|while
condition|(
name|num_points
operator|--
operator|>
literal|0
condition|)
block|{
name|PathPoint
modifier|*
name|bpt
decl_stmt|;
comment|/* Read in a path */
name|bpt
operator|=
name|v1read_bz_point
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pts_list
operator|=
name|g_slist_append
argument_list|(
name|pts_list
argument_list|,
name|bpt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|2
condition|)
block|{
comment|/* Had extra type field and points are stored as doubles */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|ptype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_points
operator|--
operator|>
literal|0
condition|)
block|{
name|PathPoint
modifier|*
name|bpt
decl_stmt|;
comment|/* Read in a path */
name|bpt
operator|=
name|read_bz_point
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pts_list
operator|=
name|g_slist_append
argument_list|(
name|pts_list
argument_list|,
name|bpt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|3
condition|)
block|{
comment|/* Has extra tatto field */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|ptype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_points
operator|--
operator|>
literal|0
condition|)
block|{
name|PathPoint
modifier|*
name|bpt
decl_stmt|;
comment|/* Read in a path */
name|bpt
operator|=
name|read_bz_point
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pts_list
operator|=
name|g_slist_append
argument_list|(
name|pts_list
argument_list|,
name|bpt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"Unknown path type. Possibly corrupt XCF file"
argument_list|)
expr_stmt|;
block|}
name|bzp
operator|=
name|path_new
argument_list|(
name|gimage
argument_list|,
name|ptype
argument_list|,
name|pts_list
argument_list|,
name|closed
argument_list|,
operator|(
name|gint
operator|)
name|state
argument_list|,
name|locked
argument_list|,
name|tattoo
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|bzp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_bzpaths (PathList * paths,XcfInfo * info)
name|write_bzpaths
parameter_list|(
name|PathList
modifier|*
name|paths
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|guint32
name|num_paths
decl_stmt|;
comment|/* Write out the following:-    *    * last_selected_row (gint)    * number_of_paths (gint)    *    * then each path:-    */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|paths
operator|->
name|last_selected_row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num_paths
operator|=
name|g_slist_length
argument_list|(
name|paths
operator|->
name|bz_paths
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|g_slist_foreach
argument_list|(
name|paths
operator|->
name|bz_paths
argument_list|,
name|write_one_path
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PathList
modifier|*
DECL|function|read_bzpaths (GImage * gimage,XcfInfo * info)
name|read_bzpaths
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|guint32
name|num_paths
decl_stmt|;
name|guint32
name|last_selected_row
decl_stmt|;
name|PathList
modifier|*
name|paths
decl_stmt|;
name|GSList
modifier|*
name|bzp_list
init|=
name|NULL
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|last_selected_row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|num_paths
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_paths
operator|--
operator|>
literal|0
condition|)
block|{
name|Path
modifier|*
name|bzp
decl_stmt|;
comment|/* Read in a path */
name|bzp
operator|=
name|read_one_path
argument_list|(
name|gimage
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|bzp_list
operator|=
name|g_slist_append
argument_list|(
name|bzp_list
argument_list|,
name|bzp
argument_list|)
expr_stmt|;
block|}
name|paths
operator|=
name|path_list_new
argument_list|(
name|gimage
argument_list|,
name|last_selected_row
argument_list|,
name|bzp_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|paths
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_prop (XcfInfo * info,PropType prop_type,...)
name|xcf_save_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
name|prop_type
parameter_list|,
modifier|...
parameter_list|)
block|{
name|guint32
name|size
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_COLORMAP
case|:
block|{
name|guint32
name|ncolors
decl_stmt|;
name|guchar
modifier|*
name|colors
decl_stmt|;
name|ncolors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|colors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|+
name|ncolors
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|ncolors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|colors
argument_list|,
name|ncolors
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_ACTIVE_LAYER
case|:
case|case
name|PROP_ACTIVE_CHANNEL
case|:
case|case
name|PROP_SELECTION
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
block|{
name|guint32
name|dummy
decl_stmt|;
name|dummy
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|floating_sel_offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|gint32
name|opacity
decl_stmt|;
name|opacity
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_MODE
case|:
block|{
name|gint32
name|mode
decl_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|guint32
name|visible
decl_stmt|;
name|visible
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
block|{
name|guint32
name|linked
decl_stmt|;
name|linked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PRESERVE_TRANSPARENCY
case|:
block|{
name|guint32
name|preserve_trans
decl_stmt|;
name|preserve_trans
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|preserve_trans
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_APPLY_MASK
case|:
block|{
name|guint32
name|apply_mask
decl_stmt|;
name|apply_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_EDIT_MASK
case|:
block|{
name|guint32
name|edit_mask
decl_stmt|;
name|edit_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASK
case|:
block|{
name|guint32
name|show_mask
decl_stmt|;
name|show_mask
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
block|{
name|guint32
name|show_masked
decl_stmt|;
name|show_masked
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_OFFSETS
case|:
block|{
name|gint32
name|offsets
index|[
literal|2
index|]
decl_stmt|;
name|offsets
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|offsets
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COLOR
case|:
block|{
name|guchar
modifier|*
name|color
decl_stmt|;
name|color
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guchar
operator|*
argument_list|)
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|color
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|compression
operator|=
operator|(
name|guint8
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|GList
modifier|*
name|guides
decl_stmt|;
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
name|int
name|nguides
decl_stmt|;
name|guides
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GList
operator|*
argument_list|)
expr_stmt|;
name|nguides
operator|=
name|g_list_length
argument_list|(
name|guides
argument_list|)
expr_stmt|;
name|size
operator|=
name|nguides
operator|*
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|guides
condition|)
block|{
name|guide
operator|=
name|guides
operator|->
name|data
expr_stmt|;
name|guides
operator|=
name|guides
operator|->
name|next
expr_stmt|;
name|position
operator|=
name|guide
operator|->
name|position
expr_stmt|;
name|orientation
operator|=
name|guide
operator|->
name|orientation
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|float
name|xresolution
decl_stmt|,
name|yresolution
decl_stmt|;
comment|/* we pass in floats, but they are promoted to double by the compiler */
name|xresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|yresolution
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
operator|*
literal|2
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|xresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|yresolution
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|guint32
name|tattoo
decl_stmt|;
name|tattoo
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|ParasiteList
modifier|*
name|list
decl_stmt|;
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|list
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|ParasiteList
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_list_persistent_length
argument_list|(
name|list
argument_list|)
operator|>
literal|0
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the parasite list will take 	     * we save the file position and write the length later 	     */
name|pos
operator|=
name|ftell
argument_list|(
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|parasite_list_foreach
argument_list|(
name|list
argument_list|,
operator|(
name|GHFunc
operator|)
name|write_a_parasite
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_UNIT
case|:
block|{
name|guint32
name|unit
decl_stmt|;
name|unit
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PATHS
case|:
block|{
name|PathList
modifier|*
name|paths_list
decl_stmt|;
name|guint32
name|base
decl_stmt|,
name|length
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|paths_list
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|PathList
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths_list
condition|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* because we don't know how much room the paths list will take 	     we save the file position and write the length later  	     ALT. OK I copied the code from above... 	  */
name|pos
operator|=
name|ftell
argument_list|(
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|write_bzpaths
argument_list|(
name|paths_list
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|length
operator|=
name|info
operator|->
name|cp
operator|-
name|base
expr_stmt|;
comment|/* go back to the saved position and write the length */
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PROP_USER_UNIT
case|:
block|{
name|GimpUnit
name|unit
decl_stmt|;
name|gchar
modifier|*
name|unit_strings
index|[
literal|5
index|]
decl_stmt|;
name|gfloat
name|factor
decl_stmt|;
name|guint32
name|digits
decl_stmt|;
name|unit
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint32
argument_list|)
expr_stmt|;
comment|/* write the entire unit definition */
name|unit_strings
index|[
literal|0
index|]
operator|=
name|gimp_unit_get_identifier
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|factor
operator|=
name|gimp_unit_get_factor
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|digits
operator|=
name|gimp_unit_get_digits
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|1
index|]
operator|=
name|gimp_unit_get_symbol
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|2
index|]
operator|=
name|gimp_unit_get_abbreviation
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|3
index|]
operator|=
name|gimp_unit_get_singular
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit_strings
index|[
literal|4
index|]
operator|=
name|gimp_unit_get_plural
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|*
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|1
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|1
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|2
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|2
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|3
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|3
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
operator|+
name|strlen
argument_list|(
name|unit_strings
index|[
literal|4
index|]
argument_list|)
condition|?
name|strlen
argument_list|(
name|unit_strings
index|[
literal|4
index|]
argument_list|)
operator|+
literal|5
else|:
literal|4
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|factor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|digits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|unit_strings
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_layer (XcfInfo * info,GImage * gimage,GimpLayer * layer)
name|xcf_save_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|saved_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width, height and image type information for the layer */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the layers name */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_OBJECT
argument_list|(
name|layer
argument_list|)
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the layer properties */
name|xcf_save_layer_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer tile hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the layer mask */
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_channel (XcfInfo * info,GImage * gimage,GimpChannel * channel)
name|xcf_save_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
comment|/* check and see if this is the drawable that the floating    *  selection is attached to.    */
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|==
name|info
operator|->
name|floating_sel_drawable
condition|)
block|{
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|floating_sel_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|info
operator|->
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
comment|/* write out the width and height information for the channel */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channels name */
name|info
operator|->
name|cp
operator|+=
name|xcf_write_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_OBJECT
argument_list|(
name|channel
argument_list|)
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write out the channel properties */
name|xcf_save_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* save the current position which is where the hierarchy offset    *  will be stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the channel tile hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|xcf_save_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tiles
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|xcf_calc_levels (gint size,gint tile_size)
name|xcf_calc_levels
parameter_list|(
name|gint
name|size
parameter_list|,
name|gint
name|tile_size
parameter_list|)
block|{
name|int
name|levels
decl_stmt|;
name|levels
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|tile_size
condition|)
block|{
name|size
operator|/=
literal|2
expr_stmt|;
name|levels
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|levels
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_hierarchy (XcfInfo * info,TileManager * tiles)
name|xcf_save_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|width
decl_stmt|;
name|guint32
name|height
decl_stmt|;
name|guint32
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|nlevels
decl_stmt|;
name|gint
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
name|tmp1
operator|=
name|xcf_calc_levels
argument_list|(
name|width
argument_list|,
name|TILE_WIDTH
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|xcf_calc_levels
argument_list|(
name|height
argument_list|,
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|MAX
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
literal|1
operator|+
name|nlevels
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* write out the level. */
name|xcf_save_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fake an empty level */
name|tmp1
operator|=
literal|0
expr_stmt|;
name|width
operator|/=
literal|2
expr_stmt|;
name|height
operator|/=
literal|2
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|tmp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* seek back to where we are to write out the next        *  level offset and write it out.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the        *  next offset.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where        *  we will write out the next level.        */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_level (XcfInfo * info,TileManager * level)
name|xcf_save_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|level
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|width
decl_stmt|;
name|guint32
name|height
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guchar
modifier|*
name|rlebuf
decl_stmt|;
name|width
operator|=
name|tile_manager_width
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|height
operator|=
name|tile_manager_height
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* allocate a temporary buffer to store the rle data before it is      written to disk */
name|rlebuf
operator|=
name|g_malloc
argument_list|(
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
name|tile_manager_bpp
argument_list|(
name|level
argument_list|)
operator|*
literal|1.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|tiles
condition|)
block|{
name|ntiles
operator|=
name|level
operator|->
name|ntile_rows
operator|*
name|level
operator|->
name|ntile_cols
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
operator|(
name|ntiles
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
comment|/* save the start offset of where we are writing 	   *  out the next tile. 	   */
name|offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* write out the tile. */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
name|xcf_save_tile
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
name|xcf_save_tile_rle
argument_list|(
name|info
argument_list|,
name|level
operator|->
name|tiles
index|[
name|i
index|]
argument_list|,
name|rlebuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|g_error
argument_list|(
literal|"xcf: fractal compression unimplemented"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* seek back to where we are to write out the next 	   *  tile offset and write it out. 	   */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment the location we are to write out the 	   *  next offset. 	   */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the end of the file which is where 	   *  we will write out the next tile. 	   */
name|xcf_seek_end
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|rlebuf
argument_list|)
expr_stmt|;
comment|/* write out a '0' offset position to indicate the end    *  of the level offsets.    */
name|offset
operator|=
literal|0
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_tile (XcfInfo * info,Tile * tile)
name|xcf_save_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_save_tile_rle (XcfInfo * info,Tile * tile,guchar * rlebuf)
name|xcf_save_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|guchar
modifier|*
name|rlebuf
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|gint
name|state
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|len
init|=
literal|0
decl_stmt|;
name|tile_lock
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* in state 0 we try to find a long sequence of 	       *  matching values. 	       */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
operator|)
condition|)
block|{
name|count
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|127
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|last
expr_stmt|;
block|}
else|else
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|last
expr_stmt|;
block|}
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|*
name|data
operator|)
condition|)
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* in state 1 we try and find a long sequence of 	       *  non-matching values. 	       */
if|if
condition|(
operator|(
name|length
operator|==
literal|32768
operator|)
operator|||
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|last
operator|==
operator|*
name|data
operator|)
operator|&&
operator|(
operator|(
name|size
operator|-
name|length
operator|)
operator|==
literal|1
operator|||
name|last
operator|==
name|data
index|[
name|bpp
index|]
operator|)
operator|)
condition|)
block|{
name|count
operator|+=
name|length
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|255
operator|-
literal|127
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
expr_stmt|;
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
name|length
operator|&
literal|0x00FF
expr_stmt|;
block|}
else|else
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|t
operator|=
name|data
operator|-
name|length
operator|*
name|bpp
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
name|rlebuf
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|+=
name|bpp
expr_stmt|;
block|}
name|size
operator|-=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|length
operator|+=
literal|1
expr_stmt|;
name|last
operator|=
operator|*
name|data
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
operator|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
condition|)
name|g_message
argument_list|(
literal|"xcf: uh oh! xcf rle tile saving error: %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|cp
operator|+=
name|xcf_write_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|rlebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|xcf_load_image (XcfInfo * info)
name|xcf_load_image
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|image_type
decl_stmt|;
name|gint
name|num_successful_elements
init|=
literal|0
decl_stmt|;
comment|/* read in the image width, height and type */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|image_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new gimage */
name|gimage
operator|=
name|gimage_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimage
condition|)
return|return
name|NULL
return|;
comment|/* read the image properties */
if|if
condition|(
operator|!
name|xcf_load_image_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
condition|)
goto|goto
name|hard_error
goto|;
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* read in the offset of the next layer */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the layer list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next layer offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the layer offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the layer */
name|layer
operator|=
name|xcf_load_layer
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
goto|goto
name|error
goto|;
name|num_successful_elements
operator|++
expr_stmt|;
comment|/* add the layer to the image if its not the floating selection */
if|if
condition|(
name|layer
operator|!=
name|info
operator|->
name|floating_sel
condition|)
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|gimp_container_num_children
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* read in the offset of the next channel */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we are at the end        *  of the channel list.        */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
comment|/* save the current position as it is where the        *  next channel offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the channel offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the layer */
name|channel
operator|=
name|xcf_load_channel
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
goto|goto
name|error
goto|;
name|num_successful_elements
operator|++
expr_stmt|;
comment|/* add the channel to the image if its not the selection */
if|if
condition|(
name|channel
operator|!=
name|gimage
operator|->
name|selection_mask
condition|)
name|gimp_image_add_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|active_layer
condition|)
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|info
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|active_channel
condition|)
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|info
operator|->
name|active_channel
argument_list|)
expr_stmt|;
name|gimp_object_set_name
argument_list|(
name|GIMP_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
name|error
label|:
if|if
condition|(
name|num_successful_elements
operator|==
literal|0
condition|)
goto|goto
name|hard_error
goto|;
name|g_message
argument_list|(
literal|"XCF: This file is corrupt!  I have loaded as much\n"
literal|"of it as I can, but it is incomplete."
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
name|hard_error
label|:
name|g_message
argument_list|(
literal|"XCF: This file is corrupt!  I could not even\n"
literal|"salvage any partial image data from it."
argument_list|)
expr_stmt|;
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_image_props (XcfInfo * info,GImage * gimage)
name|xcf_load_image_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_COLORMAP
case|:
if|if
condition|(
name|info
operator|->
name|file_version
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|g_message
argument_list|(
name|_
argument_list|(
literal|"XCF warning: version 0 of XCF file format\n"
literal|"did not save indexed colormaps correctly.\n"
literal|"Substituting grayscale map."
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|num_cols
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|cp
operator|+
name|gimage
operator|->
name|num_cols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gimage
operator|->
name|num_cols
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|gimage
operator|->
name|cmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|gimage
operator|->
name|num_cols
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_COMPRESSION
case|:
block|{
name|guint8
name|compression
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|compression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compression
operator|!=
name|COMPRESS_NONE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_RLE
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_ZLIB
operator|)
operator|&&
operator|(
name|compression
operator|!=
name|COMPRESS_FRACTAL
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"unknown compression type: %d"
argument_list|,
operator|(
name|int
operator|)
name|compression
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|->
name|compression
operator|=
name|compression
expr_stmt|;
block|}
break|break;
case|case
name|PROP_GUIDES
case|:
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|gint8
name|orientation
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|nguides
decl_stmt|;
name|nguides
operator|=
name|prop_size
operator|/
operator|(
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nguides
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|position
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|orientation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|orientation
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
name|gimage
operator|->
name|guides
operator|=
name|g_list_reverse
argument_list|(
name|gimage
operator|->
name|guides
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
block|{
name|gfloat
name|xres
decl_stmt|,
name|yres
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|xres
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|yres
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xres
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|xres
operator|>
name|GIMP_MAX_RESOLUTION
operator|||
name|yres
operator|<
name|GIMP_MIN_RESOLUTION
operator|||
name|yres
operator|>
name|GIMP_MAX_RESOLUTION
condition|)
block|{
name|g_message
argument_list|(
literal|"Warning, resolution out of range in XCF file"
argument_list|)
expr_stmt|;
name|xres
operator|=
name|default_xresolution
expr_stmt|;
name|yres
operator|=
name|default_yresolution
expr_stmt|;
block|}
name|gimage
operator|->
name|xresolution
operator|=
name|xres
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|yres
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|gimage
operator|->
name|tattoo_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|glong
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|gimage
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
literal|"Error detected while loading an image's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_UNIT
case|:
block|{
name|guint32
name|unit
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|<=
name|GIMP_UNIT_PIXEL
operator|)
operator|||
operator|(
name|unit
operator|>=
name|gimp_unit_get_number_of_built_in_units
argument_list|()
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"Warning, unit out of range in XCF file, falling back to inches"
argument_list|)
expr_stmt|;
name|unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
block|}
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PATHS
case|:
block|{
name|PathList
modifier|*
name|paths
init|=
name|read_bzpaths
argument_list|(
name|gimage
argument_list|,
name|info
argument_list|)
decl_stmt|;
comment|/* add to gimage */
name|gimp_image_set_paths
argument_list|(
name|gimage
argument_list|,
name|paths
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_USER_UNIT
case|:
block|{
name|gchar
modifier|*
name|unit_strings
index|[
literal|5
index|]
decl_stmt|;
name|float
name|factor
decl_stmt|;
name|guint32
name|digits
decl_stmt|;
name|GimpUnit
name|unit
decl_stmt|;
name|gint
name|num_units
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_float
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|factor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|digits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|unit_strings
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|unit_strings
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|unit_strings
index|[
name|i
index|]
operator|=
name|g_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|num_units
operator|=
name|gimp_unit_get_number_of_units
argument_list|()
expr_stmt|;
for|for
control|(
name|unit
operator|=
name|gimp_unit_get_number_of_built_in_units
argument_list|()
init|;
name|unit
operator|<
name|num_units
condition|;
name|unit
operator|++
control|)
block|{
comment|/* if the factor and the identifier match some unit 		 * in unitrc, use the unitrc unit 		 */
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|gimp_unit_get_factor
argument_list|(
name|unit
argument_list|)
operator|-
name|factor
argument_list|)
operator|<
literal|1e-5
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|,
name|gimp_unit_get_identifier
argument_list|(
name|unit
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* no match */
if|if
condition|(
name|unit
operator|==
name|num_units
condition|)
name|unit
operator|=
name|gimp_unit_new
argument_list|(
name|unit_strings
index|[
literal|0
index|]
argument_list|,
name|factor
argument_list|,
name|digits
argument_list|,
name|unit_strings
index|[
literal|1
index|]
argument_list|,
name|unit_strings
index|[
literal|2
index|]
argument_list|,
name|unit_strings
index|[
literal|3
index|]
argument_list|,
name|unit_strings
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|unit_strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
literal|"unexpected/unknown image property: %d (skipping)"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_layer_props (XcfInfo * info,GImage * gimage,GimpLayer * layer,gboolean * apply_mask,gboolean * edit_mask,gboolean * show_mask)
name|xcf_load_layer_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpLayer
modifier|*
name|layer
parameter_list|,
name|gboolean
modifier|*
name|apply_mask
parameter_list|,
name|gboolean
modifier|*
name|edit_mask
parameter_list|,
name|gboolean
modifier|*
name|show_mask
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_LAYER
case|:
name|info
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
name|info
operator|->
name|floating_sel
operator|=
name|layer
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|info
operator|->
name|floating_sel_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|gboolean
name|visible
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|visible
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_LINKED
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|linked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PRESERVE_TRANSPARENCY
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|preserve_trans
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_APPLY_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|apply_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_EDIT_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|edit_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASK
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|show_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_MODE
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|layer
operator|->
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|long
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_drawable_parasite_attach
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
literal|"Error detected while loading a layer's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
literal|"unexpected/unknown layer property: %d (skipping)"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_channel_props (XcfInfo * info,GImage * gimage,GimpChannel * channel)
name|xcf_load_channel_props
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpChannel
modifier|*
name|channel
parameter_list|)
block|{
name|PropType
name|prop_type
decl_stmt|;
name|guint32
name|prop_size
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|xcf_load_prop
argument_list|(
name|info
argument_list|,
operator|&
name|prop_type
argument_list|,
operator|&
name|prop_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
name|TRUE
return|;
case|case
name|PROP_ACTIVE_CHANNEL
case|:
name|info
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
break|break;
case|case
name|PROP_SELECTION
case|:
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|selection_mask
operator|=
name|channel
expr_stmt|;
name|channel
operator|->
name|boundary_known
operator|=
name|FALSE
expr_stmt|;
name|channel
operator|->
name|bounds_known
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
block|{
name|guint32
name|opacity
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|opacity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|channel
operator|->
name|color
operator|.
name|a
operator|=
name|opacity
operator|/
literal|255.0
expr_stmt|;
block|}
break|break;
case|case
name|PROP_VISIBLE
case|:
block|{
name|gboolean
name|visible
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|visible
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
name|visible
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|channel
operator|->
name|show_masked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_COLOR
case|:
block|{
name|guchar
name|col
index|[
literal|3
index|]
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gimp_rgb_set_uchar
argument_list|(
operator|&
name|channel
operator|->
name|color
argument_list|,
name|col
index|[
literal|0
index|]
argument_list|,
name|col
index|[
literal|1
index|]
argument_list|,
name|col
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TATTOO
case|:
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tattoo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
block|{
name|long
name|base
init|=
name|info
operator|->
name|cp
decl_stmt|;
name|GimpParasite
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|info
operator|->
name|cp
operator|-
name|base
operator|)
operator|<
name|prop_size
condition|)
block|{
name|p
operator|=
name|read_a_parasite
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|gimp_drawable_parasite_attach
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cp
operator|-
name|base
operator|!=
name|prop_size
condition|)
name|g_message
argument_list|(
literal|"Error detected while loading a channel's parasites"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
literal|"unexpected/unknown channel property: %d (skipping)"
argument_list|,
name|prop_type
argument_list|)
expr_stmt|;
block|{
name|guint8
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|guint
name|amount
decl_stmt|;
while|while
condition|(
name|prop_size
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|MIN
argument_list|(
literal|16
argument_list|,
name|prop_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|buf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|prop_size
operator|-=
name|MIN
argument_list|(
literal|16
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_prop (XcfInfo * info,PropType * prop_type,guint32 * prop_size)
name|xcf_load_prop
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|PropType
modifier|*
name|prop_type
parameter_list|,
name|guint32
modifier|*
name|prop_size
parameter_list|)
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
name|prop_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|GimpLayer
modifier|*
DECL|function|xcf_load_layer (XcfInfo * info,GImage * gimage)
name|xcf_load_layer
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GimpLayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|guint32
name|layer_mask_offset
decl_stmt|;
name|gboolean
name|apply_mask
decl_stmt|;
name|gboolean
name|edit_mask
decl_stmt|;
name|gboolean
name|show_mask
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gint
name|add_floating_sel
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height, type and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
literal|255
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer
condition|)
return|return
name|NULL
return|;
comment|/* read in the layer properties */
if|if
condition|(
operator|!
name|xcf_load_layer_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|apply_mask
argument_list|,
operator|&
name|edit_mask
argument_list|,
operator|&
name|show_mask
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|layer_mask_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read in the layer mask */
if|if
condition|(
name|layer_mask_offset
operator|!=
literal|0
condition|)
block|{
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|layer_mask_offset
argument_list|)
expr_stmt|;
name|layer_mask
operator|=
name|xcf_load_layer_mask
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
goto|goto
name|error
goto|;
comment|/* set the offsets of the layer_mask */
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|offset_x
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_x
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|offset_y
operator|=
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
operator|->
name|offset_y
expr_stmt|;
name|gimp_layer_add_mask
argument_list|(
name|layer
argument_list|,
name|layer_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|layer
operator|->
name|mask
operator|->
name|apply_mask
operator|=
name|apply_mask
expr_stmt|;
name|layer
operator|->
name|mask
operator|->
name|edit_mask
operator|=
name|edit_mask
expr_stmt|;
name|layer
operator|->
name|mask
operator|->
name|show_mask
operator|=
name|show_mask
expr_stmt|;
block|}
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|layer
return|;
name|error
label|:
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpChannel
modifier|*
DECL|function|xcf_load_channel (XcfInfo * info,GImage * gimage)
name|xcf_load_channel
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpChannel
modifier|*
name|channel
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|add_floating_sel
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpRGB
name|color
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|1.0
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new channel */
name|channel
operator|=
name|gimp_channel_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
return|return
name|NULL
return|;
comment|/* read in the channel properties */
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|channel
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|channel
return|;
name|error
label|:
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpLayerMask
modifier|*
DECL|function|xcf_load_layer_mask (XcfInfo * info,GImage * gimage)
name|xcf_load_layer_mask
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GimpLayerMask
modifier|*
name|layer_mask
decl_stmt|;
name|guint32
name|hierarchy_offset
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|add_floating_sel
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
name|GimpRGB
name|color
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|1.0
block|}
decl_stmt|;
comment|/* check and see if this is the drawable the floating selection    *  is attached to. if it is then we'll do the attachment at    *  the end of this function.    */
name|add_floating_sel
operator|=
operator|(
name|info
operator|->
name|cp
operator|==
name|info
operator|->
name|floating_sel_offset
operator|)
expr_stmt|;
comment|/* read in the layer width, height and name */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_string
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create a new layer mask */
name|layer_mask
operator|=
name|gimp_layer_mask_new
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|name
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layer_mask
condition|)
return|return
name|NULL
return|;
comment|/* read in the layer_mask properties */
if|if
condition|(
operator|!
name|xcf_load_channel_props
argument_list|(
name|info
argument_list|,
name|gimage
argument_list|,
name|GIMP_CHANNEL
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the hierarchy and layer mask offsets */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|hierarchy_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read in the hierarchy */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|hierarchy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcf_load_hierarchy
argument_list|(
name|info
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
operator|->
name|tiles
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* attach the floating selection... */
if|if
condition|(
name|add_floating_sel
condition|)
block|{
name|GimpLayer
modifier|*
name|floating_sel
decl_stmt|;
name|floating_sel
operator|=
name|info
operator|->
name|floating_sel
expr_stmt|;
name|floating_sel_attach
argument_list|(
name|floating_sel
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|layer_mask
return|;
name|error
label|:
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|layer_mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_hierarchy (XcfInfo * info,TileManager * tiles)
name|xcf_load_hierarchy
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|;
name|guint32
name|junk
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|bpp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure the values in the file correspond to the values    *  calculated when the TileManager was created.    */
if|if
condition|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
operator|||
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
operator|||
name|bpp
operator|!=
name|tile_manager_bpp
argument_list|(
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* load in the levels...we make sure that the number of levels    *  calculated when the TileManager was created is the same    *  as the number of levels found in the file.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* top level */
comment|/* discard offsets for layers below first, if any.    */
do|do
block|{
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|junk
operator|!=
literal|0
condition|)
do|;
comment|/* save the current position as it is where the    *  next level offset is stored.    */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* seek to the level offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* read in the level */
if|if
condition|(
operator|!
name|xcf_load_level
argument_list|(
name|info
argument_list|,
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* restore the saved position so we'll be ready to    *  read the next offset.    */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_level (XcfInfo * info,TileManager * tiles)
name|xcf_load_level
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|TileManager
modifier|*
name|tiles
parameter_list|)
block|{
name|guint32
name|saved_pos
decl_stmt|;
name|guint32
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|guint
name|ntiles
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|fail
decl_stmt|;
name|Tile
modifier|*
name|previous
decl_stmt|;
name|Tile
modifier|*
name|tile
decl_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|&
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|tile_manager_width
argument_list|(
name|tiles
argument_list|)
operator|||
name|height
operator|!=
name|tile_manager_height
argument_list|(
name|tiles
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* read in the first tile offset.    *  if it is '0', then this tile level is empty    *  and we can simply return.    */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Initialise the reference for the in-memory tile-compression    */
name|previous
operator|=
name|NULL
expr_stmt|;
name|ntiles
operator|=
name|tiles
operator|->
name|ntile_rows
operator|*
name|tiles
operator|->
name|ntile_cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntiles
condition|;
name|i
operator|++
control|)
block|{
name|fail
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"not enough tiles found in level"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* save the current position as it is where the        *  next tile offset is stored.        */
name|saved_pos
operator|=
name|info
operator|->
name|cp
expr_stmt|;
comment|/* read in the offset of the next tile so we can calculate the amount 	 of data needed for this tile*/
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the offset is 0 then we need to read in the maximum possible 	 allowing for negative compression */
if|if
condition|(
name|offset2
operator|==
literal|0
condition|)
name|offset2
operator|=
name|offset
operator|+
name|TILE_WIDTH
operator|*
name|TILE_WIDTH
operator|*
literal|4
operator|*
literal|1.5
expr_stmt|;
comment|/* 1.5 is probably more 					   than we need to allow */
comment|/* seek to the tile offset */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* get the tile from the tile manager */
name|tile
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* read in the tile */
switch|switch
condition|(
name|info
operator|->
name|compression
condition|)
block|{
case|case
name|COMPRESS_NONE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile
argument_list|(
name|info
argument_list|,
name|tile
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_RLE
case|:
if|if
condition|(
operator|!
name|xcf_load_tile_rle
argument_list|(
name|info
argument_list|,
name|tile
argument_list|,
name|offset2
operator|-
name|offset
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_ZLIB
case|:
name|g_error
argument_list|(
literal|"xcf: zlib compression unimplemented"
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COMPRESS_FRACTAL
case|:
name|g_error
argument_list|(
literal|"xcf: fractal compression unimplemented"
argument_list|)
expr_stmt|;
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* To potentially save memory, we compare the        *  newly-fetched tile against the last one, and        *  if they're the same we copy-on-write mirror one against        *  the other.        */
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
name|tile_lock
argument_list|(
name|previous
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_ewidth
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_eheight
argument_list|(
name|previous
argument_list|)
operator|&&
name|tile_bpp
argument_list|(
name|tile
argument_list|)
operator|==
name|tile_bpp
argument_list|(
name|previous
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_data_pointer
argument_list|(
name|previous
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|tile_manager_map
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|previous
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|tile_release
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|previous
operator|=
name|tile_manager_get
argument_list|(
name|tiles
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore the saved position so we'll be ready to        *  read the next offset.        */
name|xcf_seek_pos
argument_list|(
name|info
argument_list|,
name|saved_pos
argument_list|)
expr_stmt|;
comment|/* read in the offset of the next tile */
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int32
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"encountered garbage after reading level: %d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_tile (XcfInfo * info,Tile * tile)
name|xcf_load_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
if|if
condition|(
operator|!
name|info
operator|->
name|swap_num
condition|)
block|{
name|info
operator|->
name|ref_count
operator|=
name|g_new
argument_list|(
name|int
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|swap_num
operator|=
name|tile_swap_add
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|xcf_swap_func
argument_list|,
name|info
operator|->
name|ref_count
argument_list|)
expr_stmt|;
block|}
name|tile
operator|->
name|swap_num
operator|=
name|info
operator|->
name|swap_num
expr_stmt|;
name|tile
operator|->
name|swap_offset
operator|=
name|info
operator|->
name|cp
expr_stmt|;
operator|*
name|info
operator|->
name|ref_count
operator|+=
literal|1
expr_stmt|;
else|#
directive|else
name|info
operator|->
name|cp
operator|+=
name|xcf_read_int8
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tile_size
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|xcf_load_tile_rle (XcfInfo * info,Tile * tile,int data_length)
name|xcf_load_tile_rle
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
name|guchar
modifier|*
name|data
decl_stmt|;
name|guchar
name|val
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|nmemb_read_successfully
decl_stmt|;
name|guchar
modifier|*
name|xcfdata
decl_stmt|,
modifier|*
name|xcfodata
decl_stmt|,
modifier|*
name|xcfdatalimit
decl_stmt|;
name|data
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|tile_bpp
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|xcfdata
operator|=
name|xcfodata
operator|=
name|g_malloc
argument_list|(
name|data_length
argument_list|)
expr_stmt|;
comment|/* we have to use fread instead of xcf_read_* because we may be      reading past the end of the file here */
name|nmemb_read_successfully
operator|=
name|fread
argument_list|(
operator|(
name|gchar
operator|*
operator|)
name|xcfdata
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|data_length
argument_list|,
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|+=
name|nmemb_read_successfully
expr_stmt|;
name|xcfdatalimit
operator|=
operator|&
name|xcfodata
index|[
name|nmemb_read_successfully
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|i
expr_stmt|;
name|size
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|val
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
name|length
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|128
condition|)
block|{
name|length
operator|=
literal|255
operator|-
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>=
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|length
operator|=
operator|(
operator|*
name|xcfdata
operator|<<
literal|8
operator|)
operator|+
name|xcfdata
index|[
literal|1
index|]
expr_stmt|;
name|xcfdata
operator|+=
literal|2
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
if|if
condition|(
operator|&
name|xcfdata
index|[
name|length
operator|-
literal|1
index|]
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|data
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|128
condition|)
block|{
if|if
condition|(
name|xcfdata
operator|>=
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|length
operator|=
operator|(
operator|*
name|xcfdata
operator|<<
literal|8
operator|)
operator|+
name|xcfdata
index|[
literal|1
index|]
expr_stmt|;
name|xcfdata
operator|+=
literal|2
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
name|size
operator|-=
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
if|if
condition|(
name|xcfdata
operator|>
name|xcfdatalimit
condition|)
block|{
goto|goto
name|bogus_rle
goto|;
block|}
name|val
operator|=
operator|*
name|xcfdata
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|data
operator|=
name|val
expr_stmt|;
name|data
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
block|}
name|g_free
argument_list|(
name|xcfodata
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|bogus_rle
label|:
if|if
condition|(
name|xcfodata
condition|)
name|g_free
argument_list|(
name|xcfodata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SWAP_FROM_FILE
end_ifdef

begin_function
specifier|static
name|gboolean
DECL|function|xcf_swap_func (gint fd,Tile * tile,gint cmd,gpointer user_data)
name|xcf_swap_func
parameter_list|(
name|gint
name|fd
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|gint
name|cmd
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|gint
name|bytes
decl_stmt|;
name|gint
name|err
decl_stmt|;
name|gint
name|nleft
decl_stmt|;
name|gint
modifier|*
name|ref_count
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SWAP_IN
case|:
name|lseek
argument_list|(
name|fd
argument_list|,
name|tile
operator|->
name|swap_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|tile_size
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|tile_alloc
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|bytes
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|err
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tile
operator|->
name|data
operator|+
name|bytes
operator|-
name|nleft
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|err
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
operator|||
operator|(
name|errno
operator|==
name|EINTR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"unable to read tile data from xcf file: %d ( %d ) bytes read"
argument_list|,
name|err
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|nleft
operator|-=
name|err
expr_stmt|;
block|}
break|break;
case|case
name|SWAP_OUT
case|:
case|case
name|SWAP_DELETE
case|:
case|case
name|SWAP_COMPRESS
case|:
name|ref_count
operator|=
name|user_data
expr_stmt|;
operator|*
name|ref_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ref_count
operator|==
literal|0
condition|)
block|{
name|tile_swap_remove
argument_list|(
name|tile
operator|->
name|swap_num
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ref_count
argument_list|)
expr_stmt|;
block|}
name|tile
operator|->
name|swap_num
operator|=
literal|1
expr_stmt|;
name|tile
operator|->
name|swap_offset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|xcf_seek_pos (XcfInfo * info,guint pos)
name|xcf_seek_pos
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|guint
name|pos
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|cp
operator|!=
name|pos
condition|)
block|{
name|info
operator|->
name|cp
operator|=
name|pos
expr_stmt|;
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
name|info
operator|->
name|cp
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xcf_seek_end (XcfInfo * info)
name|xcf_seek_end
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|)
block|{
name|fseek
argument_list|(
name|info
operator|->
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|info
operator|->
name|cp
operator|=
name|ftell
argument_list|(
name|info
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_int32 (FILE * fp,guint32 * data,gint count)
name|xcf_read_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|xcf_read_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
argument_list|,
name|count
operator|*
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
name|data
operator|=
name|g_ntohl
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
return|return
name|total
operator|*
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_float (FILE * fp,gfloat * data,gint count)
name|xcf_read_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
return|return
operator|(
name|xcf_read_int32
argument_list|(
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|data
operator|)
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_int8 (FILE * fp,guint8 * data,gint count)
name|xcf_read_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bytes
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
comment|/* something bad happened */
break|break;
name|count
operator|-=
name|bytes
expr_stmt|;
name|data
operator|+=
name|bytes
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_read_string (FILE * fp,gchar ** data,gint count)
name|xcf_read_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|guint
name|total
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|xcf_read_int32
argument_list|(
name|fp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|total
operator|+=
name|xcf_read_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_int32 (FILE * fp,guint32 * data,gint count)
name|xcf_write_int32
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint32
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|g_htonl
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xcf_write_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
operator|&
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
operator|*
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_float (FILE * fp,gfloat * data,gint count)
name|xcf_write_float
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
return|return
operator|(
name|xcf_write_int32
argument_list|(
name|fp
argument_list|,
operator|(
name|guint32
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|data
operator|)
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_int8 (FILE * fp,guint8 * data,gint count)
name|xcf_write_int8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint8
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint
name|total
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|total
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bytes
operator|=
name|fwrite
argument_list|(
operator|(
name|gchar
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|gchar
argument_list|)
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|count
operator|-=
name|bytes
expr_stmt|;
name|data
operator|+=
name|bytes
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|xcf_write_string (FILE * fp,gchar ** data,gint count)
name|xcf_write_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gchar
modifier|*
modifier|*
name|data
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|guint32
name|tmp
decl_stmt|;
name|guint
name|total
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
condition|)
name|tmp
operator|=
name|strlen
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|tmp
operator|=
literal|0
expr_stmt|;
name|xcf_write_int32
argument_list|(
name|fp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
name|xcf_write_int8
argument_list|(
name|fp
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|data
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|total
operator|+=
literal|4
operator|+
name|tmp
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

end_unit

