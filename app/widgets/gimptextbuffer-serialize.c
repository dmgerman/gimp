begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * GimpTextBuffer-serialize  * Copyright (C) 2010  Michael Natterer<mitch@gimp.org>  *  * inspired by  * gtktextbufferserialize.c  * Copyright (C) 2004  Nokia Corporation.  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"widgets-types.h"
end_include

begin_include
include|#
directive|include
file|"gimptextbuffer.h"
end_include

begin_include
include|#
directive|include
file|"gimptextbuffer-serialize.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_comment
comment|/*  serialize  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_list_delta (GSList * old_list,GSList * new_list,GList ** added,GList ** removed)
name|find_list_delta
parameter_list|(
name|GSList
modifier|*
name|old_list
parameter_list|,
name|GSList
modifier|*
name|new_list
parameter_list|,
name|GList
modifier|*
modifier|*
name|added
parameter_list|,
name|GList
modifier|*
modifier|*
name|removed
parameter_list|)
block|{
name|GSList
modifier|*
name|tmp
decl_stmt|;
name|GList
modifier|*
name|tmp_added
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|tmp_removed
init|=
name|NULL
decl_stmt|;
comment|/* Find added tags */
for|for
control|(
name|tmp
operator|=
name|new_list
init|;
name|tmp
condition|;
name|tmp
operator|=
name|g_slist_next
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|g_slist_find
argument_list|(
name|old_list
argument_list|,
name|tmp
operator|->
name|data
argument_list|)
condition|)
name|tmp_added
operator|=
name|g_list_prepend
argument_list|(
name|tmp_added
argument_list|,
name|tmp
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
operator|*
name|added
operator|=
name|tmp_added
expr_stmt|;
comment|/* Find removed tags */
for|for
control|(
name|tmp
operator|=
name|old_list
init|;
name|tmp
condition|;
name|tmp
operator|=
name|g_slist_next
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|g_slist_find
argument_list|(
name|new_list
argument_list|,
name|tmp
operator|->
name|data
argument_list|)
condition|)
name|tmp_removed
operator|=
name|g_list_prepend
argument_list|(
name|tmp_removed
argument_list|,
name|tmp
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* We reverse the list here to match the xml semantics */
operator|*
name|removed
operator|=
name|g_list_reverse
argument_list|(
name|tmp_removed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|open_tag (GimpTextBuffer * buffer,GString * string,GtkTextTag * tag)
name|open_tag
parameter_list|(
name|GimpTextBuffer
modifier|*
name|buffer
parameter_list|,
name|GString
modifier|*
name|string
parameter_list|,
name|GtkTextTag
modifier|*
name|tag
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|attribute
decl_stmt|;
name|gchar
modifier|*
name|attribute_value
decl_stmt|;
name|name
operator|=
name|gimp_text_buffer_tag_to_name
argument_list|(
name|buffer
argument_list|,
name|tag
argument_list|,
operator|&
name|attribute
argument_list|,
operator|&
name|attribute_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|attribute
operator|&&
name|attribute_value
condition|)
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<%s %s=\"%s\">"
argument_list|,
name|name
argument_list|,
name|attribute
argument_list|,
name|attribute_value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|attribute_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|close_tag (GimpTextBuffer * buffer,GString * string,GtkTextTag * tag)
name|close_tag
parameter_list|(
name|GimpTextBuffer
modifier|*
name|buffer
parameter_list|,
name|GString
modifier|*
name|string
parameter_list|,
name|GtkTextTag
modifier|*
name|tag
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|name
init|=
name|gimp_text_buffer_tag_to_name
argument_list|(
name|buffer
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"</%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|guint8
modifier|*
DECL|function|gimp_text_buffer_serialize (GtkTextBuffer * register_buffer,GtkTextBuffer * content_buffer,const GtkTextIter * start,const GtkTextIter * end,gsize * length,gpointer user_data)
name|gimp_text_buffer_serialize
parameter_list|(
name|GtkTextBuffer
modifier|*
name|register_buffer
parameter_list|,
name|GtkTextBuffer
modifier|*
name|content_buffer
parameter_list|,
specifier|const
name|GtkTextIter
modifier|*
name|start
parameter_list|,
specifier|const
name|GtkTextIter
modifier|*
name|end
parameter_list|,
name|gsize
modifier|*
name|length
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|GString
modifier|*
name|string
decl_stmt|;
name|GtkTextIter
name|iter
decl_stmt|,
name|old_iter
decl_stmt|;
name|GSList
modifier|*
name|tag_list
decl_stmt|,
modifier|*
name|new_tag_list
decl_stmt|;
name|GSList
modifier|*
name|active_tags
decl_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
literal|"<markup>"
argument_list|)
expr_stmt|;
name|iter
operator|=
operator|*
name|start
expr_stmt|;
name|tag_list
operator|=
name|NULL
expr_stmt|;
name|active_tags
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|GList
modifier|*
name|added
decl_stmt|,
modifier|*
name|removed
decl_stmt|;
name|GList
modifier|*
name|tmp
decl_stmt|;
name|gchar
modifier|*
name|tmp_text
decl_stmt|,
modifier|*
name|escaped_text
decl_stmt|;
name|new_tag_list
operator|=
name|gtk_text_iter_get_tags
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|find_list_delta
argument_list|(
name|tag_list
argument_list|,
name|new_tag_list
argument_list|,
operator|&
name|added
argument_list|,
operator|&
name|removed
argument_list|)
expr_stmt|;
comment|/* Handle removed tags */
for|for
control|(
name|tmp
operator|=
name|removed
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|GtkTextTag
modifier|*
name|tag
init|=
name|tmp
operator|->
name|data
decl_stmt|;
comment|/* Only close the tag if we didn't close it before (by using            * the stack logic in the while() loop below)            */
if|if
condition|(
name|g_slist_find
argument_list|(
name|active_tags
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* Drop all tags that were opened after this one (which are                * above this on in the stack), but move them to the added                * list so they get re-opened again, *unless* they are also                * closed at this iter                */
while|while
condition|(
name|active_tags
operator|->
name|data
operator|!=
name|tag
condition|)
block|{
name|close_tag
argument_list|(
name|GIMP_TEXT_BUFFER
argument_list|(
name|content_buffer
argument_list|)
argument_list|,
name|string
argument_list|,
name|active_tags
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* if it also in the list of removed tags, *don't* add                    * it to the list of added tags again                    */
if|if
condition|(
operator|!
name|g_list_find
argument_list|(
name|removed
argument_list|,
name|active_tags
operator|->
name|data
argument_list|)
condition|)
name|added
operator|=
name|g_list_prepend
argument_list|(
name|added
argument_list|,
name|active_tags
operator|->
name|data
argument_list|)
expr_stmt|;
name|active_tags
operator|=
name|g_slist_remove
argument_list|(
name|active_tags
argument_list|,
name|active_tags
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
comment|/*  then, close the tag itself  */
name|close_tag
argument_list|(
name|GIMP_TEXT_BUFFER
argument_list|(
name|content_buffer
argument_list|)
argument_list|,
name|string
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|active_tags
operator|=
name|g_slist_remove
argument_list|(
name|active_tags
argument_list|,
name|active_tags
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle added tags */
for|for
control|(
name|tmp
operator|=
name|added
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|GtkTextTag
modifier|*
name|tag
init|=
name|tmp
operator|->
name|data
decl_stmt|;
name|open_tag
argument_list|(
name|GIMP_TEXT_BUFFER
argument_list|(
name|content_buffer
argument_list|)
argument_list|,
name|string
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|active_tags
operator|=
name|g_slist_prepend
argument_list|(
name|active_tags
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|tag_list
argument_list|)
expr_stmt|;
name|tag_list
operator|=
name|new_tag_list
expr_stmt|;
name|g_list_free
argument_list|(
name|added
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|removed
argument_list|)
expr_stmt|;
name|old_iter
operator|=
name|iter
expr_stmt|;
comment|/* Now try to go to either the next tag toggle, or if a pixbuf appears */
while|while
condition|(
name|TRUE
condition|)
block|{
name|gunichar
name|ch
init|=
name|gtk_text_iter_get_char
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0xFFFC
condition|)
block|{
comment|/* pixbuf? can't happen! */
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|gtk_text_iter_forward_char
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gtk_text_iter_toggles_tag
argument_list|(
operator|&
name|iter
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
block|}
comment|/* We might have moved too far */
if|if
condition|(
name|gtk_text_iter_compare
argument_list|(
operator|&
name|iter
argument_list|,
name|end
argument_list|)
operator|>
literal|0
condition|)
name|iter
operator|=
operator|*
name|end
expr_stmt|;
comment|/* Append the text */
name|tmp_text
operator|=
name|gtk_text_iter_get_slice
argument_list|(
operator|&
name|old_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|escaped_text
operator|=
name|g_markup_escape_text
argument_list|(
name|tmp_text
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_text
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
name|escaped_text
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|escaped_text
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|gtk_text_iter_equal
argument_list|(
operator|&
name|iter
argument_list|,
name|end
argument_list|)
condition|)
do|;
comment|/* Close any open tags */
for|for
control|(
name|tag_list
operator|=
name|active_tags
init|;
name|tag_list
condition|;
name|tag_list
operator|=
name|tag_list
operator|->
name|next
control|)
name|close_tag
argument_list|(
name|GIMP_TEXT_BUFFER
argument_list|(
name|content_buffer
argument_list|)
argument_list|,
name|string
argument_list|,
name|tag_list
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|active_tags
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</markup>"
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|string
operator|->
name|len
expr_stmt|;
return|return
operator|(
name|guint8
operator|*
operator|)
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  deserialize  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon292fe2a10103
block|{
DECL|enumerator|STATE_START
name|STATE_START
block|,
DECL|enumerator|STATE_MARKUP
name|STATE_MARKUP
block|,
DECL|enumerator|STATE_TAG
name|STATE_TAG
block|,
DECL|enumerator|STATE_UNKNOWN
name|STATE_UNKNOWN
DECL|typedef|ParseState
block|}
name|ParseState
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon292fe2a10208
block|{
DECL|member|states
name|GSList
modifier|*
name|states
decl_stmt|;
DECL|member|buffer
name|GtkTextBuffer
modifier|*
name|buffer
decl_stmt|;
DECL|member|tag_stack
name|GSList
modifier|*
name|tag_stack
decl_stmt|;
DECL|member|spans
name|GList
modifier|*
name|spans
decl_stmt|;
DECL|typedef|ParseInfo
block|}
name|ParseInfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon292fe2a10308
block|{
DECL|member|text
name|gchar
modifier|*
name|text
decl_stmt|;
DECL|member|tags
name|GSList
modifier|*
name|tags
decl_stmt|;
DECL|typedef|TextSpan
block|}
name|TextSpan
typedef|;
end_typedef

begin_function
specifier|static
name|void
DECL|function|set_error (GError ** err,GMarkupParseContext * context,int error_domain,int error_code,const char * format,...)
name|set_error
parameter_list|(
name|GError
modifier|*
modifier|*
name|err
parameter_list|,
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
name|int
name|error_domain
parameter_list|,
name|int
name|error_code
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|gint
name|line
decl_stmt|,
name|ch
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|gchar
modifier|*
name|str
decl_stmt|;
name|g_markup_parse_context_get_position
argument_list|(
name|context
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|ch
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|str
operator|=
name|g_strdup_vprintf
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|g_set_error
argument_list|(
name|err
argument_list|,
name|error_domain
argument_list|,
name|error_code
argument_list|,
operator|(
literal|"Line %d character %d: %s"
operator|)
argument_list|,
name|line
argument_list|,
name|ch
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|push_state (ParseInfo * info,ParseState state)
name|push_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|,
name|ParseState
name|state
parameter_list|)
block|{
name|info
operator|->
name|states
operator|=
name|g_slist_prepend
argument_list|(
name|info
operator|->
name|states
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|pop_state (ParseInfo * info)
name|pop_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|info
operator|->
name|states
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|states
operator|=
name|g_slist_remove
argument_list|(
name|info
operator|->
name|states
argument_list|,
name|info
operator|->
name|states
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ParseState
DECL|function|peek_state (ParseInfo * info)
name|peek_state
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|info
operator|->
name|states
operator|!=
name|NULL
argument_list|,
name|STATE_START
argument_list|)
expr_stmt|;
return|return
name|GPOINTER_TO_INT
argument_list|(
name|info
operator|->
name|states
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|check_no_attributes (GMarkupParseContext * context,const char * element_name,const char ** attribute_names,const char ** attribute_values,GError ** error)
name|check_no_attributes
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|element_name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|attribute_names
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|set_error
argument_list|(
name|error
argument_list|,
name|context
argument_list|,
name|G_MARKUP_ERROR
argument_list|,
name|G_MARKUP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"Attribute \"%s\" is invalid on<%s> element in this context"
argument_list|)
argument_list|,
name|attribute_names
index|[
literal|0
index|]
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_tag_element (GMarkupParseContext * context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,ParseInfo * info,GError ** error)
name|parse_tag_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|ParseInfo
modifier|*
name|info
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GtkTextTag
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|attribute_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|attribute_value
init|=
name|NULL
decl_stmt|;
name|g_assert
argument_list|(
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_MARKUP
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_TAG
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_UNKNOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute_names
condition|)
name|attribute_name
operator|=
name|attribute_names
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|attribute_values
condition|)
name|attribute_value
operator|=
name|attribute_values
index|[
literal|0
index|]
expr_stmt|;
name|tag
operator|=
name|gimp_text_buffer_name_to_tag
argument_list|(
name|GIMP_TEXT_BUFFER
argument_list|(
name|info
operator|->
name|buffer
argument_list|)
argument_list|,
name|element_name
argument_list|,
name|attribute_name
argument_list|,
name|attribute_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|info
operator|->
name|tag_stack
operator|=
name|g_slist_prepend
argument_list|(
name|info
operator|->
name|tag_stack
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_TAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_UNKNOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|start_element_handler (GMarkupParseContext * context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,gpointer user_data,GError ** error)
name|start_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|peek_state
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|STATE_START
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"markup"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_no_attributes
argument_list|(
name|context
argument_list|,
name|element_name
argument_list|,
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
name|error
argument_list|)
condition|)
return|return;
name|push_state
argument_list|(
name|info
argument_list|,
name|STATE_MARKUP
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|set_error
argument_list|(
name|error
argument_list|,
name|context
argument_list|,
name|G_MARKUP_ERROR
argument_list|,
name|G_MARKUP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"Outermost element in text must be<markup> not<%s>"
argument_list|)
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_MARKUP
case|:
case|case
name|STATE_TAG
case|:
case|case
name|STATE_UNKNOWN
case|:
name|parse_tag_element
argument_list|(
name|context
argument_list|,
name|element_name
argument_list|,
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
name|info
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|end_element_handler (GMarkupParseContext * context,const gchar * element_name,gpointer user_data,GError ** error)
name|end_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|peek_state
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|STATE_UNKNOWN
case|:
name|pop_state
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_UNKNOWN
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_TAG
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_MARKUP
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_TAG
case|:
name|pop_state
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_UNKNOWN
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_TAG
operator|||
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_MARKUP
argument_list|)
expr_stmt|;
comment|/* Pop tag */
name|info
operator|->
name|tag_stack
operator|=
name|g_slist_delete_link
argument_list|(
name|info
operator|->
name|tag_stack
argument_list|,
name|info
operator|->
name|tag_stack
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_MARKUP
case|:
name|pop_state
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g_assert
argument_list|(
name|peek_state
argument_list|(
name|info
argument_list|)
operator|==
name|STATE_START
argument_list|)
expr_stmt|;
name|info
operator|->
name|spans
operator|=
name|g_list_reverse
argument_list|(
name|info
operator|->
name|spans
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|all_whitespace (const char * text,gint text_len)
name|all_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|gint
name|text_len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|text
operator|+
name|text_len
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|g_ascii_isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|g_utf8_next_char
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|text_handler (GMarkupParseContext * context,const gchar * text,gsize text_len,gpointer user_data,GError ** error)
name|text_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|ParseInfo
modifier|*
name|info
init|=
name|user_data
decl_stmt|;
name|TextSpan
modifier|*
name|span
decl_stmt|;
if|if
condition|(
name|all_whitespace
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
operator|&&
name|peek_state
argument_list|(
name|info
argument_list|)
operator|!=
name|STATE_MARKUP
operator|&&
name|peek_state
argument_list|(
name|info
argument_list|)
operator|!=
name|STATE_TAG
operator|&&
name|peek_state
argument_list|(
name|info
argument_list|)
operator|!=
name|STATE_UNKNOWN
condition|)
return|return;
switch|switch
condition|(
name|peek_state
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|STATE_START
case|:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
comment|/* gmarkup shouldn't do this */
break|break;
case|case
name|STATE_MARKUP
case|:
case|case
name|STATE_TAG
case|:
case|case
name|STATE_UNKNOWN
case|:
if|if
condition|(
name|text_len
operator|==
literal|0
condition|)
return|return;
name|span
operator|=
name|g_new0
argument_list|(
name|TextSpan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|span
operator|->
name|text
operator|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
name|span
operator|->
name|tags
operator|=
name|g_slist_copy
argument_list|(
name|info
operator|->
name|tag_stack
argument_list|)
expr_stmt|;
name|info
operator|->
name|spans
operator|=
name|g_list_prepend
argument_list|(
name|info
operator|->
name|spans
argument_list|,
name|span
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_info_init (ParseInfo * info,GtkTextBuffer * buffer)
name|parse_info_init
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|,
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|info
operator|->
name|states
operator|=
name|g_slist_prepend
argument_list|(
name|NULL
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|STATE_START
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|tag_stack
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|spans
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|text_span_free (TextSpan * span)
name|text_span_free
parameter_list|(
name|TextSpan
modifier|*
name|span
parameter_list|)
block|{
name|g_free
argument_list|(
name|span
operator|->
name|text
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|span
operator|->
name|tags
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|span
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_info_free (ParseInfo * info)
name|parse_info_free
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|)
block|{
name|g_slist_free
argument_list|(
name|info
operator|->
name|tag_stack
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|info
operator|->
name|states
argument_list|)
expr_stmt|;
name|g_list_foreach
argument_list|(
name|info
operator|->
name|spans
argument_list|,
operator|(
name|GFunc
operator|)
name|text_span_free
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|info
operator|->
name|spans
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|insert_text (ParseInfo * info,GtkTextIter * iter)
name|insert_text
parameter_list|(
name|ParseInfo
modifier|*
name|info
parameter_list|,
name|GtkTextIter
modifier|*
name|iter
parameter_list|)
block|{
name|GtkTextIter
name|start_iter
decl_stmt|;
name|GtkTextMark
modifier|*
name|mark
decl_stmt|;
name|GList
modifier|*
name|tmp
decl_stmt|;
name|GSList
modifier|*
name|tags
decl_stmt|;
name|start_iter
operator|=
operator|*
name|iter
expr_stmt|;
name|mark
operator|=
name|gtk_text_buffer_create_mark
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
literal|"deserialize-insert-point"
argument_list|,
operator|&
name|start_iter
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|info
operator|->
name|spans
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|TextSpan
modifier|*
name|span
init|=
name|tmp
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|span
operator|->
name|text
condition|)
name|gtk_text_buffer_insert
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|iter
argument_list|,
name|span
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_iter_at_mark
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
name|mark
argument_list|)
expr_stmt|;
comment|/* Apply tags */
for|for
control|(
name|tags
operator|=
name|span
operator|->
name|tags
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next
control|)
block|{
name|GtkTextTag
modifier|*
name|tag
init|=
name|tags
operator|->
name|data
decl_stmt|;
name|gtk_text_buffer_apply_tag
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|tag
argument_list|,
operator|&
name|start_iter
argument_list|,
name|iter
argument_list|)
expr_stmt|;
block|}
name|gtk_text_buffer_move_mark
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|mark
argument_list|,
name|iter
argument_list|)
expr_stmt|;
block|}
name|gtk_text_buffer_delete_mark
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_text_buffer_deserialize (GtkTextBuffer * register_buffer,GtkTextBuffer * content_buffer,GtkTextIter * iter,const guint8 * text,gsize length,gboolean create_tags,gpointer user_data,GError ** error)
name|gimp_text_buffer_deserialize
parameter_list|(
name|GtkTextBuffer
modifier|*
name|register_buffer
parameter_list|,
name|GtkTextBuffer
modifier|*
name|content_buffer
parameter_list|,
name|GtkTextIter
modifier|*
name|iter
parameter_list|,
specifier|const
name|guint8
modifier|*
name|text
parameter_list|,
name|gsize
name|length
parameter_list|,
name|gboolean
name|create_tags
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GMarkupParseContext
modifier|*
name|context
decl_stmt|;
name|ParseInfo
name|info
decl_stmt|;
name|gboolean
name|retval
init|=
name|FALSE
decl_stmt|;
specifier|static
specifier|const
name|GMarkupParser
name|markup_parser
init|=
block|{
name|start_element_handler
block|,
name|end_element_handler
block|,
name|text_handler
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|parse_info_init
argument_list|(
operator|&
name|info
argument_list|,
name|content_buffer
argument_list|)
expr_stmt|;
name|context
operator|=
name|g_markup_parse_context_new
argument_list|(
operator|&
name|markup_parser
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_markup_parse_context_parse
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|text
argument_list|,
name|length
argument_list|,
name|error
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|g_markup_parse_context_end_parse
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|retval
operator|=
name|TRUE
expr_stmt|;
name|insert_text
argument_list|(
operator|&
name|info
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|out
label|:
name|parse_info_free
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|g_markup_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

