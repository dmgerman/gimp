begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Wilber Cairo rendering  * Copyright (C) 2008  Sven Neumann<sven@gimp.org>  *  * Some code here is based on code from librsvg that was originally  * written by Raph Levien<raph@artofcode.com> for Gill.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|<gimpcairo-wilber.h>
end_include

begin_decl_stmt
DECL|variable|wilber_paths
specifier|static
specifier|const
name|gchar
modifier|*
specifier|const
name|wilber_paths
index|[]
init|=
block|{
literal|"M 10.374369,12.467884 C 10.374369,12.467884 13.248878,18.395518 19.973611,18.228291 C 34.066126,17.874738 36.53732,10.523341 36.890873,9.4626804 C 37.244427,8.4020202 37.785407,8.5626825 37.91048,9.542947 C 42.506674,51.262247 6.0135488,33.362123 4.7175144,26.256467 C 11.965359,24.135147 10.197592,20.069282 10.197592,20.069282 L 10.374369,12.467884 z "
block|,
literal|"M 15.73779,30.066049 C 22.47669,31.413886 25.908481,30.164142 27.916965,28.613273 C 27.386635,27.928263 26.480655,27.176962 26.480655,27.176962 C 26.480655,27.176962 28.833972,27.830904 29.662635,28.900535 C 30.488925,29.967103 29.969443,30.624242 29.753196,31.988905 C 29.271785,30.790306 28.373215,30.340813 28.251562,29.864573 C 26.445294,32.3615 21.94512,32.257773 15.73779,30.066049 z "
literal|"M 23.003067,31.736544 C 24.500439,31.879636 25.852696,31.464331 26.41496,31.262497 C 26.513185,30.707111 26.951512,29.64124 28.461048,29.571029 L 27.930718,28.642952 C 27.930718,28.642952 25.964077,29.990873 23.864854,30.388621 L 23.003067,31.736544 z "
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|parse_path_data
parameter_list|(
name|cairo_t
modifier|*
name|cr
parameter_list|,
specifier|const
name|gchar
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
DECL|function|gimp_cairo_wilber (cairo_t * cr)
name|gimp_cairo_wilber
parameter_list|(
name|cairo_t
modifier|*
name|cr
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wilber_paths
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|parse_path_data
argument_list|(
name|cr
argument_list|,
name|wilber_paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************/
end_comment

begin_comment
comment|/*  Below is the code that parses the actual path data.   */
end_comment

begin_comment
comment|/*                                                        */
end_comment

begin_comment
comment|/*  This code is taken from librsvg and was originally    */
end_comment

begin_comment
comment|/*  written by Raph Levien<raph@artofcode.com> for Gill. */
end_comment

begin_comment
comment|/**********************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28e670ae0108
block|{
DECL|member|cr
name|cairo_t
modifier|*
name|cr
decl_stmt|;
DECL|member|cpx
DECL|member|cpy
name|gdouble
name|cpx
decl_stmt|,
name|cpy
decl_stmt|;
comment|/* current point                               */
DECL|member|rpx
DECL|member|rpy
name|gdouble
name|rpx
decl_stmt|,
name|rpy
decl_stmt|;
comment|/* reflection point (for 's' and 't' commands) */
DECL|member|cmd
name|gchar
name|cmd
decl_stmt|;
comment|/* current command (lowercase)                 */
DECL|member|param
name|gint
name|param
decl_stmt|;
comment|/* number of parameters                        */
DECL|member|rel
name|gboolean
name|rel
decl_stmt|;
comment|/* true if relative coords                     */
DECL|member|params
name|gdouble
name|params
index|[
literal|7
index|]
decl_stmt|;
comment|/* parameters that have been parsed            */
DECL|typedef|ParsePathContext
block|}
name|ParsePathContext
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|parse_path_default_xy
parameter_list|(
name|ParsePathContext
modifier|*
name|ctx
parameter_list|,
name|gint
name|n_params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_path_do_cmd
parameter_list|(
name|ParsePathContext
modifier|*
name|ctx
parameter_list|,
name|gboolean
name|final
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
DECL|function|parse_path_data (cairo_t * cr,const gchar * data)
name|parse_path_data
parameter_list|(
name|cairo_t
modifier|*
name|cr
parameter_list|,
specifier|const
name|gchar
modifier|*
name|data
parameter_list|)
block|{
name|ParsePathContext
name|ctx
decl_stmt|;
name|gboolean
name|in_num
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|in_frac
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|in_exp
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|exp_wait_sign
init|=
name|FALSE
decl_stmt|;
name|gdouble
name|val
init|=
literal|0.0
decl_stmt|;
name|gchar
name|c
init|=
literal|0
decl_stmt|;
name|gint
name|sign
init|=
literal|0
decl_stmt|;
name|gint
name|exp
init|=
literal|0
decl_stmt|;
name|gint
name|exp_sign
init|=
literal|0
decl_stmt|;
name|gdouble
name|frac
init|=
literal|0.0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ParsePathContext
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|cr
operator|=
name|cr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* digit */
if|if
condition|(
name|in_num
condition|)
block|{
if|if
condition|(
name|in_exp
condition|)
block|{
name|exp
operator|=
operator|(
name|exp
operator|*
literal|10
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|exp_wait_sign
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_frac
condition|)
name|val
operator|+=
operator|(
name|frac
operator|*=
literal|0.1
operator|)
operator|*
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|in_num
operator|=
name|TRUE
expr_stmt|;
name|in_frac
operator|=
name|FALSE
expr_stmt|;
name|in_exp
operator|=
name|FALSE
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|exp_sign
operator|=
literal|1
expr_stmt|;
name|exp_wait_sign
operator|=
name|FALSE
expr_stmt|;
name|val
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|in_num
condition|)
block|{
name|in_num
operator|=
name|TRUE
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|in_frac
operator|=
name|TRUE
expr_stmt|;
name|frac
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
operator|)
operator|&&
name|in_num
condition|)
block|{
name|in_exp
operator|=
name|TRUE
expr_stmt|;
name|exp_wait_sign
operator|=
name|TRUE
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|exp_sign
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
name|in_exp
condition|)
block|{
name|exp_sign
operator|=
name|c
operator|==
literal|'+'
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_num
condition|)
block|{
comment|/* end of number */
name|val
operator|*=
name|sign
operator|*
name|pow
argument_list|(
literal|10
argument_list|,
name|exp_sign
operator|*
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|rel
condition|)
block|{
comment|/* Handle relative coordinates. This switch statement attempts                  to determine _what_ the coords are relative to. This is                  underspecified in the 12 Apr working draft. */
switch|switch
condition|(
name|ctx
operator|.
name|cmd
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'c'
case|:
case|case
literal|'s'
case|:
case|case
literal|'q'
case|:
case|case
literal|'t'
case|:
comment|/* rule: even-numbered params are x-relative, odd-numbered                      are y-relative */
if|if
condition|(
operator|(
name|ctx
operator|.
name|param
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|val
operator|+=
name|ctx
operator|.
name|cpx
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ctx
operator|.
name|param
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
name|val
operator|+=
name|ctx
operator|.
name|cpy
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* rule: sixth and seventh are x and y, rest are not                      relative */
if|if
condition|(
name|ctx
operator|.
name|param
operator|==
literal|5
condition|)
name|val
operator|+=
name|ctx
operator|.
name|cpx
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|param
operator|==
literal|6
condition|)
name|val
operator|+=
name|ctx
operator|.
name|cpy
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* rule: x-relative */
name|val
operator|+=
name|ctx
operator|.
name|cpx
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* rule: y-relative */
name|val
operator|+=
name|ctx
operator|.
name|cpy
expr_stmt|;
break|break;
block|}
block|}
name|ctx
operator|.
name|params
index|[
name|ctx
operator|.
name|param
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|parse_path_do_cmd
argument_list|(
operator|&
name|ctx
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|in_num
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|!
name|exp_wait_sign
condition|)
block|{
name|sign
operator|=
name|c
operator|==
literal|'+'
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|in_num
operator|=
name|TRUE
expr_stmt|;
name|in_frac
operator|=
name|FALSE
expr_stmt|;
name|in_exp
operator|=
name|FALSE
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|exp_sign
operator|=
literal|1
expr_stmt|;
name|exp_wait_sign
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'z'
operator|||
name|c
operator|==
literal|'Z'
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|param
condition|)
name|parse_path_do_cmd
argument_list|(
operator|&
name|ctx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|cairo_close_path
argument_list|(
name|ctx
operator|.
name|cr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|&&
name|c
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|param
condition|)
name|parse_path_do_cmd
argument_list|(
operator|&
name|ctx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|cmd
operator|=
name|c
operator|+
literal|'a'
operator|-
literal|'A'
expr_stmt|;
name|ctx
operator|.
name|rel
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|&&
name|c
operator|!=
literal|'e'
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|param
condition|)
name|parse_path_do_cmd
argument_list|(
operator|&
name|ctx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|cmd
operator|=
name|c
expr_stmt|;
name|ctx
operator|.
name|rel
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* else c _should_ be whitespace or , */
block|}
block|}
end_function

begin_comment
comment|/* supply defaults for missing parameters, assuming relative coordinates    are to be interpreted as x,y */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_path_default_xy (ParsePathContext * ctx,gint n_params)
name|parse_path_default_xy
parameter_list|(
name|ParsePathContext
modifier|*
name|ctx
parameter_list|,
name|gint
name|n_params
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|rel
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|param
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|ctx
operator|->
name|params
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|params
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|ctx
operator|->
name|params
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|cpy
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* we shouldn't get here (ctx->param> 0 as precondition) */
name|ctx
operator|->
name|params
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|cpx
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|param
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
name|ctx
operator|->
name|params
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_path_do_cmd (ParsePathContext * ctx,gboolean final)
name|parse_path_do_cmd
parameter_list|(
name|ParsePathContext
modifier|*
name|ctx
parameter_list|,
name|gboolean
name|final
parameter_list|)
block|{
switch|switch
condition|(
name|ctx
operator|->
name|cmd
condition|)
block|{
case|case
literal|'m'
case|:
comment|/* moveto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|2
operator|||
name|final
condition|)
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|cairo_move_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* lineto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|2
operator|||
name|final
condition|)
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|cairo_line_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* curveto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|6
operator|||
name|final
condition|)
block|{
name|gdouble
name|x
decl_stmt|,
name|y
decl_stmt|;
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|x
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|3
index|]
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|4
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|5
index|]
expr_stmt|;
name|cairo_curve_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
operator|->
name|rpx
argument_list|,
name|ctx
operator|->
name|rpy
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* smooth curveto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|4
operator|||
name|final
condition|)
block|{
name|gdouble
name|x
decl_stmt|,
name|y
decl_stmt|;
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator|=
literal|2
operator|*
name|ctx
operator|->
name|cpx
operator|-
name|ctx
operator|->
name|rpx
expr_stmt|;
name|y
operator|=
literal|2
operator|*
name|ctx
operator|->
name|cpy
operator|-
name|ctx
operator|->
name|rpy
expr_stmt|;
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|3
index|]
expr_stmt|;
name|cairo_curve_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
operator|->
name|rpx
argument_list|,
name|ctx
operator|->
name|rpy
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* horizontal lineto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|1
condition|)
block|{
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|cairo_line_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* vertical lineto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|1
condition|)
block|{
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|cairo_line_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* quadratic bezier curveto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|4
operator|||
name|final
condition|)
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|3
index|]
expr_stmt|;
name|g_warning
argument_list|(
literal|"quadratic bezier curveto not implemented"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* truetype quadratic bezier curveto */
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|2
operator|||
name|final
condition|)
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rpx
operator|=
literal|2
operator|*
name|ctx
operator|->
name|cpx
operator|-
name|ctx
operator|->
name|rpx
expr_stmt|;
name|ctx
operator|->
name|rpy
operator|=
literal|2
operator|*
name|ctx
operator|->
name|cpy
operator|-
name|ctx
operator|->
name|rpy
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|g_warning
argument_list|(
literal|"truetype quadratic bezier curveto not implemented"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|param
operator|>
literal|2
condition|)
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|3
index|]
expr_stmt|;
name|g_warning
argument_list|(
literal|"conicto not implemented"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_path_default_xy
argument_list|(
name|ctx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|1
index|]
expr_stmt|;
name|cairo_line_to
argument_list|(
name|ctx
operator|->
name|cr
argument_list|,
name|ctx
operator|->
name|cpx
argument_list|,
name|ctx
operator|->
name|cpy
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|ctx
operator|->
name|param
operator|==
literal|7
operator|||
name|final
condition|)
block|{
name|ctx
operator|->
name|cpx
operator|=
name|ctx
operator|->
name|rpx
operator|=
name|ctx
operator|->
name|params
index|[
literal|5
index|]
expr_stmt|;
name|ctx
operator|->
name|cpy
operator|=
name|ctx
operator|->
name|rpy
operator|=
name|ctx
operator|->
name|params
index|[
literal|6
index|]
expr_stmt|;
name|g_warning
argument_list|(
literal|"arcto not implemented"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|ctx
operator|->
name|param
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

