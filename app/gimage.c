begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"channels_dialog.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"indexed_palette.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"layers_dialog.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"palette.h"
end_include

begin_include
include|#
directive|include
file|"plug_in.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager_pvt.h"
end_include

begin_comment
comment|/* ick. */
end_comment

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_include
include|#
directive|include
file|"drawable_pvt.h"
end_include

begin_comment
comment|/* ick ick. */
end_comment

begin_comment
comment|/*  Local function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimage_free_projection
parameter_list|(
name|GImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_allocate_shadow
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GImage
modifier|*
name|gimage_create
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_allocate_projection
parameter_list|(
name|GImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_free_layers
parameter_list|(
name|GImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_free_channels
parameter_list|(
name|GImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_construct_layers
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_construct_channels
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_initialize_projection
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimage_get_active_channels
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  projection functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|project_intensity
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_intensity_alpha
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_indexed
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_channel
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|Channel
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Global variables  */
end_comment

begin_decl_stmt
DECL|variable|valid_combinations
name|int
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* RGB GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* RGBA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GRAY GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GRAYA GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXED GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXEDA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Static variables  */
end_comment

begin_decl_stmt
DECL|variable|global_gimage_ID
specifier|static
name|int
name|global_gimage_ID
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_list
name|link_ptr
name|image_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static functions */
end_comment

begin_function
specifier|static
name|GImage
modifier|*
DECL|function|gimage_create (void)
name|gimage_create
parameter_list|(
name|void
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GImage
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|ID
operator|=
name|global_gimage_ID
operator|++
expr_stmt|;
name|gimage
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|flat
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
operator|-
literal|1
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_bytes
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|undo_levels
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|pushing_undo_group
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|image_list
operator|=
name|append_to_list
argument_list|(
name|image_list
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_allocate_projection (GImage * gimage)
name|gimage_allocate_projection
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|gimage_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Find the number of bytes required for the projection.    *  This includes the intensity channels and an alpha channel    *  if one doesn't exist.    */
switch|switch
condition|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|4
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|2
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|GRAYA_GIMAGE
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"gimage type unsupported.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|projection
operator|=
name|tile_manager_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|gimage
operator|->
name|proj_bytes
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|projection
operator|->
name|user_data
operator|=
operator|(
name|void
operator|*
operator|)
name|gimage
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
name|gimage_validate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_free_projection (GImage * gimage)
name|gimage_free_projection
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_allocate_shadow (GImage * gimage,int width,int height,int bpp)
name|gimage_allocate_shadow
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function definitions */
end_comment

begin_function
name|GImage
modifier|*
DECL|function|gimage_new (int width,int height,int base_type)
name|gimage_new
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|base_type
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gimage
operator|=
name|gimage_create
argument_list|()
expr_stmt|;
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|GRAY
case|:
break|break;
case|case
name|INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
literal|0
argument_list|,
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  configure the active pointers  */
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/* no default active channel */
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
comment|/*  set all color channels visible and active  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|visible
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|active
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* create the selection mask */
name|gimage
operator|->
name|selection_mask
operator|=
name|channel_new_mask
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|lc_dialog_update_image_list
argument_list|()
expr_stmt|;
name|indexed_palette_update_image_list
argument_list|()
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_filename (GImage * gimage,char * filename)
name|gimage_set_filename
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
name|new_filename
operator|=
name|g_strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|gimage
operator|->
name|filename
operator|=
name|new_filename
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|FALSE
expr_stmt|;
block|}
name|gdisplays_update_title
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|lc_dialog_update_image_list
argument_list|()
expr_stmt|;
name|indexed_palette_update_image_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_resize (GImage * gimage,int new_width,int new_height,int offset_x,int offset_y)
name|gimage_resize
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|new_width
parameter_list|,
name|int
name|new_height
parameter_list|,
name|int
name|offset_x
parameter_list|,
name|int
name|offset_y
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
operator|||
name|new_height
operator|<=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_resize: width and height must be positive"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|GIMAGE_MOD_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Resize all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_resize
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_resize
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Reposition all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimage_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  shrink wrap and update all views  */
name|channel_invalidate_previews
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|layer_invalidate_previews
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gdisplays_update_full
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|gdisplays_shrink_wrap
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_scale (GImage * gimage,int new_width,int new_height)
name|gimage_scale
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|new_width
parameter_list|,
name|int
name|new_height
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|int
name|old_width
decl_stmt|,
name|old_height
decl_stmt|;
name|int
name|layer_width
decl_stmt|,
name|layer_height
decl_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|GIMAGE_MOD_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|old_width
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|old_height
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Scale all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_scale
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_scale
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Scale all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_width
operator|=
operator|(
name|new_width
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_width
expr_stmt|;
name|layer_height
operator|=
operator|(
name|new_height
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_height
expr_stmt|;
name|layer_scale
argument_list|(
name|layer
argument_list|,
name|layer_width
argument_list|,
name|layer_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimage_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  shrink wrap and update all views  */
name|channel_invalidate_previews
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|layer_invalidate_previews
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gdisplays_update_full
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|gdisplays_shrink_wrap
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GImage
modifier|*
DECL|function|gimage_get_named (char * name)
name|gimage_get_named
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|link_ptr
name|tmp
init|=
name|image_list
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|gimage
operator|=
name|tmp
operator|->
name|data
expr_stmt|;
name|str
operator|=
name|prune_filename
argument_list|(
name|gimage_filename
argument_list|(
name|gimage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|gimage
return|;
name|tmp
operator|=
name|next_item
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|GImage
modifier|*
DECL|function|gimage_get_ID (int ID)
name|gimage_get_ID
parameter_list|(
name|int
name|ID
parameter_list|)
block|{
name|link_ptr
name|tmp
init|=
name|image_list
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|tmp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|ID
operator|==
name|ID
condition|)
return|return
name|gimage
return|;
name|tmp
operator|=
name|next_item
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimage_shadow (GImage * gimage,int width,int height,int bpp)
name|gimage_shadow
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|shadow
operator|&&
operator|(
operator|(
name|width
operator|!=
name|gimage
operator|->
name|shadow
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|width
operator|)
operator|||
operator|(
name|height
operator|!=
name|gimage
operator|->
name|shadow
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|height
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|gimage
operator|->
name|shadow
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|bpp
operator|)
operator|)
condition|)
name|gimage_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
return|return
name|gimage
operator|->
name|shadow
return|;
name|gimage_allocate_shadow
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_free_shadow (GImage * gimage)
name|gimage_free_shadow
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free the shadow buffer from the specified gimage if it exists  */
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_delete (GImage * gimage)
name|gimage_delete
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|ref_count
operator|<=
literal|0
condition|)
block|{
comment|/*  free the undo list  */
name|undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  remove this image from the global list  */
name|image_list
operator|=
name|remove_from_list
argument_list|(
name|image_list
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
expr_stmt|;
name|gimage_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gimage_free_layers
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage_free_channels
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|channel_delete
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|lc_dialog_update_image_list
argument_list|()
expr_stmt|;
name|indexed_palette_update_image_list
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimage_apply_image (GImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,int undo,int opacity,int mode,TileManager * src1_tiles,int x,int y)
name|gimage_apply_image
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|int
name|undo
parameter_list|,
name|int
name|opacity
parameter_list|,
name|int
name|mode
parameter_list|,
comment|/*  alternative to using drawable tiles as src1: */
name|TileManager
modifier|*
name|src1_tiles
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimage_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_apply_image sent illegal parameters\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|drawable_apply_image
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
if|if
condition|(
name|src1_tiles
condition|)
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src1_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to gimage_apply_image but works in "replace" mode (i.e.    transparent pixels in src2 make the result transparent rather    than opaque.     Takes an additional mask pixel region as well.  */
end_comment

begin_function
name|void
DECL|function|gimage_replace_image (GImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,int undo,int opacity,PixelRegion * maskPR,int x,int y)
name|gimage_replace_image
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|int
name|undo
parameter_list|,
name|int
name|opacity
parameter_list|,
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|;
name|PixelRegion
name|mask2PR
decl_stmt|,
name|tempPR
decl_stmt|;
name|unsigned
name|char
modifier|*
name|temp_data
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimage_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_apply_image sent illegal parameters\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|drawable_apply_image
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mask2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|rowstride
operator|=
name|mask2PR
operator|.
name|rowstride
expr_stmt|;
name|temp_data
operator|=
name|g_malloc
argument_list|(
name|tempPR
operator|.
name|h
operator|*
name|tempPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|mask2PR
argument_list|,
operator|&
name|tempPR
argument_list|)
expr_stmt|;
comment|/* apparently, region operations can mutate some PR data. */
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|apply_mask_to_region
argument_list|(
operator|&
name|tempPR
argument_list|,
name|maskPR
argument_list|,
name|OPAQUE_OPACITY
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|tempPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_data
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_get_foreground (GImage * gimage,GimpDrawable * drawable,unsigned char * fg)
name|gimage_get_foreground
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|fg
parameter_list|)
block|{
name|unsigned
name|char
name|pfg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|palette_get_foreground
argument_list|(
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimage_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pfg
argument_list|,
name|fg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_get_background (GImage * gimage,GimpDrawable * drawable,unsigned char * bg)
name|gimage_get_background
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|bg
parameter_list|)
block|{
name|unsigned
name|char
name|pbg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|palette_get_background
argument_list|(
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimage_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pbg
argument_list|,
name|bg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_get_color (GImage * gimage,int d_type,unsigned char * rgb,unsigned char * src)
name|gimage_get_color
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|d_type
parameter_list|,
name|unsigned
name|char
modifier|*
name|rgb
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|)
block|{
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|2
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimage_transform_color (GImage * gimage,GimpDrawable * drawable,unsigned char * src,unsigned char * dest,int type)
name|gimage_transform_color
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|type
parameter_list|)
block|{
DECL|macro|INTENSITY (r,g,b)
define|#
directive|define
name|INTENSITY
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|(r * 0.30 + g * 0.59 + b * 0.11 + 0.001)
name|int
name|d_type
decl_stmt|;
name|d_type
operator|=
operator|(
name|drawable
operator|!=
name|NULL
operator|)
condition|?
name|drawable_type
argument_list|(
name|drawable
argument_list|)
else|:
name|gimage_base_type_with_alpha
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RGB
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|INTENSITY
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
operator|->
name|ID
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GRAY
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
operator|->
name|ID
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimage_add_hguide (GImage * gimage)
name|gimage_add_hguide
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|HORIZONTAL_GUIDE
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimage_add_vguide (GImage * gimage)
name|gimage_add_vguide
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|VERTICAL_GUIDE
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_add_guide (GImage * gimage,Guide * guide)
name|gimage_add_guide
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_remove_guide (GImage * gimage,Guide * guide)
name|gimage_remove_guide
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_delete_guide (GImage * gimage,Guide * guide)
name|gimage_delete_guide
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection functions                                    */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|project_intensity (GImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_intensity_alpha (GImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity_alpha
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed (GImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest)
name|project_indexed
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Unable to project indexed image."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed_alpha (GImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_indexed_alpha
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INDEXED_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_channel (GImage * gimage,Channel * channel,PixelRegion * src,PixelRegion * src2)
name|project_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|INITIAL_CHANNEL_MASK
else|:
name|INITIAL_CHANNEL_SELECTION
expr_stmt|;
name|initial_region
argument_list|(
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|COMBINE_INTEN_A_CHANNEL_MASK
else|:
name|COMBINE_INTEN_A_CHANNEL_SELECTION
expr_stmt|;
name|combine_regions
argument_list|(
name|src
argument_list|,
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Layer/Channel functions                                 */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimage_free_layers (GImage * gimage)
name|gimage_free_layers
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|link_ptr
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_delete
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_free_channels (GImage * gimage)
name|gimage_free_channels
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|link_ptr
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_delete
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_construct_layers (GImage * gimage,int x,int y,int w,int h)
name|gimage_construct_layers
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|link_ptr
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|link_ptr
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  composite the floating selection if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_composite
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  If all channels are not visible, simply return  */
switch|switch
condition|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
if|if
condition|(
operator|!
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|Red
argument_list|)
operator|&&
operator|!
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|Green
argument_list|)
operator|&&
operator|!
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|Blue
argument_list|)
condition|)
return|return;
break|break;
case|case
name|GRAY
case|:
if|if
condition|(
operator|!
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|Gray
argument_list|)
condition|)
return|return;
break|break;
case|case
name|INDEXED
case|:
if|if
condition|(
operator|!
name|gimage_get_component_visible
argument_list|(
name|gimage
argument_list|,
name|Indexed
argument_list|)
condition|)
return|return;
break|break;
block|}
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections to the list  */
if|if
condition|(
operator|!
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|add_to_list
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|BOUNDS
argument_list|(
name|off_x
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|off_y
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimage_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  If we're showing the layer mask instead of the layer...  */
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|show_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|copy_gray_to_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
block|}
comment|/*  Otherwise, normal  */
else|else
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the 	   *  projection image... 	   */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
comment|/* no mask possible */
name|project_intensity
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|project_intensity_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
comment|/* no mask possible */
name|project_indexed
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXEDA_GIMAGE
case|:
name|project_indexed_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
comment|/*  something was projected  */
name|reverse_list
operator|=
name|next_item
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_construct_channels (GImage * gimage,int x,int y,int w,int h)
name|gimage_construct_channels
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|;
name|link_ptr
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|link_ptr
name|reverse_list
init|=
name|NULL
decl_stmt|;
comment|/*  reverse the channel list  */
while|while
condition|(
name|list
condition|)
block|{
name|reverse_list
operator|=
name|add_to_list
argument_list|(
name|reverse_list
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimage_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|project_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
block|}
name|reverse_list
operator|=
name|next_item
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_initialize_projection (GImage * gimage,int x,int y,int w,int h)
name|gimage_initialize_projection
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|link_ptr
name|list
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|coverage
init|=
literal|0
decl_stmt|;
name|PixelRegion
name|PR
decl_stmt|;
name|unsigned
name|char
name|clear
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*  this function determines whether a visible layer    *  provides complete coverage over the image.  If not,    *  the projection is initialized to transparent    */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
operator|(
name|off_x
operator|<=
name|x
operator|)
operator|&&
operator|(
name|off_y
operator|<=
name|y
operator|)
operator|&&
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|x
operator|+
name|w
operator|)
operator|&&
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|y
operator|+
name|h
operator|)
condition|)
name|coverage
operator|=
literal|1
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coverage
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|PR
argument_list|,
name|gimage_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|PR
argument_list|,
name|clear
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimage_get_active_channels (GImage * gimage,GimpDrawable * drawable,int * active)
name|gimage_get_active_channels
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|int
modifier|*
name|active
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  first, blindly copy the gimage active channels  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|active
index|[
name|i
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|i
index|]
expr_stmt|;
comment|/*  If the drawable is a channel (a saved selection, etc.)    *  make sure that the alpha channel is not valid    */
if|if
condition|(
name|drawable_channel
argument_list|(
name|drawable
argument_list|)
operator|!=
name|NULL
condition|)
name|active
index|[
name|ALPHA_G_PIX
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  no alpha values in channels  */
else|else
block|{
comment|/*  otherwise, check whether preserve transparency is        *  enabled in the layer and if the layer has alpha        */
if|if
condition|(
operator|(
name|layer
operator|=
name|drawable_layer
argument_list|(
name|drawable
argument_list|)
operator|)
condition|)
if|if
condition|(
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer
operator|->
name|preserve_trans
condition|)
name|active
index|[
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimage_inflate (GImage * gimage)
name|gimage_inflate
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Make sure the projection image is allocated  */
name|gimage_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|flat
operator|=
name|FALSE
expr_stmt|;
comment|/*  update the gdisplay titles  */
name|gdisplays_update_title
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_deflate (GImage * gimage)
name|gimage_deflate
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Make sure the projection image is deallocated  */
name|gimage_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|flat
operator|=
name|TRUE
expr_stmt|;
comment|/*  update the gdisplay titles  */
name|gdisplays_update_title
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_construct (GImage * gimage,int x,int y,int w,int h)
name|gimage_construct
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
comment|/*  if the gimage is not flat, construction is necessary.  */
if|if
condition|(
operator|!
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
comment|/*  set the construct flag, used to determine if anything        *  has been written to the gimage raw image yet.        */
name|gimage
operator|->
name|construct_flag
operator|=
literal|0
expr_stmt|;
comment|/*  First, determine if the projection image needs to be        *  initialized--this is the case when there are no visible        *  layers that cover the entire canvas--either because layers        *  are offset or only a floating selection is visible        */
name|gimage_initialize_projection
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/*  call functions which process the list of layers and        *  the list of channels        */
name|gimage_construct_layers
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|gimage_construct_channels
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimage_invalidate (GImage * gimage,int x,int y,int w,int h,int x1,int y1,int x2,int y2)
name|gimage_invalidate
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|startx
decl_stmt|,
name|starty
decl_stmt|;
name|int
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|int
name|tilex
decl_stmt|,
name|tiley
decl_stmt|;
name|int
name|flat
decl_stmt|;
name|flat
operator|=
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gimage_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|startx
operator|=
name|x
expr_stmt|;
name|starty
operator|=
name|y
expr_stmt|;
name|endx
operator|=
name|x
operator|+
name|w
expr_stmt|;
name|endy
operator|=
name|y
operator|+
name|h
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  invalidate all lower level tiles  */
comment|/*tile_manager_invalidate_tiles (gimage_projection (gimage), tile);*/
if|if
condition|(
operator|!
name|flat
condition|)
block|{
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile
operator|->
name|ewidth
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|x1
condition|)
name|startx
operator|=
name|MAX
argument_list|(
name|startx
argument_list|,
operator|(
name|j
operator|+
name|tile
operator|->
name|ewidth
operator|)
argument_list|)
expr_stmt|;
else|else
name|endx
operator|=
name|MIN
argument_list|(
name|endx
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile
operator|->
name|eheight
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|y1
condition|)
name|starty
operator|=
name|MAX
argument_list|(
name|starty
argument_list|,
operator|(
name|i
operator|+
name|tile
operator|->
name|eheight
operator|)
argument_list|)
expr_stmt|;
else|else
name|endy
operator|=
name|MIN
argument_list|(
name|endy
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tile is not valid, make sure we get the entire tile 		 *   in the construction extents 		 */
if|if
condition|(
name|tile
operator|->
name|valid
operator|==
name|FALSE
condition|)
block|{
name|tilex
operator|=
name|j
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
expr_stmt|;
name|tiley
operator|=
name|i
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
expr_stmt|;
name|startx
operator|=
name|MIN
argument_list|(
name|startx
argument_list|,
name|tilex
argument_list|)
expr_stmt|;
name|endx
operator|=
name|MAX
argument_list|(
name|endx
argument_list|,
name|tilex
operator|+
name|tile
operator|->
name|ewidth
argument_list|)
expr_stmt|;
name|starty
operator|=
name|MIN
argument_list|(
name|starty
argument_list|,
name|tiley
argument_list|)
expr_stmt|;
name|endy
operator|=
name|MAX
argument_list|(
name|endy
argument_list|,
name|tiley
operator|+
name|tile
operator|->
name|eheight
argument_list|)
expr_stmt|;
name|tile
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|flat
operator|&&
operator|(
name|endx
operator|-
name|startx
operator|)
operator|>
literal|0
operator|&&
operator|(
name|endy
operator|-
name|starty
operator|)
operator|>
literal|0
condition|)
name|gimage_construct
argument_list|(
name|gimage
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
operator|(
name|endx
operator|-
name|startx
operator|)
argument_list|,
operator|(
name|endy
operator|-
name|starty
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_validate (TileManager * tm,Tile * tile,int level)
name|gimage_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/*  Get the gimage from the tilemanager  */
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|tm
operator|->
name|user_data
expr_stmt|;
comment|/*  Find the coordinates of this tile  */
name|x
operator|=
name|TILE_WIDTH
operator|*
operator|(
name|tile
operator|->
name|tile_num
operator|%
name|tm
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|ntile_cols
operator|)
expr_stmt|;
name|y
operator|=
name|TILE_HEIGHT
operator|*
operator|(
name|tile
operator|->
name|tile_num
operator|/
name|tm
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|ntile_cols
operator|)
expr_stmt|;
name|w
operator|=
name|tile
operator|->
name|ewidth
expr_stmt|;
name|h
operator|=
name|tile
operator|->
name|eheight
expr_stmt|;
name|gimage_construct
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_get_layer_index (GImage * gimage,Layer * layer_arg)
name|gimage_get_layer_index
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|link_ptr
name|layers
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|layers
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layers
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|layers
operator|=
name|next_item
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_get_channel_index (GImage * gimage,Channel * channel_ID)
name|gimage_get_channel_index
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_ID
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|link_ptr
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_ID
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|channels
operator|=
name|next_item
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_get_active_layer (GImage * gimage)
name|gimage_get_active_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_get_active_channel (GImage * gimage)
name|gimage_get_active_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_get_component_active (GImage * gimage,ChannelType type)
name|gimage_get_component_active
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gimage_get_component_visible (GImage * gimage,ChannelType type)
name|gimage_get_component_visible
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_get_mask (GImage * gimage)
name|gimage_get_mask
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_layer_boundary (GImage * gimage,BoundSeg ** segs,int * num_segs)
name|gimage_layer_boundary
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|num_segs
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage
operator|->
name|active_layer
operator|)
condition|)
block|{
operator|*
name|segs
operator|=
name|layer_boundary
argument_list|(
name|layer
argument_list|,
name|num_segs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_segs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_set_active_layer (GImage * gimage,Layer * layer)
name|gimage_set_active_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
comment|/*  First, find the layer in the gimage    *  If it isn't valid, find the first layer that is    */
if|if
condition|(
name|gimage_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|layers
condition|)
return|return
name|NULL
return|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layers
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|layer
condition|)
return|return
name|NULL
return|;
comment|/*  Configure the layer stack to reflect this change  */
name|gimage
operator|->
name|layer_stack
operator|=
name|remove_from_list
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|add_to_list
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
comment|/*  invalidate the selection boundary because of a layer modification  */
name|layer_invalidate_boundary
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Set the active layer  */
name|gimage
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/*  return the layer  */
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_set_active_channel (GImage * gimage,Channel * channel)
name|gimage_set_active_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*  First, find the channel    *  If it doesn't exist, find the first channel that does    */
if|if
condition|(
operator|!
name|channel
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|channels
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
expr_stmt|;
block|}
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
comment|/*  return the channel  */
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_unset_active_channel (GImage * gimage)
name|gimage_unset_active_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
comment|/*  make sure there is an active channel  */
if|if
condition|(
operator|!
operator|(
name|channel
operator|=
name|gimage
operator|->
name|active_channel
operator|)
condition|)
return|return
name|NULL
return|;
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_component_active (GImage * gimage,ChannelType type,int value)
name|gimage_set_component_active
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Auxillary
case|:
break|break;
block|}
comment|/*  If there is an active channel and we mess with the components,    *  the active channel gets unset...    */
if|if
condition|(
name|type
operator|!=
name|Auxillary
condition|)
name|gimage_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_component_visible (GImage * gimage,ChannelType type,int value)
name|gimage_set_component_visible
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_pick_correlate_layer (GImage * gimage,int x,int y)
name|gimage_pick_correlate_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_pick_correlate
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|layer
return|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_layer_mask_apply (GImage * gimage,int layer_id)
name|gimage_set_layer_mask_apply
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|layer_id
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  find the layer  */
if|if
condition|(
operator|!
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|layer_id
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|layer
operator|->
name|mask
condition|)
return|return;
name|layer
operator|->
name|apply_mask
operator|=
operator|!
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_layer_mask_edit (GImage * gimage,Layer * layer,int edit)
name|gimage_set_layer_mask_edit
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|int
name|edit
parameter_list|)
block|{
comment|/*  find the layer  */
if|if
condition|(
operator|!
name|layer
condition|)
return|return;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
name|layer
operator|->
name|edit_mask
operator|=
name|edit
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_set_layer_mask_show (GImage * gimage,int layer_id)
name|gimage_set_layer_mask_show
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|layer_id
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  find the layer  */
if|if
condition|(
operator|!
operator|(
name|layer
operator|=
name|layer_get_ID
argument_list|(
name|layer_id
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|layer
operator|->
name|mask
condition|)
return|return;
name|layer
operator|->
name|show_mask
operator|=
operator|!
name|layer
operator|->
name|show_mask
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_raise_layer (GImage * gimage,Layer * layer_arg)
name|gimage_raise_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|prev_layer
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|link_ptr
name|prev
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|off2_x
decl_stmt|,
name|off2_y
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|prev_layer
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|prev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/*  We can only raise a layer if it has an alpha channel&& 	   *  If it's not already the top layer 	   */
if|if
condition|(
name|prev
operator|&&
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer_has_alpha
argument_list|(
name|prev_layer
argument_list|)
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|prev_layer
expr_stmt|;
name|prev
operator|->
name|data
operator|=
name|layer
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|,
operator|&
name|off2_x
argument_list|,
operator|&
name|off2_y
argument_list|)
expr_stmt|;
comment|/*  calculate minimum area to update  */
name|x1
operator|=
name|MAXIMUM
argument_list|(
name|off_x
argument_list|,
name|off2_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAXIMUM
argument_list|(
name|off_y
argument_list|,
name|off2_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MINIMUM
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MINIMUM
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>
literal|0
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
operator|>
literal|0
condition|)
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|prev_layer
return|;
block|}
else|else
block|{
name|message_box
argument_list|(
literal|"Layer cannot be raised any further"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_lower_layer (GImage * gimage,Layer * layer_arg)
name|gimage_lower_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|next_layer
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|link_ptr
name|next
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|off2_x
decl_stmt|,
name|off2_y
decl_stmt|;
name|next_layer
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/*  We can only lower a layer if it has an alpha channel&& 	   *  The layer beneath it has an alpha channel&& 	   *  If it's not already the bottom layer 	   */
if|if
condition|(
name|next
operator|&&
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer_has_alpha
argument_list|(
name|next_layer
argument_list|)
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|next_layer
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|layer
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|,
operator|&
name|off2_x
argument_list|,
operator|&
name|off2_y
argument_list|)
expr_stmt|;
comment|/*  calculate minimum area to update  */
name|x1
operator|=
name|MAXIMUM
argument_list|(
name|off_x
argument_list|,
name|off2_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAXIMUM
argument_list|(
name|off_y
argument_list|,
name|off2_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MINIMUM
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MINIMUM
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>
literal|0
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
operator|>
literal|0
condition|)
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|next_layer
return|;
block|}
else|else
block|{
name|message_box
argument_list|(
literal|"Layer cannot be lowered any further"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_merge_visible_layers (GImage * gimage,MergeType merge_type)
name|gimage_merge_visible_layers
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|link_ptr
name|layer_list
decl_stmt|;
name|link_ptr
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|append_to_list
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|next_item
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|layer
operator|=
name|gimage_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|message_box
argument_list|(
literal|"There are not enough visible layers for a merge.\nThere must be at least two."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_flatten (GImage * gimage)
name|gimage_flatten
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|link_ptr
name|layer_list
decl_stmt|;
name|link_ptr
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|append_to_list
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|next_item
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|layer
operator|=
name|gimage_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|FlattenImage
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_merge_layers (GImage * gimage,link_ptr merge_list,MergeType merge_type)
name|gimage_merge_layers
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|link_ptr
name|merge_list
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|link_ptr
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|Layer
modifier|*
name|merge_layer
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|bottom
decl_stmt|;
name|unsigned
name|char
name|bg
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|position
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
name|NULL
expr_stmt|;
comment|/*  Get the layer extents  */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|merge_type
condition|)
block|{
case|case
name|ExpandAsNecessary
case|:
case|case
name|ClipToImage
case|:
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off_x
operator|<
name|x1
condition|)
name|x1
operator|=
name|off_x
expr_stmt|;
if|if
condition|(
name|off_y
operator|<
name|y1
condition|)
name|y1
operator|=
name|off_y
expr_stmt|;
if|if
condition|(
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|x2
condition|)
name|x2
operator|=
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|y2
condition|)
name|y2
operator|=
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_type
operator|==
name|ClipToImage
condition|)
block|{
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ClipToBottomLayer
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FlattenImage
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
literal|0
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|y2
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|reverse_list
operator|=
name|add_to_list
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|next_item
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
operator|||
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*  Start a merge undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_MERGE_UNDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_type
operator|==
name|FlattenImage
condition|)
block|{
switch|switch
condition|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
name|type
operator|=
name|RGB_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|type
operator|=
name|GRAY_GIMAGE
expr_stmt|;
break|break;
case|case
name|INDEXED
case|:
name|type
operator|=
name|INDEXED_GIMAGE
expr_stmt|;
break|break;
block|}
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|type
argument_list|,
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  get the background for compositing  */
name|gimage_get_background
argument_list|(
name|gimage
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  init the pixel region  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to the background color  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*  The final merged layer inherits the attributes of the bottomost layer,        *  with a notable exception:  The resulting layer has an alpha channel        *  whether or not the original did        */
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|drawable_type_with_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_merge_layers: could not allocate merge layer"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  Set the layer to transparent  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to 0's  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  Find the index in the layer list of the bottom layer--we need this        *  in order to add the final, merged layer to the layer list correctly        */
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|position
operator|=
name|list_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|gimage_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* set the mode of the bottom layer to normal so that the contents        *  aren't lost when merging with the all-alpha merge_layer        *  Keep a pointer to it so that we can set the mode right after it's been        *  merged so that undo works correctly.        */
name|layer
operator|->
name|mode
operator|=
name|NORMAL
expr_stmt|;
name|bottom
operator|=
name|layer
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and        *  if it's actually legal...        */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
index|]
index|[
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_merge_layers attempting to merge incompatible layers\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x3
operator|=
name|BOUNDS
argument_list|(
name|off_x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y3
operator|=
name|BOUNDS
argument_list|(
name|off_y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x4
operator|=
name|BOUNDS
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y4
operator|=
name|BOUNDS
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|y1
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|gimage_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|next_item
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
comment|/* Save old mode in undo */
if|if
condition|(
name|bottom
condition|)
name|bottom
operator|->
name|mode
operator|=
name|merge_layer
operator|->
name|mode
expr_stmt|;
name|free_list
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
comment|/*  if the type is flatten, remove all the remaining layers  */
if|if
condition|(
name|merge_type
operator|==
name|FlattenImage
condition|)
block|{
name|merge_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|merge_list
operator|=
name|next_item
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimage_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|gimage_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Add the layer to the gimage  */
name|gimage_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
operator|(
name|list_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|position
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  End the merge undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Update the gimage  */
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
comment|/*  update gdisplay titles to reflect the possibility of    *  this layer being the only layer in the gimage    */
name|gdisplays_update_title
argument_list|(
name|gimage
operator|->
name|ID
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|merge_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_add_layer (GImage * gimage,Layer * float_layer,int position)
name|gimage_add_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|float_layer
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage_ID
operator|!=
literal|0
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage_ID
operator|!=
name|gimage
operator|->
name|ID
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_add_layer: attempt to add layer to wrong image"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|{
name|link_ptr
name|ll
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|data
operator|==
name|float_layer
condition|)
block|{
name|warning
argument_list|(
literal|"gimage_add_layer: trying to add layer to image twice"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ll
operator|=
name|next_item
argument_list|(
name|ll
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Prepare a layer undo and push it  */
name|lu
operator|=
operator|(
name|LayerUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|float_layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
name|lu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|float_layer
argument_list|)
condition|)
name|gimage
operator|->
name|floating_sel
operator|=
name|float_layer
expr_stmt|;
comment|/*  let the layer know about the gimage  */
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage_ID
operator|=
name|gimage
operator|->
name|ID
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
name|position
operator|=
name|gimage_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*  If there is a floating selection (and this isn't it!),        *  make sure the insert position is greater than 0        */
if|if
condition|(
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|&&
operator|(
name|gimage
operator|->
name|floating_sel
operator|!=
name|float_layer
operator|)
operator|&&
name|position
operator|==
literal|0
condition|)
name|position
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|insert_in_list
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|float_layer
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
name|gimage
operator|->
name|layers
operator|=
name|add_to_list
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|add_to_list
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimage_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  update the new layer's area  */
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|float_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_remove_layer (GImage * gimage,Layer * layer)
name|gimage_remove_layer
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
comment|/*  Prepare a layer undo--push it at the end  */
name|lu
operator|=
operator|(
name|LayerUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
name|gimage_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|remove_from_list
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|remove_from_list
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  If this was the floating selection, reset the fs pointer  */
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_reset
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|==
name|layer
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|layers
condition|)
name|gimage
operator|->
name|active_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layer_stack
operator|->
name|data
expr_stmt|;
else|else
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Push the layer undo--It is important it goes here since layer might        *   be immediately destroyed if the undo push fails        */
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|LayerMask
modifier|*
DECL|function|gimage_add_layer_mask (GImage * gimage,Layer * layer,LayerMask * mask)
name|gimage_add_layer_mask
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|LayerMask
modifier|*
name|mask
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|char
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|"Unable to add a layer mask since\nthe layer already has one."
expr_stmt|;
if|if
condition|(
name|drawable_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|error
operator|=
literal|"Unable to add a layer mask to a\nlayer in an indexed image."
expr_stmt|;
if|if
condition|(
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
name|error
operator|=
literal|"Cannot add layer mask to a layer\nwith no alpha channel."
expr_stmt|;
if|if
condition|(
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|||
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
condition|)
name|error
operator|=
literal|"Cannot add layer mask of different dimensions than specified layer."
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|message_box
argument_list|(
name|error
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer undo and push it  */
name|lmu
operator|=
operator|(
name|LayerMaskUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerMaskUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|lmu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
name|gimage_set_layer_mask_edit
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
name|layer
operator|->
name|edit_mask
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_remove_layer_mask (GImage * gimage,Layer * layer,int mode)
name|gimage_remove_layer_mask
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|layer
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|layer
operator|->
name|mask
condition|)
return|return
name|NULL
return|;
comment|/*  Start an undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_APPLY_MASK_UNDO
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer mask undo--push it below  */
name|lmu
operator|=
operator|(
name|LayerMaskUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerMaskUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|layer
operator|->
name|mask
expr_stmt|;
name|lmu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|lmu
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|layer_apply_mask
argument_list|(
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*  Push the undo--Important to do it here, AFTER the call    *   to layer_apply_mask, in case the undo push fails and the    *   mask is deleted    */
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
comment|/*  end the undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer mode is discard, update the layer--invalidate gimage also  */
if|if
condition|(
name|mode
operator|==
name|DISCARD
condition|)
block|{
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gdisplays_update_area
argument_list|(
name|gimage
operator|->
name|ID
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdisplays_flush
argument_list|()
expr_stmt|;
return|return
name|GIMP_CHANNEL
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_raise_channel (GImage * gimage,Channel * channel_arg)
name|gimage_raise_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|prev_channel
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|link_ptr
name|prev
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|prev_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|prev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|prev_channel
expr_stmt|;
name|prev
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|prev_channel
return|;
block|}
else|else
block|{
name|message_box
argument_list|(
literal|"Channel cannot be raised any further"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_lower_channel (GImage * gimage,Channel * channel_arg)
name|gimage_lower_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|next_channel
decl_stmt|;
name|link_ptr
name|list
decl_stmt|;
name|link_ptr
name|next
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|next_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|next_channel
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|next_channel
return|;
block|}
else|else
block|{
name|message_box
argument_list|(
literal|"Channel cannot be lowered any further"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_add_channel (GImage * gimage,Channel * channel,int position)
name|gimage_add_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
comment|/*  Prepare a channel undo and push it  */
name|cu
operator|=
operator|(
name|ChannelUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChannelUndo
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|cu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/*  add the channel to the list  */
name|gimage
operator|->
name|channels
operator|=
name|add_to_list
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active channel  */
name|gimage_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  if channel is visible, update the image  */
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimage_remove_channel (GImage * gimage,Channel * channel)
name|gimage_remove_channel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
comment|/*  Prepare a channel undo--push it below  */
name|cu
operator|=
operator|(
name|ChannelUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChannelUndo
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
name|gimage_get_channel_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|cu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|remove_from_list
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|==
name|channel
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|channels
condition|)
name|gimage
operator|->
name|active_channel
operator|=
operator|(
operator|(
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
operator|)
operator|)
expr_stmt|;
else|else
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Important to push the undo here in case the push fails  */
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Access functions                                        */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|int
DECL|function|gimage_is_flat (GImage * gimage)
name|gimage_is_flat
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|ac_visible
init|=
name|TRUE
decl_stmt|;
name|int
name|flat
init|=
name|TRUE
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  Are there no layers?  */
if|if
condition|(
name|gimage_is_empty
argument_list|(
name|gimage
argument_list|)
condition|)
name|flat
operator|=
name|FALSE
expr_stmt|;
comment|/*  Is there more than one layer?  */
elseif|else
if|if
condition|(
name|gimage
operator|->
name|layers
operator|->
name|next
condition|)
name|flat
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
comment|/*  determine if all channels are visible  */
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|layer
operator|=
name|gimage
operator|->
name|layers
operator|->
name|data
expr_stmt|;
name|a
operator|=
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|?
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|-
literal|1
else|:
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|a
condition|;
name|b
operator|++
control|)
if|if
condition|(
name|gimage
operator|->
name|visible
index|[
name|b
index|]
operator|==
name|FALSE
condition|)
name|ac_visible
operator|=
name|FALSE
expr_stmt|;
comment|/*  What makes a flat image?        *  1) the solitary layer is exactly gimage-sized and placed        *  2) no layer mask        *  3) opacity == OPAQUE_OPACITY        *  4) all channels must be visible        */
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|gimage
operator|->
name|width
operator|)
operator|||
operator|(
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|gimage
operator|->
name|height
operator|)
operator|||
operator|(
name|off_x
operator|!=
literal|0
operator|)
operator|||
operator|(
name|off_y
operator|!=
literal|0
operator|)
operator|||
operator|(
name|layer
operator|->
name|mask
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|layer
operator|->
name|opacity
operator|!=
name|OPAQUE_OPACITY
operator|)
operator|||
operator|(
name|ac_visible
operator|==
name|FALSE
operator|)
condition|)
name|flat
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  Are there any channels?  */
if|if
condition|(
name|gimage
operator|->
name|channels
condition|)
name|flat
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|flat
operator|!=
name|flat
condition|)
block|{
if|if
condition|(
name|flat
condition|)
name|gimage_deflate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_inflate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
return|return
name|gimage
operator|->
name|flat
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_is_empty (GImage * gimage)
name|gimage_is_empty
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
operator|(
operator|!
name|gimage
operator|->
name|layers
operator|)
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimage_active_drawable (GImage * gimage)
name|gimage_active_drawable
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|!=
name|NULL
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_channel
argument_list|)
return|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|!=
name|NULL
condition|)
block|{
name|layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_base_type (GImage * gimage)
name|gimage_base_type
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_base_type_with_alpha (GImage * gimage)
name|gimage_base_type_with_alpha
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
switch|switch
condition|(
name|gimage
operator|->
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
return|return
name|RGBA_GIMAGE
return|;
case|case
name|GRAY
case|:
return|return
name|GRAYA_GIMAGE
return|;
case|case
name|INDEXED
case|:
return|return
name|INDEXEDA_GIMAGE
return|;
block|}
return|return
name|RGB_GIMAGE
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|gimage_filename (GImage * gimage)
name|gimage_filename
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
return|return
name|gimage
operator|->
name|filename
return|;
else|else
return|return
literal|"Untitled"
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_enable_undo (GImage * gimage)
name|gimage_enable_undo
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free all undo steps as they are now invalidated  */
name|undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_disable_undo (GImage * gimage)
name|gimage_disable_undo
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|undo_on
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_dirty (GImage * gimage)
name|gimage_dirty
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|dirty
operator|<
literal|0
condition|)
name|gimage
operator|->
name|dirty
operator|=
literal|2
expr_stmt|;
else|else
name|gimage
operator|->
name|dirty
operator|++
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_clean (GImage * gimage)
name|gimage_clean
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|dirty
operator|<=
literal|0
condition|)
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
else|else
name|gimage
operator|->
name|dirty
operator|--
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_clean_all (GImage * gimage)
name|gimage_clean_all
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimage_floating_sel (GImage * gimage)
name|gimage_floating_sel
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|gimage
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
DECL|function|gimage_cmap (GImage * gimage)
name|gimage_cmap
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|drawable_cmap
argument_list|(
name|gimage_active_drawable
argument_list|(
name|gimage
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection access functions                             */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimage_projection (GImage * gimage)
name|gimage_projection
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If the gimage is flat, we simply want the data of the    *  first layer...Otherwise, we'll pass back the projection    */
if|if
condition|(
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage
operator|->
name|active_layer
operator|)
condition|)
return|return
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|gimage
operator|->
name|projection
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|width
operator|!=
name|gimage
operator|->
name|width
operator|)
operator|||
operator|(
name|gimage
operator|->
name|projection
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|height
operator|!=
name|gimage
operator|->
name|height
operator|)
condition|)
name|gimage_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|projection
return|;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gimage_projection_type (GImage * gimage)
name|gimage_projection_type
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If the gimage is flat, we simply want the type of the    *  first layer...Otherwise, we'll pass back the proj_type    */
if|if
condition|(
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|layer
operator|=
operator|(
name|gimage
operator|->
name|active_layer
operator|)
operator|)
condition|)
return|return
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
name|gimage
operator|->
name|proj_type
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_projection_bytes (GImage * gimage)
name|gimage_projection_bytes
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If the gimage is flat, we simply want the bytes in the    *  first layer...Otherwise, we'll pass back the proj_bytes    */
if|if
condition|(
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|layer
operator|=
operator|(
name|gimage
operator|->
name|active_layer
operator|)
operator|)
condition|)
return|return
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
name|gimage
operator|->
name|proj_bytes
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_projection_opacity (GImage * gimage)
name|gimage_projection_opacity
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If the gimage is flat, return the opacity of the active layer    *  Otherwise, we'll pass back OPAQUE_OPACITY    */
if|if
condition|(
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|layer
operator|=
operator|(
name|gimage
operator|->
name|active_layer
operator|)
operator|)
condition|)
return|return
name|layer
operator|->
name|opacity
return|;
else|else
return|return
name|OPAQUE_OPACITY
return|;
block|}
else|else
return|return
name|OPAQUE_OPACITY
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_projection_realloc (GImage * gimage)
name|gimage_projection_realloc
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage_is_flat
argument_list|(
name|gimage
argument_list|)
condition|)
name|gimage_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Composition access functions                            */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimage_composite (GImage * gimage)
name|gimage_composite
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage_projection
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_composite_type (GImage * gimage)
name|gimage_composite_type
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage_projection_type
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimage_composite_bytes (GImage * gimage)
name|gimage_composite_bytes
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage_projection_bytes
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|TempBuf
modifier|*
DECL|function|gimage_construct_composite_preview (GImage * gimage,int width,int height)
name|gimage_construct_composite_preview
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|TempBuf
modifier|*
name|comp
decl_stmt|;
name|TempBuf
modifier|*
name|layer_buf
decl_stmt|;
name|TempBuf
modifier|*
name|mask_buf
decl_stmt|;
name|link_ptr
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|link_ptr
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|double
name|ratio
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|construct_flag
decl_stmt|;
name|int
name|visible
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|ratio
operator|=
operator|(
name|double
operator|)
name|width
operator|/
operator|(
name|double
operator|)
name|gimage
operator|->
name|width
expr_stmt|;
switch|switch
condition|(
name|gimage_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|bytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|bytes
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*  The construction buffer  */
name|comp
operator|=
name|temp_buf_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|comp
operator|->
name|width
operator|*
name|comp
operator|->
name|height
operator|*
name|comp
operator|->
name|bytes
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections to the list  */
if|if
condition|(
operator|!
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|add_to_list
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|next_item
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|construct_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|w
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|h
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|x1
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src1PR
operator|.
name|bytes
operator|=
name|comp
operator|->
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|src1PR
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|src1PR
operator|.
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|rowstride
operator|=
name|comp
operator|->
name|width
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
operator|+
name|y1
operator|*
name|src1PR
operator|.
name|rowstride
operator|+
name|x1
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|layer_buf
operator|=
name|layer_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|src2PR
operator|.
name|bytes
operator|=
name|layer_buf
operator|->
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|w
operator|=
name|src1PR
operator|.
name|w
expr_stmt|;
name|src2PR
operator|.
name|h
operator|=
name|src1PR
operator|.
name|h
expr_stmt|;
name|src2PR
operator|.
name|rowstride
operator|=
name|layer_buf
operator|->
name|width
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|layer_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|src2PR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|mask_buf
operator|=
name|layer_mask_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|maskPR
operator|.
name|bytes
operator|=
name|mask_buf
operator|->
name|bytes
expr_stmt|;
name|maskPR
operator|.
name|rowstride
operator|=
name|mask_buf
operator|->
name|width
expr_stmt|;
name|maskPR
operator|.
name|data
operator|=
name|mask_buf_data
argument_list|(
name|mask_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|maskPR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|maskPR
operator|.
name|bytes
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the        *   composite preview...        *  Indexed images are actually already converted to RGB and RGBA,        *   so just project them as if they were type "intensity"        *  Send in all TRUE for visible since that info doesn't matter for previews        */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
case|case
name|INDEXED_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|construct_flag
operator|=
literal|1
expr_stmt|;
name|reverse_list
operator|=
name|next_item
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
return|return
name|comp
return|;
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimage_composite_preview (GImage * gimage,ChannelType type,int width,int height)
name|gimage_composite_preview
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|channel
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|channel
operator|=
name|RED_PIX
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|channel
operator|=
name|GREEN_PIX
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|channel
operator|=
name|BLUE_PIX
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|channel
operator|=
name|GRAY_PIX
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|channel
operator|=
name|INDEXED_PIX
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
comment|/*  The easy way  */
if|if
condition|(
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|width
operator|==
name|width
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|height
operator|==
name|height
condition|)
return|return
name|gimage
operator|->
name|comp_preview
return|;
comment|/*  The hard way  */
else|else
block|{
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
comment|/*  Actually construct the composite preview from the layer previews!        *  This might seem ridiculous, but it's actually the best way, given        *  a number of unsavory alternatives.        */
name|gimage
operator|->
name|comp_preview
operator|=
name|gimage_construct_composite_preview
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
name|gimage
operator|->
name|comp_preview
return|;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gimage_preview_valid (gimage,type)
name|gimage_preview_valid
parameter_list|(
name|gimage
parameter_list|,
name|type
parameter_list|)
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimage_invalidate_preview (GImage * gimage)
name|gimage_invalidate_preview
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  Invalidate the floating sel if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_invalidate
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimage_invalidate_previews (void)
name|gimage_invalidate_previews
parameter_list|(
name|void
parameter_list|)
block|{
name|link_ptr
name|tmp
init|=
name|image_list
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|tmp
operator|->
name|data
expr_stmt|;
name|gimage_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|next_item
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

