begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"airbrush.h"
end_include

begin_include
include|#
directive|include
file|"blend.h"
end_include

begin_include
include|#
directive|include
file|"bucket_fill.h"
end_include

begin_include
include|#
directive|include
file|"by_color_select.h"
end_include

begin_include
include|#
directive|include
file|"channel.h"
end_include

begin_include
include|#
directive|include
file|"clone.h"
end_include

begin_include
include|#
directive|include
file|"color_picker.h"
end_include

begin_include
include|#
directive|include
file|"convolve.h"
end_include

begin_include
include|#
directive|include
file|"crop.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"ellipse_select.h"
end_include

begin_include
include|#
directive|include
file|"eraser.h"
end_include

begin_include
include|#
directive|include
file|"flip_tool.h"
end_include

begin_include
include|#
directive|include
file|"free_select.h"
end_include

begin_include
include|#
directive|include
file|"fuzzy_select.h"
end_include

begin_include
include|#
directive|include
file|"paint_core.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"paintbrush.h"
end_include

begin_include
include|#
directive|include
file|"pencil.h"
end_include

begin_include
include|#
directive|include
file|"perspective_tool.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"rotate_tool.h"
end_include

begin_include
include|#
directive|include
file|"scale_tool.h"
end_include

begin_include
include|#
directive|include
file|"shear_tool.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager_pvt.h"
end_include

begin_include
include|#
directive|include
file|"transform_core.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_decl_stmt
DECL|variable|airbrush_proc
specifier|static
name|ProcRecord
name|airbrush_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|blend_proc
specifier|static
name|ProcRecord
name|blend_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bucket_fill_proc
specifier|static
name|ProcRecord
name|bucket_fill_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|by_color_select_proc
specifier|static
name|ProcRecord
name|by_color_select_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|clone_proc
specifier|static
name|ProcRecord
name|clone_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|color_picker_proc
specifier|static
name|ProcRecord
name|color_picker_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|convolve_proc
specifier|static
name|ProcRecord
name|convolve_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|crop_proc
specifier|static
name|ProcRecord
name|crop_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ellipse_select_proc
specifier|static
name|ProcRecord
name|ellipse_select_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eraser_proc
specifier|static
name|ProcRecord
name|eraser_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|flip_proc
specifier|static
name|ProcRecord
name|flip_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|free_select_proc
specifier|static
name|ProcRecord
name|free_select_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|fuzzy_select_proc
specifier|static
name|ProcRecord
name|fuzzy_select_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|paintbrush_proc
specifier|static
name|ProcRecord
name|paintbrush_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pencil_proc
specifier|static
name|ProcRecord
name|pencil_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|perspective_proc
specifier|static
name|ProcRecord
name|perspective_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rect_select_proc
specifier|static
name|ProcRecord
name|rect_select_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rotate_proc
specifier|static
name|ProcRecord
name|rotate_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|scale_proc
specifier|static
name|ProcRecord
name|scale_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|shear_proc
specifier|static
name|ProcRecord
name|shear_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_tools_procs (void)
name|register_tools_procs
parameter_list|(
name|void
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
operator|&
name|airbrush_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|blend_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|bucket_fill_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|by_color_select_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|clone_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|color_picker_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|convolve_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|crop_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|ellipse_select_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|eraser_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|flip_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|free_select_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|fuzzy_select_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|paintbrush_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|pencil_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|perspective_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|rect_select_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|rotate_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|scale_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|shear_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|airbrush_invoker (Argument * args)
name|airbrush_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|pressure
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pressure
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|pressure
operator|<
literal|0.0
operator|||
name|pressure
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|airbrush_non_gui
argument_list|(
name|drawable
argument_list|,
name|pressure
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|airbrush_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|airbrush_inargs
specifier|static
name|ProcArg
name|airbrush_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"pressure"
block|,
literal|"The pressure of the airbrush strokes (0<= pressure<= 100)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|airbrush_proc
specifier|static
name|ProcRecord
name|airbrush_proc
init|=
block|{
literal|"gimp_airbrush"
block|,
literal|"Paint in the current brush with varying pressure. Paint application is time-dependent."
block|,
literal|"This tool simulates the use of an airbrush. Paint pressure represents the relative intensity of the paint application. High pressure results in a thicker layer of paint while low pressure results in a thinner layer."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|4
block|,
name|airbrush_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|airbrush_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|blend_invoker (Argument * args)
name|blend_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|blend_mode
decl_stmt|;
name|gint32
name|paint_mode
decl_stmt|;
name|gint32
name|gradient_type
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|gdouble
name|offset
decl_stmt|;
name|gint32
name|repeat
decl_stmt|;
name|gboolean
name|supersample
decl_stmt|;
name|gint32
name|max_depth
decl_stmt|;
name|gdouble
name|threshold
decl_stmt|;
name|gdouble
name|x1
decl_stmt|;
name|gdouble
name|y1
decl_stmt|;
name|gdouble
name|x2
decl_stmt|;
name|gdouble
name|y2
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|blend_mode
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|blend_mode
operator|<
name|FG_BG_RGB_MODE
operator|||
name|blend_mode
operator|>
name|CUSTOM_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|paint_mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|paint_mode
operator|<
name|NORMAL_MODE
operator|||
name|paint_mode
operator|>
name|DIVIDE_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|gradient_type
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|gradient_type
operator|<
name|LINEAR
operator|||
name|gradient_type
operator|>
name|SPIRAL_ANTICLOCKWISE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offset
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|repeat
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|repeat
operator|<
name|REPEAT_NONE
operator|||
name|repeat
operator|>
name|REPEAT_TRIANGULAR
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|supersample
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|max_depth
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|supersample
operator|&&
operator|(
name|max_depth
operator|<
literal|1
operator|||
name|max_depth
operator|>
literal|9
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|9
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|supersample
operator|&&
operator|(
name|threshold
operator|<
literal|0.0
operator|||
name|threshold
operator|>
literal|4.0
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x1
operator|=
name|args
index|[
literal|10
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y1
operator|=
name|args
index|[
literal|11
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|x2
operator|=
name|args
index|[
literal|12
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y2
operator|=
name|args
index|[
literal|13
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|blend
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|blend_mode
argument_list|,
name|paint_mode
argument_list|,
name|gradient_type
argument_list|,
name|opacity
argument_list|,
name|offset
argument_list|,
name|repeat
argument_list|,
name|supersample
argument_list|,
name|max_depth
argument_list|,
name|threshold
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|blend_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|blend_inargs
specifier|static
name|ProcArg
name|blend_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"blend_mode"
block|,
literal|"The type of blend: { FG_BG_RGB (0), FG_BG_HSV (1), FG_TRANS (2), CUSTOM (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"paint_mode"
block|,
literal|"The paint application mode: { NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY/BURN (3), SCREEN (4), OVERLAY (5), DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14), DIVIDE/DODGE (15) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"gradient_type"
block|,
literal|"The type of gradient: { LINEAR (0), BILINEAR (1), RADIAL (2), SQUARE (3), CONICAL_SYMMETRIC (4), CONICAL_ASYMMETRIC (5), SHAPEBURST_ANGULAR (6), SHAPEBURST_SPHERICAL (7), SHAPEBURST_DIMPLED (8), SPIRAL_CLOCKWISE (9), SPIRAL_ANTICLOCKWISE (10) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the final blend (0<= opacity<= 100)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"offset"
block|,
literal|"Offset relates to the starting and ending coordinates specified for the blend. This parameter is mode dependent (0<= offset)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"repeat"
block|,
literal|"Repeat mode: { REPEAT_NONE (0), REPEAT_SAWTOOTH (1), REPEAT_TRIANGULAR (2) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"supersample"
block|,
literal|"Do adaptive supersampling (TRUE or FALSE)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"max_depth"
block|,
literal|"Maximum recursion levels for supersampling"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"threshold"
block|,
literal|"Supersampling threshold"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x1"
block|,
literal|"The x coordinate of this blend's starting point"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y1"
block|,
literal|"The y coordinate of this blend's starting point"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x2"
block|,
literal|"The x coordinate of this blend's ending point"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y2"
block|,
literal|"The y coordinate of this blend's ending point"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|blend_proc
specifier|static
name|ProcRecord
name|blend_proc
init|=
block|{
literal|"gimp_blend"
block|,
literal|"Blend between the starting and ending coordinates with the specified blend mode and gradient type."
block|,
literal|"This tool requires information on the paint application mode, the blend mode, and the gradient type. It creates the specified variety of blend using the starting and ending coordinates as defined for each gradient type."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|14
block|,
name|blend_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|blend_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|bucket_fill_invoker (Argument * args)
name|bucket_fill_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|fill_mode
decl_stmt|;
name|gint32
name|paint_mode
decl_stmt|;
name|gdouble
name|opacity
decl_stmt|;
name|gdouble
name|threshold
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|fill_mode
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|fill_mode
operator|<
name|FG_BUCKET_FILL
operator|||
name|fill_mode
operator|>
name|PATTERN_BUCKET_FILL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|paint_mode
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|paint_mode
operator|<
name|NORMAL_MODE
operator|||
name|paint_mode
operator|>
name|DIVIDE_MODE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|opacity
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|opacity
operator|<
literal|0.0
operator|||
name|opacity
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|0.0
operator|||
name|threshold
operator|>
literal|255.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|bucket_fill
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|fill_mode
argument_list|,
name|paint_mode
argument_list|,
name|opacity
argument_list|,
name|threshold
argument_list|,
name|sample_merged
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|bucket_fill_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|bucket_fill_inargs
specifier|static
name|ProcArg
name|bucket_fill_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"fill_mode"
block|,
literal|"The type of fill: { FG_BUCKET_FILL (0), BG_BUCKET_FILL (1), PATTERN_BUCKET_FILL (2) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"paint_mode"
block|,
literal|"The paint application mode: { NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY/BURN (3), SCREEN (4), OVERLAY (5), DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14), DIVIDE/DODGE (15) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"opacity"
block|,
literal|"The opacity of the final bucket fill (0<= opacity<= 100)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"threshold"
block|,
literal|"The threshold determines how extensive the seed fill will be. It's value is specified in terms of intensity levels (0<= threshold<= 255). This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"The x coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image."
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"The y coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bucket_fill_proc
specifier|static
name|ProcRecord
name|bucket_fill_proc
init|=
block|{
literal|"gimp_bucket_fill"
block|,
literal|"Fill the area specified either by the current selection if there is one, or by a seed fill starting at the specified coordinates."
block|,
literal|"This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern. If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter. If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of merged sampling, the x,y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|8
block|,
name|bucket_fill_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|bucket_fill_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|by_color_select_invoker (Argument * args)
name|by_color_select_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|guchar
modifier|*
name|color
decl_stmt|;
name|gint32
name|threshold
decl_stmt|;
name|gint32
name|operation
decl_stmt|;
name|gboolean
name|antialias
decl_stmt|;
name|gboolean
name|feather
decl_stmt|;
name|gdouble
name|feather_radius
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|color
operator|=
operator|(
name|guchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|0
operator|||
name|threshold
operator|>
literal|255
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|operation
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|operation
operator|<
name|ADD
operator|||
name|operation
operator|>
name|INTERSECT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|antialias
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather_radius
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|by_color_select
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|color
argument_list|,
name|threshold
argument_list|,
name|operation
argument_list|,
name|antialias
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|,
name|sample_merged
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|by_color_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|by_color_select_inargs
specifier|static
name|ProcArg
name|by_color_select_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_COLOR
block|,
literal|"color"
block|,
literal|"The color to select"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"threshold"
block|,
literal|"Threshold in intensity levels 0<= threshold<= 255"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"The selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"antialias"
block|,
literal|"Antialiasing (TRUE or FALSE)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"Feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"Radius for feather operation"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|by_color_select_proc
specifier|static
name|ProcRecord
name|by_color_select_proc
init|=
block|{
literal|"gimp_by_color_select"
block|,
literal|"Create a selection by selecting all pixels (in the specified drawable) with the same (or similar) color to that specified."
block|,
literal|"This tool creates a selection over the specified image. A by-color selection is determined by the supplied color under the constraints of the specified threshold. Essentially, all pixels (in the drawable) that have color sufficiently close to the specified color (as determined by the threshold value) are included in the selection. The antialiasing parameter allows the final selection mask to contain intermediate values based on close misses to the threshold bar. Feathering can be enabled optionally and is controlled with the \"feather_radius\" parameter. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of a merged sampling, the supplied drawable is ignored."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|8
block|,
name|by_color_select_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|by_color_select_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|clone_invoker (Argument * args)
name|clone_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpDrawable
modifier|*
name|src_drawable
decl_stmt|;
name|gint32
name|clone_type
decl_stmt|;
name|gdouble
name|src_x
decl_stmt|;
name|gdouble
name|src_y
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|src_drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|clone_type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|clone_type
operator|<
name|IMAGE_CLONE
operator|||
name|clone_type
operator|>
name|PATTERN_CLONE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|src_x
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|src_y
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|clone_non_gui
argument_list|(
name|drawable
argument_list|,
name|src_drawable
argument_list|,
name|clone_type
argument_list|,
name|src_x
argument_list|,
name|src_y
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|clone_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|clone_inargs
specifier|static
name|ProcArg
name|clone_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"src_drawable"
block|,
literal|"The source drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"clone_type"
block|,
literal|"The type of clone: { IMAGE_CLONE (0), PATTERN_CLONE (1) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"src_x"
block|,
literal|"The x coordinate in the source image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"src_y"
block|,
literal|"The y coordinate in the source image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|clone_proc
specifier|static
name|ProcRecord
name|clone_proc
init|=
block|{
literal|"gimp_clone"
block|,
literal|"Clone from the source to the dest drawable using the current brush"
block|,
literal|"This tool clones (copies) from the source drawable starting at the specified source coordinates to the dest drawable. If the \"clone_type\" argument is set to PATTERN-CLONE, then the current pattern is used as the source and the \"src_drawable\" argument is ignored. Pattern cloning assumes a tileable pattern and mods the sum of the src coordinates and subsequent stroke offsets with the width and height of the pattern. For image cloning, if the sum of the src coordinates and subsequent stroke offsets exceeds the extents of the src drawable, then no paint is transferred. The clone tool is capable of transforming between any image types including RGB->Indexed--although converting from any type to indexed is significantly slower."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|7
block|,
name|clone_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|clone_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|color_picker_invoker (Argument * args)
name|color_picker_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|gboolean
name|sample_average
decl_stmt|;
name|gdouble
name|average_radius
decl_stmt|;
name|gboolean
name|save_color
decl_stmt|;
name|guchar
modifier|*
name|color
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|sample_average
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|average_radius
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|sample_average
operator|&&
operator|(
name|average_radius
operator|<=
literal|0.0
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|save_color
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|sample_merged
condition|)
if|if
condition|(
operator|!
name|drawable
operator|||
operator|(
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
operator|!=
name|gimage
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|pick_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
name|sample_merged
argument_list|,
name|sample_average
argument_list|,
name|average_radius
argument_list|,
name|save_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|color
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|color
index|[
name|RED_PIX
index|]
operator|=
name|col_value
index|[
name|RED_PIX
index|]
expr_stmt|;
name|color
index|[
name|GREEN_PIX
index|]
operator|=
name|col_value
index|[
name|GREEN_PIX
index|]
expr_stmt|;
name|color
index|[
name|BLUE_PIX
index|]
operator|=
name|col_value
index|[
name|BLUE_PIX
index|]
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|color_picker_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|color
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|color_picker_inargs
specifier|static
name|ProcArg
name|color_picker_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_average"
block|,
literal|"Average the color of all the pixels in a specified radius"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"average_radius"
block|,
literal|"The radius of pixels to average"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"save_color"
block|,
literal|"Save the color to the active palette"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|color_picker_outargs
specifier|static
name|ProcArg
name|color_picker_outargs
index|[]
init|=
block|{
block|{
name|PDB_COLOR
block|,
literal|"color"
block|,
literal|"The return color"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|color_picker_proc
specifier|static
name|ProcRecord
name|color_picker_proc
init|=
block|{
literal|"gimp_color_picker"
block|,
literal|"Determine the color at the given drawable coordinates"
block|,
literal|"This tool determines the color at the specified coordinates. The returned color is an RGB triplet even for grayscale and indexed drawables. If the coordinates lie outside of the extents of the specified drawable, then an error is returned. If the drawable has an alpha channel, the algorithm examines the alpha value of the drawable at the coordinates. If the alpha value is completely transparent (0), then an error is returned. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of a merged sampling, the supplied drawable is ignored."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|8
block|,
name|color_picker_inargs
block|,
literal|1
block|,
name|color_picker_outargs
block|,
block|{
block|{
name|color_picker_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|convolve_invoker (Argument * args)
name|convolve_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|pressure
decl_stmt|;
name|gint32
name|convolve_type
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pressure
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|pressure
operator|<
literal|0.0
operator|||
name|pressure
operator|>
literal|100.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|convolve_type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|convolve_type
operator|<
name|BLUR_CONVOLVE
operator|||
name|convolve_type
operator|>
name|SHARPEN_CONVOLVE
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|convolve_non_gui
argument_list|(
name|drawable
argument_list|,
name|pressure
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|convolve_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|convolve_inargs
specifier|static
name|ProcArg
name|convolve_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"pressure"
block|,
literal|"The pressure: 0<= pressure<= 100"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"convolve_type"
block|,
literal|"Convolve type: { BLUR (0), SHARPEN (1) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|convolve_proc
specifier|static
name|ProcRecord
name|convolve_proc
init|=
block|{
literal|"gimp_convolve"
block|,
literal|"Convolve (Blur, Sharpen) using the current brush."
block|,
literal|"This tool convolves the specified drawable with either a sharpening or blurring kernel. The pressure parameter controls the magnitude of the operation. Like the paintbrush, this tool linearly interpolates between the specified stroke coordinates."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|convolve_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|convolve_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|crop_invoker (Argument * args)
name|crop_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|new_width
decl_stmt|;
name|gint32
name|new_height
decl_stmt|;
name|gint32
name|offx
decl_stmt|;
name|gint32
name|offy
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_width
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_width
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|new_height
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|new_height
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offx
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|offx
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|offy
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|offy
operator|<
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|new_width
operator|>
name|gimage
operator|->
name|width
operator|||
name|new_height
operator|>
name|gimage
operator|->
name|height
operator|||
name|offx
operator|>
operator|(
name|gimage
operator|->
name|width
operator|-
name|new_width
operator|)
operator|||
name|offy
operator|>
operator|(
name|gimage
operator|->
name|height
operator|-
name|new_height
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|crop_image
argument_list|(
name|gimage
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|offx
operator|+
name|new_width
argument_list|,
name|offy
operator|+
name|new_height
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|crop_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|crop_inargs
specifier|static
name|ProcArg
name|crop_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_width"
block|,
literal|"New image width: (0< new_width<= width)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"new_height"
block|,
literal|"New image height: (0< new_height<= height)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offx"
block|,
literal|"x offset: (0<= offx<= (width - new_width))"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"offy"
block|,
literal|"y offset: (0<= offy<= (height - new_height))"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|crop_proc
specifier|static
name|ProcRecord
name|crop_proc
init|=
block|{
literal|"gimp_crop"
block|,
literal|"Crop the image to the specified extents."
block|,
literal|"This procedure crops the image so that it's new width and height are equal to the supplied parameters. Offsets are also provided which describe the position of the previous image's content. All channels and layers within the image are cropped to the new image extents; this includes the image selection mask. If any parameters are out of range, an error is returned."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|crop_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|crop_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|ellipse_select_invoker (Argument * args)
name|ellipse_select_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|gdouble
name|width
decl_stmt|;
name|gdouble
name|height
decl_stmt|;
name|gint32
name|operation
decl_stmt|;
name|gboolean
name|antialias
decl_stmt|;
name|gboolean
name|feather
decl_stmt|;
name|gdouble
name|feather_radius
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|width
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|height
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|operation
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|operation
operator|<
name|ADD
operator|||
name|operation
operator|>
name|INTERSECT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|antialias
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather_radius
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|ellipse_select
argument_list|(
name|gimage
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
operator|(
name|int
operator|)
name|width
argument_list|,
operator|(
name|int
operator|)
name|height
argument_list|,
name|operation
argument_list|,
name|antialias
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|ellipse_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|ellipse_select_inargs
specifier|static
name|ProcArg
name|ellipse_select_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of upper-left corner of ellipse bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of upper-left corner of ellipse bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"width"
block|,
literal|"The width of the ellipse: 0< width"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"height"
block|,
literal|"The height of the ellipse: 0< height"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"The selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"antialias"
block|,
literal|"Antialiasing (TRUE or FALSE)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"Feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"Radius for feather operation"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ellipse_select_proc
specifier|static
name|ProcRecord
name|ellipse_select_proc
init|=
block|{
literal|"gimp_ellipse_select"
block|,
literal|"Create an elliptical selection over the specified image."
block|,
literal|"This tool creates an elliptical selection over the specified image. The elliptical region can be either added to, subtracted from, or replace the contents of the previous selection mask. If antialiasing is turned on, the edges of the elliptical region will contain intermediate values which give the appearance of a sharper, less pixelized edge. This should be set as TRUE most of the time. If the feather option is enabled, the resulting selection is blurred before combining. The blur is a gaussian blur with the specified feather radius."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|9
block|,
name|ellipse_select_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|ellipse_select_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|eraser_invoker (Argument * args)
name|eraser_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|gint32
name|hardness
decl_stmt|;
name|gint32
name|method
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|hardness
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|hardness
operator|<
name|HARD
operator|||
name|hardness
operator|>
name|SOFT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|method
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|method
operator|<
name|CONSTANT
operator|||
name|method
operator|>
name|INCREMENTAL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|eraser_non_gui
argument_list|(
name|drawable
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|,
name|hardness
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|eraser_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|eraser_inargs
specifier|static
name|ProcArg
name|eraser_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"hardness"
block|,
literal|"HARD (0) or SOFT (1)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"method"
block|,
literal|"CONTINUOUS (0) or INCREMENTAL (1)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eraser_proc
specifier|static
name|ProcRecord
name|eraser_proc
init|=
block|{
literal|"gimp_eraser"
block|,
literal|"Erase using the current brush."
block|,
literal|"This tool erases using the current brush mask. If the specified drawable contains an alpha channel, then the erased pixels will become transparent. Otherwise, the eraser tool replaces the contents of the drawable with the background color. Like paintbrush, this tool linearly interpolates between the specified stroke coordinates."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|eraser_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|eraser_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|flip_invoker (Argument * args)
name|flip_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|flip_type
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|,
modifier|*
name|new_tiles
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|flip_type
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|flip_type
operator|<
literal|0
operator|||
name|flip_type
operator|>
literal|1
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
comment|/* flip the buffer */
switch|switch
condition|(
name|flip_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* horz */
case|case
literal|1
case|:
comment|/* vert */
name|new_tiles
operator|=
name|flip_tool_flip
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|float_tiles
argument_list|,
operator|-
literal|1
argument_list|,
name|flip_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_tiles
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|layer
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/* push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|flip_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|flip_inargs
specifier|static
name|ProcArg
name|flip_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"flip_type"
block|,
literal|"Type of flip: HORIZONTAL (0) or VERTICAL (1)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|flip_outargs
specifier|static
name|ProcArg
name|flip_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The flipped drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|flip_proc
specifier|static
name|ProcRecord
name|flip_proc
init|=
block|{
literal|"gimp_flip"
block|,
literal|"Flip the specified drawable about its center either vertically or horizontally."
block|,
literal|"This tool flips the specified drawable if no selection exists. If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then flipd by the specified amount. The return value is the ID of the flipped drawable. If there was no selection, this will be equal to the drawable ID supplied as input. Otherwise, this will be the newly created and flipped drawable. The flip type parameter indicates whether the flip will be applied horizontally or vertically."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|flip_inargs
block|,
literal|1
block|,
name|flip_outargs
block|,
block|{
block|{
name|flip_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|free_select_invoker (Argument * args)
name|free_select_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_segs
decl_stmt|;
name|gdouble
modifier|*
name|segs
decl_stmt|;
name|gint32
name|operation
decl_stmt|;
name|gboolean
name|antialias
decl_stmt|;
name|gboolean
name|feather
decl_stmt|;
name|gdouble
name|feather_radius
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_segs
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_segs
operator|<
literal|2
operator|)
condition|)
name|num_segs
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|segs
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|operation
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|operation
operator|<
name|ADD
operator|||
name|operation
operator|>
name|INTERSECT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|antialias
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather_radius
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|free_select
argument_list|(
name|gimage
argument_list|,
name|num_segs
argument_list|,
operator|(
name|FreeSelectPoint
operator|*
operator|)
name|segs
argument_list|,
name|operation
argument_list|,
name|antialias
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|free_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|free_select_inargs
specifier|static
name|ProcArg
name|free_select_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_segs"
block|,
literal|"Number of points (count 1 coordinate as two points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"segs"
block|,
literal|"Array of points: { p1.x, p1.y, p2.x, p2.y, ..., pn.x, pn.y}"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"The selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"antialias"
block|,
literal|"Antialiasing (TRUE or FALSE)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"Feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"Radius for feather operation"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|free_select_proc
specifier|static
name|ProcRecord
name|free_select_proc
init|=
block|{
literal|"gimp_free_select"
block|,
literal|"Create a polygonal selection over the specified image."
block|,
literal|"This tool creates a polygonal selection over the specified image. The polygonal region can be either added to, subtracted from, or replace the contents of the previous selection mask. The polygon is specified through an array of floating point numbers and its length. The length of array must be 2n, where n is the number of points. Each point is defined by 2 floating point values which correspond to the x and y coordinates. If the final point does not connect to the starting point, a connecting segment is automatically added. If the feather option is enabled, the resulting selection is blurred before combining. The blur is a gaussian blur with the specified feather radius."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|7
block|,
name|free_select_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|free_select_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|fuzzy_select_invoker (Argument * args)
name|fuzzy_select_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|gint32
name|threshold
decl_stmt|;
name|gint32
name|operation
decl_stmt|;
name|gboolean
name|antialias
decl_stmt|;
name|gboolean
name|feather
decl_stmt|;
name|gdouble
name|feather_radius
decl_stmt|;
name|gboolean
name|sample_merged
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|Channel
modifier|*
name|new
decl_stmt|,
modifier|*
name|old_fuzzy_mask
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|threshold
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|0
operator|||
name|threshold
operator|>
literal|255
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|operation
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|operation
operator|<
name|ADD
operator|||
name|operation
operator|>
name|INTERSECT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|antialias
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather_radius
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|sample_merged
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|find_contiguous_region
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|sample_merged
argument_list|)
expr_stmt|;
name|old_fuzzy_mask
operator|=
name|fuzzy_mask
expr_stmt|;
name|fuzzy_mask
operator|=
name|new
expr_stmt|;
name|drawable
operator|=
name|sample_merged
condition|?
name|NULL
else|:
name|drawable
expr_stmt|;
name|fuzzy_select
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|operation
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|)
expr_stmt|;
name|fuzzy_mask
operator|=
name|old_fuzzy_mask
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|fuzzy_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|fuzzy_select_inargs
specifier|static
name|ProcArg
name|fuzzy_select_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of initial seed fill point: (image coordinates)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of initial seed fill point: (image coordinates)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"threshold"
block|,
literal|"Threshold in intensity levels 0<= threshold<= 255"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"The selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"antialias"
block|,
literal|"Antialiasing (TRUE or FALSE)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"Feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"Radius for feather operation"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"sample_merged"
block|,
literal|"Use the composite image, not the drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|fuzzy_select_proc
specifier|static
name|ProcRecord
name|fuzzy_select_proc
init|=
block|{
literal|"gimp_fuzzy_select"
block|,
literal|"Create a fuzzy selection starting at the specified coordinates on the specified drawable."
block|,
literal|"This tool creates a fuzzy selection over the specified image. A fuzzy selection is determined by a seed fill under the constraints of the specified threshold. Essentially, the color at the specified coordinates (in the drawable) is measured and the selection expands outwards from that point to any adjacent pixels which are not significantly different (as determined by the threshold value). This process continues until no more expansion is possible. The antialiasing parameter allows the final selection mask to contain intermediate values based on close misses to the threshold bar at pixels along the seed fill boundary. Feathering can be enabled optionally and is controlled with the \"feather_radius\" paramter. If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of a merged sampling, the supplied drawable is ignored."
literal|"If the sample is merged, the specified coordinates are relative to the image origin; otherwise, they are relative to the drawable's origin."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|9
block|,
name|fuzzy_select_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|fuzzy_select_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|paintbrush_invoker (Argument * args)
name|paintbrush_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gdouble
name|fade_out
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|gint32
name|method
decl_stmt|;
name|gdouble
name|gradient_length
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|fade_out
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|fade_out
operator|<
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|method
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|method
operator|<
name|CONSTANT
operator|||
name|method
operator|>
name|INCREMENTAL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|gradient_length
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|gradient_length
operator|<
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|paintbrush_non_gui
argument_list|(
name|drawable
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|,
name|fade_out
argument_list|,
name|method
argument_list|,
name|gradient_length
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|paintbrush_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|paintbrush_inargs
specifier|static
name|ProcArg
name|paintbrush_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"fade_out"
block|,
literal|"Fade out parameter: 0<= fade_out"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"method"
block|,
literal|"CONTINUOUS (0) or INCREMENTAL (1)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"gradient_length"
block|,
literal|"Length of gradient to draw: 0<= gradient_length"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|paintbrush_proc
specifier|static
name|ProcRecord
name|paintbrush_proc
init|=
block|{
literal|"gimp_paintbrush"
block|,
literal|"Paint in the current brush with optional fade out parameter and pull colors from a gradient."
block|,
literal|"This tool is the standard paintbrush. It draws linearly interpolated lines through the specified stroke coordinates. It operates on the specified drawable in the foreground color with the active brush. The \"fade_out\" parameter is measured in pixels and allows the brush stroke to linearly fall off. The pressure is set to the maximum at the beginning of the stroke. As the distance of the stroke nears the fade_out value, the pressure will approach zero. The gradient_length is the distance to spread the gradient over. It is measured in pixels. If the gradient_length is 0, no gradient is used."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|6
block|,
name|paintbrush_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|paintbrush_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|pencil_invoker (Argument * args)
name|pencil_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|num_strokes
decl_stmt|;
name|gdouble
modifier|*
name|strokes
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|num_strokes
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_strokes
operator|<
literal|2
operator|)
condition|)
name|num_strokes
operator|/=
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
name|strokes
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|pencil_non_gui
argument_list|(
name|drawable
argument_list|,
name|num_strokes
argument_list|,
name|strokes
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|pencil_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|pencil_inargs
specifier|static
name|ProcArg
name|pencil_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"Number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"Array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y }"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pencil_proc
specifier|static
name|ProcRecord
name|pencil_proc
init|=
block|{
literal|"gimp_pencil"
block|,
literal|"Paint in the current brush without sub-pixel sampling."
block|,
literal|"This tool is the standard pencil. It draws linearly interpolated lines through the specified stroke coordinates. It operates on the specified drawable in the foreground color with the active brush. The brush mask is treated as though it contains only black and white values. Any value below half is treated as black; any above half, as white."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|pencil_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|pencil_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|perspective_invoker (Argument * args)
name|perspective_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|interpolation
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|,
modifier|*
name|new_tiles
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|double
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|double
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|double
name|trans_info
index|[
literal|8
index|]
decl_stmt|;
name|GimpMatrix
name|m
decl_stmt|,
name|matrix
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|interpolation
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|trans_info
index|[
name|X0
index|]
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y0
index|]
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|X1
index|]
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y1
index|]
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|X2
index|]
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y2
index|]
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|X3
index|]
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y3
index|]
operator|=
name|args
index|[
literal|9
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
comment|/* Determine the perspective transform that maps from        * the unit cube to the trans_info coordinates        */
name|perspective_find_transform
argument_list|(
name|trans_info
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cx
operator|=
name|float_tiles
operator|->
name|x
expr_stmt|;
name|cy
operator|=
name|float_tiles
operator|->
name|y
expr_stmt|;
name|scalex
operator|=
literal|1.0
expr_stmt|;
name|scaley
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|float_tiles
operator|->
name|width
condition|)
name|scalex
operator|=
literal|1.0
operator|/
name|float_tiles
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|float_tiles
operator|->
name|height
condition|)
name|scaley
operator|=
literal|1.0
operator|/
name|float_tiles
operator|->
name|height
expr_stmt|;
comment|/* Assemble the transformation matrix */
name|gimp_matrix_identity
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
name|gimp_matrix_scale
argument_list|(
name|matrix
argument_list|,
name|scalex
argument_list|,
name|scaley
argument_list|)
expr_stmt|;
name|gimp_matrix_mult
argument_list|(
name|m
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/* Perspective the buffer */
name|new_tiles
operator|=
name|perspective_tool_perspective
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|NULL
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/*  push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|perspective_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|perspective_inargs
specifier|static
name|ProcArg
name|perspective_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"interpolation"
block|,
literal|"Whether to use interpolation"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x0"
block|,
literal|"The new x coordinate of upper-left corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y0"
block|,
literal|"The new y coordinate of upper-left corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x1"
block|,
literal|"The new x coordinate of upper-right corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y1"
block|,
literal|"The new y coordinate of upper-right corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x2"
block|,
literal|"The new x coordinate of lower-left corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y2"
block|,
literal|"The new y coordinate of lower-left corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x3"
block|,
literal|"The new x coordinate of lower-right corner of original bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y3"
block|,
literal|"The new y coordinate of lower-right corner of original bounding box"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|perspective_outargs
specifier|static
name|ProcArg
name|perspective_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The newly mapped drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|perspective_proc
specifier|static
name|ProcRecord
name|perspective_proc
init|=
block|{
literal|"gimp_perspective"
block|,
literal|"Perform a possibly non-affine transformation on the specified drawable."
block|,
literal|"This tool performs a possibly non-affine transformation on the specified drawable by allowing the corners of the original bounding box to be arbitrarily remapped to any values. The specified drawable is remapped if no selection exists. However, if a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then remapped as specified. The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting remapped drawable. The return value is the ID of the remapped drawable. If there was no selection, this will be equal to the drawable ID supplied as input. Otherwise, this will be the newly created and remapped drawable. The 4 coordinates specify the new locations of each corner of the original bounding box. By specifying these values, any affine transformation (rotation, scaling, translation) can be affected. Additionally,"
literal|"these values can be specified such that the resulting transformed drawable will appear to have been projected via a perspective transform."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|10
block|,
name|perspective_inargs
block|,
literal|1
block|,
name|perspective_outargs
block|,
block|{
block|{
name|perspective_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|rect_select_invoker (Argument * args)
name|rect_select_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gdouble
name|x
decl_stmt|;
name|gdouble
name|y
decl_stmt|;
name|gdouble
name|width
decl_stmt|;
name|gdouble
name|height
decl_stmt|;
name|gint32
name|operation
decl_stmt|;
name|gboolean
name|feather
decl_stmt|;
name|gdouble
name|feather_radius
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|width
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|height
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0.0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|operation
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|operation
operator|<
name|ADD
operator|||
name|operation
operator|>
name|INTERSECT
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|feather
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|feather_radius
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|rect_select
argument_list|(
name|gimage
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
operator|(
name|int
operator|)
name|width
argument_list|,
operator|(
name|int
operator|)
name|height
argument_list|,
name|operation
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|rect_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|rect_select_inargs
specifier|static
name|ProcArg
name|rect_select_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of upper-left corner of rectangle"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"width"
block|,
literal|"The width of the rectangle: 0< width"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"height"
block|,
literal|"The height of the rectangle: 0< height"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"The selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"Feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"Radius for feather operation"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rect_select_proc
specifier|static
name|ProcRecord
name|rect_select_proc
init|=
block|{
literal|"gimp_rect_select"
block|,
literal|"Create a rectangular selection over the specified image;"
block|,
literal|"This tool creates a rectangular selection over the specified image. The rectangular region can be either added to, subtracted from, or replace the contents of the previous selection mask. If the feather option is enabled, the resulting selection is blurred before combining. The blur is a gaussian blur with the specified feather radius."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|8
block|,
name|rect_select_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|rect_select_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|rotate_invoker (Argument * args)
name|rotate_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|interpolation
decl_stmt|;
name|gdouble
name|angle
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|,
modifier|*
name|new_tiles
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|double
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|GimpMatrix
name|matrix
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|interpolation
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|angle
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
name|cx
operator|=
name|float_tiles
operator|->
name|x
operator|+
name|float_tiles
operator|->
name|width
operator|/
literal|2.0
expr_stmt|;
name|cy
operator|=
name|float_tiles
operator|->
name|y
operator|+
name|float_tiles
operator|->
name|height
operator|/
literal|2.0
expr_stmt|;
comment|/* Assemble the transformation matrix */
name|gimp_matrix_identity
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
name|gimp_matrix_rotate
argument_list|(
name|matrix
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
operator|+
name|cx
argument_list|,
operator|+
name|cy
argument_list|)
expr_stmt|;
comment|/* Rotate the buffer */
name|new_tiles
operator|=
name|rotate_tool_rotate
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|NULL
argument_list|,
name|angle
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/* Push the undo group end */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|rotate_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|rotate_inargs
specifier|static
name|ProcArg
name|rotate_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"interpolation"
block|,
literal|"Whether to use interpolation"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"angle"
block|,
literal|"The angle of rotation (radians)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rotate_outargs
specifier|static
name|ProcArg
name|rotate_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The rotated drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rotate_proc
specifier|static
name|ProcRecord
name|rotate_proc
init|=
block|{
literal|"gimp_rotate"
block|,
literal|"Rotate the specified drawable about its center through the specified angle."
block|,
literal|"This tool rotates the specified drawable if no selection exists. If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then rotated by the specified amount. The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting rotated drawable. The return value is the ID of the rotated drawable. If there was no selection, this will be equal to the drawable ID supplied as input. Otherwise, this will be the newly created and rotated drawable."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|rotate_inargs
block|,
literal|1
block|,
name|rotate_outargs
block|,
block|{
block|{
name|rotate_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|scale_invoker (Argument * args)
name|scale_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|interpolation
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|,
modifier|*
name|new_tiles
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|double
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|double
name|trans_info
index|[
literal|4
index|]
decl_stmt|;
name|GimpMatrix
name|matrix
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|interpolation
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|trans_info
index|[
name|X0
index|]
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y0
index|]
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|X1
index|]
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|trans_info
index|[
name|Y1
index|]
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|trans_info
index|[
name|X0
index|]
operator|<
name|trans_info
index|[
name|X1
index|]
operator|&&
name|trans_info
index|[
name|Y0
index|]
operator|<
name|trans_info
index|[
name|X1
index|]
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
name|scalex
operator|=
name|scaley
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|float_tiles
operator|->
name|width
condition|)
name|scalex
operator|=
operator|(
name|trans_info
index|[
name|X1
index|]
operator|-
name|trans_info
index|[
name|X0
index|]
operator|)
operator|/
operator|(
name|double
operator|)
name|float_tiles
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|float_tiles
operator|->
name|height
condition|)
name|scaley
operator|=
operator|(
name|trans_info
index|[
name|Y1
index|]
operator|-
name|trans_info
index|[
name|Y0
index|]
operator|)
operator|/
operator|(
name|double
operator|)
name|float_tiles
operator|->
name|height
expr_stmt|;
comment|/* Assemble the transformation matrix */
name|gimp_matrix_identity
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
name|float_tiles
operator|->
name|x
argument_list|,
name|float_tiles
operator|->
name|y
argument_list|)
expr_stmt|;
name|gimp_matrix_scale
argument_list|(
name|matrix
argument_list|,
name|scalex
argument_list|,
name|scaley
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
name|trans_info
index|[
name|X0
index|]
argument_list|,
name|trans_info
index|[
name|Y0
index|]
argument_list|)
expr_stmt|;
comment|/* Scale the buffer */
name|new_tiles
operator|=
name|scale_tool_scale
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|NULL
argument_list|,
name|trans_info
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/*  push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|scale_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|scale_inargs
specifier|static
name|ProcArg
name|scale_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"interpolation"
block|,
literal|"Whether to use interpolation"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x0"
block|,
literal|"The new x coordinate of upper-left corner of newly scaled region"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y0"
block|,
literal|"The new y coordinate of upper-left corner of newly scaled region"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x1"
block|,
literal|"The new x coordinate of lower-right corner of newly scaled region"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y1"
block|,
literal|"The new y coordinate of lower-right corner of newly scaled region"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|scale_outargs
specifier|static
name|ProcArg
name|scale_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The scaled drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|scale_proc
specifier|static
name|ProcRecord
name|scale_proc
init|=
block|{
literal|"gimp_scale"
block|,
literal|"Scale the specified drawable."
block|,
literal|"This tool scales the specified drawable if no selection exists. If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then scaled by the specified amount. The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting scaled drawable. The return value is the ID of the scaled drawable. If there was no selection, this will be equal to the drawable ID supplied as input. Otherwise, this will be the newly created and scaled drawable."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|6
block|,
name|scale_inargs
block|,
literal|1
block|,
name|scale_outargs
block|,
block|{
block|{
name|scale_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|shear_invoker (Argument * args)
name|shear_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gboolean
name|interpolation
decl_stmt|;
name|gint32
name|shear_type
decl_stmt|;
name|gdouble
name|magnitude
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|,
modifier|*
name|new_tiles
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|double
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|GimpMatrix
name|matrix
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get_ID
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|interpolation
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|shear_type
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|shear_type
operator|<
name|HORZ_SHEAR
operator|||
name|shear_type
operator|>
name|VERT_SHEAR
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|magnitude
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start a transform undo group */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/* Cut/Copy from the specified drawable */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
name|cx
operator|=
name|float_tiles
operator|->
name|x
operator|+
name|float_tiles
operator|->
name|width
operator|/
literal|2.0
expr_stmt|;
name|cy
operator|=
name|float_tiles
operator|->
name|y
operator|+
name|float_tiles
operator|->
name|height
operator|/
literal|2.0
expr_stmt|;
name|gimp_matrix_identity
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
comment|/* Shear matrix */
if|if
condition|(
name|shear_type
operator|==
name|HORZ_SHEAR
condition|)
name|gimp_matrix_xshear
argument_list|(
name|matrix
argument_list|,
name|magnitude
operator|/
name|float_tiles
operator|->
name|height
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shear_type
operator|==
name|VERT_SHEAR
condition|)
name|gimp_matrix_yshear
argument_list|(
name|matrix
argument_list|,
name|magnitude
operator|/
name|float_tiles
operator|->
name|width
argument_list|)
expr_stmt|;
name|gimp_matrix_translate
argument_list|(
name|matrix
argument_list|,
operator|+
name|cx
argument_list|,
operator|+
name|cy
argument_list|)
expr_stmt|;
comment|/* Shear the buffer */
name|new_tiles
operator|=
name|shear_tool_shear
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|NULL
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/* Free the cut/copied buffer */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
block|{
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
expr_stmt|;
name|success
operator|=
name|layer
operator|!=
name|NULL
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/* Push the undo group end */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|shear_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|shear_inargs
specifier|static
name|ProcArg
name|shear_inargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"interpolation"
block|,
literal|"Whether to use interpolation"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"shear_type"
block|,
literal|"Type of shear: HORIZONTAL (0) or VERTICAL (1)"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"magnitude"
block|,
literal|"The magnitude of the shear"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|shear_outargs
specifier|static
name|ProcArg
name|shear_outargs
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The sheared drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|shear_proc
specifier|static
name|ProcRecord
name|shear_proc
init|=
block|{
literal|"gimp_shear"
block|,
literal|"Shear the specified drawable about its center by the specified magnitude."
block|,
literal|"This tool shears the specified drawable if no selection exists. If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then sheard by the specified amount. The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting sheared drawable. The return value is the ID of the sheard drawable. If there was no selection, this will be equal to the drawable ID supplied as input. Otherwise, this will be the newly created and sheard drawable. The shear type parameter indicates whether the shear will be applied horizontally or vertically. The magnitude can be either positive or negative and indicates the extent (in pixels) to shear by."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
literal|4
block|,
name|shear_inargs
block|,
literal|1
block|,
name|shear_outargs
block|,
block|{
block|{
name|shear_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

