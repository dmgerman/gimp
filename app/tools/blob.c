begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* blob.c: routines for manipulating scan converted convex  *         polygons.  *    * Copyright 1998, Owen Taylor<otaylor@gtk.org>  *  *> Please contact the above author before modifying the copy<  *> of this file in the GIMP distribution. Thanks.<  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"blob.h"
end_include

begin_include
include|#
directive|include
file|"glib.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
DECL|macro|ROUND (A)
define|#
directive|define
name|ROUND
parameter_list|(
name|A
parameter_list|)
value|floor((A)+0.5)
end_define

begin_function
specifier|static
name|Blob
modifier|*
DECL|function|blob_new (int y,int height)
name|blob_new
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Blob
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BlobSpan
argument_list|)
operator|*
operator|(
name|height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|result
operator|->
name|height
operator|=
name|height
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
DECL|enum|__anon2794ae4b0103
typedef|typedef
enum|enum
block|{
DECL|enumerator|EDGE_NONE
name|EDGE_NONE
init|=
literal|0
block|,
DECL|enumerator|EDGE_LEFT
name|EDGE_LEFT
init|=
literal|1
operator|<<
literal|0
block|,
DECL|enumerator|EDGE_RIGHT
name|EDGE_RIGHT
init|=
literal|1
operator|<<
literal|1
DECL|typedef|EdgeType
block|}
name|EdgeType
typedef|;
end_typedef

begin_function
name|Blob
modifier|*
DECL|function|blob_convex_union (Blob * b1,Blob * b2)
name|blob_convex_union
parameter_list|(
name|Blob
modifier|*
name|b1
parameter_list|,
name|Blob
modifier|*
name|b2
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|start
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
comment|/* Create the storage for the result */
name|y
operator|=
name|MIN
argument_list|(
name|b1
operator|->
name|y
argument_list|,
name|b2
operator|->
name|y
argument_list|)
expr_stmt|;
name|result
operator|=
name|blob_new
argument_list|(
name|y
argument_list|,
name|MAX
argument_list|(
name|b1
operator|->
name|y
operator|+
name|b1
operator|->
name|height
argument_list|,
name|b2
operator|->
name|y
operator|+
name|b2
operator|->
name|height
argument_list|)
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|height
operator|==
literal|0
condition|)
return|return
name|result
return|;
name|present
operator|=
name|g_new
argument_list|(
name|EdgeType
argument_list|,
name|result
operator|->
name|height
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|present
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|height
operator|*
sizeof|sizeof
argument_list|(
name|EdgeType
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize spans from original objects */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b1
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b1
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b2
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b2
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
if|if
condition|(
name|present
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|>
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|<
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
block|}
comment|/* Now walk through edges, deleting points that aren't on convex hull */
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|start
index|]
operator|)
condition|)
name|start
operator|++
expr_stmt|;
comment|/*    left edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|result
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|<
literal|0
condition|)
comment|/* clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_LEFT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
operator|--
name|i1
index|]
operator|&
name|EDGE_LEFT
operator|)
operator|&&
name|i1
operator|>=
name|start
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
operator|-
name|result
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
comment|/*     Right edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|result
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|>
literal|0
condition|)
comment|/* counter-clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_RIGHT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
operator|--
name|i1
index|]
operator|&
name|EDGE_RIGHT
operator|)
operator|&&
name|i1
operator|>=
name|start
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|result
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
operator|-
name|result
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
comment|/* Restore edges of spans that were deleted in last step or never present */
comment|/* We fill only interior regions of convex hull, as if we were filling      polygons. But since we draw ellipses with nearest points, not interior      points, maybe it would look better if we did the same here. Probably      not a big deal either way after anti-aliasing */
comment|/*     left edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|result
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
block|{
name|int
name|increment
decl_stmt|;
comment|/* fractional part */
name|int
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|int
name|step
decl_stmt|;
comment|/* integral step */
name|int
name|frac
decl_stmt|;
comment|/* fractional step */
name|int
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_LEFT
operator|)
operator|&&
name|i2
operator|<
name|result
operator|->
name|height
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|result
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|increment
operator|==
literal|0
operator|||
name|reverse
condition|)
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
expr_stmt|;
else|else
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
comment|/*     right edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|result
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
block|{
name|int
name|increment
decl_stmt|;
comment|/* fractional part */
name|int
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|int
name|step
decl_stmt|;
comment|/* integral step */
name|int
name|frac
decl_stmt|;
comment|/* fractional step */
name|int
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_RIGHT
operator|)
operator|&&
name|i2
operator|<
name|result
operator|->
name|height
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|result
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|result
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|x2
operator|=
name|result
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|&&
name|increment
operator|!=
literal|0
condition|)
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
operator|-
literal|1
expr_stmt|;
else|else
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
comment|/* Mark empty lines at top and bottom as unused */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|start
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|result
operator|->
name|height
operator|-
literal|1
init|;
operator|!
name|present
index|[
name|i
index|]
condition|;
name|i
operator|--
control|)
block|{
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_line_add_pixel (Blob * b,int x,int y)
name|blob_line_add_pixel
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|>
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
condition|)
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|x
expr_stmt|;
else|else
block|{
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|blob_line (Blob * b,int x0,int y0,int x1,int y1)
name|blob_line
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|d
decl_stmt|;
name|int
name|incrE
decl_stmt|,
name|incrNE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xstep
init|=
literal|1
decl_stmt|;
name|int
name|ystep
init|=
literal|1
decl_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|xstep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|ystep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/*  for (y = y0; y != y1 + ystep ; y += ystep)     {       b->data[y-b->y].left = 0;       b->data[y-b->y].right = -1;       }*/
name|x
operator|=
name|x0
expr_stmt|;
name|y
operator|=
name|y0
expr_stmt|;
if|if
condition|(
name|dy
operator|<
name|dx
condition|)
block|{
name|d
operator|=
literal|2
operator|*
name|dy
operator|-
name|dx
expr_stmt|;
comment|/* initial value of d */
name|incrE
operator|=
literal|2
operator|*
name|dy
expr_stmt|;
comment|/* increment used for move to E */
name|incrNE
operator|=
literal|2
operator|*
operator|(
name|dy
operator|-
name|dx
operator|)
expr_stmt|;
comment|/* increment used for move to NE */
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
name|d
operator|+=
name|incrE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
block|}
else|else
block|{
name|d
operator|+=
name|incrNE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|=
literal|2
operator|*
name|dx
operator|-
name|dy
expr_stmt|;
comment|/* initial value of d */
name|incrE
operator|=
literal|2
operator|*
name|dx
expr_stmt|;
comment|/* increment used for move to E */
name|incrNE
operator|=
literal|2
operator|*
operator|(
name|dx
operator|-
name|dy
operator|)
expr_stmt|;
comment|/* increment used for move to NE */
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
name|d
operator|+=
name|incrE
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
else|else
block|{
name|d
operator|+=
name|incrNE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/****************************************************************  * Code to scan convert an arbitrary ellipse into a Blob. Based  * on Van Aken's conic algorithm in Foley and Van Damn   ****************************************************************/
end_comment

begin_comment
comment|/* Return octant from gradient */
end_comment

begin_function
specifier|static
name|int
DECL|function|blob_get_octant (int D,int E)
name|blob_get_octant
parameter_list|(
name|int
name|D
parameter_list|,
name|int
name|E
parameter_list|)
block|{
if|if
condition|(
name|D
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|E
operator|<
literal|0
condition|)
return|return
operator|(
name|D
operator|<
operator|-
name|E
operator|)
condition|?
literal|1
else|:
literal|2
return|;
else|else
return|return
operator|(
name|D
operator|>
name|E
operator|)
condition|?
literal|3
else|:
literal|4
return|;
block|}
elseif|else
if|if
condition|(
name|E
operator|>
literal|0
condition|)
return|return
operator|(
operator|-
name|D
operator|<
name|E
operator|)
condition|?
literal|5
else|:
literal|6
return|;
else|else
return|return
operator|(
operator|-
name|D
operator|>
operator|-
name|E
operator|)
condition|?
literal|7
else|:
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_conic_add_pixel (Blob * b,EdgeType * present,int x,int y,int octant)
name|blob_conic_add_pixel
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|octant
parameter_list|)
block|{
comment|/*  printf ("%d %d\n",x,y); */
if|if
condition|(
name|y
operator|<
name|b
operator|->
name|y
operator|||
name|y
operator|>=
name|b
operator|->
name|y
operator|+
name|b
operator|->
name|height
condition|)
block|{
comment|/*      g_warning("Out of bounds!\n"); */
block|}
else|else
block|{
if|if
condition|(
name|octant
operator|<=
literal|4
condition|)
block|{
if|if
condition|(
name|present
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|&
name|EDGE_RIGHT
condition|)
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|x
expr_stmt|;
name|present
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator||=
name|EDGE_RIGHT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|present
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|&
name|EDGE_LEFT
condition|)
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|present
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator||=
name|EDGE_LEFT
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_conic (Blob * b,int xs,int ys,int A,int B,int C,int D,int E,int F)
name|blob_conic
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
name|xs
parameter_list|,
name|int
name|ys
parameter_list|,
name|int
name|A
parameter_list|,
name|int
name|B
parameter_list|,
name|int
name|C
parameter_list|,
name|int
name|D
parameter_list|,
name|int
name|E
parameter_list|,
name|int
name|F
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* current point */
name|int
name|octant
decl_stmt|;
comment|/* current octant */
name|int
name|dxsquare
decl_stmt|,
name|dysquare
decl_stmt|;
comment|/* change in (x,y) for square moves */
name|int
name|dxdiag
decl_stmt|,
name|dydiag
decl_stmt|;
comment|/* change in (x,y) for diagonal moves */
name|int
name|d
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|k3
decl_stmt|;
comment|/* decision variables and increments */
name|int
name|octantCount
decl_stmt|;
comment|/* number of octants to be drawn */
name|int
name|count
decl_stmt|;
comment|/* number of steps for last octant */
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
name|present
operator|=
name|g_new
argument_list|(
name|EdgeType
argument_list|,
name|b
operator|->
name|height
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|present
argument_list|,
literal|0
argument_list|,
name|b
operator|->
name|height
operator|*
sizeof|sizeof
argument_list|(
name|EdgeType
argument_list|)
argument_list|)
expr_stmt|;
name|octant
operator|=
name|blob_get_octant
argument_list|(
name|D
argument_list|,
name|E
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|octant
condition|)
block|{
case|case
literal|1
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|+
name|C
operator|/
literal|4.
operator|+
name|D
operator|+
name|E
operator|/
literal|2.
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|+
name|D
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|+
name|D
operator|+
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|A
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|A
operator|+
name|B
expr_stmt|;
name|k3
operator|=
name|k2
operator|+
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|1
expr_stmt|;
name|dysquare
operator|=
literal|0
expr_stmt|;
name|dxdiag
operator|=
literal|1
expr_stmt|;
name|dydiag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|/
literal|4.
operator|+
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|D
operator|/
literal|2.
operator|+
name|E
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|E
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|D
operator|+
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|C
expr_stmt|;
name|k2
operator|=
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|k3
operator|=
literal|2
operator|*
name|A
operator|+
literal|2
operator|*
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|0
expr_stmt|;
name|dysquare
operator|=
literal|1
expr_stmt|;
name|dxdiag
operator|=
literal|1
expr_stmt|;
name|dydiag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|/
literal|4.
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|D
operator|/
literal|2.
operator|+
name|E
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|E
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|D
operator|+
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|C
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|C
operator|-
name|B
expr_stmt|;
name|k3
operator|=
literal|2
operator|*
name|A
operator|-
literal|2
operator|*
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|0
expr_stmt|;
name|dysquare
operator|=
literal|1
expr_stmt|;
name|dxdiag
operator|=
operator|-
literal|1
expr_stmt|;
name|dydiag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|/
literal|4.
operator|-
name|D
operator|+
name|E
operator|/
literal|2.
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|-
name|D
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|-
name|D
operator|+
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|A
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|A
operator|-
name|B
expr_stmt|;
name|k3
operator|=
name|k2
operator|-
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
operator|-
literal|1
expr_stmt|;
name|dysquare
operator|=
literal|0
expr_stmt|;
name|dxdiag
operator|=
operator|-
literal|1
expr_stmt|;
name|dydiag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|+
name|C
operator|/
literal|4.
operator|-
name|D
operator|-
name|E
operator|/
literal|2.
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|-
name|D
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|A
operator|+
name|B
operator|/
literal|2.
operator|-
name|D
operator|-
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|A
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|A
operator|+
name|B
expr_stmt|;
name|k3
operator|=
name|k2
operator|+
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
operator|-
literal|1
expr_stmt|;
name|dysquare
operator|=
literal|0
expr_stmt|;
name|dxdiag
operator|=
operator|-
literal|1
expr_stmt|;
name|dydiag
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|/
literal|4.
operator|+
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|D
operator|/
literal|2.
operator|-
name|E
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|E
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|D
operator|-
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|C
expr_stmt|;
name|k2
operator|=
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|k3
operator|=
literal|2
operator|*
name|A
operator|+
literal|2
operator|*
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|0
expr_stmt|;
name|dysquare
operator|=
operator|-
literal|1
expr_stmt|;
name|dxdiag
operator|=
operator|-
literal|1
expr_stmt|;
name|dydiag
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|/
literal|4.
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|D
operator|/
literal|2.
operator|-
name|E
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|-
name|E
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|+
name|D
operator|-
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|C
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|C
operator|-
name|B
expr_stmt|;
name|k3
operator|=
literal|2
operator|*
name|A
operator|-
literal|2
operator|*
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|0
expr_stmt|;
name|dysquare
operator|=
operator|-
literal|1
expr_stmt|;
name|dxdiag
operator|=
literal|1
expr_stmt|;
name|dydiag
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* case 8: */
name|d
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|+
name|C
operator|/
literal|4.
operator|+
name|D
operator|-
name|E
operator|/
literal|2.
operator|+
name|F
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|+
name|D
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|A
operator|-
name|B
operator|/
literal|2.
operator|+
name|D
operator|-
name|E
argument_list|)
expr_stmt|;
name|k1
operator|=
literal|2
operator|*
name|A
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|A
operator|-
name|B
expr_stmt|;
name|k3
operator|=
name|k2
operator|-
name|B
operator|+
literal|2
operator|*
name|C
expr_stmt|;
name|dxsquare
operator|=
literal|1
expr_stmt|;
name|dysquare
operator|=
literal|0
expr_stmt|;
name|dxdiag
operator|=
literal|1
expr_stmt|;
name|dydiag
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|octantCount
operator|=
literal|8
expr_stmt|;
name|x
operator|=
name|xs
expr_stmt|;
name|y
operator|=
name|ys
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* ignore until last octant */
comment|/* Initialize boundary checking - we keep track of the discriminants      for the conic as quadratics in x and y, and when they go negative      we know we are beyond the boundaries of the conic. */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|octantCount
operator|==
literal|0
condition|)
block|{
comment|/* figure out remaining steps in square direction */
switch|switch
condition|(
name|octant
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|8
case|:
name|count
operator|=
name|xs
operator|-
name|x
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|count
operator|=
name|ys
operator|-
name|y
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|count
operator|=
name|x
operator|-
name|xs
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|count
operator|=
name|y
operator|-
name|ys
expr_stmt|;
break|break;
block|}
comment|/*	  if (count< 0) 	    g_warning("Negative count (%d) in octant %d\n",count,octant); */
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|octant
operator|%
literal|2
condition|)
comment|/* odd octants */
block|{
while|while
condition|(
name|v
operator|<
name|k2
operator|/
literal|2
condition|)
block|{
name|blob_conic_add_pixel
argument_list|(
name|b
argument_list|,
name|present
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|octant
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|x
operator|+=
name|dxsquare
expr_stmt|;
name|y
operator|+=
name|dysquare
expr_stmt|;
name|u
operator|+=
name|k1
expr_stmt|;
name|v
operator|+=
name|k2
expr_stmt|;
name|d
operator|+=
name|u
expr_stmt|;
block|}
else|else
block|{
name|x
operator|+=
name|dxdiag
expr_stmt|;
name|y
operator|+=
name|dydiag
expr_stmt|;
name|u
operator|+=
name|k2
expr_stmt|;
name|v
operator|+=
name|k3
expr_stmt|;
name|d
operator|+=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* We now cross diagonal octant boundary */
name|d
operator|=
name|ROUND
argument_list|(
name|d
operator|-
name|u
operator|+
name|v
operator|/
literal|2.
operator|-
name|k2
operator|/
literal|2.
operator|+
literal|3
operator|*
name|k3
operator|/
literal|8.
argument_list|)
expr_stmt|;
name|u
operator|=
name|ROUND
argument_list|(
operator|-
name|u
operator|+
name|v
operator|-
name|k2
operator|/
literal|2.
operator|+
name|k3
operator|/
literal|2.
argument_list|)
expr_stmt|;
name|v
operator|=
name|ROUND
argument_list|(
name|v
operator|-
name|k2
operator|+
name|k3
operator|/
literal|2.
argument_list|)
expr_stmt|;
comment|/* could be v + A - C */
name|k1
operator|=
name|k1
operator|-
literal|2
operator|*
name|k2
operator|+
name|k3
expr_stmt|;
name|k2
operator|=
name|k3
operator|-
name|k2
expr_stmt|;
name|tmp
operator|=
name|dxsquare
expr_stmt|;
name|dxsquare
operator|=
operator|-
name|dysquare
expr_stmt|;
name|dysquare
operator|=
name|tmp
expr_stmt|;
block|}
else|else
comment|/* Even octants */
block|{
while|while
condition|(
name|u
operator|<
name|k2
operator|/
literal|2
condition|)
block|{
name|blob_conic_add_pixel
argument_list|(
name|b
argument_list|,
name|present
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|octant
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|x
operator|+=
name|dxdiag
expr_stmt|;
name|y
operator|+=
name|dydiag
expr_stmt|;
name|u
operator|+=
name|k2
expr_stmt|;
name|v
operator|+=
name|k3
expr_stmt|;
name|d
operator|+=
name|v
expr_stmt|;
block|}
else|else
block|{
name|x
operator|+=
name|dxsquare
expr_stmt|;
name|y
operator|+=
name|dysquare
expr_stmt|;
name|u
operator|+=
name|k1
expr_stmt|;
name|v
operator|+=
name|k2
expr_stmt|;
name|d
operator|+=
name|u
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&&
operator|--
name|count
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* We now cross square octant boundary */
name|d
operator|=
name|d
operator|+
name|u
operator|-
name|v
operator|+
name|k1
operator|-
name|k2
expr_stmt|;
name|v
operator|=
literal|2
operator|*
name|u
operator|-
name|v
operator|+
name|k1
operator|-
name|k2
expr_stmt|;
comment|/* Do v first; it depends on u */
name|u
operator|=
name|u
operator|+
name|k1
operator|-
name|k2
expr_stmt|;
name|k3
operator|=
literal|4
operator|*
operator|(
name|k1
operator|-
name|k2
operator|)
operator|+
name|k3
expr_stmt|;
name|k2
operator|=
literal|2
operator|*
name|k1
operator|-
name|k2
expr_stmt|;
name|tmp
operator|=
name|dxdiag
expr_stmt|;
name|dxdiag
operator|=
operator|-
name|dydiag
expr_stmt|;
name|dydiag
operator|=
name|tmp
expr_stmt|;
block|}
name|octant
operator|++
expr_stmt|;
if|if
condition|(
name|octant
operator|>
literal|8
condition|)
name|octant
operator|-=
literal|8
expr_stmt|;
name|octantCount
operator|--
expr_stmt|;
block|}
name|done
label|:
comment|/* jump out of two levels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|present
index|[
name|i
index|]
operator|!=
operator|(
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
operator|)
condition|)
block|{
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan convert an ellipse specified by _offsets_ of major and    minor axes, and by center into a blob */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_ellipse (double xc,double yc,double xp,double yp,double xq,double yq)
name|blob_ellipse
parameter_list|(
name|double
name|xc
parameter_list|,
name|double
name|yc
parameter_list|,
name|double
name|xp
parameter_list|,
name|double
name|yp
parameter_list|,
name|double
name|xq
parameter_list|,
name|double
name|yq
parameter_list|)
block|{
name|Blob
modifier|*
name|r
decl_stmt|;
name|double
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|,
name|E
decl_stmt|,
name|F
decl_stmt|;
comment|/* coefficients of conic */
name|double
name|xprod
decl_stmt|,
name|tmp
decl_stmt|;
name|double
name|height
decl_stmt|;
comment|/*  double dpx, dpy; */
name|int
name|y
decl_stmt|;
name|xprod
operator|=
name|xp
operator|*
name|yq
operator|-
name|xq
operator|*
name|yp
expr_stmt|;
if|if
condition|(
name|xprod
operator|==
literal|0
condition|)
comment|/* colinear points */
block|{
name|g_print
argument_list|(
literal|"Colinear points!\n"
argument_list|)
expr_stmt|;
name|g_on_error_query
argument_list|(
literal|"gimp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xprod
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|xq
expr_stmt|;
name|xq
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|yp
expr_stmt|;
name|yp
operator|=
name|yq
expr_stmt|;
name|yq
operator|=
name|tmp
expr_stmt|;
name|xprod
operator|=
operator|-
name|xprod
expr_stmt|;
block|}
name|A
operator|=
name|yp
operator|*
name|yp
operator|+
name|yq
operator|*
name|yq
expr_stmt|;
name|B
operator|=
operator|-
literal|2
operator|*
operator|(
name|xp
operator|*
name|yp
operator|+
name|xq
operator|*
name|yq
operator|)
expr_stmt|;
name|C
operator|=
name|xp
operator|*
name|xp
operator|+
name|xq
operator|*
name|xq
expr_stmt|;
name|D
operator|=
literal|2
operator|*
name|yq
operator|*
name|xprod
expr_stmt|;
name|E
operator|=
operator|-
literal|2
operator|*
name|xq
operator|*
name|xprod
expr_stmt|;
name|F
operator|=
literal|0
expr_stmt|;
comment|/* Now offset the ellipse so that the center is exact, but the      starting point is no longer exactly on the ellipse */
comment|/* This needs a change to blob_conic to work. blob_conic assumes    * we start at (0,0)    */
comment|/*  dpx = ROUND(xp+xc)-xp-xc;   dpy = ROUND(yp+yc)-yp-yc;    F += dpx*(A*dpx+D+B*dpy) + dpy*(C*dpy+E);   D += 2*A*dpx + B*dpy;   E += B*dpx + 2*C*dpy;   */
name|height
operator|=
name|sqrt
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|y
operator|=
name|floor
argument_list|(
name|yc
operator|-
name|height
operator|-
literal|0.5
argument_list|)
expr_stmt|;
comment|/* We allow an extra pixel of slop on top and bottom to deal with      round-off error */
name|r
operator|=
name|blob_new
argument_list|(
name|y
operator|-
literal|1
argument_list|,
name|ceil
argument_list|(
name|yc
operator|+
name|height
operator|+
literal|0.5
argument_list|)
operator|-
name|y
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* Although it seems that multiplying A-F by a constant would improve      things, this seems not to be the case in practice. Several test      cases showed about equal improvement and degradation */
name|blob_conic
argument_list|(
name|r
argument_list|,
name|ROUND
argument_list|(
name|xp
operator|+
name|xc
argument_list|)
argument_list|,
name|ROUND
argument_list|(
name|yp
operator|+
name|yc
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|A
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|B
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|C
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|D
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|E
argument_list|)
argument_list|,
name|ROUND
argument_list|(
literal|1
operator|*
name|F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a line through the center to improve things a bit. (Doesn't    * work perfectly because sometimes we overshoot    */
block|{
name|int
name|x0
init|=
name|floor
argument_list|(
literal|0.5
operator|+
name|xc
operator|-
name|xp
argument_list|)
decl_stmt|;
name|int
name|x1
init|=
name|floor
argument_list|(
literal|0.5
operator|+
name|xc
operator|+
name|xp
argument_list|)
decl_stmt|;
name|int
name|y0
init|=
name|floor
argument_list|(
literal|0.5
operator|+
name|yc
operator|-
name|yp
argument_list|)
decl_stmt|;
name|int
name|y1
init|=
name|floor
argument_list|(
literal|0.5
operator|+
name|yc
operator|+
name|yp
argument_list|)
decl_stmt|;
comment|/*    r = blob_new (MIN(y0,y1), abs(y1-y0)+1); */
name|blob_line
argument_list|(
name|r
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
DECL|function|blob_bounds (Blob * b,int * x,int * y,int * width,int * height)
name|blob_bounds
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|height
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|y0
decl_stmt|,
name|y1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|>
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|y0
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
name|x0
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|<=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
block|{
name|x0
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|y1
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|x0
operator|=
name|y0
operator|=
literal|0
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|x
operator|=
name|x0
expr_stmt|;
operator|*
name|y
operator|=
name|y0
expr_stmt|;
operator|*
name|width
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
operator|*
name|height
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|blob_dump (Blob * b)
name|blob_dump
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
init|;
name|j
operator|<=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

