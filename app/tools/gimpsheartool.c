begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"info_dialog.h"
end_include

begin_include
include|#
directive|include
file|"palette.h"
end_include

begin_include
include|#
directive|include
file|"shear_tool.h"
end_include

begin_include
include|#
directive|include
file|"selection.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_include
include|#
directive|include
file|"transform_core.h"
end_include

begin_include
include|#
directive|include
file|"transform_tool.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager_pvt.h"
end_include

begin_comment
comment|/*  index into trans_info array  */
end_comment

begin_define
DECL|macro|HORZ_OR_VERT
define|#
directive|define
name|HORZ_OR_VERT
value|0
end_define

begin_define
DECL|macro|XSHEAR
define|#
directive|define
name|XSHEAR
value|1
end_define

begin_define
DECL|macro|YSHEAR
define|#
directive|define
name|YSHEAR
value|2
end_define

begin_comment
comment|/*  types of shearing  */
end_comment

begin_define
DECL|macro|HORZ
define|#
directive|define
name|HORZ
value|1
end_define

begin_define
DECL|macro|VERT
define|#
directive|define
name|VERT
value|2
end_define

begin_comment
comment|/*  the minimum movement before direction of shear can be determined (pixels) */
end_comment

begin_define
DECL|macro|MIN_MOVE
define|#
directive|define
name|MIN_MOVE
value|5
end_define

begin_comment
comment|/*  variables local to this file  */
end_comment

begin_decl_stmt
DECL|variable|direction_unknown
specifier|static
name|int
name|direction_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xshear_buf
specifier|static
name|char
name|xshear_buf
index|[
name|MAX_INFO_BUF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yshear_buf
specifier|static
name|char
name|yshear_buf
index|[
name|MAX_INFO_BUF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  forward function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|shear_tool_shear
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|TileManager
modifier|*
parameter_list|,
name|int
parameter_list|,
name|Matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|shear_tool_recalc
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shear_tool_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shear_info_update
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|shear_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Info dialog callback funtions  */
end_comment

begin_function_decl
specifier|static
name|void
name|shear_x_mag_changed
parameter_list|(
name|GtkWidget
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shear_y_mag_changed
parameter_list|(
name|GtkWidget
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
DECL|function|shear_tool_transform (tool,gdisp_ptr,state)
name|shear_tool_transform
parameter_list|(
name|tool
parameter_list|,
name|gdisp_ptr
parameter_list|,
name|state
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|gpointer
name|gdisp_ptr
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|INIT
case|:
if|if
condition|(
operator|!
name|transform_info
condition|)
block|{
name|transform_info
operator|=
name|info_dialog_new
argument_list|(
literal|"Shear Information"
argument_list|)
expr_stmt|;
name|info_dialog_add_field
argument_list|(
name|transform_info
argument_list|,
literal|"X Shear Magnitude: "
argument_list|,
name|xshear_buf
argument_list|,
name|shear_x_mag_changed
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|info_dialog_add_field
argument_list|(
name|transform_info
argument_list|,
literal|"Y Shear Magnitude: "
argument_list|,
name|yshear_buf
argument_list|,
name|shear_y_mag_changed
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
name|direction_unknown
operator|=
literal|1
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ_OR_VERT
index|]
operator|=
name|HORZ
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|=
literal|0.0
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|=
literal|0.0
expr_stmt|;
return|return
name|NULL
return|;
break|break;
case|case
name|MOTION
case|:
name|shear_tool_motion
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|shear_tool_recalc
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|)
operator|)
return|;
break|break;
case|case
name|RECALC
case|:
return|return
operator|(
name|shear_tool_recalc
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|)
operator|)
return|;
break|break;
case|case
name|FINISH
case|:
name|direction_unknown
operator|=
literal|1
expr_stmt|;
return|return
name|shear_tool_shear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|transform_core
operator|->
name|original
argument_list|,
name|transform_tool_smoothing
argument_list|()
argument_list|,
name|transform_core
operator|->
name|transform
argument_list|)
return|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_shear_tool ()
name|tools_new_shear_tool
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|TransformCore
modifier|*
name|private
decl_stmt|;
name|tool
operator|=
name|transform_core_new
argument_list|(
name|SHEAR
argument_list|,
name|INTERACTIVE
argument_list|)
expr_stmt|;
name|private
operator|=
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  set the rotation specific transformation attributes  */
name|private
operator|->
name|trans_func
operator|=
name|shear_tool_transform
expr_stmt|;
comment|/*  assemble the transformation matrix  */
name|identity_matrix
argument_list|(
name|private
operator|->
name|transform
argument_list|)
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_shear_tool (tool)
name|tools_free_shear_tool
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|transform_core_free
argument_list|(
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shear_info_update (tool)
name|shear_info_update
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|sprintf
argument_list|(
name|xshear_buf
argument_list|,
literal|"%0.2f"
argument_list|,
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|yshear_buf
argument_list|,
literal|"%0.2f"
argument_list|,
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
argument_list|)
expr_stmt|;
name|info_dialog_update
argument_list|(
name|transform_info
argument_list|)
expr_stmt|;
name|info_dialog_popup
argument_list|(
name|transform_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shear_x_mag_changed (GtkWidget * w,gpointer data)
name|shear_x_mag_changed
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gchar
modifier|*
name|str
decl_stmt|;
name|int
name|value
decl_stmt|;
name|tool
operator|=
operator|(
name|Tool
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|tool
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|str
operator|=
name|g_strdup
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|int
operator|)
name|atof
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
condition|)
block|{
name|draw_core_pause
argument_list|(
name|transform_core
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|=
name|value
expr_stmt|;
name|shear_tool_recalc
argument_list|(
name|tool
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|transform_core
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shear_y_mag_changed (GtkWidget * w,gpointer data)
name|shear_y_mag_changed
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gchar
modifier|*
name|str
decl_stmt|;
name|int
name|value
decl_stmt|;
name|tool
operator|=
operator|(
name|Tool
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|tool
condition|)
block|{
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|str
operator|=
name|g_strdup
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|int
operator|)
name|atof
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
condition|)
block|{
name|draw_core_pause
argument_list|(
name|transform_core
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|=
name|value
expr_stmt|;
name|shear_tool_recalc
argument_list|(
name|tool
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|transform_core
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shear_tool_motion (tool,gdisp_ptr)
name|shear_tool_motion
parameter_list|(
name|tool
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|void
modifier|*
name|gdisp_ptr
decl_stmt|;
block|{
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|int
name|diffx
decl_stmt|,
name|diffy
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|diffx
operator|=
name|transform_core
operator|->
name|curx
operator|-
name|transform_core
operator|->
name|lastx
expr_stmt|;
name|diffy
operator|=
name|transform_core
operator|->
name|cury
operator|-
name|transform_core
operator|->
name|lasty
expr_stmt|;
comment|/*  If we haven't yet decided on which way to control shearing    *  decide using the maximum differential    */
if|if
condition|(
name|direction_unknown
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|diffx
argument_list|)
operator|>
name|MIN_MOVE
operator|||
name|abs
argument_list|(
name|diffy
argument_list|)
operator|>
name|MIN_MOVE
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|diffx
argument_list|)
operator|>
name|abs
argument_list|(
name|diffy
argument_list|)
condition|)
block|{
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ_OR_VERT
index|]
operator|=
name|HORZ
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|VERT
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ_OR_VERT
index|]
operator|=
name|VERT
expr_stmt|;
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
name|direction_unknown
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  set the current coords to the last ones  */
else|else
block|{
name|transform_core
operator|->
name|curx
operator|=
name|transform_core
operator|->
name|lastx
expr_stmt|;
name|transform_core
operator|->
name|cury
operator|=
name|transform_core
operator|->
name|lasty
expr_stmt|;
block|}
block|}
comment|/*  if the direction is known, keep track of the magnitude  */
if|if
condition|(
operator|!
name|direction_unknown
condition|)
block|{
name|dir
operator|=
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ_OR_VERT
index|]
expr_stmt|;
switch|switch
condition|(
name|transform_core
operator|->
name|function
condition|)
block|{
case|case
name|HANDLE_1
case|:
if|if
condition|(
name|dir
operator|==
name|HORZ
condition|)
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|-=
name|diffx
expr_stmt|;
else|else
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|-=
name|diffy
expr_stmt|;
break|break;
case|case
name|HANDLE_2
case|:
if|if
condition|(
name|dir
operator|==
name|HORZ
condition|)
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|-=
name|diffx
expr_stmt|;
else|else
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|+=
name|diffy
expr_stmt|;
break|break;
case|case
name|HANDLE_3
case|:
if|if
condition|(
name|dir
operator|==
name|HORZ
condition|)
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|+=
name|diffx
expr_stmt|;
else|else
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|-=
name|diffy
expr_stmt|;
break|break;
case|case
name|HANDLE_4
case|:
if|if
condition|(
name|dir
operator|==
name|HORZ
condition|)
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|+=
name|diffx
expr_stmt|;
else|else
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|+=
name|diffy
expr_stmt|;
break|break;
default|default :
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|shear_tool_recalc (tool,gdisp_ptr)
name|shear_tool_recalc
parameter_list|(
name|tool
parameter_list|,
name|gdisp_ptr
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
name|void
modifier|*
name|gdisp_ptr
decl_stmt|;
block|{
name|TransformCore
modifier|*
name|transform_core
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|float
name|width
decl_stmt|,
name|height
decl_stmt|;
name|float
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|transform_core
operator|=
operator|(
name|TransformCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|cx
operator|=
operator|(
name|transform_core
operator|->
name|x1
operator|+
name|transform_core
operator|->
name|x2
operator|)
operator|/
literal|2.0
expr_stmt|;
name|cy
operator|=
operator|(
name|transform_core
operator|->
name|y1
operator|+
name|transform_core
operator|->
name|y2
operator|)
operator|/
literal|2.0
expr_stmt|;
name|width
operator|=
name|transform_core
operator|->
name|x2
operator|-
name|transform_core
operator|->
name|x1
expr_stmt|;
name|height
operator|=
name|transform_core
operator|->
name|y2
operator|-
name|transform_core
operator|->
name|y1
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|height
operator|==
literal|0
condition|)
name|height
operator|=
literal|1
expr_stmt|;
comment|/*  assemble the transformation matrix  */
name|identity_matrix
argument_list|(
name|transform_core
operator|->
name|transform
argument_list|)
expr_stmt|;
name|translate_matrix
argument_list|(
name|transform_core
operator|->
name|transform
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
comment|/*  shear matrix  */
if|if
condition|(
name|transform_core
operator|->
name|trans_info
index|[
name|HORZ_OR_VERT
index|]
operator|==
name|HORZ
condition|)
name|xshear_matrix
argument_list|(
name|transform_core
operator|->
name|transform
argument_list|,
operator|(
name|float
operator|)
name|transform_core
operator|->
name|trans_info
index|[
name|XSHEAR
index|]
operator|/
name|height
argument_list|)
expr_stmt|;
else|else
name|yshear_matrix
argument_list|(
name|transform_core
operator|->
name|transform
argument_list|,
operator|(
name|float
operator|)
name|transform_core
operator|->
name|trans_info
index|[
name|YSHEAR
index|]
operator|/
name|width
argument_list|)
expr_stmt|;
name|translate_matrix
argument_list|(
name|transform_core
operator|->
name|transform
argument_list|,
operator|+
name|cx
argument_list|,
operator|+
name|cy
argument_list|)
expr_stmt|;
comment|/*  transform the bounding box  */
name|transform_bounding_box
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/*  update the information dialog  */
name|shear_info_update
argument_list|(
name|tool
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|shear_tool_shear (gimage,drawable,float_tiles,interpolation,matrix)
name|shear_tool_shear
parameter_list|(
name|gimage
parameter_list|,
name|drawable
parameter_list|,
name|float_tiles
parameter_list|,
name|interpolation
parameter_list|,
name|matrix
parameter_list|)
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|;
name|int
name|interpolation
decl_stmt|;
name|Matrix
name|matrix
decl_stmt|;
block|{
return|return
name|transform_core_do
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  The shear procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|shear_args
name|ProcArg
name|shear_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the affected drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"interpolation"
block|,
literal|"whether to use interpolation"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"shear_type"
block|,
literal|"Type of shear: { HORIZONTAL (0), VERTICAL (1) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"magnitude"
block|,
literal|"the magnitude of the shear"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|shear_out_args
name|ProcArg
name|shear_out_args
index|[]
init|=
block|{
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the sheard drawable"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|shear_proc
name|ProcRecord
name|shear_proc
init|=
block|{
literal|"gimp_shear"
block|,
literal|"Shear the specified drawable about its center by the specified magnitude"
block|,
literal|"This tool shears the specified drawable if no selection exists.  If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then sheard by the specified amount.  The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting sheard drawable.  The return value is the ID of the sheard drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and sheard drawable.  The shear type parameter indicates whether the shear will be applied horizontally or vertically.  The magnitude can be either positive or negative and indicates the extent (in pixels) to shear by."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|5
block|,
name|shear_args
block|,
comment|/*  Output arguments  */
literal|1
block|,
name|shear_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|shear_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|shear_invoker (args)
name|shear_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|interpolation
decl_stmt|;
name|int
name|shear_type
decl_stmt|;
name|double
name|shear_magnitude
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|TileManager
modifier|*
name|float_tiles
decl_stmt|;
name|TileManager
modifier|*
name|new_tiles
decl_stmt|;
name|Matrix
name|matrix
decl_stmt|;
name|int
name|new_layer
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|shear_type
operator|=
name|HORZ
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
operator|||
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  interpolation  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|interpolation
operator|=
operator|(
name|int_value
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
comment|/*  shear type */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|shear_type
operator|=
name|HORZ
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shear_type
operator|=
name|VERT
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/*  shear extents  */
if|if
condition|(
name|success
condition|)
block|{
name|shear_magnitude
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
block|}
comment|/*  call the shear procedure  */
if|if
condition|(
name|success
condition|)
block|{
name|double
name|cx
decl_stmt|,
name|cy
decl_stmt|;
comment|/*  Start a transform undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|TRANSFORM_CORE_UNDO
argument_list|)
expr_stmt|;
comment|/*  Cut/Copy from the specified drawable  */
name|float_tiles
operator|=
name|transform_core_cut
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
operator|&
name|new_layer
argument_list|)
expr_stmt|;
name|cx
operator|=
name|float_tiles
operator|->
name|x
operator|+
name|float_tiles
operator|->
name|width
operator|/
literal|2.0
expr_stmt|;
name|cy
operator|=
name|float_tiles
operator|->
name|y
operator|+
name|float_tiles
operator|->
name|height
operator|/
literal|2.0
expr_stmt|;
name|identity_matrix
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
name|translate_matrix
argument_list|(
name|matrix
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
comment|/*  shear matrix  */
if|if
condition|(
name|shear_type
operator|==
name|HORZ
condition|)
name|xshear_matrix
argument_list|(
name|matrix
argument_list|,
name|shear_magnitude
operator|/
name|float_tiles
operator|->
name|height
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shear_type
operator|==
name|VERT
condition|)
name|yshear_matrix
argument_list|(
name|matrix
argument_list|,
name|shear_magnitude
operator|/
name|float_tiles
operator|->
name|width
argument_list|)
expr_stmt|;
name|translate_matrix
argument_list|(
name|matrix
argument_list|,
operator|+
name|cx
argument_list|,
operator|+
name|cy
argument_list|)
expr_stmt|;
comment|/*  shear the buffer  */
name|new_tiles
operator|=
name|shear_tool_shear
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|float_tiles
argument_list|,
name|interpolation
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
comment|/*  free the cut/copied buffer  */
name|tile_manager_destroy
argument_list|(
name|float_tiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tiles
condition|)
name|success
operator|=
operator|(
name|layer
operator|=
name|transform_core_paste
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|new_tiles
argument_list|,
name|new_layer
argument_list|)
operator|)
operator|!=
name|NULL
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/*  push the undo group end  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|shear_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|drawable_ID
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

end_unit

