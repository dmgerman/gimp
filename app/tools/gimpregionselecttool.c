begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_warning
warning|#
directive|warning
warning|(everything commented out)
end_warning

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"apptypes.h"
end_include

begin_include
include|#
directive|include
file|"boundary.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"gimprc.h"
end_include

begin_include
include|#
directive|include
file|"pixel_region.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"gimpeditselectiontool.h"
end_include

begin_include
include|#
directive|include
file|"gimpfuzzyselecttool.h"
end_include

begin_include
include|#
directive|include
file|"gimprectselecttool.h"
end_include

begin_include
include|#
directive|include
file|"gimptool.h"
end_include

begin_include
include|#
directive|include
file|"selection_options.h"
end_include

begin_include
include|#
directive|include
file|"tool_options.h"
end_include

begin_include
include|#
directive|include
file|"tool_manager.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  the fuzzy selection structures  */
end_comment

begin_comment
unit|typedef struct _FuzzySelect FuzzySelect;  struct _FuzzySelect {   DrawCore *core;
comment|/*  Core select object                      */
end_comment

begin_comment
unit|gint      op;
comment|/*  selection operation (ADD, SUB, etc)     */
end_comment

begin_comment
unit|gint      current_x;
comment|/*  these values are updated on every motion event  */
end_comment

begin_comment
unit|gint      current_y;
comment|/*  (enables immediate cursor updating on modifier 			 *   key events).  */
end_comment

begin_comment
unit|gint      x, y;
comment|/*  Point from which to execute seed fill  */
end_comment

begin_comment
unit|gint      first_x;
comment|/*                                         */
end_comment

begin_comment
unit|gint      first_y;
comment|/*  variables to keep track of sensitivity */
end_comment

begin_comment
unit|gdouble   first_threshold;
comment|/* initial value of threshold slider   */
end_comment

begin_comment
unit|};
comment|/*  fuzzy select action functions  */
end_comment

begin_comment
unit|static void         fuzzy_select_button_press    (Tool           *tool, 						  GdkEventButton *bevent, 						  GDisplay       *gdisp); static void         fuzzy_select_button_release  (Tool           *tool, 						  GdkEventButton *bevent, 						  GDisplay       *gdisp); static void         fuzzy_select_motion          (Tool           *tool, 						  GdkEventMotion *mevent, 						  GDisplay       *gdisp); static void         fuzzy_select_control         (Tool           *tool, 						  ToolAction      tool_action, 						  GDisplay       *gdisp);  static void         fuzzy_select_draw            (Tool           *tool);  static GdkSegment * fuzzy_select_calculate       (Tool           *tool, 						  GDisplay       *gdisp, 						  gint           *nsegs);
comment|/*  the fuzzy selection tool options  */
end_comment

begin_comment
unit|static SelectionOptions  *fuzzy_options = NULL;
comment|/*  XSegments which make up the fuzzy selection boundary  */
end_comment

begin_endif
unit|static GdkSegment *segs     = NULL; static gint        num_segs = 0;  GimpChannel * fuzzy_mask = NULL;
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/*  Fuzzy selection apparatus  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|is_pixel_sufficiently_different (guchar * col1,guchar * col2,gboolean antialias,gint threshold,gint bytes,gboolean has_alpha)
name|is_pixel_sufficiently_different
parameter_list|(
name|guchar
modifier|*
name|col1
parameter_list|,
name|guchar
modifier|*
name|col2
parameter_list|,
name|gboolean
name|antialias
parameter_list|,
name|gint
name|threshold
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|)
block|{
name|gint
name|diff
decl_stmt|;
name|gint
name|max
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|alpha
operator|=
operator|(
name|has_alpha
operator|)
condition|?
name|bytes
operator|-
literal|1
else|:
name|bytes
expr_stmt|;
comment|/*  if there is an alpha channel, never select transparent regions  */
if|if
condition|(
name|has_alpha
operator|&&
name|col2
index|[
name|alpha
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
name|diff
operator|=
name|col1
index|[
name|b
index|]
operator|-
name|col2
index|[
name|b
index|]
expr_stmt|;
name|diff
operator|=
name|abs
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|max
condition|)
name|max
operator|=
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
block|{
name|float
name|aa
decl_stmt|;
name|aa
operator|=
literal|1.5
operator|-
operator|(
operator|(
name|float
operator|)
name|max
operator|/
name|threshold
operator|)
expr_stmt|;
if|if
condition|(
name|aa
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|aa
operator|<
literal|0.5
condition|)
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|aa
operator|*
literal|512
argument_list|)
return|;
else|else
return|return
literal|255
return|;
block|}
else|else
block|{
if|if
condition|(
name|max
operator|>
name|threshold
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|255
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ref_tiles (TileManager * src,TileManager * mask,Tile ** s_tile,Tile ** m_tile,gint x,gint y,guchar ** s,guchar ** m)
name|ref_tiles
parameter_list|(
name|TileManager
modifier|*
name|src
parameter_list|,
name|TileManager
modifier|*
name|mask
parameter_list|,
name|Tile
modifier|*
modifier|*
name|s_tile
parameter_list|,
name|Tile
modifier|*
modifier|*
name|m_tile
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
modifier|*
name|s
parameter_list|,
name|guchar
modifier|*
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s_tile
operator|!=
name|NULL
condition|)
name|tile_release
argument_list|(
operator|*
name|s_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m_tile
operator|!=
name|NULL
condition|)
name|tile_release
argument_list|(
operator|*
name|m_tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|s_tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|m_tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|tile_data_pointer
argument_list|(
operator|*
name|s_tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|tile_data_pointer
argument_list|(
operator|*
name|m_tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|find_contiguous_segment (guchar * col,PixelRegion * src,PixelRegion * mask,gint width,gint bytes,gboolean has_alpha,gboolean antialias,gint threshold,gint initial,gint * start,gint * end)
name|find_contiguous_segment
parameter_list|(
name|guchar
modifier|*
name|col
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|,
name|gboolean
name|antialias
parameter_list|,
name|gint
name|threshold
parameter_list|,
name|gint
name|initial
parameter_list|,
name|gint
modifier|*
name|start
parameter_list|,
name|gint
modifier|*
name|end
parameter_list|)
block|{
name|guchar
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|m
decl_stmt|;
name|guchar
name|diff
decl_stmt|;
name|Tile
modifier|*
name|s_tile
init|=
name|NULL
decl_stmt|;
name|Tile
modifier|*
name|m_tile
init|=
name|NULL
decl_stmt|;
name|ref_tiles
argument_list|(
name|src
operator|->
name|tiles
argument_list|,
name|mask
operator|->
name|tiles
argument_list|,
operator|&
name|s_tile
argument_list|,
operator|&
name|m_tile
argument_list|,
name|src
operator|->
name|x
argument_list|,
name|src
operator|->
name|y
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* check the starting pixel */
if|if
condition|(
operator|!
operator|(
name|diff
operator|=
name|is_pixel_sufficiently_different
argument_list|(
name|col
argument_list|,
name|s
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|bytes
argument_list|,
name|has_alpha
argument_list|)
operator|)
condition|)
block|{
name|tile_release
argument_list|(
name|s_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|m_tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|m
operator|--
operator|=
name|diff
expr_stmt|;
name|s
operator|-=
name|bytes
expr_stmt|;
operator|*
name|start
operator|=
name|initial
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|>=
literal|0
operator|&&
name|diff
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|start
operator|+
literal|1
operator|)
operator|%
name|TILE_WIDTH
operator|)
condition|)
name|ref_tiles
argument_list|(
name|src
operator|->
name|tiles
argument_list|,
name|mask
operator|->
name|tiles
argument_list|,
operator|&
name|s_tile
argument_list|,
operator|&
name|m_tile
argument_list|,
operator|*
name|start
argument_list|,
name|src
operator|->
name|y
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|diff
operator|=
name|is_pixel_sufficiently_different
argument_list|(
name|col
argument_list|,
name|s
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|bytes
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|--
operator|=
name|diff
operator|)
condition|)
block|{
name|s
operator|-=
name|bytes
expr_stmt|;
operator|(
operator|*
name|start
operator|)
operator|--
expr_stmt|;
block|}
block|}
name|diff
operator|=
literal|1
expr_stmt|;
operator|*
name|end
operator|=
name|initial
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|%
name|TILE_WIDTH
operator|&&
operator|*
name|end
operator|<
name|width
condition|)
name|ref_tiles
argument_list|(
name|src
operator|->
name|tiles
argument_list|,
name|mask
operator|->
name|tiles
argument_list|,
operator|&
name|s_tile
argument_list|,
operator|&
name|m_tile
argument_list|,
operator|*
name|end
argument_list|,
name|src
operator|->
name|y
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|<
name|width
operator|&&
name|diff
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|end
operator|%
name|TILE_WIDTH
operator|)
condition|)
name|ref_tiles
argument_list|(
name|src
operator|->
name|tiles
argument_list|,
name|mask
operator|->
name|tiles
argument_list|,
operator|&
name|s_tile
argument_list|,
operator|&
name|m_tile
argument_list|,
operator|*
name|end
argument_list|,
name|src
operator|->
name|y
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|diff
operator|=
name|is_pixel_sufficiently_different
argument_list|(
name|col
argument_list|,
name|s
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|bytes
argument_list|,
name|has_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|++
operator|=
name|diff
operator|)
condition|)
block|{
name|s
operator|+=
name|bytes
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|tile_release
argument_list|(
name|s_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|m_tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_contiguous_region_helper (PixelRegion * mask,PixelRegion * src,gboolean has_alpha,gboolean antialias,gint threshold,gboolean indexed,gint x,gint y,guchar * col)
name|find_contiguous_region_helper
parameter_list|(
name|PixelRegion
modifier|*
name|mask
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|gboolean
name|has_alpha
parameter_list|,
name|gboolean
name|antialias
parameter_list|,
name|gint
name|threshold
parameter_list|,
name|gboolean
name|indexed
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|)
block|{
name|gint
name|start
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|Tile
modifier|*
name|tile
decl_stmt|;
if|if
condition|(
name|threshold
operator|==
literal|0
condition|)
name|threshold
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|src
operator|->
name|w
condition|)
return|return;
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|src
operator|->
name|h
condition|)
return|return;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|mask
operator|->
name|tiles
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
operator|(
name|guchar
operator|*
operator|)
operator|(
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
operator|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return;
name|src
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|src
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|bytes
operator|=
name|src
operator|->
name|bytes
expr_stmt|;
if|if
condition|(
name|indexed
condition|)
block|{
name|bytes
operator|=
name|has_alpha
condition|?
literal|4
else|:
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|find_contiguous_segment
argument_list|(
name|col
argument_list|,
name|src
argument_list|,
name|mask
argument_list|,
name|src
operator|->
name|w
argument_list|,
name|src
operator|->
name|bytes
argument_list|,
name|has_alpha
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|x
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|find_contiguous_region_helper
argument_list|(
name|mask
argument_list|,
name|src
argument_list|,
name|has_alpha
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|indexed
argument_list|,
name|i
argument_list|,
name|y
operator|-
literal|1
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|find_contiguous_region_helper
argument_list|(
name|mask
argument_list|,
name|src
argument_list|,
name|has_alpha
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|indexed
argument_list|,
name|i
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GimpChannel
modifier|*
DECL|function|find_contiguous_region (GimpImage * gimage,GimpDrawable * drawable,gboolean antialias,gint threshold,gint x,gint y,gboolean sample_merged)
name|find_contiguous_region
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
name|antialias
parameter_list|,
name|gint
name|threshold
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gboolean
name|sample_merged
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|GimpChannel
modifier|*
name|mask
decl_stmt|;
name|guchar
modifier|*
name|start
decl_stmt|;
name|gboolean
name|has_alpha
decl_stmt|;
name|gboolean
name|indexed
decl_stmt|;
name|gint
name|type
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|Tile
modifier|*
name|tile
decl_stmt|;
if|if
condition|(
name|sample_merged
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|gimp_image_composite
argument_list|(
name|gimage
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|type
operator|=
name|gimp_image_composite_type
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
operator|(
name|type
operator|==
name|RGBA_GIMAGE
operator|||
name|type
operator|==
name|GRAYA_GIMAGE
operator|||
name|type
operator|==
name|INDEXEDA_GIMAGE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|indexed
operator|=
name|gimp_drawable_is_indexed
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|gimp_drawable_bytes
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexed
condition|)
block|{
name|bytes
operator|=
name|has_alpha
condition|?
literal|4
else|:
literal|3
expr_stmt|;
block|}
name|mask
operator|=
name|gimp_channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|srcPR
operator|.
name|w
argument_list|,
name|srcPR
operator|.
name|h
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|srcPR
operator|.
name|tiles
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
condition|)
block|{
name|start
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
name|find_contiguous_region_helper
argument_list|(
operator|&
name|maskPR
argument_list|,
operator|&
name|srcPR
argument_list|,
name|has_alpha
argument_list|,
name|antialias
argument_list|,
name|threshold
argument_list|,
name|bytes
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void fuzzy_select (GImage       *gimage,  	      GimpDrawable *drawable,  	      gint          op,  	      gboolean      feather, 	      gdouble       feather_radius) {   gint off_x, off_y;
comment|/*  if applicable, replace the current selection  */
end_comment

begin_comment
unit|if (op == CHANNEL_OP_REPLACE)     gimage_mask_clear (gimage);   else     gimage_mask_undo (gimage);    if (drawable)
comment|/* NULL if sample_merged is active */
end_comment

begin_comment
unit|gimp_drawable_offsets (drawable,&off_x,&off_y);   else     off_x = off_y = 0;      if (feather)     gimp_channel_feather (fuzzy_mask, gimp_image_get_mask (gimage), 			  feather_radius, 			  feather_radius, 			  op, off_x, off_y);   else     gimp_channel_combine_mask (gimp_image_get_mask (gimage), 			       fuzzy_mask, op, off_x, off_y);    gtk_object_unref (GTK_OBJECT (fuzzy_mask));   fuzzy_mask = NULL; }
comment|/*  fuzzy select action functions  */
end_comment

begin_comment
unit|static void fuzzy_select_button_press (Tool           *tool,  			   GdkEventButton *bevent, 			   GDisplay       *gdisp) {   FuzzySelect *fuzzy_sel;    fuzzy_sel = (FuzzySelect *) tool->private;    fuzzy_sel->x = bevent->x;   fuzzy_sel->y = bevent->y;   fuzzy_sel->first_x = fuzzy_sel->x;   fuzzy_sel->first_y = fuzzy_sel->y;   fuzzy_sel->first_threshold = fuzzy_options->threshold;    gdk_pointer_grab (gdisp->canvas->window, FALSE, 		    GDK_POINTER_MOTION_HINT_MASK | 		    GDK_BUTTON1_MOTION_MASK | 		    GDK_BUTTON_RELEASE_MASK, 		    NULL, NULL, bevent->time);    tool->state = ACTIVE;   tool->gdisp = gdisp;    if (fuzzy_sel->op == SELECTION_MOVE_MASK)     {       init_edit_selection (tool, gdisp, bevent, EDIT_MASK_TRANSLATE);       return;     }   else if (fuzzy_sel->op == SELECTION_MOVE)     {       init_edit_selection (tool, gdisp, bevent, EDIT_MASK_TO_LAYER_TRANSLATE);       return;     }
comment|/*  calculate the region boundary  */
end_comment

begin_comment
unit|segs = fuzzy_select_calculate (tool, gdisp,&num_segs);    draw_core_start (fuzzy_sel->core, 		   gdisp->canvas->window, 		   tool); }  static void fuzzy_select_button_release (Tool           *tool,  			     GdkEventButton *bevent, 			     GDisplay       *gdisp) {   FuzzySelect  *fuzzy_sel;   GimpDrawable *drawable;    fuzzy_sel = (FuzzySelect *) tool->private;    gdk_pointer_ungrab (bevent->time);   gdk_flush ();    draw_core_stop (fuzzy_sel->core, tool);   tool->state = INACTIVE;
comment|/*  First take care of the case where the user "cancels" the action  */
end_comment

begin_comment
unit|if (! (bevent->state& GDK_BUTTON3_MASK))     {       drawable = (fuzzy_options->sample_merged ? 		  NULL : gimp_image_active_drawable (gdisp->gimage));        fuzzy_select (gdisp->gimage, drawable, fuzzy_sel->op, 		    fuzzy_options->feather,  		    fuzzy_options->feather_radius);       gdisplays_flush ();     }
comment|/*  If the segment array is allocated, free it  */
end_comment

begin_comment
unit|if (segs)     g_free (segs);   segs = NULL; }  static void fuzzy_select_motion (Tool           *tool,  		     GdkEventMotion *mevent,  		     GDisplay       *gdisp) {   FuzzySelect *fuzzy_sel;   GdkSegment  *new_segs;   gint         num_new_segs;   gint         diff_x, diff_y;   gdouble      diff;    static guint last_time = 0;    fuzzy_sel = (FuzzySelect *) tool->private;
comment|/*  needed for immediate cursor update on modifier event  */
end_comment

begin_comment
unit|fuzzy_sel->current_x = mevent->x;   fuzzy_sel->current_y = mevent->y;    if (tool->state != ACTIVE)     return;
comment|/* don't let the events come in too fast, ignore below a delay of 100 ms */
end_comment

begin_comment
unit|if (ABS (mevent->time - last_time)< 100)     return;      last_time = mevent->time;    diff_x = mevent->x - fuzzy_sel->first_x;   diff_y = mevent->y - fuzzy_sel->first_y;    diff = ((ABS (diff_x)> ABS (diff_y)) ? diff_x : diff_y) / 2.0;    gtk_adjustment_set_value (GTK_ADJUSTMENT (fuzzy_options->threshold_w),  			    fuzzy_sel->first_threshold + diff);
comment|/*  calculate the new fuzzy boundary  */
end_comment

begin_comment
unit|new_segs = fuzzy_select_calculate (tool, gdisp,&num_new_segs);
comment|/*  stop the current boundary  */
end_comment

begin_comment
unit|draw_core_pause (fuzzy_sel->core, tool);
comment|/*  make sure the XSegment array is freed before we assign the new one  */
end_comment

begin_comment
unit|if (segs)     g_free (segs);   segs = new_segs;   num_segs = num_new_segs;
comment|/*  start the new boundary  */
end_comment

begin_comment
unit|draw_core_resume (fuzzy_sel->core, tool); }   static GdkSegment * fuzzy_select_calculate (Tool     *tool,  			GDisplay *gdisp, 			gint     *nsegs) {   PixelRegion   maskPR;   FuzzySelect  *fuzzy_sel;   GimpChannel  *new;   GdkSegment   *segs;   BoundSeg     *bsegs;   GimpDrawable *drawable;   gint          i;   gint          x, y;   gboolean      use_offsets;    fuzzy_sel = (FuzzySelect *) tool->private;   drawable  = gimp_image_active_drawable (gdisp->gimage);    gimp_add_busy_cursors ();    use_offsets = fuzzy_options->sample_merged ? FALSE : TRUE;    gdisplay_untransform_coords (gdisp, fuzzy_sel->x, 			       fuzzy_sel->y,&x,&y, FALSE, use_offsets);    new = find_contiguous_region (gdisp->gimage, drawable,  				fuzzy_options->antialias, 				fuzzy_options->threshold, x, y,  				fuzzy_options->sample_merged);    if (fuzzy_mask)     gtk_object_unref (GTK_OBJECT (fuzzy_mask));    fuzzy_mask = new;    gtk_object_ref (GTK_OBJECT (fuzzy_mask));   gtk_object_sink (GTK_OBJECT (fuzzy_mask));
comment|/*  calculate and allocate a new XSegment array which represents the boundary    *  of the color-contiguous region    */
end_comment

begin_comment
unit|pixel_region_init (&maskPR, gimp_drawable_data (GIMP_DRAWABLE (fuzzy_mask)), 		     0, 0,  		     gimp_drawable_width (GIMP_DRAWABLE (fuzzy_mask)),  		     gimp_drawable_height (GIMP_DRAWABLE (fuzzy_mask)),  		     FALSE);   bsegs = find_mask_boundary (&maskPR, nsegs, WithinBounds, 			      0, 0, 			      gimp_drawable_width (GIMP_DRAWABLE (fuzzy_mask)), 			      gimp_drawable_height (GIMP_DRAWABLE (fuzzy_mask)));    segs = g_new (GdkSegment, *nsegs);    for (i = 0; i< *nsegs; i++)     {       gdisplay_transform_coords (gdisp, bsegs[i].x1, bsegs[i].y1,&x,&y, use_offsets);       segs[i].x1 = x;  segs[i].y1 = y;       gdisplay_transform_coords (gdisp, bsegs[i].x2, bsegs[i].y2,&x,&y, use_offsets);       segs[i].x2 = x;  segs[i].y2 = y;     }
comment|/*  free boundary segments  */
end_comment

begin_comment
unit|g_free (bsegs);    gimp_remove_busy_cursors (NULL);    return segs; }  static void fuzzy_select_draw (Tool *tool) {   FuzzySelect *fuzzy_sel;    fuzzy_sel = (FuzzySelect *) tool->private;    if (segs)     gdk_draw_segments (fuzzy_sel->core->win, fuzzy_sel->core->gc, segs, num_segs); }  static void fuzzy_select_control (Tool       *tool, 		      ToolAction  action, 		      GDisplay   *gdisp) {   FuzzySelect *fuzzy_sel;    fuzzy_sel = (FuzzySelect *) tool->private;    switch (action)     {     case PAUSE :       draw_core_pause (fuzzy_sel->core, tool);       break;      case RESUME :       draw_core_resume (fuzzy_sel->core, tool);       break;      case HALT :       draw_core_stop (fuzzy_sel->core, tool);       break;      default:       break;     } }  static void fuzzy_select_options_reset (void) {   selection_options_reset (fuzzy_options); }  Tool * tools_new_fuzzy_select (void) {   Tool        *tool;   FuzzySelect *private;
comment|/*  The tool options  */
end_comment

begin_comment
unit|if (! fuzzy_options)     {       fuzzy_options = selection_options_new (FUZZY_SELECT, 					     fuzzy_select_options_reset);       tools_register (FUZZY_SELECT, (ToolOptions *) fuzzy_options);     }    tool = tools_new_tool (FUZZY_SELECT);   private = g_new0 (FuzzySelect, 1);    private->core = draw_core_new (fuzzy_select_draw);    tool->scroll_lock = TRUE;
comment|/*  Disallow scrolling  */
end_comment

begin_endif
unit|tool->private = (void *) private;    tool->tool_cursor = GIMP_FUZZY_SELECT_TOOL_CURSOR;    tool->button_press_func   = fuzzy_select_button_press;   tool->button_release_func = fuzzy_select_button_release;   tool->motion_func         = fuzzy_select_motion;   tool->modifier_key_func   = rect_select_modifier_update;   tool->cursor_update_func  = rect_select_cursor_update;   tool->oper_update_func    = rect_select_oper_update;   tool->control_func        = fuzzy_select_control;    return tool; }  void tools_free_fuzzy_select (Tool *tool) {   FuzzySelect *fuzzy_sel;    fuzzy_sel = (FuzzySelect *) tool->private;   draw_core_free (fuzzy_sel->core);   g_free (fuzzy_sel); }
endif|#
directive|endif
end_endif

end_unit

