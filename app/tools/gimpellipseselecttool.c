begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"ellipse_select.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_comment
comment|/*  private header file for rect_select data structure  */
end_comment

begin_include
include|#
directive|include
file|"rect_selectP.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_define
DECL|macro|NO
define|#
directive|define
name|NO
value|0
end_define

begin_define
DECL|macro|YES
define|#
directive|define
name|YES
value|1
end_define

begin_decl_stmt
DECL|variable|ellipse_options
name|SelectionOptions
modifier|*
name|ellipse_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ellipse_select
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|ellipse_select_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/*  Ellipsoidal selection apparatus  */
end_comment

begin_function
name|void
DECL|function|ellipse_select (gimage,x,y,w,h,op,antialias,feather,feather_radius)
name|ellipse_select
parameter_list|(
name|gimage
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|op
parameter_list|,
name|antialias
parameter_list|,
name|feather
parameter_list|,
name|feather_radius
parameter_list|)
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|antialias
decl_stmt|;
name|int
name|feather
decl_stmt|;
name|double
name|feather_radius
decl_stmt|;
block|{
name|Channel
modifier|*
name|new_mask
decl_stmt|;
comment|/*  if applicable, replace the current selection  */
if|if
condition|(
name|op
operator|==
name|REPLACE
condition|)
name|gimage_mask_clear
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  if feathering for rect, make a new mask with the    *  rectangle and feather that with the old mask    */
if|if
condition|(
name|feather
condition|)
block|{
name|new_mask
operator|=
name|channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|channel_combine_ellipse
argument_list|(
name|new_mask
argument_list|,
name|ADD
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|antialias
argument_list|)
expr_stmt|;
name|channel_feather
argument_list|(
name|new_mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|channel_delete
argument_list|(
name|new_mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|INTERSECT
condition|)
block|{
name|new_mask
operator|=
name|channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|channel_combine_ellipse
argument_list|(
name|new_mask
argument_list|,
name|ADD
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|antialias
argument_list|)
expr_stmt|;
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|new_mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|channel_delete
argument_list|(
name|new_mask
argument_list|)
expr_stmt|;
block|}
else|else
name|channel_combine_ellipse
argument_list|(
name|gimage_get_mask
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|op
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|antialias
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ellipse_select_draw (tool)
name|ellipse_select_draw
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|EllipseSelect
modifier|*
name|ellipse_sel
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|ellipse_sel
operator|=
operator|(
name|EllipseSelect
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|x1
operator|=
name|MINIMUM
argument_list|(
name|ellipse_sel
operator|->
name|x
argument_list|,
name|ellipse_sel
operator|->
name|x
operator|+
name|ellipse_sel
operator|->
name|w
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MINIMUM
argument_list|(
name|ellipse_sel
operator|->
name|y
argument_list|,
name|ellipse_sel
operator|->
name|y
operator|+
name|ellipse_sel
operator|->
name|h
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MAXIMUM
argument_list|(
name|ellipse_sel
operator|->
name|x
argument_list|,
name|ellipse_sel
operator|->
name|x
operator|+
name|ellipse_sel
operator|->
name|w
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MAXIMUM
argument_list|(
name|ellipse_sel
operator|->
name|y
argument_list|,
name|ellipse_sel
operator|->
name|y
operator|+
name|ellipse_sel
operator|->
name|h
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdk_draw_arc
argument_list|(
name|ellipse_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|ellipse_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_ellipse_select ()
name|tools_new_ellipse_select
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|EllipseSelect
modifier|*
name|private
decl_stmt|;
comment|/*  The tool options  */
if|if
condition|(
operator|!
name|ellipse_options
condition|)
name|ellipse_options
operator|=
name|create_selection_options
argument_list|(
name|ELLIPSE_SELECT
argument_list|)
expr_stmt|;
name|tool
operator|=
operator|(
name|Tool
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
name|EllipseSelect
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EllipseSelect
argument_list|)
argument_list|)
expr_stmt|;
name|private
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|ellipse_select_draw
argument_list|)
expr_stmt|;
comment|/*  Make the selection static, not blinking  */
name|private
operator|->
name|x
operator|=
name|private
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|private
operator|->
name|w
operator|=
name|private
operator|->
name|h
operator|=
literal|0
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|ELLIPSE_SELECT
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|0
expr_stmt|;
comment|/*  Allow scrolling  */
name|tool
operator|->
name|auto_snap_to
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|private
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|rect_select_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|rect_select_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|rect_select_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|rect_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|rect_select_control
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|TRUE
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_ellipse_select (tool)
name|tools_free_ellipse_select
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|EllipseSelect
modifier|*
name|ellipse_sel
decl_stmt|;
name|ellipse_sel
operator|=
operator|(
name|EllipseSelect
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|draw_core_free
argument_list|(
name|ellipse_sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ellipse_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  The ellipse_select procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|ellipse_select_args
name|ProcArg
name|ellipse_select_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"x"
block|,
literal|"x coordinate of upper-left corner of ellipse bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"y"
block|,
literal|"y coordinate of upper-left corner of ellipse bounding box"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"width"
block|,
literal|"the width of the ellipse: width> 0"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"height"
block|,
literal|"the height of the ellipse: height> 0"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"operation"
block|,
literal|"the selection operation: { ADD (0), SUB (1), REPLACE (2), INTERSECT (3) }"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"antialias"
block|,
literal|"antialiasing On/Off"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"feather"
block|,
literal|"feather option for selections"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"feather_radius"
block|,
literal|"radius for feather operation"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ellipse_select_proc
name|ProcRecord
name|ellipse_select_proc
init|=
block|{
literal|"gimp_ellipse_select"
block|,
literal|"Create an elliptical selection over the specified image"
block|,
literal|"This tool creates an elliptical selection over the specified image.  The elliptical region can be either added to, subtracted from, or replace the contents of the previous selection mask.  If antialiasing is turned on, the edges of the elliptical region will contain intermediate values which give the appearance of a sharper, less pixelized edge.  This should be set as TRUE most of the time.  If the feather option is enabled, the resulting selection is blurred before combining.  The blur is a gaussian blur with the specified feather radius."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|9
block|,
name|ellipse_select_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|ellipse_select_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|ellipse_select_invoker (args)
name|ellipse_select_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|antialias
decl_stmt|;
name|int
name|feather
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|double
name|w
decl_stmt|,
name|h
decl_stmt|;
name|double
name|feather_radius
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|op
operator|=
name|REPLACE
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  x, y, w, h  */
if|if
condition|(
name|success
condition|)
block|{
name|x
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|y
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|w
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|h
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
block|}
comment|/*  operation  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|op
operator|=
name|ADD
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|op
operator|=
name|SUB
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|REPLACE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|INTERSECT
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/*  antialiasing?  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|antialias
operator|=
operator|(
name|int_value
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
comment|/*  feathering  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|feather
operator|=
operator|(
name|int_value
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
comment|/*  feather radius  */
if|if
condition|(
name|success
condition|)
block|{
name|feather_radius
operator|=
name|args
index|[
literal|8
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
block|}
comment|/*  call the ellipse_select procedure  */
if|if
condition|(
name|success
condition|)
name|ellipse_select
argument_list|(
name|gimage
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
operator|(
name|int
operator|)
name|w
argument_list|,
operator|(
name|int
operator|)
name|h
argument_list|,
name|op
argument_list|,
name|antialias
argument_list|,
name|feather
argument_list|,
name|feather_radius
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|ellipse_select_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

end_unit

