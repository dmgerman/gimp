begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"actionarea.h"
end_include

begin_include
include|#
directive|include
file|"bezier_select.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"paths_dialog.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_comment
comment|/* Bezier extensions made by Raphael FRANCOIS (fraph@ibm.net)    BEZIER_EXTENDS VER 1.0     - work as the cut/copy/paste named functions.   - allow to add/remove/replace bezier curves   - allow to modify the control/anchor points even if the selection is made   - allow to add/remove control/anchor points on a curve   - allow to update a previous saved curve    - cannot operate on open or multiple curves simultaneously */
end_comment

begin_define
DECL|macro|BEZIER_DRAW_CURVE
define|#
directive|define
name|BEZIER_DRAW_CURVE
value|1
end_define

begin_define
DECL|macro|BEZIER_DRAW_CURRENT
define|#
directive|define
name|BEZIER_DRAW_CURRENT
value|2
end_define

begin_define
DECL|macro|BEZIER_DRAW_HANDLES
define|#
directive|define
name|BEZIER_DRAW_HANDLES
value|4
end_define

begin_define
DECL|macro|BEZIER_DRAW_ALL
define|#
directive|define
name|BEZIER_DRAW_ALL
value|(BEZIER_DRAW_CURVE | BEZIER_DRAW_HANDLES)
end_define

begin_define
DECL|macro|BEZIER_WIDTH
define|#
directive|define
name|BEZIER_WIDTH
value|8
end_define

begin_define
DECL|macro|BEZIER_HALFWIDTH
define|#
directive|define
name|BEZIER_HALFWIDTH
value|4
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE2
define|#
directive|define
name|SUPERSAMPLE2
value|9
end_define

begin_define
DECL|macro|NO
define|#
directive|define
name|NO
value|0
end_define

begin_define
DECL|macro|YES
define|#
directive|define
name|YES
value|1
end_define

begin_comment
comment|/* bezier select type definitions */
end_comment

begin_typedef
DECL|typedef|BezierMatrix
typedef|typedef
name|double
name|BezierMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_comment
comment|/* The named paste dialog */
end_comment

begin_typedef
DECL|typedef|PasteNamedDlg
typedef|typedef
name|struct
name|_PasteNamedDlg
name|PasteNamedDlg
typedef|;
end_typedef

begin_struct
DECL|struct|_PasteNamedDlg
struct|struct
name|_PasteNamedDlg
block|{
DECL|member|shell
name|GtkWidget
modifier|*
name|shell
decl_stmt|;
DECL|member|list
name|GtkWidget
modifier|*
name|list
decl_stmt|;
DECL|member|gdisp
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The named buffer structure... */
end_comment

begin_typedef
DECL|typedef|BezierNamedBuffer
typedef|typedef
name|struct
name|_named_buffer
name|BezierNamedBuffer
typedef|;
end_typedef

begin_struct
DECL|struct|_named_buffer
struct|struct
name|_named_buffer
block|{
DECL|member|sel
name|BezierSelect
modifier|*
name|sel
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|BezierPointsFunc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_compose
parameter_list|(
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|test_add_point_on_segment
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_to_sel_internal
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|Tool
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|stroke_interpolatable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|basis
specifier|static
name|BezierMatrix
name|basis
init|=
block|{
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
operator|-
literal|6
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static BezierMatrix basis = {   { -1/6.0,  3/6.0, -3/6.0,  1/6.0 },   {  3/6.0, -6/6.0,  3/6.0,  0 },   { -3/6.0,  0,  3/6.0,  0 },   {  1/6.0,  4/6.0,  1,  0 }, }; */
end_comment

begin_comment
comment|/*  The named buffer list  */
end_comment

begin_decl_stmt
DECL|variable|bezier_named_buffers
name|GSList
modifier|*
name|bezier_named_buffers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bezier_options
specifier|static
name|SelectionOptions
modifier|*
name|bezier_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global Static Variable to maintain informations about rhe "contexte" */
end_comment

begin_decl_stmt
DECL|variable|curSel
specifier|static
name|BezierSelect
modifier|*
name|curSel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curTool
specifier|static
name|Tool
modifier|*
name|curTool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curGdisp
specifier|static
name|GDisplay
modifier|*
name|curGdisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curCore
specifier|static
name|DrawCore
modifier|*
name|curCore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ModeEdit
specifier|static
name|int
name|ModeEdit
init|=
name|EXTEND_NEW
decl_stmt|;
end_decl_stmt

begin_function
name|Tool
modifier|*
DECL|function|tools_new_bezier_select ()
name|tools_new_bezier_select
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
comment|/*  The tool options  */
if|if
condition|(
operator|!
name|bezier_options
condition|)
name|bezier_options
operator|=
name|create_selection_options
argument_list|(
name|BEZIER_SELECT
argument_list|)
expr_stmt|;
name|tool
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierSelect
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|bezier_select_draw
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|BEZIER_SELECT
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|1
expr_stmt|;
comment|/*  Do not allow scrolling  */
name|tool
operator|->
name|auto_snap_to
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|bezier_sel
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|bezier_select_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|bezier_select_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|bezier_select_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|rect_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|bezier_select_control
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|FALSE
expr_stmt|;
name|curCore
operator|=
name|bezier_sel
operator|->
name|core
expr_stmt|;
name|curSel
operator|=
name|bezier_sel
expr_stmt|;
name|curTool
operator|=
name|tool
expr_stmt|;
name|paths_new_bezier_select_tool
argument_list|()
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_bezier_select (Tool * tool)
name|tools_free_bezier_select
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|bezier_select_load (void * gdisp_ptr,BezierPoint * pts,int num_pts,int closed)
name|bezier_select_load
parameter_list|(
name|void
modifier|*
name|gdisp_ptr
parameter_list|,
name|BezierPoint
modifier|*
name|pts
parameter_list|,
name|int
name|num_pts
parameter_list|,
name|int
name|closed
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
comment|/*  select the bezier tool  */
name|gtk_widget_activate
argument_list|(
name|tool_info
index|[
name|BEZIER_SELECT
index|]
operator|.
name|tool_widget
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
operator|(
name|BezierSelect
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|pts
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|pts
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
name|num_pts
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_draw_curve (BezierSelect * bezier_sel,BezierPointsFunc func,gint coord)
name|bezier_draw_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPointsFunc
name|func
parameter_list|,
name|gint
name|coord
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|coord
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
block|}
else|else
block|{
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|num_points
operator|>=
literal|4
condition|)
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|coord
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|bezier_select_reset (BezierSelect * bezier_sel)
name|bezier_select_reset
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|temp_pt
decl_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
operator|(
name|bezier_sel
operator|->
name|closed
operator|)
condition|?
operator|(
name|bezier_sel
operator|->
name|points
operator|)
else|:
operator|(
name|NULL
operator|)
expr_stmt|;
do|do
block|{
name|temp_pt
operator|=
name|points
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|temp_pt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
comment|/* we are starting the curve */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* draw everything by default */
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* the curve is initally open */
name|bezier_sel
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/* initially there are no points */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
comment|/* intially there are no points */
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/* empty mask */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_edit_point_on_curve (int x,int y,int halfwidth,GDisplay * gdisp,BezierSelect * bezier_sel,Tool * tool)
name|bezier_edit_point_on_curve
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|gint
name|grab_pointer
init|=
literal|0
decl_stmt|;
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
comment|/* find if the button press occurred on a point */
do|do
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|BezierPoint
modifier|*
name|finded
init|=
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_op
decl_stmt|;
name|BezierPoint
modifier|*
name|end_op
decl_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<=
literal|7
condition|)
block|{
comment|/* If we've got less then 7 points ie: 2 anchors points 4 controls  		     Then the curve is minimal closed curve. 		     I've decided to not operate on this kind of curve because it     		     implies opening the curve and change some drawing states         		     Removing 1 point of curve that contains 2 point is something     		     similare to reconstruct the curve !!! 		  */
goto|goto
name|end
goto|;
block|}
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
operator|&&
operator|(
name|finded
operator|==
name|bezier_sel
operator|->
name|points
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|points
operator|->
name|next
operator|)
condition|)
block|{
comment|/* This is the first point on the curve */
comment|/* FIXME printf("Del first point\n"); */
block|}
elseif|else
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
operator|&&
operator|(
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|->
name|prev
operator|)
condition|)
block|{
comment|/* This is the last point on the curve */
comment|/* FIXME printf("Del last point\n"); */
block|}
else|else
block|{
if|if
condition|(
name|finded
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
block|{
if|if
condition|(
name|finded
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
name|finded
operator|=
name|finded
operator|->
name|prev
expr_stmt|;
else|else
name|finded
operator|=
name|finded
operator|->
name|next
expr_stmt|;
block|}
name|start_op
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
name|end_op
operator|=
name|finded
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|start_op
operator|->
name|next
operator|=
name|end_op
expr_stmt|;
name|end_op
operator|->
name|prev
operator|=
name|start_op
expr_stmt|;
if|if
condition|(
operator|(
name|bezier_sel
operator|->
name|last_point
operator|==
name|finded
operator|)
operator|||
operator|(
name|bezier_sel
operator|->
name|last_point
operator|==
name|finded
operator|->
name|next
operator|)
operator|||
operator|(
name|bezier_sel
operator|->
name|last_point
operator|==
name|finded
operator|->
name|prev
operator|)
condition|)
block|{
name|bezier_sel
operator|->
name|last_point
operator|=
name|start_op
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|start_op
operator|->
name|prev
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|num_points
operator|-=
literal|3
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|prev
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
argument_list|)
expr_stmt|;
comment|/* Clear current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|end
label|:
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set the current anchor and control points */
switch|switch
condition|(
name|points
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
name|grab_pointer
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
return|return
name|grab_pointer
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_add_point_on_segment (int x,int y,int halfwidth,GDisplay * gdisp,BezierSelect * bezier_sel,Tool * tool)
name|bezier_add_point_on_segment
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
do|do
block|{
if|if
condition|(
name|test_add_point_on_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_press (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|int
name|grab_pointer
decl_stmt|;
name|int
name|op
decl_stmt|,
name|replace
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|grab_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|extend
condition|)
block|{
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp_ptr
operator|!=
name|tool
operator|->
name|gdisp_ptr
condition|)
block|{
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|curTool
operator|=
name|active_tool
expr_stmt|;
name|curSel
operator|=
name|curTool
operator|->
name|private
expr_stmt|;
name|curGdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|active_tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|curCore
operator|=
name|bezier_sel
operator|->
name|core
expr_stmt|;
switch|switch
condition|(
name|bezier_sel
operator|->
name|state
condition|)
block|{
case|case
name|BEZIER_START
case|:
name|grab_pointer
operator|=
literal|1
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskTranslate
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|layer_is_floating_sel
argument_list|(
name|gimage_get_active_layer
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|)
operator|)
operator|&&
name|gdisplay_mask_value
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|)
operator|>
name|HALF_WAY
condition|)
block|{
name|init_edit_selection
argument_list|(
name|tool
argument_list|,
name|gdisp_ptr
argument_list|,
name|bevent
argument_list|,
name|MaskToLayerTranslate
argument_list|)
expr_stmt|;
break|break;
block|}
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER_ADD
case|:
name|grab_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_EDIT
condition|)
block|{
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<
literal|6
condition|)
return|return;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<
literal|5
condition|)
return|return;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|points
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_EDIT
case|:
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"tried to edit on open bezier curve in edit selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grab_pointer
operator|&&
name|channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|ADD
expr_stmt|;
name|replace
operator|=
literal|1
expr_stmt|;
block|}
name|bezier_to_sel_internal
argument_list|(
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|gdisp
argument_list|,
name|op
argument_list|,
name|replace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* draw the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
comment|/* Don't bother doing this if we don't have any points */
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
name|paths_first_button_press
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|&=
operator|~
operator|(
name|BEZIER_DRAG
operator|)
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
comment|/* Here ?*/
name|paths_newpoint_current
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
specifier|static
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|anchor
decl_stmt|;
name|BezierPoint
modifier|*
name|opposite_control
decl_stmt|;
name|int
name|offsetx
decl_stmt|;
name|int
name|offsety
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
return|return;
name|gdisp
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|cur_anchor
operator|||
operator|!
name|bezier_sel
operator|->
name|cur_control
condition|)
return|return;
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
block|}
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the first point then change the state and "remember" the point.    */
if|if
condition|(
operator|!
operator|(
name|bezier_sel
operator|->
name|state
operator|&
name|BEZIER_DRAG
operator|)
condition|)
block|{
name|bezier_sel
operator|->
name|state
operator||=
name|BEZIER_DRAG
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
comment|/* The Alt key is down... Move all the points of the bezier curve */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|int
name|i
decl_stmt|;
name|BezierPoint
modifier|*
name|tmp
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bezier_sel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
condition|)
block|{
comment|/* the control key is down ... move the current anchor point */
comment|/* we must also move the neighboring control points appropriately */
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the control key is not down ... we move the current control point */
name|offsetx
operator|=
name|x
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_control
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
comment|/* if the shift key is not down then we align the opposite control */
comment|/* point...ie the opposite control point acts like a mirror of the */
comment|/* current control point */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|anchor
operator|=
name|NULL
expr_stmt|;
name|opposite_control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"Encountered orphaned bezier control point"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opposite_control
condition|)
block|{
name|offsetx
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
operator|-
name|anchor
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
operator|-
name|anchor
operator|->
name|y
expr_stmt|;
name|opposite_control
operator|->
name|x
operator|=
name|anchor
operator|->
name|x
operator|-
name|offsetx
expr_stmt|;
name|opposite_control
operator|->
name|y
operator|=
name|anchor
operator|->
name|y
operator|-
name|offsety
expr_stmt|;
block|}
block|}
block|}
comment|/* As we're moving all the control points of the curve,      we have to redraw all !!!      */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_control (Tool * tool,int action,gpointer gdisp_ptr)
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|int
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_draw (Tool * tool)
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|int
name|draw_curve
decl_stmt|;
name|int
name|draw_handles
decl_stmt|;
name|int
name|draw_current
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|draw
condition|)
return|return;
name|draw_curve
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_current
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|draw_handles
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_HANDLES
expr_stmt|;
comment|/* reset to the default drawing state of drawing the curve and handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|points
operator|->
name|x
argument_list|,
name|points
operator|->
name|y
argument_list|,
operator|&
name|points
operator|->
name|sx
argument_list|,
operator|&
name|points
operator|->
name|sy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|draw_curve
condition|)
name|bezier_draw_curve
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|SCREEN_COORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|draw_handles
condition|)
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|draw_current
condition|)
name|bezier_draw_current
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_add_point (BezierSelect * bezier_sel,int type,int x,int y)
name|bezier_add_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|newpt
decl_stmt|;
name|newpt
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
name|newpt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|newpt
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|newpt
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|newpt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|newpt
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|points
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|newpt
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|newpt
expr_stmt|;
break|break;
block|}
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_offset_point (BezierPoint * pt,int x,int y)
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|x
operator|+=
name|x
expr_stmt|;
name|pt
operator|->
name|y
operator|+=
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bezier_check_point (BezierPoint * pt,int x,int y,int halfwidth)
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|l
operator|=
name|pt
operator|->
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|pt
operator|->
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|pt
operator|->
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|pt
operator|->
name|y
operator|+
name|halfwidth
expr_stmt|;
return|return
operator|(
operator|(
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|y
operator|<=
name|b
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_handles (BezierSelect * bezier_sel)
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|<=
literal|0
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|points
operator|==
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|next
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|num_points
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_current (BezierSelect * bezier_sel)
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_point (BezierSelect * bezier_sel,BezierPoint * pt,int fill)
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|fill
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
switch|switch
condition|(
name|pt
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_CONTROL
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_line (BezierSelect * bezier_sel,BezierPoint * pt1,BezierPoint * pt2)
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt1
parameter_list|,
name|BezierPoint
modifier|*
name|pt2
parameter_list|)
block|{
if|if
condition|(
name|pt1
operator|&&
name|pt2
condition|)
block|{
name|gdk_draw_line
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|pt1
operator|->
name|sx
argument_list|,
name|pt1
operator|->
name|sy
argument_list|,
name|pt2
operator|->
name|sx
argument_list|,
name|pt2
operator|->
name|sy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment (BezierSelect * bezier_sel,BezierPoint * points,int subdivisions,int space,BezierPointsFunc points_func)
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|space
parameter_list|,
name|BezierPointsFunc
name|points_func
parameter_list|)
block|{
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
specifier|static
name|GdkPoint
name|gdk_points
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|npoints
init|=
literal|256
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"bad bezier segment"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"unknown coordinate space: %d"
argument_list|)
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|lastx
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|lasty
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then draw it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
comment|/* add the point to the point buffer */
name|gdk_points
index|[
name|index
index|]
operator|.
name|x
operator|=
name|newx
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|y
operator|=
name|newy
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* if the point buffer is full put it to the screen and zero it out */
if|if
condition|(
name|index
operator|>=
name|npoints
condition|)
block|{
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* if there are points in the buffer, then put them on the screen */
if|if
condition|(
name|index
condition|)
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints)
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|gdk_draw_points
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|points
argument_list|,
name|npoints
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_compose (BezierMatrix a,BezierMatrix b,BezierMatrix ab)
name|bezier_compose
parameter_list|(
name|BezierMatrix
name|a
parameter_list|,
name|BezierMatrix
name|b
parameter_list|,
name|BezierMatrix
name|ab
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ab
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|a
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|b
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|b
index|[
literal|1
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|b
index|[
literal|2
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|3
index|]
operator|*
name|b
index|[
literal|3
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
DECL|variable|start_convert
specifier|static
name|int
name|start_convert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|width
DECL|variable|height
specifier|static
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lastx
specifier|static
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lasty
specifier|static
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|bezier_convert (BezierSelect * bezier_sel,GDisplay * gdisp,int subdivisions,int antialias)
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|antialias
parameter_list|)
block|{
name|PixelRegion
name|maskPR
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|draw_type
decl_stmt|;
name|int
modifier|*
name|vals
decl_stmt|,
name|val
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|x
decl_stmt|,
name|x2
decl_stmt|,
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"tried to convert an open bezier curve"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* destroy previous mask */
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
block|{
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get the new mask's maximum extents */
if|if
condition|(
name|antialias
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|draw_type
operator|=
name|AA_IMAGE_COORDS
expr_stmt|;
comment|/* allocate value array  */
name|vals
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
expr_stmt|;
name|draw_type
operator|=
name|IMAGE_COORDS
expr_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new mask */
name|bezier_sel
operator|->
name|mask
operator|=
name|channel_ref
argument_list|(
name|channel_new_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate room for the scanlines */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GSList
operator|*
argument_list|)
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* zero out the scanlines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* scan convert the curve */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_convert
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|subdivisions
argument_list|,
name|draw_type
argument_list|,
name|bezier_convert_points
argument_list|)
expr_stmt|;
comment|/*  advance to the next segment  */
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
if|if
condition|(
name|antialias
condition|)
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|x
argument_list|,
name|bezier_sel
operator|->
name|points
operator|->
name|y
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|=
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
expr_stmt|;
comment|/*  zero the vals array  */
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
name|i
operator|%
name|SUPERSAMPLE
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|x
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/*           if (!list) 	    g_message (_("cannot properly scanline convert bezier curve: %d"), i);           else */
block|{
comment|/*  bounds checking  */
name|x
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
operator|(
name|long
operator|)
name|list
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|w
operator|=
name|x2
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|antialias
condition|)
name|channel_add_segment
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|i
argument_list|,
name|w
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
name|vals
index|[
name|j
operator|+
name|x
index|]
operator|+=
literal|255
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|SUPERSAMPLE
operator|)
condition|)
block|{
name|b
operator|=
name|buf
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|width
expr_stmt|;
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|+=
name|SUPERSAMPLE
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SUPERSAMPLE
condition|;
name|x
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
operator|*
name|b
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|/
name|SUPERSAMPLE2
argument_list|)
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|maskPR
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|/
name|SUPERSAMPLE
operator|)
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
block|{
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
name|channel_invalidate_bounds
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints)
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|start_convert
condition|)
name|start_convert
operator|=
literal|0
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|npoints
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_line (GSList ** scanlines,int x1,int y1,int x2,int y2)
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|error
decl_stmt|,
name|inc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|float
name|slope
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y2
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
operator|+
operator|(
literal|0
operator|-
name|y2
operator|)
operator|/
name|slope
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y2
operator|>=
name|height
condition|)
block|{
if|if
condition|(
name|y1
operator|>=
name|height
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y2
operator|=
name|height
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|float
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
operator|(
name|height
operator|-
name|y1
operator|)
operator|/
name|slope
expr_stmt|;
name|y2
operator|=
name|height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|scanlines
operator|=
operator|&
name|scanlines
index|[
name|y1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|dx
else|:
name|dx
operator|)
operator|>
operator|(
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
operator|)
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|dx
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|x1
operator|!=
name|x2
condition|)
block|{
name|error
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dx
expr_stmt|;
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
block|}
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
operator|-
name|dy
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|y1
operator|++
operator|<
name|y2
condition|)
block|{
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
name|error
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dy
expr_stmt|;
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|bezier_insert_in_list (GSList * list,int x)
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|GSList
modifier|*
name|orig
init|=
name|list
decl_stmt|;
name|GSList
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
return|;
while|while
condition|(
name|list
condition|)
block|{
name|rest
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|long
operator|)
name|list
operator|->
name|data
condition|)
block|{
name|rest
operator|=
name|g_slist_prepend
argument_list|(
name|rest
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|list
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
expr_stmt|;
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rest
condition|)
block|{
name|g_slist_append
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_paste_bezierselect_to_current (GDisplay * gdisp,BezierSelect * bsel)
name|bezier_paste_bezierselect_to_current
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bsel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|pts
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|Tool
modifier|*
name|tool
decl_stmt|;
comment|/*  If the tool was being used before clear it */
if|if
condition|(
name|active_tool_type
operator|==
name|BEZIER_SELECT
operator|&&
name|active_tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
init|=
operator|(
name|BezierSelect
operator|*
operator|)
name|active_tool
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|bezier_sel
condition|)
block|{
name|draw_core_stop
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
block|}
name|gtk_widget_activate
argument_list|(
name|tool_info
index|[
name|BEZIER_SELECT
index|]
operator|.
name|tool_widget
argument_list|)
expr_stmt|;
name|tools_select
argument_list|(
name|BEZIER_SELECT
argument_list|)
expr_stmt|;
name|active_tool
operator|->
name|paused_count
operator|=
literal|0
expr_stmt|;
name|active_tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp
expr_stmt|;
empty_stmt|;
name|active_tool
operator|->
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|curSel
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|pts
operator|=
operator|(
name|BezierPoint
operator|*
operator|)
name|bsel
operator|->
name|points
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bsel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
name|bezier_add_point
argument_list|(
name|curSel
argument_list|,
name|pts
operator|->
name|type
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|bsel
operator|->
name|closed
condition|)
block|{
name|curSel
operator|->
name|last_point
operator|->
name|next
operator|=
name|curSel
operator|->
name|points
expr_stmt|;
name|curSel
operator|->
name|points
operator|->
name|prev
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
name|curSel
operator|->
name|cur_anchor
operator|=
name|curSel
operator|->
name|points
expr_stmt|;
name|curSel
operator|->
name|cur_control
operator|=
name|curSel
operator|->
name|points
operator|->
name|next
expr_stmt|;
name|curSel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curTool
operator|->
name|gdisp_ptr
condition|)
name|bezier_convert
argument_list|(
name|curSel
argument_list|,
name|curTool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|curSel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
name|curSel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|curTool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curSel
operator|->
name|state
operator|=
name|bsel
operator|->
name|state
expr_stmt|;
name|curSel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|curTool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_to_sel_internal (BezierSelect * bezier_sel,Tool * tool,GDisplay * gdisp,gint op,gint replace)
name|bezier_to_sel_internal
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|op
parameter_list|,
name|gint
name|replace
parameter_list|)
block|{
comment|/*  If we're antialiased, then recompute the    *  mask...    */
if|if
condition|(
name|bezier_options
operator|->
name|antialias
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_options
operator|->
name|extend
condition|)
block|{
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|feather
condition|)
name|channel_feather
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_sel
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  show selection on all views  */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|test_add_point_on_segment (BezierSelect * bezier_sel,BezierPoint * pt,int subdivisions,int space,int xpos,int ypos,int halfwidth)
name|test_add_point_on_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|space
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|halfwidth
parameter_list|)
block|{
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|double
name|ratio
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
comment|/* ALT ignore invalid segments since we might be working on an open curve */
name|points
operator|=
name|pt
expr_stmt|;
name|ratio
operator|=
operator|-
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"unknown coordinate space: %d"
argument_list|)
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then test it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|b
decl_stmt|,
name|t
decl_stmt|;
name|l
operator|=
name|newx
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|newx
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|newy
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|newy
operator|+
name|halfwidth
expr_stmt|;
if|if
condition|(
operator|(
name|xpos
operator|>=
name|l
operator|)
operator|&&
operator|(
name|xpos
operator|<=
name|r
operator|)
operator|&&
operator|(
name|ypos
operator|>=
name|t
operator|)
operator|&&
operator|(
name|ypos
operator|<=
name|b
operator|)
condition|)
block|{
comment|/* so we found one point in the square hit */
name|ratio
operator|=
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|subdivisions
expr_stmt|;
comment|/* We found the exact point on the curve, so take it ...*/
if|if
condition|(
operator|(
name|xpos
operator|==
name|newx
operator|)
operator|&&
operator|(
name|ypos
operator|==
name|newy
operator|)
condition|)
break|break;
comment|/* to Implement :  		 keep each time the nearest point of the curve from where we've clicked 		 in the case where we haven't click exactely on the curve. 	      */
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* we found a point on the curve */
if|if
condition|(
name|ratio
operator|>=
literal|0.0
condition|)
block|{
name|BezierPoint
modifier|*
name|pts
decl_stmt|,
modifier|*
name|pt1
decl_stmt|,
modifier|*
name|pt2
decl_stmt|,
modifier|*
name|pt3
decl_stmt|;
name|BezierPoint
modifier|*
name|P00
decl_stmt|,
modifier|*
name|P01
decl_stmt|,
modifier|*
name|P02
decl_stmt|,
modifier|*
name|P03
decl_stmt|;
name|BezierPoint
name|P10
decl_stmt|,
name|P11
decl_stmt|,
name|P12
decl_stmt|;
name|BezierPoint
name|P20
decl_stmt|,
name|P21
decl_stmt|;
name|BezierPoint
name|P30
decl_stmt|;
name|pts
operator|=
name|pt
expr_stmt|;
name|P00
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P01
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P02
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P03
operator|=
name|pts
expr_stmt|;
comment|/* De Casteljau algorithme  	 [Advanced Animation& Randering Technics / Alan& Mark WATT] 	 [ADDISON WESLEY ref 54412] 	 Iteratif way of drawing a Bezier curve by geometrical approch  	  	 P0x represent the four controls points ( anchor / control /control /anchor )  	 P30 represent the new anchor point to add on the curve  	 P2x represent the new control points of P30 	 P1x represent the new values of the control points P01 and P02  	 so if we moves ratio from 0 to 1 we draw the all curve between P00 and P03       */
name|P10
operator|.
name|x
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|x
operator|+
name|ratio
operator|*
name|P01
operator|->
name|x
argument_list|)
expr_stmt|;
name|P10
operator|.
name|y
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|y
operator|+
name|ratio
operator|*
name|P01
operator|->
name|y
argument_list|)
expr_stmt|;
name|P11
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|x
operator|+
name|ratio
operator|*
name|P02
operator|->
name|x
expr_stmt|;
name|P11
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|y
operator|+
name|ratio
operator|*
name|P02
operator|->
name|y
expr_stmt|;
name|P12
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|x
operator|+
name|ratio
operator|*
name|P03
operator|->
name|x
expr_stmt|;
name|P12
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|y
operator|+
name|ratio
operator|*
name|P03
operator|->
name|y
expr_stmt|;
name|P20
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|x
operator|+
name|ratio
operator|*
name|P11
operator|.
name|x
expr_stmt|;
name|P20
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|y
operator|+
name|ratio
operator|*
name|P11
operator|.
name|y
expr_stmt|;
name|P21
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|x
operator|+
name|ratio
operator|*
name|P12
operator|.
name|x
expr_stmt|;
name|P21
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|y
operator|+
name|ratio
operator|*
name|P12
operator|.
name|y
expr_stmt|;
name|P30
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|x
operator|+
name|ratio
operator|*
name|P21
operator|.
name|x
expr_stmt|;
name|P30
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|y
operator|+
name|ratio
operator|*
name|P21
operator|.
name|y
expr_stmt|;
name|P01
operator|->
name|x
operator|=
name|P10
operator|.
name|x
expr_stmt|;
name|P01
operator|->
name|y
operator|=
name|P10
operator|.
name|y
expr_stmt|;
name|P02
operator|->
name|x
operator|=
name|P12
operator|.
name|x
expr_stmt|;
name|P02
operator|->
name|y
operator|=
name|P12
operator|.
name|y
expr_stmt|;
comment|/* All the computes are done, let's insert the new point on the curve */
name|pt1
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BezierPoint
argument_list|)
argument_list|)
expr_stmt|;
name|pt1
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt2
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
name|pt3
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt1
operator|->
name|x
operator|=
name|P20
operator|.
name|x
expr_stmt|;
name|pt1
operator|->
name|y
operator|=
name|P20
operator|.
name|y
expr_stmt|;
name|pt2
operator|->
name|x
operator|=
name|P30
operator|.
name|x
expr_stmt|;
name|pt2
operator|->
name|y
operator|=
name|P30
operator|.
name|y
expr_stmt|;
name|pt3
operator|->
name|x
operator|=
name|P21
operator|.
name|x
expr_stmt|;
name|pt3
operator|->
name|y
operator|=
name|P21
operator|.
name|y
expr_stmt|;
name|P01
operator|->
name|next
operator|=
name|pt1
expr_stmt|;
name|pt1
operator|->
name|prev
operator|=
name|P01
expr_stmt|;
name|pt1
operator|->
name|next
operator|=
name|pt2
expr_stmt|;
name|pt2
operator|->
name|prev
operator|=
name|pt1
expr_stmt|;
name|pt2
operator|->
name|next
operator|=
name|pt3
expr_stmt|;
name|pt3
operator|->
name|prev
operator|=
name|pt2
expr_stmt|;
name|pt3
operator|->
name|next
operator|=
name|P02
expr_stmt|;
name|P02
operator|->
name|prev
operator|=
name|pt3
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|3
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|pt2
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|pt1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|bezier_select_mode (gint mode)
name|void
name|bezier_select_mode
parameter_list|(
name|gint
name|mode
parameter_list|)
block|{
name|ModeEdit
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The curve has to be closed to do a selection. */
end_comment

begin_function
name|void
DECL|function|bezier_to_selection (BezierSelect * bezier_sel,GDisplay * gdisp)
name|bezier_to_selection
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Call the internal function */
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|g_warning
argument_list|(
literal|"Curve not closed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* force the passed selection to be the current selection..*/
comment|/* This loads it into curSel for this image */
name|bezier_paste_bezierselect_to_current
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_to_sel_internal
argument_list|(
name|curSel
argument_list|,
name|curTool
argument_list|,
name|gdisp
argument_list|,
name|ADD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|printSel (BezierSelect * sel)
name|void
name|printSel
parameter_list|(
name|BezierSelect
modifier|*
name|sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pt
operator|=
name|sel
operator|->
name|points
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d %d %d\n"
argument_list|,
name|i
argument_list|,
name|pt
operator|->
name|x
argument_list|,
name|pt
operator|->
name|y
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"core : %p\n"
argument_list|,
name|sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"closed : %d\n"
argument_list|,
name|sel
operator|->
name|closed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"draw : %d\n"
argument_list|,
name|sel
operator|->
name|draw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"state: %d\n"
argument_list|,
name|sel
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|stroke_points
specifier|static
name|gdouble
modifier|*
name|stroke_points
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_stroke_points
specifier|static
name|gint
name|num_stroke_points
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|num_stroke_points
comment|/* num of valid points */
end_comment

begin_decl_stmt
DECL|variable|len_stroke_points
specifier|static
name|gint
name|len_stroke_points
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|len_stroke_points
comment|/* allocated length */
end_comment

begin_comment
comment|/* check whether vectors (offx, offy), (l_offx, l_offy) have the same angle. */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|stroke_interpolatable (int offx,int offy,int l_offx,int l_offy,gdouble error)
name|stroke_interpolatable
parameter_list|(
name|int
name|offx
parameter_list|,
name|int
name|offy
parameter_list|,
name|int
name|l_offx
parameter_list|,
name|int
name|l_offy
parameter_list|,
name|gdouble
name|error
parameter_list|)
block|{
if|if
condition|(
operator|(
name|offx
operator|==
name|l_offx
operator|)
operator|&
operator|(
name|offy
operator|==
name|l_offy
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|offx
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offx
operator|==
literal|0
operator|)
condition|)
if|if
condition|(
name|offx
operator|==
name|l_offx
condition|)
return|return
operator|(
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|&
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|)
operator||
operator|(
operator|(
name|offy
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offy
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
operator|(
name|offy
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offy
operator|==
literal|0
operator|)
condition|)
if|if
condition|(
name|offy
operator|==
name|l_offy
condition|)
return|return
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
comment|/* At this point, we can assert: offx, offy, l_offx, l_offy != 0 */
elseif|else
if|if
condition|(
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|gdouble
name|grad1
decl_stmt|,
name|grad2
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|offy
argument_list|)
operator|<
name|ABS
argument_list|(
name|offx
argument_list|)
condition|)
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offy
operator|/
operator|(
name|gdouble
operator|)
name|offx
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offy
operator|/
operator|(
name|gdouble
operator|)
name|l_offx
expr_stmt|;
block|}
else|else
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offx
operator|/
operator|(
name|gdouble
operator|)
name|offy
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offx
operator|/
operator|(
name|gdouble
operator|)
name|l_offy
expr_stmt|;
block|}
comment|/* printf ("error: %f / %f\n", ABS (grad1 - grad2), error); */
return|return
operator|(
name|ABS
argument_list|(
name|grad1
operator|-
name|grad2
argument_list|)
operator|<=
name|error
operator|)
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points_aux (GdkPoint * points,int start,int end,gdouble error)
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|gdouble
name|error
parameter_list|)
block|{
specifier|const
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|med
decl_stmt|;
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|,
name|l_offx
decl_stmt|,
name|l_offy
decl_stmt|;
if|if
condition|(
name|stroke_points
operator|==
name|NULL
condition|)
return|return;
comment|/* BASE CASE: stack the end point */
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|stroke_points
index|[
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|stroke_points
index|[
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|y
operator|)
condition|)
return|return;
name|num_stroke_points
operator|++
expr_stmt|;
if|if
condition|(
name|len_stroke_points
operator|<=
name|num_stroke_points
condition|)
block|{
name|len_stroke_points
operator|+=
name|expand_size
expr_stmt|;
name|stroke_points
operator|=
name|g_renew
argument_list|(
name|double
argument_list|,
name|stroke_points
argument_list|,
literal|2
operator|*
name|len_stroke_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroke_points
operator|==
name|NULL
condition|)
block|{
name|len_stroke_points
operator|=
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|stroke_points
index|[
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
expr_stmt|;
name|stroke_points
index|[
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|32
condition|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, check whether to divide the segment recursively */
name|offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
name|med
operator|=
operator|(
name|end
operator|+
name|start
operator|)
operator|/
literal|2
expr_stmt|;
name|l_offx
operator|=
name|points
index|[
name|med
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|med
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|l_offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|med
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|med
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, the curve can be represented by a points pair: (start, end).      So, add the last point to stroke_points. */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|end
argument_list|,
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints)
name|bezier_stack_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|gdouble
name|error
decl_stmt|;
if|if
condition|(
name|npoints
operator|<
literal|2
condition|)
comment|/* Does this happen? */
return|return;
if|if
condition|(
name|stroke_points
operator|==
name|NULL
condition|)
comment|/*  initialize it here */
block|{
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
name|len_stroke_points
operator|=
name|expand_size
expr_stmt|;
name|stroke_points
operator|=
name|g_new
argument_list|(
name|double
argument_list|,
literal|2
operator|*
name|len_stroke_points
argument_list|)
expr_stmt|;
block|}
name|maxx
operator|=
name|minx
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|maxy
operator|=
name|miny
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxx
operator|<
name|points
index|[
name|i
index|]
operator|.
name|x
condition|)
name|maxx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxy
operator|<
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
name|maxy
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* allow one pixel fluctuation */
name|error
operator|=
literal|2.0
operator|/
name|MAX
argument_list|(
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
expr_stmt|;
comment|/* add the start point */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* divide segments recursively */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|npoints
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* printf ("npoints: %d\n", npoints); */
block|}
end_function

begin_function
name|void
DECL|function|bezier_stroke (BezierSelect * bezier_sel,GDisplay * gdisp,int subdivisions,int open_path)
name|bezier_stroke
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|open_path
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|Argument
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|int
name|redraw
init|=
name|FALSE
decl_stmt|;
comment|/* stack points */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
operator|&&
operator|(
operator|!
name|open_path
operator|)
condition|)
block|{
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|bezier_stack_points
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|redraw
operator|=
name|TRUE
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|num_points
operator|>=
literal|4
condition|)
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|bezier_stack_points
argument_list|)
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stroke_points
condition|)
block|{
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset_x
operator|!=
literal|0
operator|)
operator|||
operator|(
name|offset_y
operator|!=
literal|0
operator|)
condition|)
block|{
name|gdouble
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|stroke_points
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|stroke_points
operator|+
operator|(
name|num_stroke_points
operator|*
literal|2
operator|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|-=
name|offset_x
expr_stmt|;
operator|*
name|ptr
operator|++
operator|-=
name|offset_y
expr_stmt|;
block|}
block|}
name|return_vals
operator|=
name|procedural_db_run_proc
argument_list|(
literal|"gimp_paintbrush"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PDB_DRAWABLE
argument_list|,
name|drawable_ID
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
literal|0
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|num_stroke_points
operator|*
literal|2
argument_list|,
name|PDB_FLOATARRAY
argument_list|,
name|stroke_points
argument_list|,
name|PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|==
name|PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|redraw
condition|)
block|{
comment|/* FIXME: how to update the image? */
block|}
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Paintbrush operation failed."
argument_list|)
argument_list|)
expr_stmt|;
name|procedural_db_destroy_args
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|stroke_points
argument_list|)
expr_stmt|;
block|}
comment|/* printf ("num_stroke_points: %d\ndone.\n", num_stroke_points); */
name|stroke_points
operator|=
name|NULL
expr_stmt|;
name|len_stroke_points
operator|=
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

