begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"actionarea.h"
end_include

begin_include
include|#
directive|include
file|"bezier_select.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"paths_dialog.h"
end_include

begin_include
include|#
directive|include
file|"selection_options.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_comment
comment|/* Bezier extensions made by Raphael FRANCOIS (fraph@ibm.net)    BEZIER_EXTENDS VER 1.0     - work as the cut/copy/paste named functions.   - allow to add/remove/replace bezier curves   - allow to modify the control/anchor points even if the selection is made   - allow to add/remove control/anchor points on a curve   - allow to update a previous saved curve    - cannot operate on open or multiple curves simultaneously */
end_comment

begin_define
DECL|macro|BEZIER_DRAW_CURVE
define|#
directive|define
name|BEZIER_DRAW_CURVE
value|1
end_define

begin_define
DECL|macro|BEZIER_DRAW_CURRENT
define|#
directive|define
name|BEZIER_DRAW_CURRENT
value|2
end_define

begin_define
DECL|macro|BEZIER_DRAW_HANDLES
define|#
directive|define
name|BEZIER_DRAW_HANDLES
value|4
end_define

begin_define
DECL|macro|BEZIER_DRAW_ALL
define|#
directive|define
name|BEZIER_DRAW_ALL
value|(BEZIER_DRAW_CURVE | BEZIER_DRAW_HANDLES)
end_define

begin_define
DECL|macro|BEZIER_WIDTH
define|#
directive|define
name|BEZIER_WIDTH
value|8
end_define

begin_define
DECL|macro|BEZIER_HALFWIDTH
define|#
directive|define
name|BEZIER_HALFWIDTH
value|4
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE2
define|#
directive|define
name|SUPERSAMPLE2
value|9
end_define

begin_define
DECL|macro|NO
define|#
directive|define
name|NO
value|0
end_define

begin_define
DECL|macro|YES
define|#
directive|define
name|YES
value|1
end_define

begin_define
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
end_define

begin_comment
comment|/*  the bezier select structures  */
end_comment

begin_typedef
DECL|typedef|BezierMatrix
typedef|typedef
name|double
name|BezierMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_comment
comment|/*  The named paste dialog  */
end_comment

begin_typedef
DECL|typedef|PasteNamedDlg
typedef|typedef
name|struct
name|_PasteNamedDlg
name|PasteNamedDlg
typedef|;
end_typedef

begin_struct
DECL|struct|_PasteNamedDlg
struct|struct
name|_PasteNamedDlg
block|{
DECL|member|shell
name|GtkWidget
modifier|*
name|shell
decl_stmt|;
DECL|member|list
name|GtkWidget
modifier|*
name|list
decl_stmt|;
DECL|member|gdisp
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  The named buffer structure...  */
end_comment

begin_typedef
DECL|typedef|BezierNamedBuffer
typedef|typedef
name|struct
name|_named_buffer
name|BezierNamedBuffer
typedef|;
end_typedef

begin_struct
DECL|struct|_named_buffer
struct|struct
name|_named_buffer
block|{
DECL|member|sel
name|BezierSelect
modifier|*
name|sel
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
DECL|struct|__anon277116600108
typedef|typedef
struct|struct
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|stroke_points
name|gdouble
modifier|*
name|stroke_points
decl_stmt|;
DECL|member|num_stroke_points
name|gint
name|num_stroke_points
decl_stmt|;
comment|/* num of valid points */
DECL|member|len_stroke_points
name|gint
name|len_stroke_points
decl_stmt|;
comment|/* allocated length */
DECL|member|next_curve
name|void
modifier|*
name|next_curve
decl_stmt|;
comment|/* Next curve in list -- we draw all curves  				 * separately. 				 */
DECL|typedef|BezierRenderPnts
block|}
name|BezierRenderPnts
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon277116600208
typedef|typedef
struct|struct
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|firstpnt
name|gboolean
name|firstpnt
decl_stmt|;
DECL|member|curdist
name|gdouble
name|curdist
decl_stmt|;
DECL|member|dist
name|gdouble
name|dist
decl_stmt|;
DECL|member|gradient
name|gdouble
modifier|*
name|gradient
decl_stmt|;
DECL|member|x
name|gint
modifier|*
name|x
decl_stmt|;
DECL|member|y
name|gint
modifier|*
name|y
decl_stmt|;
DECL|member|lastx
name|gdouble
name|lastx
decl_stmt|;
DECL|member|lasty
name|gdouble
name|lasty
decl_stmt|;
DECL|member|found
name|gboolean
name|found
decl_stmt|;
DECL|typedef|BezierDistance
block|}
name|BezierDistance
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon277116600308
typedef|typedef
struct|struct
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|x
name|gint
name|x
decl_stmt|;
DECL|member|y
name|gint
name|y
decl_stmt|;
DECL|member|halfwidth
name|gint
name|halfwidth
decl_stmt|;
DECL|member|found
name|gint
name|found
decl_stmt|;
DECL|typedef|BezierCheckPnts
block|}
name|BezierCheckPnts
typedef|;
end_typedef

begin_comment
comment|/*  the bezier selection tool options  */
end_comment

begin_decl_stmt
DECL|variable|bezier_options
specifier|static
name|SelectionOptions
modifier|*
name|bezier_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  local variables  */
end_comment

begin_decl_stmt
DECL|variable|basis
specifier|static
name|BezierMatrix
name|basis
init|=
block|{
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
operator|-
literal|6
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static BezierMatrix basis = {   { -1/6.0,  3/6.0, -3/6.0,  1/6.0 },   {  3/6.0, -6/6.0,  3/6.0,  0 },   { -3/6.0,  0,  3/6.0,  0 },   {  1/6.0,  4/6.0,  1,  0 }, }; */
end_comment

begin_comment
comment|/*  The named buffer list  */
end_comment

begin_decl_stmt
DECL|variable|bezier_named_buffers
name|GSList
modifier|*
name|bezier_named_buffers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Global Static Variable to maintain informations about the "contexte"  */
end_comment

begin_decl_stmt
DECL|variable|curSel
specifier|static
name|BezierSelect
modifier|*
name|curSel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curTool
specifier|static
name|Tool
modifier|*
name|curTool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curGdisp
specifier|static
name|GDisplay
modifier|*
name|curGdisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curCore
specifier|static
name|DrawCore
modifier|*
name|curCore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ModeEdit
specifier|static
name|int
name|ModeEdit
init|=
name|EXTEND_NEW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_cursor_update
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|BezierPointsFunc
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_compose
parameter_list|(
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|,
name|BezierMatrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|test_add_point_on_segment
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|BezierPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_to_sel_internal
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|Tool
modifier|*
parameter_list|,
name|GDisplay
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points
parameter_list|(
name|BezierSelect
modifier|*
parameter_list|,
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|stroke_interpolatable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gdouble
parameter_list|,
name|BezierRenderPnts
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|count_points_on_curve
parameter_list|(
name|BezierPoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|bezier_select_options_reset ()
name|bezier_select_options_reset
parameter_list|()
block|{
name|selection_options_reset
argument_list|(
name|bezier_options
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_bezier_select ()
name|tools_new_bezier_select
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
comment|/*  The tool options  */
if|if
condition|(
operator|!
name|bezier_options
condition|)
block|{
name|bezier_options
operator|=
name|selection_options_new
argument_list|(
name|BEZIER_SELECT
argument_list|,
name|bezier_select_options_reset
argument_list|)
expr_stmt|;
name|tools_register
argument_list|(
name|BEZIER_SELECT
argument_list|,
operator|(
name|ToolOptions
operator|*
operator|)
name|bezier_options
argument_list|)
expr_stmt|;
block|}
name|tool
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tool
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|=
name|g_new0
argument_list|(
name|BezierSelect
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|bezier_select_draw
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|tool
operator|->
name|type
operator|=
name|BEZIER_SELECT
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|tool
operator|->
name|scroll_lock
operator|=
literal|1
expr_stmt|;
comment|/*  Do not allow scrolling  */
name|tool
operator|->
name|auto_snap_to
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|bezier_sel
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|bezier_select_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|bezier_select_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|bezier_select_motion
expr_stmt|;
name|tool
operator|->
name|arrow_keys_func
operator|=
name|standard_arrow_keys_func
expr_stmt|;
name|tool
operator|->
name|modifier_key_func
operator|=
name|standard_modifier_key_func
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|bezier_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|bezier_select_control
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|FALSE
expr_stmt|;
name|curCore
operator|=
name|bezier_sel
operator|->
name|core
expr_stmt|;
name|curSel
operator|=
name|bezier_sel
expr_stmt|;
name|curTool
operator|=
name|tool
expr_stmt|;
name|paths_new_bezier_select_tool
argument_list|()
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_bezier_select (Tool * tool)
name|tools_free_bezier_select
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|bezier_select_load (void * gdisp_ptr,BezierPoint * pts,int num_pts,int closed)
name|bezier_select_load
parameter_list|(
name|void
modifier|*
name|gdisp_ptr
parameter_list|,
name|BezierPoint
modifier|*
name|pts
parameter_list|,
name|int
name|num_pts
parameter_list|,
name|int
name|closed
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
comment|/*  select the bezier tool  */
name|gtk_widget_activate
argument_list|(
name|tool_info
index|[
name|BEZIER_SELECT
index|]
operator|.
name|tool_widget
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
operator|(
name|BezierSelect
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|pts
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|pts
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
name|num_pts
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|BezierPoint
modifier|*
DECL|function|valid_curve_segment (BezierPoint * points)
name|valid_curve_segment
parameter_list|(
name|BezierPoint
modifier|*
name|points
parameter_list|)
block|{
comment|/* Valid curve segment is made up of four points */
if|if
condition|(
name|points
operator|&&
name|points
operator|->
name|next
operator|&&
name|points
operator|->
name|next
operator|->
name|next
operator|&&
name|points
operator|->
name|next
operator|->
name|next
operator|->
name|next
condition|)
return|return
operator|(
name|points
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|BezierPoint
modifier|*
DECL|function|next_anchor (BezierPoint * points,BezierPoint ** next_curve)
name|next_anchor
parameter_list|(
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|BezierPoint
modifier|*
modifier|*
name|next_curve
parameter_list|)
block|{
name|int
name|loop
decl_stmt|;
operator|*
name|next_curve
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|3
condition|;
name|loop
operator|++
control|)
block|{
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
block|{
operator|*
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
block|}
block|}
return|return
name|valid_curve_segment
argument_list|(
name|points
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_draw_curve (BezierSelect * bezier_sel,BezierPointsFunc func,gint coord,gpointer udata)
name|bezier_draw_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPointsFunc
name|func
parameter_list|,
name|gint
name|coord
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|CountCurves
modifier|*
name|cnt
init|=
operator|(
name|CountCurves
operator|*
operator|)
name|udata
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
comment|/*   printSel(bezier_sel); */
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_counts
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|coord
argument_list|,
name|func
argument_list|,
name|udata
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
comment|/* 	  printf("next_anchor = %p\n",points); */
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|++
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
else|else
break|break;
comment|/* must be last curve since only this one is allowed< 4 		  * points. 		  */
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|bezier_select_reset (BezierSelect * bezier_sel)
name|bezier_select_reset
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|temp_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
do|do
block|{
name|temp_pt
operator|=
name|points
expr_stmt|;
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|next_curve
condition|)
block|{
name|g_warning
argument_list|(
literal|"Curve points out of sync"
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|temp_pt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|points
operator|=
name|next_curve
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
comment|/* we are starting the curve */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* draw everything by default */
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* the curve is initally open */
name|bezier_sel
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/* initially there are no points */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
comment|/* intially there are no points */
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/* empty mask */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the curve that points to this curve. This makes to_check point  * the start of a curve.   */
end_comment

begin_function
specifier|static
name|BezierPoint
modifier|*
DECL|function|check_for_next_curve (BezierSelect * bezier_sel,BezierPoint * to_check)
name|check_for_next_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|to_check
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
operator|==
name|to_check
condition|)
return|return
operator|(
name|points
operator|)
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|count_points_on_curve (BezierPoint * points)
name|count_points_on_curve
parameter_list|(
name|BezierPoint
modifier|*
name|points
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|start
init|=
name|points
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|points
operator|->
name|next
operator|!=
name|start
condition|)
block|{
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the start of the last open curve, if curve already closed  * this is an error..  */
end_comment

begin_function
specifier|static
name|BezierPoint
modifier|*
DECL|function|find_start_open_curve (BezierSelect * bsel)
name|find_start_open_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bsel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|start_pnt
init|=
name|NULL
decl_stmt|;
name|BezierPoint
modifier|*
name|this_pnt
init|=
name|bsel
operator|->
name|last_point
decl_stmt|;
comment|/* Could be one of the first points */
if|if
condition|(
operator|!
name|bsel
operator|->
name|last_point
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bsel
operator|->
name|closed
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Bezier path already closed."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Step backwards until the prev point is null.    * in this case this is the start of the open curve.    * The start_pnt stuff is to stop us going around forever.    * If we even have a closed curve then we are in seroius     * trouble.    */
while|while
condition|(
name|this_pnt
operator|->
name|prev
operator|&&
name|start_pnt
operator|!=
name|this_pnt
condition|)
block|{
if|if
condition|(
operator|!
name|start_pnt
condition|)
name|start_pnt
operator|=
name|this_pnt
expr_stmt|;
name|this_pnt
operator|=
name|this_pnt
operator|->
name|prev
expr_stmt|;
block|}
comment|/* Must be an anchor to be the start */
if|if
condition|(
name|start_pnt
operator|==
name|this_pnt
operator|||
name|this_pnt
operator|->
name|type
operator|!=
name|BEZIER_ANCHOR
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Corrupt curve"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*   printf("Returned start pnt of curve %p is %p\n",bsel->last_point,this_pnt); */
return|return
operator|(
name|this_pnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete a whole curve. Watch out for special cases.  * start_pnt must always be the start point if the curve to delete.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|delete_whole_curve (BezierSelect * bezier_sel,BezierPoint * start_pnt)
name|delete_whole_curve
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|start_pnt
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|tmppnt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
init|=
name|NULL
decl_stmt|;
comment|/* Next curve this one  				      * points at (if any)  				      */
name|BezierPoint
modifier|*
name|prev_curve
decl_stmt|;
comment|/* Does a curve point to this one? */
name|gint
name|cnt_pnts
init|=
literal|0
decl_stmt|;
comment|/* Count how many pnts deleted */
name|gint
name|reset_last
init|=
name|FALSE
decl_stmt|;
comment|/* shift and del means delete whole curve */
comment|/* Three cases, this is first curve, middle curve     * or end curve.    */
comment|/* Does this curve have another chained on the end?     * or is this curve pointed to another one?    */
comment|/*   printf("delete_whole_curve::\n"); */
name|tmppnt
operator|=
name|start_pnt
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tmppnt
operator|->
name|next_curve
condition|)
block|{
name|next_curve
operator|=
name|tmppnt
operator|->
name|next_curve
expr_stmt|;
break|break;
block|}
name|tmppnt
operator|=
name|tmppnt
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tmppnt
operator|!=
name|start_pnt
operator|&&
name|tmppnt
condition|)
do|;
name|prev_curve
operator|=
name|check_for_next_curve
argument_list|(
name|bezier_sel
argument_list|,
name|start_pnt
argument_list|)
expr_stmt|;
comment|/* First curve ?*/
if|if
condition|(
name|bezier_sel
operator|->
name|points
operator|==
name|start_pnt
condition|)
name|bezier_sel
operator|->
name|points
operator|=
name|next_curve
expr_stmt|;
else|else
block|{
comment|/* better have a previous curve else how did we get here? */
name|prev_curve
operator|->
name|next_curve
operator|=
name|next_curve
expr_stmt|;
block|}
comment|/* start_pnt points to the curve we should free .. ignoring the next_curve */
name|tmppnt
operator|=
name|start_pnt
expr_stmt|;
do|do
block|{
name|BezierPoint
modifier|*
name|fpnt
decl_stmt|;
name|fpnt
operator|=
name|tmppnt
expr_stmt|;
name|tmppnt
operator|=
name|tmppnt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|fpnt
operator|==
name|bezier_sel
operator|->
name|last_point
condition|)
name|reset_last
operator|=
name|TRUE
expr_stmt|;
name|g_free
argument_list|(
name|fpnt
argument_list|)
expr_stmt|;
name|cnt_pnts
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|tmppnt
operator|!=
name|start_pnt
operator|&&
name|tmppnt
condition|)
do|;
name|bezier_sel
operator|->
name|num_points
operator|-=
name|cnt_pnts
expr_stmt|;
comment|/* if deleted curve was unclosed then must have been the last curve     * and thus this curve becomes closed.    */
if|if
condition|(
operator|!
name|tmppnt
operator|&&
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<=
literal|0
condition|)
block|{
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
comment|/* The last point could have been on this curve as well... */
if|if
condition|(
name|reset_last
condition|)
block|{
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|l_pnt
init|=
name|NULL
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|l_pnt
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|last_point
operator|=
name|l_pnt
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_edit_point_on_curve (int x,int y,int halfwidth,GDisplay * gdisp,BezierSelect * bezier_sel,Tool * tool,GdkEventButton * bevent)
name|bezier_edit_point_on_curve
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|)
block|{
name|gint
name|grab_pointer
init|=
literal|0
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
comment|/* find if the button press occurred on a point */
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|BezierPoint
modifier|*
name|finded
init|=
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_op
decl_stmt|;
name|BezierPoint
modifier|*
name|end_op
decl_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
name|delete_whole_curve
argument_list|(
name|bezier_sel
argument_list|,
name|start_pt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|point_counts
operator|<=
literal|7
condition|)
block|{
comment|/* If we've got less then 7 points ie: 2 anchors points 4 controls  		     Then the curve is minimal closed curve. 		     I've decided to not operate on this kind of curve because it     		     implies opening the curve and change some drawing states         		     Removing 1 point of curve that contains 2 point is something     		     similare to reconstruct the curve !!! 		  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|finded
operator|->
name|prev
operator|||
operator|!
name|finded
operator|->
name|prev
operator|->
name|prev
condition|)
block|{
comment|/* This is the first point on the curve */
comment|/* FIXME printf("Del first point\n"); */
block|}
elseif|else
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
operator|&&
operator|(
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|->
name|prev
operator|)
condition|)
block|{
comment|/* This is the last point on the curve */
comment|/* FIXME printf("Del last point\n"); */
block|}
else|else
block|{
if|if
condition|(
name|finded
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
block|{
if|if
condition|(
name|finded
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
name|finded
operator|=
name|finded
operator|->
name|prev
expr_stmt|;
else|else
name|finded
operator|=
name|finded
operator|->
name|next
expr_stmt|;
block|}
name|start_op
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
name|end_op
operator|=
name|finded
operator|->
name|next
operator|->
name|next
expr_stmt|;
comment|/* we can use next_curve here since we are going to  		   * drop out the bottom anyways. 		   */
name|next_curve
operator|=
name|check_for_next_curve
argument_list|(
name|bezier_sel
argument_list|,
name|finded
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_curve
condition|)
block|{
comment|/* Deleteing first point of next curve*/
name|next_curve
operator|->
name|next_curve
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
else|else
comment|/* Can't be both first and a next curve!*/
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|points
operator|==
name|finded
condition|)
block|{
comment|/* 			  printf("Deleting first point %p\n",finded); */
name|bezier_sel
operator|->
name|points
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
block|}
comment|/* Make sure the chain of curves is preserved */
if|if
condition|(
name|finded
operator|->
name|prev
operator|->
name|next_curve
condition|)
block|{
comment|/* 		      printf("Moving curve on next_curve %p\n",finded->prev->next_curve); */
comment|/* last point on closed multi-path */
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
operator|->
name|next_curve
operator|=
name|finded
operator|->
name|prev
operator|->
name|next_curve
expr_stmt|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
operator|==
name|finded
operator|->
name|prev
condition|)
block|{
comment|/* 		      printf("Deleting last point %p\n",finded->prev); */
name|bezier_sel
operator|->
name|last_point
operator|=
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
name|start_op
operator|->
name|next
operator|=
name|end_op
expr_stmt|;
name|end_op
operator|->
name|prev
operator|=
name|start_op
expr_stmt|;
comment|/* 		  if ( (bezier_sel->last_point == finded) ||  */
comment|/* 		       (bezier_sel->last_point == finded->next) ||  */
comment|/* 		       (bezier_sel->last_point  == finded->prev)) */
comment|/* 		    { */
comment|/* 		      bezier_sel->last_point = start_op->prev->prev; */
comment|/* 		      bezier_sel->points = start_op->prev; */
comment|/* 		    } */
name|bezier_sel
operator|->
name|num_points
operator|-=
literal|3
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|prev
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
argument_list|)
expr_stmt|;
comment|/* Clear current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* set the current anchor and control points */
switch|switch
condition|(
name|points
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
return|return
name|grab_pointer
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_add_point_on_segment (int x,int y,int halfwidth,GDisplay * gdisp,BezierSelect * bezier_sel,Tool * tool)
name|bezier_add_point_on_segment
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
do|do
block|{
do|do
block|{
if|if
condition|(
name|test_add_point_on_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_start_new_segment (BezierSelect * bezier_sel,gint x,gint y)
name|bezier_start_new_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
comment|/* Must be closed to do this! */
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
return|return;
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* End is no longer closed !*/
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_MOVE
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_press (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_press
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|curve_start
decl_stmt|;
name|int
name|grab_pointer
decl_stmt|;
name|int
name|op
decl_stmt|,
name|replace
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|grab_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|extend
condition|)
block|{
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp_ptr
operator|!=
name|tool
operator|->
name|gdisp_ptr
condition|)
block|{
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|curTool
operator|=
name|active_tool
expr_stmt|;
name|curSel
operator|=
name|curTool
operator|->
name|private
expr_stmt|;
name|curGdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|active_tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
name|curCore
operator|=
name|bezier_sel
operator|->
name|core
expr_stmt|;
switch|switch
condition|(
name|bezier_sel
operator|->
name|state
condition|)
block|{
case|case
name|BEZIER_START
case|:
if|if
condition|(
name|ModeEdit
operator|!=
name|EXTEND_NEW
condition|)
break|break;
name|grab_pointer
operator|=
literal|1
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
comment|/*       if (bevent->state& GDK_MOD1_MASK) */
comment|/* 	{ */
comment|/* 	  init_edit_selection (tool, gdisp_ptr, bevent, MaskTranslate); */
comment|/* 	  break; */
comment|/* 	} */
comment|/*       else if (!(bevent->state& GDK_SHIFT_MASK)&& !(bevent->state& GDK_CONTROL_MASK)) */
comment|/* 	if (! (layer_is_floating_sel (gimage_get_active_layer (gdisp->gimage)))&& */
comment|/* 	    gdisplay_mask_value (gdisp, bevent->x, bevent->y)> HALF_WAY) */
comment|/* 	  { */
comment|/* 	    init_edit_selection (tool, gdisp_ptr, bevent, MaskToLayerTranslate); */
comment|/* 	    break; */
comment|/* 	  } */
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER_ADD
case|:
name|grab_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_EDIT
condition|)
block|{
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
comment|/* 	  if(bezier_sel->num_points< 6) */
comment|/* 	    return; */
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<
literal|5
condition|)
return|return;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
name|curve_start
operator|=
name|find_start_open_curve
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|curve_start
operator|&&
name|bezier_check_point
argument_list|(
name|curve_start
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|curve_start
expr_stmt|;
name|curve_start
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|curve_start
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|curve_start
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|pointflags
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_EDIT
case|:
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"tried to edit on open bezier curve in edit selection"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grab_pointer
operator|&&
name|channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|ADD
expr_stmt|;
name|replace
operator|=
literal|1
expr_stmt|;
block|}
name|bezier_to_sel_internal
argument_list|(
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|gdisp
argument_list|,
name|op
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* draw the handles */
if|if
condition|(
operator|!
name|grab_pointer
condition|)
name|bezier_start_new_segment
argument_list|(
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
comment|/* Don't bother doing this if we don't have any points */
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
name|paths_first_button_press
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|bezier_select_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|&=
operator|~
operator|(
name|BEZIER_DRAG
operator|)
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
comment|/* Here ?*/
name|paths_newpoint_current
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bez_copy_points (BezierSelect * tobez,BezierSelect * frombez)
name|bez_copy_points
parameter_list|(
name|BezierSelect
modifier|*
name|tobez
parameter_list|,
name|BezierSelect
modifier|*
name|frombez
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|pts
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|BezierPoint
modifier|*
name|bpnt
init|=
name|NULL
decl_stmt|;
name|int
name|need_move
init|=
literal|0
decl_stmt|;
name|pts
operator|=
operator|(
name|BezierPoint
operator|*
operator|)
name|frombez
operator|->
name|points
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frombez
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_move
condition|)
block|{
name|bezier_add_point
argument_list|(
name|tobez
argument_list|,
name|BEZIER_MOVE
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
name|need_move
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bezier_add_point
argument_list|(
name|tobez
argument_list|,
name|pts
operator|->
name|type
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|pts
operator|==
name|frombez
operator|->
name|cur_anchor
condition|)
name|tobez
operator|->
name|cur_anchor
operator|=
name|tobez
operator|->
name|last_point
expr_stmt|;
elseif|else
if|if
condition|(
name|pts
operator|==
name|frombez
operator|->
name|cur_control
condition|)
name|tobez
operator|->
name|cur_control
operator|=
name|tobez
operator|->
name|last_point
expr_stmt|;
if|if
condition|(
name|bpnt
operator|==
name|NULL
condition|)
name|bpnt
operator|=
name|tobez
operator|->
name|last_point
expr_stmt|;
if|if
condition|(
name|pts
operator|->
name|next_curve
condition|)
block|{
comment|/* 	  printf("bezier_paste_bezierselect_to_current:: Close last curve off \n"); */
name|tobez
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|tobez
operator|->
name|last_point
expr_stmt|;
name|bpnt
operator|=
name|NULL
expr_stmt|;
name|need_move
operator|=
literal|1
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next_curve
expr_stmt|;
block|}
else|else
block|{
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frombez
operator|->
name|closed
condition|)
block|{
name|tobez
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|tobez
operator|->
name|last_point
expr_stmt|;
name|tobez
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|bezier_select_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
specifier|static
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|BezierPoint
modifier|*
name|anchor
decl_stmt|;
name|BezierPoint
modifier|*
name|opposite_control
decl_stmt|;
name|int
name|offsetx
decl_stmt|;
name|int
name|offsety
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
return|return;
name|gdisp
operator|=
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|cur_anchor
operator|||
operator|!
name|bezier_sel
operator|->
name|cur_control
condition|)
return|return;
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
block|}
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the first point then change the state and "remember" the point.    */
if|if
condition|(
operator|!
operator|(
name|bezier_sel
operator|->
name|state
operator|&
name|BEZIER_DRAG
operator|)
condition|)
block|{
name|bezier_sel
operator|->
name|state
operator||=
name|BEZIER_DRAG
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
comment|/* The Alt key is down... Move all the points of the bezier curve */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|BezierPoint
modifier|*
name|tmp
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
comment|/* Only move this curve */
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|cur_anchor
decl_stmt|;
comment|/* 	  printf("moving only one curve\n"); */
name|tmp
operator|=
name|start_pt
expr_stmt|;
do|do
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|!=
name|start_pt
operator|&&
name|tmp
condition|)
do|;
comment|/* Check if need to go backwards because curve is open */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
condition|)
block|{
name|BezierPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
decl_stmt|;
name|tmp
operator|=
name|start_pt
expr_stmt|;
do|do
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|prev
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|!=
name|start_pt
operator|&&
name|tmp
condition|)
do|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tmp
operator|&&
name|num_points
condition|)
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|next_curve
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|next_curve
expr_stmt|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
condition|)
block|{
comment|/* the control key is down ... move the current anchor point */
comment|/* we must also move the neighboring control points appropriately */
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the control key is not down ... we move the current control point */
name|offsetx
operator|=
name|x
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_control
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
comment|/* if the shift key is not down then we align the opposite control */
comment|/* point...ie the opposite control point acts like a mirror of the */
comment|/* current control point */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|anchor
operator|=
name|NULL
expr_stmt|;
name|opposite_control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"Encountered orphaned bezier control point"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opposite_control
condition|)
block|{
name|offsetx
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
operator|-
name|anchor
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
operator|-
name|anchor
operator|->
name|y
expr_stmt|;
name|opposite_control
operator|->
name|x
operator|=
name|anchor
operator|->
name|x
operator|-
name|offsetx
expr_stmt|;
name|opposite_control
operator|->
name|y
operator|=
name|anchor
operator|->
name|y
operator|-
name|offsety
expr_stmt|;
block|}
block|}
block|}
comment|/* As we're moving all the control points of the curve,      we have to redraw all !!!      */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 0 if not on control point, else BEZIER_ANCHOR or BEZIER_CONTROL */
end_comment

begin_function
specifier|static
name|gint
DECL|function|bezier_on_control_point (GDisplay * gdisp,BezierSelect * bezier_sel,gint x,gint y,gint halfwidth)
name|bezier_on_control_point
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|num_points
decl_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
return|return
name|points
operator|->
name|type
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_check_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints,gpointer udata)
name|bezier_check_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
name|gint
name|loop
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
name|BezierCheckPnts
modifier|*
name|chkpnts
init|=
name|udata
decl_stmt|;
name|gint
name|halfwidth
init|=
name|chkpnts
operator|->
name|halfwidth
decl_stmt|;
comment|/* Quick exit if already found */
if|if
condition|(
name|chkpnts
operator|->
name|found
condition|)
return|return;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|npoints
condition|;
name|loop
operator|++
control|)
block|{
name|l
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|y
operator|+
name|halfwidth
expr_stmt|;
comment|/*       printf("x,y = [%d,%d] halfwidth %d l,r,t,d [%d,%d,%d,%d]\n", */
comment|/* 	     points[loop].x, */
comment|/* 	     points[loop].y, */
comment|/* 	     halfwidth, */
comment|/* 	     l,r,t,b); */
if|if
condition|(
operator|(
name|chkpnts
operator|->
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|y
operator|<=
name|b
operator|)
condition|)
block|{
name|chkpnts
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|points_in_box (BezierPoint * points,gint x,gint y)
name|points_in_box
parameter_list|(
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
comment|/* below code adapted from Wm. Randolph Franklin<wrf@ecse.rpi.edu>    */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|double
name|yp
index|[
literal|4
index|]
decl_stmt|,
name|xp
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|xp
index|[
name|i
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|yp
index|[
name|i
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* Check if straight line ..below don't work if it is! */
if|if
condition|(
operator|(
name|xp
index|[
literal|0
index|]
operator|==
name|xp
index|[
literal|1
index|]
operator|&&
name|yp
index|[
literal|0
index|]
operator|==
name|yp
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|xp
index|[
literal|2
index|]
operator|==
name|xp
index|[
literal|3
index|]
operator|&&
name|yp
index|[
literal|0
index|]
operator|==
name|yp
index|[
literal|1
index|]
operator|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|3
init|;
name|i
operator|<
literal|4
condition|;
name|j
operator|=
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|yp
index|[
name|i
index|]
operator|<=
name|y
operator|)
operator|&&
operator|(
name|y
operator|<
name|yp
index|[
name|j
index|]
operator|)
operator|)
operator|||
operator|(
operator|(
name|yp
index|[
name|j
index|]
operator|<=
name|y
operator|)
operator|&&
operator|(
name|y
operator|<
name|yp
index|[
name|i
index|]
operator|)
operator|)
operator|)
operator|&&
operator|(
name|x
operator|<
operator|(
name|xp
index|[
name|j
index|]
operator|-
name|xp
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|y
operator|-
name|yp
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|yp
index|[
name|j
index|]
operator|-
name|yp
index|[
name|i
index|]
operator|)
operator|+
name|xp
index|[
name|i
index|]
operator|)
condition|)
name|c
operator|=
operator|!
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bezier_point_on_curve (GDisplay * gdisp,BezierSelect * bezier_sel,gint x,gint y,gint halfwidth)
name|bezier_point_on_curve
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|BezierCheckPnts
name|chkpnts
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|CountCurves
modifier|*
name|cnt
init|=
operator|(
name|CountCurves
operator|*
operator|)
operator|&
name|chkpnts
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
name|chkpnts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|chkpnts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|chkpnts
operator|.
name|halfwidth
operator|=
name|halfwidth
expr_stmt|;
name|chkpnts
operator|.
name|found
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_counts
operator|>=
literal|4
condition|)
block|{
do|do
block|{
if|if
condition|(
name|points_in_box
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|bezier_check_points
argument_list|,
operator|&
name|chkpnts
argument_list|)
expr_stmt|;
block|}
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
comment|/* 	  printf("next_anchor = %p\n",points); */
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|++
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
else|else
break|break;
comment|/* must be last curve since only this one is allowed< 4 		  * points. 		  */
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
return|return
operator|(
name|chkpnts
operator|.
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_cursor_update (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|bezier_select_cursor_update
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gboolean
name|on_curve
decl_stmt|;
name|gboolean
name|on_control_pnt
decl_stmt|;
name|gboolean
name|in_selection_area
decl_stmt|;
name|gint
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|gdisp
operator|!=
name|tool
operator|->
name|gdisp_ptr
operator|||
name|bezier_sel
operator|->
name|core
operator|->
name|draw_state
operator|==
name|INVISIBLE
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1_CURSOR
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|on_control_pnt
operator|=
name|bezier_on_control_point
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
expr_stmt|;
name|on_curve
operator|=
name|bezier_point_on_curve
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|mask
operator|&&
name|bezier_sel
operator|->
name|closed
operator|&&
name|channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|!
name|on_control_pnt
operator|&&
operator|(
operator|!
name|on_curve
operator|||
name|ModeEdit
operator|!=
name|EXTEND_ADD
operator|)
condition|)
block|{
name|in_selection_area
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1SELP_CURSOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1SELM_CURSOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_BIGCIRC_CURSOR
argument_list|)
expr_stmt|;
else|else
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1SEL_CURSOR
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
comment|/* Moving curve */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
comment|/* moving on 1 curve */
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1MM_CURSOR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1MM_CURSOR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ModeEdit
condition|)
block|{
case|case
name|EXTEND_NEW
case|:
if|if
condition|(
name|on_control_pnt
operator|&&
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1CP_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("add to curve cursor\n"); */
block|}
elseif|else
if|if
condition|(
name|on_curve
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1AP_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("edit control point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1AP_CURSOR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTEND_ADD
case|:
if|if
condition|(
name|on_curve
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1P_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("add to curve cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("default no action cursor\n"); */
block|}
break|break;
case|case
name|EXTEND_EDIT
case|:
if|if
condition|(
name|on_control_pnt
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1CP_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("edit control point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("default no action cursor\n"); */
block|}
break|break;
case|case
name|EXTEND_REMOVE
case|:
if|if
condition|(
name|on_control_pnt
operator|&&
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1M_CURSOR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"delete whole curve cursor\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|on_control_pnt
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1M_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("remove point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1_CURSOR
argument_list|)
expr_stmt|;
comment|/* 	      printf("default no action cursor\n"); */
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"In default\n"
argument_list|)
expr_stmt|;
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE1_CURSOR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_control (Tool * tool,int action,gpointer gdisp_ptr)
name|bezier_select_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|int
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|bezier_sel
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|bezier_draw (GDisplay * gdisp,BezierSelect * bezier_sel)
name|bezier_draw
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
name|int
name|draw_curve
decl_stmt|;
name|int
name|draw_handles
decl_stmt|;
name|int
name|draw_current
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|draw
condition|)
return|return;
name|draw_curve
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_current
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|draw_handles
operator|=
name|bezier_sel
operator|->
name|draw
operator|&
name|BEZIER_DRAW_HANDLES
expr_stmt|;
comment|/* reset to the default drawing state of drawing the curve and handles */
name|bezier_sel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|points
operator|->
name|x
argument_list|,
name|points
operator|->
name|y
argument_list|,
operator|&
name|points
operator|->
name|sx
argument_list|,
operator|&
name|points
operator|->
name|sy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|draw_curve
condition|)
block|{
name|bezier_draw_curve
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|draw_current
condition|)
block|{
name|bezier_draw_current
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|draw_handles
condition|)
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_draw (Tool * tool)
name|bezier_select_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|BezierSelect
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|bezier_sel
operator|=
name|tool
operator|->
name|private
expr_stmt|;
name|bezier_draw
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_add_point (BezierSelect * bezier_sel,int type,gdouble x,gdouble y)
name|bezier_add_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|int
name|type
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|newpt
decl_stmt|;
name|newpt
operator|=
name|g_new0
argument_list|(
name|BezierPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|newpt
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|newpt
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|newpt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|next_curve
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|BEZIER_MOVE
operator|&&
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
comment|/*       printf("Adding move point\n"); */
name|newpt
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next_curve
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|BEZIER_MOVE
condition|)
block|{
name|newpt
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
comment|/* 	  printf("Adding MOVE point to null curve\n"); */
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|newpt
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|points
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|newpt
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|newpt
expr_stmt|;
break|break;
block|}
block|}
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_offset_point (BezierPoint * pt,int x,int y)
name|bezier_offset_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|x
operator|+=
name|x
expr_stmt|;
name|pt
operator|->
name|y
operator|+=
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bezier_check_point (BezierPoint * pt,int x,int y,int halfwidth)
name|bezier_check_point
parameter_list|(
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|halfwidth
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|l
operator|=
name|pt
operator|->
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|pt
operator|->
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|pt
operator|->
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|pt
operator|->
name|y
operator|+
name|halfwidth
expr_stmt|;
return|return
operator|(
operator|(
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|y
operator|<=
name|b
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_handles (BezierSelect * bezier_sel,gint doAll)
name|bezier_draw_handles
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|doAll
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|int
name|num_points
decl_stmt|;
comment|/*   printf("bezier_draw_handles cur_anchor = %p\n",bezier_sel->cur_anchor); */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|<=
literal|0
condition|)
return|return;
while|while
condition|(
name|num_points
operator|&&
name|num_points
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|points
operator|==
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
comment|/* 	printf("bezier_draw_handles:: found cur_anchor %p\n",points); */
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|next
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	printf("bezier_draw_handles:: not found cur_anchor %p\n",points); */
if|if
condition|(
name|doAll
operator|||
name|points
operator|->
name|pointflags
operator|==
literal|1
condition|)
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|points
operator|->
name|pointflags
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_current (BezierSelect * bezier_sel)
name|bezier_draw_current
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_point (BezierSelect * bezier_sel,BezierPoint * pt,int fill)
name|bezier_draw_point
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|fill
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
switch|switch
condition|(
name|pt
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_arc
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_CONTROL
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_rectangle
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_line (BezierSelect * bezier_sel,BezierPoint * pt1,BezierPoint * pt2)
name|bezier_draw_line
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt1
parameter_list|,
name|BezierPoint
modifier|*
name|pt2
parameter_list|)
block|{
if|if
condition|(
name|pt1
operator|&&
name|pt2
condition|)
block|{
name|gdk_draw_line
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|pt1
operator|->
name|sx
argument_list|,
name|pt1
operator|->
name|sy
argument_list|,
name|pt2
operator|->
name|sx
argument_list|,
name|pt2
operator|->
name|sy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment (BezierSelect * bezier_sel,BezierPoint * points,int subdivisions,int space,BezierPointsFunc points_func,gpointer udata)
name|bezier_draw_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|space
parameter_list|,
name|BezierPointsFunc
name|points_func
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
DECL|macro|ROUND (x)
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((int) ((x) + 0.5))
specifier|static
name|GdkPoint
name|gdk_points
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|npoints
init|=
literal|256
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"bad bezier segment"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
operator|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
operator|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"unknown coordinate space: %d"
argument_list|)
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|x
operator|=
operator|(
name|lastx
operator|)
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|(
name|lasty
operator|)
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then draw it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
comment|/* add the point to the point buffer */
name|gdk_points
index|[
name|index
index|]
operator|.
name|x
operator|=
operator|(
name|newx
operator|)
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|y
operator|=
operator|(
name|newy
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* if the point buffer is full put it to the screen and zero it out */
if|if
condition|(
name|index
operator|>=
name|npoints
condition|)
block|{
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|,
name|udata
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* if there are points in the buffer, then put them on the screen */
if|if
condition|(
name|index
condition|)
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|,
name|udata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints,gpointer udata)
name|bezier_draw_segment_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
name|gdk_draw_points
argument_list|(
name|bezier_sel
operator|->
name|core
operator|->
name|win
argument_list|,
name|bezier_sel
operator|->
name|core
operator|->
name|gc
argument_list|,
name|points
argument_list|,
name|npoints
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_compose (BezierMatrix a,BezierMatrix b,BezierMatrix ab)
name|bezier_compose
parameter_list|(
name|BezierMatrix
name|a
parameter_list|,
name|BezierMatrix
name|b
parameter_list|,
name|BezierMatrix
name|ab
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ab
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|a
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|b
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|b
index|[
literal|1
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|b
index|[
literal|2
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|3
index|]
operator|*
name|b
index|[
literal|3
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
DECL|variable|start_convert
specifier|static
name|int
name|start_convert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|width
DECL|variable|height
specifier|static
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lastx
specifier|static
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lasty
specifier|static
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|bezier_convert (BezierSelect * bezier_sel,GDisplay * gdisp,int subdivisions,int antialias)
name|bezier_convert
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|antialias
parameter_list|)
block|{
name|PixelRegion
name|maskPR
decl_stmt|;
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|draw_type
decl_stmt|;
name|int
modifier|*
name|vals
decl_stmt|,
name|val
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|x
decl_stmt|,
name|x2
decl_stmt|,
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"tried to convert an open bezier curve"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* destroy previous mask */
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
block|{
name|channel_delete
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get the new mask's maximum extents */
if|if
condition|(
name|antialias
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|draw_type
operator|=
name|AA_IMAGE_COORDS
expr_stmt|;
comment|/* allocate value array  */
name|vals
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
expr_stmt|;
name|draw_type
operator|=
name|IMAGE_COORDS
expr_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new mask */
name|bezier_sel
operator|->
name|mask
operator|=
name|channel_ref
argument_list|(
name|channel_new_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate room for the scanlines */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GSList
operator|*
argument_list|)
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* zero out the scanlines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* scan convert the curve */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
name|start_convert
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|subdivisions
argument_list|,
name|draw_type
argument_list|,
name|bezier_convert_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  advance to the next segment  */
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|=
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
expr_stmt|;
comment|/*  zero the vals array  */
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
name|i
operator|%
name|SUPERSAMPLE
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|x
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/*           if (!list) 	    g_message (_("cannot properly scanline convert bezier curve: %d"), i);           else */
block|{
comment|/*  bounds checking  */
name|x
operator|=
name|BOUNDS
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
operator|(
name|long
operator|)
name|list
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|w
operator|=
name|x2
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|antialias
condition|)
name|channel_add_segment
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|i
argument_list|,
name|w
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
name|vals
index|[
name|j
operator|+
name|x
index|]
operator|+=
literal|255
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|SUPERSAMPLE
operator|)
condition|)
block|{
name|b
operator|=
name|buf
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|width
expr_stmt|;
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|+=
name|SUPERSAMPLE
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SUPERSAMPLE
condition|;
name|x
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
operator|*
name|b
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|/
name|SUPERSAMPLE2
argument_list|)
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|maskPR
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|/
name|SUPERSAMPLE
operator|)
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
block|{
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
name|channel_invalidate_bounds
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints,gpointer udata)
name|bezier_convert_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|start_convert
condition|)
name|start_convert
operator|=
literal|0
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|npoints
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_line (GSList ** scanlines,int x1,int y1,int x2,int y2)
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|error
decl_stmt|,
name|inc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|slope
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y2
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|double
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
operator|+
operator|(
literal|0
operator|-
name|y2
operator|)
operator|/
name|slope
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y2
operator|>=
name|height
condition|)
block|{
if|if
condition|(
name|y1
operator|>=
name|height
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y2
operator|=
name|height
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|double
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
operator|(
name|height
operator|-
name|y1
operator|)
operator|/
name|slope
expr_stmt|;
name|y2
operator|=
name|height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|scanlines
operator|=
operator|&
name|scanlines
index|[
name|y1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|dx
else|:
name|dx
operator|)
operator|>
operator|(
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
operator|)
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|dx
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|x1
operator|!=
name|x2
condition|)
block|{
name|error
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dx
expr_stmt|;
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
block|}
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
operator|-
name|dy
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|y1
operator|++
operator|<
name|y2
condition|)
block|{
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
name|error
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dy
expr_stmt|;
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|bezier_insert_in_list (GSList * list,int x)
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|GSList
modifier|*
name|orig
init|=
name|list
decl_stmt|;
name|GSList
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
return|;
while|while
condition|(
name|list
condition|)
block|{
name|rest
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|long
operator|)
name|list
operator|->
name|data
condition|)
block|{
name|rest
operator|=
name|g_slist_prepend
argument_list|(
name|rest
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|list
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
expr_stmt|;
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rest
condition|)
block|{
name|g_slist_append
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|bezier_tool_selected ()
name|bezier_tool_selected
parameter_list|()
block|{
return|return
operator|(
name|active_tool_type
operator|==
name|BEZIER_SELECT
operator|&&
name|active_tool
operator|->
name|state
operator|==
name|ACTIVE
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_paste_bezierselect_to_current (GDisplay * gdisp,BezierSelect * bsel)
name|bezier_paste_bezierselect_to_current
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|BezierSelect
modifier|*
name|bsel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|pts
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|Tool
modifier|*
name|tool
decl_stmt|;
name|BezierPoint
modifier|*
name|bpnt
init|=
name|NULL
decl_stmt|;
name|int
name|need_move
init|=
literal|0
decl_stmt|;
comment|/*   printf("bezier_paste_bezierselect_to_current::\n"); */
comment|/*   printSel(bsel); */
comment|/*  If the tool was being used before clear it */
if|if
condition|(
name|active_tool_type
operator|==
name|BEZIER_SELECT
operator|&&
name|active_tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
block|{
name|BezierSelect
modifier|*
name|bezier_sel
init|=
operator|(
name|BezierSelect
operator|*
operator|)
name|active_tool
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|bezier_sel
condition|)
block|{
name|draw_core_stop
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
block|}
name|gtk_widget_activate
argument_list|(
name|tool_info
index|[
name|BEZIER_SELECT
index|]
operator|.
name|tool_widget
argument_list|)
expr_stmt|;
name|tools_select
argument_list|(
name|BEZIER_SELECT
argument_list|)
expr_stmt|;
name|active_tool
operator|->
name|paused_count
operator|=
literal|0
expr_stmt|;
name|active_tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp
expr_stmt|;
empty_stmt|;
name|active_tool
operator|->
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|curSel
argument_list|)
expr_stmt|;
name|draw_core_start
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|pts
operator|=
operator|(
name|BezierPoint
operator|*
operator|)
name|bsel
operator|->
name|points
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bsel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_move
condition|)
block|{
name|bezier_add_point
argument_list|(
name|curSel
argument_list|,
name|BEZIER_MOVE
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
name|need_move
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bezier_add_point
argument_list|(
name|curSel
argument_list|,
name|pts
operator|->
name|type
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpnt
operator|==
name|NULL
condition|)
name|bpnt
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
if|if
condition|(
name|pts
operator|->
name|next_curve
condition|)
block|{
comment|/* 	  printf("bezier_paste_bezierselect_to_current:: Close last curve off \n"); */
name|curSel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
name|curSel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|curSel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bpnt
operator|=
name|NULL
expr_stmt|;
name|need_move
operator|=
literal|1
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next_curve
expr_stmt|;
block|}
else|else
block|{
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bsel
operator|->
name|closed
condition|)
block|{
name|curSel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
name|curSel
operator|->
name|cur_anchor
operator|=
name|curSel
operator|->
name|points
expr_stmt|;
name|curSel
operator|->
name|cur_control
operator|=
name|curSel
operator|->
name|points
operator|->
name|next
expr_stmt|;
name|curSel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curTool
operator|->
name|gdisp_ptr
condition|)
name|bezier_convert
argument_list|(
name|curSel
argument_list|,
name|curTool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
comment|/*   printf("After pasting...\n"); */
comment|/*   printSel(curSel); */
if|if
condition|(
name|bsel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|curSel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
name|curSel
operator|->
name|draw
operator|=
literal|0
expr_stmt|;
name|draw_core_stop
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|curTool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curSel
operator|->
name|state
operator|=
name|bsel
operator|->
name|state
expr_stmt|;
name|curSel
operator|->
name|draw
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|draw_core_resume
argument_list|(
name|curSel
operator|->
name|core
argument_list|,
name|curTool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_to_sel_internal (BezierSelect * bezier_sel,Tool * tool,GDisplay * gdisp,gint op,gint replace)
name|bezier_to_sel_internal
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|Tool
modifier|*
name|tool
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|op
parameter_list|,
name|gint
name|replace
parameter_list|)
block|{
comment|/*  If we're antialiased, then recompute the    *  mask...    */
if|if
condition|(
name|bezier_options
operator|->
name|antialias
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp_ptr
argument_list|,
name|SUBDIVIDE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
comment|/*   if (!bezier_options->extend) */
comment|/*     { */
comment|/*       tool->state = INACTIVE; */
comment|/*       bezier_sel->draw = BEZIER_DRAW_CURVE; */
comment|/*       draw_core_resume (bezier_sel->core, tool); */
comment|/*       bezier_sel->draw = 0; */
comment|/*       draw_core_stop (bezier_sel->core, tool); */
comment|/*     } */
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|feather
condition|)
name|channel_feather
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_sel
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  show selection on all views  */
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|test_add_point_on_segment (BezierSelect * bezier_sel,BezierPoint * pt,int subdivisions,int space,int xpos,int ypos,int halfwidth)
name|test_add_point_on_segment
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|pt
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|space
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|halfwidth
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|int
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|double
name|ratio
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
comment|/* ALT ignore invalid segments since we might be working on an open curve */
name|points
operator|=
name|pt
expr_stmt|;
name|ratio
operator|=
operator|-
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|rint
argument_list|(
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|rint
argument_list|(
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"unknown coordinate space: %d"
argument_list|)
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then test it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|b
decl_stmt|,
name|t
decl_stmt|;
name|l
operator|=
name|newx
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|newx
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|newy
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|newy
operator|+
name|halfwidth
expr_stmt|;
if|if
condition|(
operator|(
name|xpos
operator|>=
name|l
operator|)
operator|&&
operator|(
name|xpos
operator|<=
name|r
operator|)
operator|&&
operator|(
name|ypos
operator|>=
name|t
operator|)
operator|&&
operator|(
name|ypos
operator|<=
name|b
operator|)
condition|)
block|{
comment|/* so we found one point in the square hit */
name|ratio
operator|=
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|subdivisions
expr_stmt|;
comment|/* We found the exact point on the curve, so take it ...*/
if|if
condition|(
operator|(
name|xpos
operator|==
name|newx
operator|)
operator|&&
operator|(
name|ypos
operator|==
name|newy
operator|)
condition|)
break|break;
comment|/* to Implement :  		 keep each time the nearest point of the curve from where we've clicked 		 in the case where we haven't click exactely on the curve. 	      */
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* we found a point on the curve */
if|if
condition|(
name|ratio
operator|>=
literal|0.0
condition|)
block|{
name|BezierPoint
modifier|*
name|pts
decl_stmt|,
modifier|*
name|pt1
decl_stmt|,
modifier|*
name|pt2
decl_stmt|,
modifier|*
name|pt3
decl_stmt|;
name|BezierPoint
modifier|*
name|P00
decl_stmt|,
modifier|*
name|P01
decl_stmt|,
modifier|*
name|P02
decl_stmt|,
modifier|*
name|P03
decl_stmt|;
name|BezierPoint
name|P10
decl_stmt|,
name|P11
decl_stmt|,
name|P12
decl_stmt|;
name|BezierPoint
name|P20
decl_stmt|,
name|P21
decl_stmt|;
name|BezierPoint
name|P30
decl_stmt|;
name|pts
operator|=
name|pt
expr_stmt|;
name|P00
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P01
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P02
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P03
operator|=
name|pts
expr_stmt|;
comment|/* De Casteljau algorithme  	 [Advanced Animation& Randering Technics / Alan& Mark WATT] 	 [ADDISON WESLEY ref 54412] 	 Iteratif way of drawing a Bezier curve by geometrical approch  	  	 P0x represent the four controls points ( anchor / control /control /anchor )  	 P30 represent the new anchor point to add on the curve  	 P2x represent the new control points of P30 	 P1x represent the new values of the control points P01 and P02  	 so if we moves ratio from 0 to 1 we draw the all curve between P00 and P03       */
name|P10
operator|.
name|x
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|x
operator|+
name|ratio
operator|*
name|P01
operator|->
name|x
argument_list|)
expr_stmt|;
name|P10
operator|.
name|y
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|y
operator|+
name|ratio
operator|*
name|P01
operator|->
name|y
argument_list|)
expr_stmt|;
name|P11
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|x
operator|+
name|ratio
operator|*
name|P02
operator|->
name|x
expr_stmt|;
name|P11
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|y
operator|+
name|ratio
operator|*
name|P02
operator|->
name|y
expr_stmt|;
name|P12
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|x
operator|+
name|ratio
operator|*
name|P03
operator|->
name|x
expr_stmt|;
name|P12
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|y
operator|+
name|ratio
operator|*
name|P03
operator|->
name|y
expr_stmt|;
name|P20
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|x
operator|+
name|ratio
operator|*
name|P11
operator|.
name|x
expr_stmt|;
name|P20
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|y
operator|+
name|ratio
operator|*
name|P11
operator|.
name|y
expr_stmt|;
name|P21
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|x
operator|+
name|ratio
operator|*
name|P12
operator|.
name|x
expr_stmt|;
name|P21
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|y
operator|+
name|ratio
operator|*
name|P12
operator|.
name|y
expr_stmt|;
name|P30
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|x
operator|+
name|ratio
operator|*
name|P21
operator|.
name|x
expr_stmt|;
name|P30
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|y
operator|+
name|ratio
operator|*
name|P21
operator|.
name|y
expr_stmt|;
name|P01
operator|->
name|x
operator|=
name|P10
operator|.
name|x
expr_stmt|;
name|P01
operator|->
name|y
operator|=
name|P10
operator|.
name|y
expr_stmt|;
name|P02
operator|->
name|x
operator|=
name|P12
operator|.
name|x
expr_stmt|;
name|P02
operator|->
name|y
operator|=
name|P12
operator|.
name|y
expr_stmt|;
comment|/* All the computes are done, let's insert the new point on the curve */
name|pt1
operator|=
name|g_new0
argument_list|(
name|BezierPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|g_new0
argument_list|(
name|BezierPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|g_new0
argument_list|(
name|BezierPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt1
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt2
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
name|pt3
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt1
operator|->
name|x
operator|=
name|P20
operator|.
name|x
expr_stmt|;
name|pt1
operator|->
name|y
operator|=
name|P20
operator|.
name|y
expr_stmt|;
name|pt2
operator|->
name|x
operator|=
name|P30
operator|.
name|x
expr_stmt|;
name|pt2
operator|->
name|y
operator|=
name|P30
operator|.
name|y
expr_stmt|;
name|pt3
operator|->
name|x
operator|=
name|P21
operator|.
name|x
expr_stmt|;
name|pt3
operator|->
name|y
operator|=
name|P21
operator|.
name|y
expr_stmt|;
name|pt3
operator|->
name|next_curve
operator|=
name|P01
operator|->
name|next_curve
expr_stmt|;
name|P01
operator|->
name|next
operator|=
name|pt1
expr_stmt|;
name|pt1
operator|->
name|prev
operator|=
name|P01
expr_stmt|;
name|pt1
operator|->
name|next
operator|=
name|pt2
expr_stmt|;
name|pt2
operator|->
name|prev
operator|=
name|pt1
expr_stmt|;
name|pt2
operator|->
name|next
operator|=
name|pt3
expr_stmt|;
name|pt3
operator|->
name|prev
operator|=
name|pt2
expr_stmt|;
name|pt3
operator|->
name|next
operator|=
name|P02
expr_stmt|;
name|P02
operator|->
name|prev
operator|=
name|pt3
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|3
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|pt2
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|pt1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|bezier_select_mode (gint mode)
name|void
name|bezier_select_mode
parameter_list|(
name|gint
name|mode
parameter_list|)
block|{
name|ModeEdit
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The curve has to be closed to do a selection. */
end_comment

begin_function
name|void
DECL|function|bezier_to_selection (BezierSelect * bezier_sel,GDisplay * gdisp)
name|bezier_to_selection
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Call the internal function */
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|g_warning
argument_list|(
literal|"Curve not closed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* force the passed selection to be the current selection..*/
comment|/* This loads it into curSel for this image */
name|bezier_paste_bezierselect_to_current
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_to_sel_internal
argument_list|(
name|curSel
argument_list|,
name|curTool
argument_list|,
name|gdisp
argument_list|,
name|ADD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|printSel (BezierSelect * sel)
name|void
name|printSel
parameter_list|(
name|BezierSelect
modifier|*
name|sel
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|pt
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pt
operator|=
name|sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|pt
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d(%p) x,y=%f,%f type=%d next=%p prev=%p next_curve=%p\n"
argument_list|,
name|i
argument_list|,
name|pt
argument_list|,
name|pt
operator|->
name|x
argument_list|,
name|pt
operator|->
name|y
argument_list|,
name|pt
operator|->
name|type
argument_list|,
name|pt
operator|->
name|next
argument_list|,
name|pt
operator|->
name|prev
argument_list|,
name|pt
operator|->
name|next_curve
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|next
operator|!=
name|start_pt
operator|&&
name|pt
operator|->
name|next_curve
condition|)
name|printf
argument_list|(
literal|"Curve out a sync!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|next_curve
condition|)
block|{
name|pt
operator|=
name|pt
operator|->
name|next_curve
expr_stmt|;
name|start_pt
operator|=
name|pt
expr_stmt|;
block|}
else|else
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"core : %p\n"
argument_list|,
name|sel
operator|->
name|core
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"closed : %d\n"
argument_list|,
name|sel
operator|->
name|closed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"draw : %d\n"
argument_list|,
name|sel
operator|->
name|draw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"state: %d\n"
argument_list|,
name|sel
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check whether vectors (offx, offy), (l_offx, l_offy) have the same angle. */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|stroke_interpolatable (int offx,int offy,int l_offx,int l_offy,gdouble error)
name|stroke_interpolatable
parameter_list|(
name|int
name|offx
parameter_list|,
name|int
name|offy
parameter_list|,
name|int
name|l_offx
parameter_list|,
name|int
name|l_offy
parameter_list|,
name|gdouble
name|error
parameter_list|)
block|{
if|if
condition|(
operator|(
name|offx
operator|==
name|l_offx
operator|)
operator|&
operator|(
name|offy
operator|==
name|l_offy
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|offx
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offx
operator|==
literal|0
operator|)
condition|)
if|if
condition|(
name|offx
operator|==
name|l_offx
condition|)
return|return
operator|(
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|&
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|)
operator||
operator|(
operator|(
name|offy
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offy
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
operator|(
name|offy
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offy
operator|==
literal|0
operator|)
condition|)
if|if
condition|(
name|offy
operator|==
name|l_offy
condition|)
return|return
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
comment|/* At this point, we can assert: offx, offy, l_offx, l_offy != 0 */
elseif|else
if|if
condition|(
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|gdouble
name|grad1
decl_stmt|,
name|grad2
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|offy
argument_list|)
operator|<
name|ABS
argument_list|(
name|offx
argument_list|)
condition|)
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offy
operator|/
operator|(
name|gdouble
operator|)
name|offx
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offy
operator|/
operator|(
name|gdouble
operator|)
name|l_offx
expr_stmt|;
block|}
else|else
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offx
operator|/
operator|(
name|gdouble
operator|)
name|offy
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offx
operator|/
operator|(
name|gdouble
operator|)
name|l_offy
expr_stmt|;
block|}
comment|/* printf ("error: %f / %f\n", ABS (grad1 - grad2), error); */
return|return
operator|(
name|ABS
argument_list|(
name|grad1
operator|-
name|grad2
argument_list|)
operator|<=
name|error
operator|)
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points_aux (GdkPoint * points,int start,int end,gdouble error,BezierRenderPnts * rpnts)
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|gdouble
name|error
parameter_list|,
name|BezierRenderPnts
modifier|*
name|rpnts
parameter_list|)
block|{
specifier|const
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|med
decl_stmt|;
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|,
name|l_offx
decl_stmt|,
name|l_offy
decl_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
return|return;
comment|/* BASE CASE: stack the end point */
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|y
operator|)
condition|)
return|return;
name|rpnts
operator|->
name|num_stroke_points
operator|++
expr_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|len_stroke_points
operator|<=
name|rpnts
operator|->
name|num_stroke_points
condition|)
block|{
name|rpnts
operator|->
name|len_stroke_points
operator|+=
name|expand_size
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|g_renew
argument_list|(
name|double
argument_list|,
name|rpnts
operator|->
name|stroke_points
argument_list|,
literal|2
operator|*
name|rpnts
operator|->
name|len_stroke_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
block|{
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|32
condition|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, check whether to divide the segment recursively */
name|offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
name|med
operator|=
operator|(
name|end
operator|+
name|start
operator|)
operator|/
literal|2
expr_stmt|;
name|l_offx
operator|=
name|points
index|[
name|med
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|med
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
name|l_offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|med
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|med
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, the curve can be represented by a points pair: (start, end).      So, add the last point to stroke_points. */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|end
argument_list|,
name|end
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points (BezierSelect * bezier_sel,GdkPoint * points,int npoints,gpointer udata)
name|bezier_stack_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|int
name|npoints
parameter_list|,
name|gpointer
name|udata
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|gdouble
name|error
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|rpnts
init|=
name|udata
decl_stmt|;
if|if
condition|(
name|npoints
operator|<
literal|2
condition|)
comment|/* Does this happen? */
return|return;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
comment|/*  initialize it here */
block|{
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|expand_size
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|g_new
argument_list|(
name|double
argument_list|,
literal|2
operator|*
name|rpnts
operator|->
name|len_stroke_points
argument_list|)
expr_stmt|;
block|}
name|maxx
operator|=
name|minx
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|maxy
operator|=
name|miny
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxx
operator|<
name|points
index|[
name|i
index|]
operator|.
name|x
condition|)
name|maxx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxy
operator|<
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
name|maxy
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* allow one pixel fluctuation */
name|error
operator|=
literal|2.0
operator|/
name|MAX
argument_list|(
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
expr_stmt|;
comment|/* add the start point */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
comment|/* divide segments recursively */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|npoints
operator|-
literal|1
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
comment|/* printf ("npoints: %d\n", npoints); */
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_gen_points (BezierSelect * bezier_sel,int open_path,BezierRenderPnts * rpnts)
name|bezier_gen_points
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|int
name|open_path
parameter_list|,
name|BezierRenderPnts
modifier|*
name|rpnts
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|next_rpnts
init|=
name|rpnts
decl_stmt|;
comment|/* stack points */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|bezier_stack_points
argument_list|,
operator|(
name|gpointer
operator|)
name|next_rpnts
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
if|if
condition|(
name|next_curve
condition|)
block|{
name|next_rpnts
operator|->
name|next_curve
operator|=
name|g_new0
argument_list|(
name|BezierRenderPnts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_rpnts
operator|=
name|next_rpnts
operator|->
name|next_curve
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_stroke (BezierSelect * bezier_sel,GDisplay * gdisp,int subdivisions,int open_path)
name|bezier_stroke
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|int
name|open_path
parameter_list|)
block|{
name|Argument
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|int
name|redraw
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|next_rpnts
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|rpnts
init|=
name|g_new0
argument_list|(
name|BezierRenderPnts
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redraw
operator|=
name|bezier_gen_points
argument_list|(
name|bezier_sel
argument_list|,
name|open_path
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
condition|)
block|{
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset_x
operator|!=
literal|0
operator|)
operator|||
operator|(
name|offset_y
operator|!=
literal|0
operator|)
condition|)
block|{
name|gdouble
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|rpnts
operator|->
name|stroke_points
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|rpnts
operator|->
name|stroke_points
operator|+
operator|(
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|-=
name|offset_x
expr_stmt|;
operator|*
name|ptr
operator|++
operator|-=
name|offset_y
expr_stmt|;
block|}
block|}
name|return_vals
operator|=
name|procedural_db_run_proc
argument_list|(
literal|"gimp_paintbrush"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PDB_DRAWABLE
argument_list|,
name|drawable_ID
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
literal|0
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
argument_list|,
name|PDB_FLOATARRAY
argument_list|,
name|rpnts
operator|->
name|stroke_points
argument_list|,
name|PDB_INT32
argument_list|,
literal|0
comment|/* continuous */
argument_list|,
name|PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
literal|0
comment|/*no grad*/
argument_list|,
name|PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
operator|&&
name|return_vals
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|==
name|PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|redraw
condition|)
block|{
comment|/* FIXME: how to update the image? */
block|}
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Paintbrush operation failed."
argument_list|)
argument_list|)
expr_stmt|;
name|procedural_db_destroy_args
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|rpnts
operator|->
name|stroke_points
argument_list|)
expr_stmt|;
block|}
name|next_rpnts
operator|=
name|rpnts
operator|->
name|next_curve
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|NULL
expr_stmt|;
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
name|g_free
argument_list|(
name|rpnts
argument_list|)
expr_stmt|;
name|rpnts
operator|=
name|next_rpnts
expr_stmt|;
block|}
do|while
condition|(
name|rpnts
condition|)
do|;
comment|/* printf ("num_stroke_points: %d\ndone.\n", num_stroke_points); */
comment|/*   rpnts->stroke_points = NULL; */
comment|/*   rpnts->len_stroke_points = rpnts->num_stroke_points = 0; */
comment|/*   g_free(rpnts); */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_for_distance (BezierSelect * bezier_sel,BezierPoint * points,int subdivisions,BezierDistance * bdist)
name|bezier_draw_segment_for_distance
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierPoint
modifier|*
name|points
parameter_list|,
name|int
name|subdivisions
parameter_list|,
name|BezierDistance
modifier|*
name|bdist
parameter_list|)
block|{
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|double
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|double
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
if|if
condition|(
name|bdist
operator|->
name|found
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|fatal_error
argument_list|(
name|_
argument_list|(
literal|"bad bezier segment"
argument_list|)
argument_list|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
comment|/*       printf("x = %g, y = %g\n",x,y); */
comment|/* if this point is different than the last one...then draw it */
comment|/* Note :        * It assumes the udata is the place we want the         * floating version of the coords to be stuffed.        * These are needed when we calculate the gradient of the         * curve.        */
if|if
condition|(
operator|!
name|bdist
operator|->
name|firstpnt
condition|)
block|{
name|gdouble
name|rx
init|=
name|x
decl_stmt|;
name|gdouble
name|ry
init|=
name|y
decl_stmt|;
name|gdouble
name|dx
init|=
name|bdist
operator|->
name|lastx
operator|-
name|rx
decl_stmt|;
name|gdouble
name|dy
init|=
name|bdist
operator|->
name|lasty
operator|-
name|ry
decl_stmt|;
name|bdist
operator|->
name|curdist
operator|+=
name|sqrt
argument_list|(
operator|(
name|dx
operator|*
name|dx
operator|)
operator|+
operator|(
name|dy
operator|*
name|dy
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdist
operator|->
name|curdist
operator|>=
name|bdist
operator|->
name|dist
condition|)
block|{
operator|*
operator|(
name|bdist
operator|->
name|x
operator|)
operator|=
operator|(
name|gint
operator|)
name|ROUND
argument_list|(
operator|(
name|rx
operator|+
name|dx
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bdist
operator|->
name|y
operator|)
operator|=
operator|(
name|gint
operator|)
name|ROUND
argument_list|(
operator|(
name|ry
operator|+
name|dy
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0.0
condition|)
operator|*
operator|(
name|bdist
operator|->
name|gradient
operator|)
operator|=
name|G_MAXDOUBLE
expr_stmt|;
else|else
operator|*
operator|(
name|bdist
operator|->
name|gradient
operator|)
operator|=
name|dy
operator|/
name|dx
expr_stmt|;
comment|/* 	      printf("found x = %d, y = %d\n",*(bdist->x),*(bdist->y)); */
name|bdist
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|bdist
operator|->
name|lastx
operator|=
name|rx
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
name|ry
expr_stmt|;
block|}
else|else
block|{
name|bdist
operator|->
name|firstpnt
operator|=
name|FALSE
expr_stmt|;
name|bdist
operator|->
name|lastx
operator|=
name|x
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
name|y
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_curve_for_distance (BezierSelect * bezier_sel,BezierDistance * udata)
name|bezier_draw_curve_for_distance
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|BezierDistance
modifier|*
name|udata
parameter_list|)
block|{
name|BezierPoint
modifier|*
name|points
decl_stmt|;
name|BezierPoint
modifier|*
name|start_pt
decl_stmt|;
name|BezierPoint
modifier|*
name|next_curve
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
do|do
block|{
name|bezier_draw_segment_for_distance
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|udata
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|bezier_distance_along (BezierSelect * bezier_sel,int open_path,gdouble dist,gint * x,gint * y,gdouble * gradient)
name|bezier_distance_along
parameter_list|(
name|BezierSelect
modifier|*
name|bezier_sel
parameter_list|,
name|int
name|open_path
parameter_list|,
name|gdouble
name|dist
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gdouble
modifier|*
name|gradient
parameter_list|)
block|{
comment|/* Render the curve as points then walk along it... */
name|BezierDistance
modifier|*
name|bdist
init|=
name|g_new0
argument_list|(
name|BezierDistance
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gint
name|ret
decl_stmt|;
name|bdist
operator|->
name|firstpnt
operator|=
name|TRUE
expr_stmt|;
name|bdist
operator|->
name|curdist
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|lastx
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|dist
operator|=
name|dist
expr_stmt|;
name|bdist
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|bdist
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|bdist
operator|->
name|gradient
operator|=
name|gradient
expr_stmt|;
name|bdist
operator|->
name|found
operator|=
name|FALSE
expr_stmt|;
name|bezier_draw_curve_for_distance
argument_list|(
name|bezier_sel
argument_list|,
name|bdist
argument_list|)
expr_stmt|;
name|ret
operator|=
name|bdist
operator|->
name|found
expr_stmt|;
name|g_free
argument_list|(
name|bdist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

