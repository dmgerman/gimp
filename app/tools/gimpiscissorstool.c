begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* This tool is based on a paper from SIGGRAPH '95:  *  "Intelligent Scissors for Image Composition", Eric N. Mortensen and  *   William A. Barrett, Brigham Young University.  *  * thanks to Professor D. Forsyth for prompting us to implement this tool. */
end_comment

begin_comment
comment|/* Personal note: Dr. Barrett, one of the authors of the paper written above  * is not only one of the most brilliant people I have ever met, he is an  * incredible professor who genuinely cares about his students and wants them  * to learn as much as they can about the topic.  *  * I didn't even notice I was taking a class from the person who wrote the  * paper until halfway through the semester.  *                                                   -- Rockwalrus  */
end_comment

begin_comment
comment|/* The history of this implementation is lonog and varied.  It was  * orignally done by Spencer and Peter, and worked fine in the 0.54  * (motif only) release of GIMP.  Later revisions (0.99.something  * until about 1.1.4) completely changed the algorithm used, until it  * bore little resemblance to the one described in the paper above.  * The 0.54 version of the algorithm was then forwards ported to 1.1.4  * by Austin Donnelly.  */
end_comment

begin_comment
comment|/* Livewire boundary implementation done by Laramie Leavitt */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdkkeysyms.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpwidgets/gimpwidgets.h"
end_include

begin_include
include|#
directive|include
file|"tools-types.h"
end_include

begin_include
include|#
directive|include
file|"base/pixel-region.h"
end_include

begin_include
include|#
directive|include
file|"base/temp-buf.h"
end_include

begin_include
include|#
directive|include
file|"base/tile-manager.h"
end_include

begin_include
include|#
directive|include
file|"base/tile.h"
end_include

begin_include
include|#
directive|include
file|"paint-funcs/paint-funcs.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel-select.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimppickable.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpscanconvert.h"
end_include

begin_include
include|#
directive|include
file|"core/gimptoolinfo.h"
end_include

begin_include
include|#
directive|include
file|"widgets/gimphelp-ids.h"
end_include

begin_include
include|#
directive|include
file|"widgets/gimpwidgets-utils.h"
end_include

begin_include
include|#
directive|include
file|"display/gimpdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimpiscissorsoptions.h"
end_include

begin_include
include|#
directive|include
file|"gimpiscissorstool.h"
end_include

begin_include
include|#
directive|include
file|"gimptoolcontrol.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_comment
comment|/*  defines  */
end_comment

begin_define
DECL|macro|MAX_GRADIENT
define|#
directive|define
name|MAX_GRADIENT
value|179.606
end_define

begin_comment
DECL|macro|MAX_GRADIENT
comment|/* == sqrt (127^2 + 127^2) */
end_comment

begin_define
DECL|macro|GRADIENT_SEARCH
define|#
directive|define
name|GRADIENT_SEARCH
value|32
end_define

begin_comment
DECL|macro|GRADIENT_SEARCH
comment|/* how far to look when snapping to an edge */
end_comment

begin_define
DECL|macro|TARGET_SIZE
define|#
directive|define
name|TARGET_SIZE
value|25
end_define

begin_define
DECL|macro|POINT_WIDTH
define|#
directive|define
name|POINT_WIDTH
value|12
end_define

begin_comment
DECL|macro|POINT_WIDTH
comment|/* size (in pixels) of seed handles */
end_comment

begin_define
DECL|macro|EXTEND_BY
define|#
directive|define
name|EXTEND_BY
value|0.2
end_define

begin_comment
DECL|macro|EXTEND_BY
comment|/* proportion to expand cost map by */
end_comment

begin_define
DECL|macro|FIXED
define|#
directive|define
name|FIXED
value|5
end_define

begin_comment
DECL|macro|FIXED
comment|/* additional fixed size to expand cost map */
end_comment

begin_define
DECL|macro|MIN_GRADIENT
define|#
directive|define
name|MIN_GRADIENT
value|63
end_define

begin_comment
DECL|macro|MIN_GRADIENT
comment|/* gradients< this are directionless */
end_comment

begin_define
DECL|macro|COST_WIDTH
define|#
directive|define
name|COST_WIDTH
value|2
end_define

begin_comment
DECL|macro|COST_WIDTH
comment|/* number of bytes for each pixel in cost map  */
end_comment

begin_comment
comment|/* weight to give between gradient (_G) and direction (_D) */
end_comment

begin_define
DECL|macro|OMEGA_D
define|#
directive|define
name|OMEGA_D
value|0.2
end_define

begin_define
DECL|macro|OMEGA_G
define|#
directive|define
name|OMEGA_G
value|0.8
end_define

begin_comment
comment|/* sentinel to mark seed point in ?cost? map */
end_comment

begin_define
DECL|macro|SEED_POINT
define|#
directive|define
name|SEED_POINT
value|9
end_define

begin_comment
comment|/*  Functional defines  */
end_comment

begin_define
DECL|macro|PIXEL_COST (x)
define|#
directive|define
name|PIXEL_COST
parameter_list|(
name|x
parameter_list|)
value|((x)>> 8)
end_define

begin_define
DECL|macro|PIXEL_DIR (x)
define|#
directive|define
name|PIXEL_DIR
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x000000ff)
end_define

begin_struct
DECL|struct|_ICurve
struct|struct
name|_ICurve
block|{
DECL|member|x1
DECL|member|y1
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
DECL|member|x2
DECL|member|y2
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
DECL|member|points
name|GPtrArray
modifier|*
name|points
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_control
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GimpToolAction
name|action
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_button_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpButtonPressType
name|press_type
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_button_release
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpButtonReleaseType
name|release_type
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_motion
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_oper_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|gboolean
name|proximity
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_cursor_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_iscissors_tool_key_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventKey
modifier|*
name|kevent
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_apply
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_reset
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_iscissors_tool_draw
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_convert
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TileManager
modifier|*
name|gradient_map_new
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_optimal_path
parameter_list|(
name|TileManager
modifier|*
name|gradient_map
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|xs
parameter_list|,
name|gint
name|ys
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_max_gradient
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_curve
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_draw_curve
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_free_icurves
parameter_list|(
name|GQueue
modifier|*
name|curves
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|mouse_over_vertex
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|clicked_on_vertex
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GList
modifier|*
name|mouse_over_curve
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|clicked_on_curve
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GPtrArray
modifier|*
name|plot_pixels
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|xs
parameter_list|,
name|gint
name|ys
parameter_list|,
name|gint
name|xe
parameter_list|,
name|gint
name|ye
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|G_DEFINE_TYPE
argument_list|(
argument|GimpIscissorsTool
argument_list|,
argument|gimp_iscissors_tool
argument_list|,
argument|GIMP_TYPE_SELECTION_TOOL
argument_list|)
end_macro

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_iscissors_tool_parent_class
end_define

begin_comment
comment|/*  static variables  */
end_comment

begin_comment
comment|/*  where to move on a given link direction  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|gint
name|move
index|[
literal|8
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IE:  * '---+---+---`  * | 7 | 5 | 6 |  * +---+---+---+  * | 4 |   | 0 |  * +---+---+---+  * | 2 | 1 | 3 |  * `---+---+---'  */
end_comment

begin_comment
comment|/*  temporary convolution buffers --  */
end_comment

begin_decl_stmt
DECL|variable|maxgrad_conv0
specifier|static
name|guchar
name|maxgrad_conv0
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|maxgrad_conv1
specifier|static
name|guchar
name|maxgrad_conv1
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|maxgrad_conv2
specifier|static
name|guchar
name|maxgrad_conv2
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|horz_deriv
specifier|static
specifier|const
name|gfloat
name|horz_deriv
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|,
operator|-
literal|2
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vert_deriv
specifier|static
specifier|const
name|gfloat
name|vert_deriv
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|blur_32
specifier|static
specifier|const
name|gfloat
name|blur_32
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|24
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|distance_weights
specifier|static
name|gfloat
name|distance_weights
index|[
name|GRADIENT_SEARCH
operator|*
name|GRADIENT_SEARCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|diagonal_weight
specifier|static
name|gint
name|diagonal_weight
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|direction_value
specifier|static
name|gint
name|direction_value
index|[
literal|256
index|]
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_tile
specifier|static
name|Tile
modifier|*
name|cur_tile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|gimp_iscissors_tool_register (GimpToolRegisterCallback callback,gpointer data)
name|gimp_iscissors_tool_register
parameter_list|(
name|GimpToolRegisterCallback
name|callback
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
call|(
modifier|*
name|callback
call|)
argument_list|(
name|GIMP_TYPE_ISCISSORS_TOOL
argument_list|,
name|GIMP_TYPE_ISCISSORS_OPTIONS
argument_list|,
name|gimp_iscissors_options_gui
argument_list|,
literal|0
argument_list|,
literal|"gimp-iscissors-tool"
argument_list|,
name|_
argument_list|(
literal|"Scissors"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Scissors Select Tool: Select shapes using intelligent edge-fitting"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Intelligent _Scissors"
argument_list|)
argument_list|,
literal|"I"
argument_list|,
name|NULL
argument_list|,
name|GIMP_HELP_TOOL_ISCISSORS
argument_list|,
name|GIMP_STOCK_TOOL_ISCISSORS
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_class_init (GimpIscissorsToolClass * klass)
name|gimp_iscissors_tool_class_init
parameter_list|(
name|GimpIscissorsToolClass
modifier|*
name|klass
parameter_list|)
block|{
name|GObjectClass
modifier|*
name|object_class
init|=
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpToolClass
modifier|*
name|tool_class
init|=
name|GIMP_TOOL_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|GimpDrawToolClass
modifier|*
name|draw_tool_class
init|=
name|GIMP_DRAW_TOOL_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|object_class
operator|->
name|finalize
operator|=
name|gimp_iscissors_tool_finalize
expr_stmt|;
name|tool_class
operator|->
name|control
operator|=
name|gimp_iscissors_tool_control
expr_stmt|;
name|tool_class
operator|->
name|button_press
operator|=
name|gimp_iscissors_tool_button_press
expr_stmt|;
name|tool_class
operator|->
name|button_release
operator|=
name|gimp_iscissors_tool_button_release
expr_stmt|;
name|tool_class
operator|->
name|motion
operator|=
name|gimp_iscissors_tool_motion
expr_stmt|;
name|tool_class
operator|->
name|oper_update
operator|=
name|gimp_iscissors_tool_oper_update
expr_stmt|;
name|tool_class
operator|->
name|cursor_update
operator|=
name|gimp_iscissors_tool_cursor_update
expr_stmt|;
name|tool_class
operator|->
name|key_press
operator|=
name|gimp_iscissors_tool_key_press
expr_stmt|;
name|draw_tool_class
operator|->
name|draw
operator|=
name|gimp_iscissors_tool_draw
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
comment|/*  The diagonal weight array  */
name|diagonal_weight
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|i
operator|*
name|G_SQRT2
argument_list|)
expr_stmt|;
comment|/*  The direction value array  */
name|direction_value
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
literal|127
operator|-
name|abs
argument_list|(
literal|127
operator|-
name|i
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|abs
argument_list|(
literal|127
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
name|abs
argument_list|(
literal|191
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
name|abs
argument_list|(
literal|63
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
comment|/*  set the 256th index of the direction_values to the hightest cost  */
name|direction_value
index|[
literal|255
index|]
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|1
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|2
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_init (GimpIscissorsTool * iscissors)
name|gimp_iscissors_tool_init
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
init|=
name|GIMP_TOOL
argument_list|(
name|iscissors
argument_list|)
decl_stmt|;
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_NONE
expr_stmt|;
name|iscissors
operator|->
name|dp_buf
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|curves
operator|=
name|g_queue_new
argument_list|()
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_NOTHING
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|NO_ACTION
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|gradient_map
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|livewire
operator|=
name|NULL
expr_stmt|;
name|gimp_tool_control_set_scroll_lock
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_tool_control_set_snap_to
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_tool_control_set_preserve
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_tool_control_set_dirty_mask
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|GIMP_DIRTY_IMAGE_SIZE
argument_list|)
expr_stmt|;
name|gimp_tool_control_set_tool_cursor
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|GIMP_TOOL_CURSOR_ISCISSORS
argument_list|)
expr_stmt|;
name|gimp_iscissors_tool_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_finalize (GObject * object)
name|gimp_iscissors_tool_finalize
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_iscissors_tool_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|g_queue_free
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|finalize
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_control (GimpTool * tool,GimpToolAction action,GimpDisplay * display)
name|gimp_iscissors_tool_control
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GimpToolAction
name|action
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|IscissorsDraw
name|draw
decl_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_CURRENT_SEED
expr_stmt|;
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_ACTIVE_CURVE
expr_stmt|;
break|break;
default|default:
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
break|break;
block|}
name|iscissors
operator|->
name|draw
operator|=
name|draw
expr_stmt|;
name|GIMP_TOOL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|control
argument_list|(
name|tool
argument_list|,
name|action
argument_list|,
name|display
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|GIMP_TOOL_ACTION_PAUSE
case|:
case|case
name|GIMP_TOOL_ACTION_RESUME
case|:
break|break;
case|case
name|GIMP_TOOL_ACTION_HALT
case|:
name|gimp_iscissors_tool_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_button_press (GimpTool * tool,const GimpCoords * coords,guint32 time,GdkModifierType state,GimpButtonPressType press_type,GimpDisplay * display)
name|gimp_iscissors_tool_button_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpButtonPressType
name|press_type
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpIscissorsOptions
modifier|*
name|options
init|=
name|GIMP_ISCISSORS_TOOL_GET_OPTIONS
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|gimp_display_get_image
argument_list|(
name|display
argument_list|)
decl_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|RINT
argument_list|(
name|coords
operator|->
name|x
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|RINT
argument_list|(
name|coords
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|gimp_tool_control_is_active
argument_list|(
name|tool
operator|->
name|control
argument_list|)
condition|)
block|{
if|if
condition|(
name|display
operator|!=
name|tool
operator|->
name|display
condition|)
block|{
name|gimp_draw_tool_stop
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_iscissors_tool_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|gimp_tool_control_activate
argument_list|(
name|tool
operator|->
name|control
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gimp_tool_control_activate
argument_list|(
name|tool
operator|->
name|control
argument_list|)
expr_stmt|;
block|}
name|tool
operator|->
name|display
operator|=
name|display
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|NO_ACTION
case|:
name|iscissors
operator|->
name|state
operator|=
name|SEED_PLACEMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|image
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|ix
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
comment|/*  Initialize the selection core only on starting the tool  */
name|gimp_draw_tool_start
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|,
name|display
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*  Check if the mouse click occurred on a vertex or the curve itself  */
if|if
condition|(
name|clicked_on_vertex
argument_list|(
name|iscissors
argument_list|,
name|coords
operator|->
name|x
argument_list|,
name|coords
operator|->
name|y
argument_list|)
condition|)
block|{
name|iscissors
operator|->
name|nx
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|ny
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|SEED_ADJUSTMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_ACTIVE_CURVE
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  If the iscissors is connected, check if the click was inside  */
elseif|else
if|if
condition|(
name|iscissors
operator|->
name|connected
operator|&&
name|iscissors
operator|->
name|mask
operator|&&
name|gimp_pickable_get_opacity_at
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|)
condition|)
block|{
name|gimp_iscissors_tool_apply
argument_list|(
name|iscissors
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|iscissors
operator|->
name|connected
condition|)
block|{
comment|/*  if we're not connected, we're adding a new point  */
comment|/*  pause the tool, but undraw nothing  */
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_NOTHING
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|SEED_PLACEMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|interactive
condition|)
name|iscissors
operator|->
name|draw
operator||=
name|DRAW_LIVEWIRE
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_convert (GimpIscissorsTool * iscissors,GimpDisplay * display)
name|iscissors_convert
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpSelectionOptions
modifier|*
name|options
init|=
name|GIMP_SELECTION_TOOL_GET_OPTIONS
argument_list|(
name|iscissors
argument_list|)
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|gimp_display_get_image
argument_list|(
name|display
argument_list|)
decl_stmt|;
name|GimpScanConvert
modifier|*
name|sc
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|GimpVector2
modifier|*
name|points
init|=
name|NULL
decl_stmt|;
name|guint
name|n_total_points
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|gimp_scan_convert_new
argument_list|()
expr_stmt|;
for|for
control|(
name|list
operator|=
name|g_queue_peek_tail_link
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_previous
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ICurve
modifier|*
name|icurve
init|=
name|list
operator|->
name|data
decl_stmt|;
name|n_total_points
operator|+=
name|icurve
operator|->
name|points
operator|->
name|len
expr_stmt|;
block|}
name|points
operator|=
name|g_new
argument_list|(
name|GimpVector2
argument_list|,
name|n_total_points
argument_list|)
expr_stmt|;
name|n_total_points
operator|=
literal|0
expr_stmt|;
comment|/* go over the curves in reverse order, adding the points we have */
for|for
control|(
name|list
operator|=
name|g_queue_peek_tail_link
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_previous
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ICurve
modifier|*
name|icurve
init|=
name|list
operator|->
name|data
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|guint
name|n_points
decl_stmt|;
name|n_points
operator|=
name|icurve
operator|->
name|points
operator|->
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_points
condition|;
name|i
operator|++
control|)
block|{
name|guint32
name|packed
init|=
name|GPOINTER_TO_INT
argument_list|(
name|g_ptr_array_index
argument_list|(
name|icurve
operator|->
name|points
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|points
index|[
name|n_total_points
operator|+
name|i
index|]
operator|.
name|x
operator|=
name|packed
operator|&
literal|0x0000ffff
expr_stmt|;
name|points
index|[
name|n_total_points
operator|+
name|i
index|]
operator|.
name|y
operator|=
name|packed
operator|>>
literal|16
expr_stmt|;
block|}
name|n_total_points
operator|+=
name|n_points
expr_stmt|;
block|}
name|gimp_scan_convert_add_polyline
argument_list|(
name|sc
argument_list|,
name|n_total_points
argument_list|,
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
name|g_object_unref
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|gimp_channel_new_mask
argument_list|(
name|image
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_scan_convert_render
argument_list|(
name|sc
argument_list|,
name|gimp_drawable_get_tiles
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|options
operator|->
name|antialias
argument_list|)
expr_stmt|;
name|gimp_scan_convert_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_button_release (GimpTool * tool,const GimpCoords * coords,guint32 time,GdkModifierType state,GimpButtonReleaseType release_type,GimpDisplay * display)
name|gimp_iscissors_tool_button_release
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpButtonReleaseType
name|release_type
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpIscissorsOptions
modifier|*
name|options
init|=
name|GIMP_ISCISSORS_TOOL_GET_OPTIONS
argument_list|(
name|tool
argument_list|)
decl_stmt|;
comment|/* Make sure X didn't skip the button release event -- as it's known    * to do    */
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|WAITING
condition|)
return|return;
comment|/*  Undraw everything  */
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_CURRENT_SEED
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|interactive
condition|)
name|iscissors
operator|->
name|draw
operator||=
name|DRAW_LIVEWIRE
expr_stmt|;
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_ACTIVE_CURVE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|gimp_draw_tool_pause
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_type
operator|!=
name|GIMP_BUTTON_RELEASE_CANCEL
condition|)
block|{
comment|/*  Progress to the next stage of intelligent selection  */
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
comment|/*  Add a new icurve  */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|first_point
condition|)
block|{
comment|/*  Determine if we're connecting to the first point  */
if|if
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|g_queue_peek_head
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_draw_tool_on_handle
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|,
name|display
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|,
name|GIMP_HANDLE_CIRCLE
argument_list|,
name|curve
operator|->
name|x1
argument_list|,
name|curve
operator|->
name|y1
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|iscissors
operator|->
name|x
operator|=
name|curve
operator|->
name|x1
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|curve
operator|->
name|y1
expr_stmt|;
name|iscissors
operator|->
name|connected
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/*  Create the new curve segment  */
if|if
condition|(
name|iscissors
operator|->
name|ix
operator|!=
name|iscissors
operator|->
name|x
operator|||
name|iscissors
operator|->
name|iy
operator|!=
name|iscissors
operator|->
name|y
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|g_slice_new
argument_list|(
name|ICurve
argument_list|)
decl_stmt|;
name|curve
operator|->
name|x1
operator|=
name|iscissors
operator|->
name|ix
expr_stmt|;
name|curve
operator|->
name|y1
operator|=
name|iscissors
operator|->
name|iy
expr_stmt|;
name|iscissors
operator|->
name|ix
operator|=
name|curve
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|curve
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
name|g_queue_push_tail
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|,
name|curve
argument_list|)
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* this was our first point */
block|{
name|iscissors
operator|->
name|first_point
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
comment|/*  recalculate both curves  */
if|if
condition|(
name|iscissors
operator|->
name|curve1
condition|)
block|{
name|iscissors
operator|->
name|curve1
operator|->
name|x1
operator|=
name|iscissors
operator|->
name|nx
expr_stmt|;
name|iscissors
operator|->
name|curve1
operator|->
name|y1
operator|=
name|iscissors
operator|->
name|ny
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|iscissors
operator|->
name|curve1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iscissors
operator|->
name|curve2
condition|)
block|{
name|iscissors
operator|->
name|curve2
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|nx
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|ny
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|iscissors
operator|->
name|curve2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|iscissors
operator|->
name|state
operator|=
name|WAITING
expr_stmt|;
comment|/*  Draw only the boundary  */
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  convert the curves into a region  */
if|if
condition|(
name|iscissors
operator|->
name|connected
condition|)
name|iscissors_convert
argument_list|(
name|iscissors
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_motion (GimpTool * tool,const GimpCoords * coords,guint32 time,GdkModifierType state,GimpDisplay * display)
name|gimp_iscissors_tool_motion
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|guint32
name|time
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpIscissorsOptions
modifier|*
name|options
init|=
name|GIMP_ISCISSORS_TOOL_GET_OPTIONS
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|gimp_display_get_image
argument_list|(
name|display
argument_list|)
decl_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|NO_ACTION
condition|)
return|return;
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|SEED_PLACEMENT
condition|)
block|{
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|interactive
condition|)
name|iscissors
operator|->
name|draw
operator||=
name|DRAW_LIVEWIRE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|SEED_ADJUSTMENT
condition|)
block|{
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_ACTIVE_CURVE
expr_stmt|;
block|}
name|gimp_draw_tool_pause
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|RINT
argument_list|(
name|coords
operator|->
name|x
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|RINT
argument_list|(
name|coords
operator|->
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
comment|/*  Hold the shift key down to disable the auto-edge snap feature  */
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|image
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|first_point
condition|)
block|{
name|iscissors
operator|->
name|ix
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
block|}
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
comment|/*  Move the current seed to the location of the cursor  */
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|image
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|CLAMP
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|nx
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|ny
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|gimp_draw_tool_resume
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_draw (GimpDrawTool * draw_tool)
name|gimp_iscissors_tool_draw
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
init|=
name|GIMP_TOOL
argument_list|(
name|draw_tool
argument_list|)
decl_stmt|;
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|draw_tool
argument_list|)
decl_stmt|;
comment|/*  Draw the crosshairs target if we're placing a seed  */
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_CURRENT_SEED
condition|)
block|{
name|gimp_draw_tool_draw_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_CROSS
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|,
name|TARGET_SIZE
argument_list|,
name|TARGET_SIZE
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Draw a line boundary */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|first_point
operator|&&
operator|!
operator|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_LIVEWIRE
operator|)
condition|)
block|{
name|gimp_draw_tool_draw_line
argument_list|(
name|draw_tool
argument_list|,
name|iscissors
operator|->
name|ix
argument_list|,
name|iscissors
operator|->
name|iy
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Draw the livewire boundary */
if|if
condition|(
operator|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_LIVEWIRE
operator|)
operator|&&
operator|!
name|iscissors
operator|->
name|first_point
condition|)
block|{
comment|/* See if the mouse has moved.  If so, create a new segment... */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|livewire
operator|||
operator|(
name|iscissors
operator|->
name|livewire
operator|&&
operator|(
name|iscissors
operator|->
name|ix
operator|!=
name|iscissors
operator|->
name|livewire
operator|->
name|x1
operator|||
name|iscissors
operator|->
name|x
operator|!=
name|iscissors
operator|->
name|livewire
operator|->
name|x2
operator|||
name|iscissors
operator|->
name|iy
operator|!=
name|iscissors
operator|->
name|livewire
operator|->
name|y1
operator|||
name|iscissors
operator|->
name|y
operator|!=
name|iscissors
operator|->
name|livewire
operator|->
name|y2
operator|)
operator|)
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|g_slice_new
argument_list|(
name|ICurve
argument_list|)
decl_stmt|;
name|curve
operator|->
name|x1
operator|=
name|iscissors
operator|->
name|ix
expr_stmt|;
name|curve
operator|->
name|y1
operator|=
name|iscissors
operator|->
name|iy
expr_stmt|;
name|curve
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|curve
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|livewire
condition|)
block|{
if|if
condition|(
name|iscissors
operator|->
name|livewire
operator|->
name|points
condition|)
name|g_ptr_array_free
argument_list|(
name|iscissors
operator|->
name|livewire
operator|->
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|ICurve
argument_list|,
name|iscissors
operator|->
name|livewire
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|livewire
operator|=
name|NULL
expr_stmt|;
block|}
name|iscissors
operator|->
name|livewire
operator|=
name|curve
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|curve
argument_list|)
expr_stmt|;
block|}
comment|/*  plot the curve  */
name|iscissors_draw_curve
argument_list|(
name|draw_tool
argument_list|,
name|iscissors
operator|->
name|livewire
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_CURVE
operator|)
operator|&&
operator|!
name|iscissors
operator|->
name|first_point
condition|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
comment|/*  Draw a point at the init point coordinates  */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|connected
condition|)
block|{
name|gimp_draw_tool_draw_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_FILLED_CIRCLE
argument_list|,
name|iscissors
operator|->
name|ix
argument_list|,
name|iscissors
operator|->
name|iy
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/*  Go through the list of icurves, and render each one...  */
for|for
control|(
name|list
operator|=
name|g_queue_peek_head_link
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_ACTIVE_CURVE
condition|)
block|{
comment|/*  don't draw curve1 at all  */
if|if
condition|(
name|curve
operator|==
name|iscissors
operator|->
name|curve1
condition|)
continue|continue;
block|}
name|gimp_draw_tool_draw_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_FILLED_CIRCLE
argument_list|,
name|curve
operator|->
name|x1
argument_list|,
name|curve
operator|->
name|y1
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_ACTIVE_CURVE
condition|)
block|{
comment|/*  draw only the start handle of curve2  */
if|if
condition|(
name|curve
operator|==
name|iscissors
operator|->
name|curve2
condition|)
continue|continue;
block|}
comment|/*  plot the curve  */
name|iscissors_draw_curve
argument_list|(
name|draw_tool
argument_list|,
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_ACTIVE_CURVE
condition|)
block|{
comment|/*  plot both curves, and the control point between them  */
if|if
condition|(
name|iscissors
operator|->
name|curve1
condition|)
block|{
name|gimp_draw_tool_draw_line
argument_list|(
name|draw_tool
argument_list|,
name|iscissors
operator|->
name|curve1
operator|->
name|x2
argument_list|,
name|iscissors
operator|->
name|curve1
operator|->
name|y2
argument_list|,
name|iscissors
operator|->
name|nx
argument_list|,
name|iscissors
operator|->
name|ny
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iscissors
operator|->
name|curve2
condition|)
block|{
name|gimp_draw_tool_draw_line
argument_list|(
name|draw_tool
argument_list|,
name|iscissors
operator|->
name|curve2
operator|->
name|x1
argument_list|,
name|iscissors
operator|->
name|curve2
operator|->
name|y1
argument_list|,
name|iscissors
operator|->
name|nx
argument_list|,
name|iscissors
operator|->
name|ny
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|gimp_draw_tool_draw_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_FILLED_CIRCLE
argument_list|,
name|iscissors
operator|->
name|nx
argument_list|,
name|iscissors
operator|->
name|ny
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_draw_curve (GimpDrawTool * draw_tool,ICurve * curve)
name|iscissors_draw_curve
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
block|{
name|GimpVector2
modifier|*
name|points
decl_stmt|;
name|gpointer
modifier|*
name|point
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|curve
operator|->
name|points
condition|)
return|return;
name|len
operator|=
name|curve
operator|->
name|points
operator|->
name|len
expr_stmt|;
name|points
operator|=
name|g_new
argument_list|(
name|GimpVector2
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|point
operator|=
name|curve
operator|->
name|points
operator|->
name|pdata
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|point
operator|++
control|)
block|{
name|guint32
name|coords
init|=
name|GPOINTER_TO_INT
argument_list|(
operator|*
name|point
argument_list|)
decl_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|x
operator|=
operator|(
name|coords
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|points
index|[
name|i
index|]
operator|.
name|y
operator|=
operator|(
name|coords
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
name|gimp_draw_tool_draw_lines
argument_list|(
name|draw_tool
argument_list|,
name|points
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_oper_update (GimpTool * tool,const GimpCoords * coords,GdkModifierType state,gboolean proximity,GimpDisplay * display)
name|gimp_iscissors_tool_oper_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|gboolean
name|proximity
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GIMP_TOOL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|oper_update
argument_list|(
name|tool
argument_list|,
name|coords
argument_list|,
name|state
argument_list|,
name|proximity
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* parent sets a message in the status bar, but it will be replaced here */
if|if
condition|(
name|mouse_over_vertex
argument_list|(
name|iscissors
argument_list|,
name|coords
operator|->
name|x
argument_list|,
name|coords
operator|->
name|y
argument_list|)
operator|>
literal|1
condition|)
block|{
name|gchar
modifier|*
name|status
decl_stmt|;
name|status
operator|=
name|gimp_suggest_modifiers
argument_list|(
name|_
argument_list|(
literal|"Click-Drag to move this point"
argument_list|)
argument_list|,
name|GDK_SHIFT_MASK
operator|&
operator|~
name|state
argument_list|,
name|_
argument_list|(
literal|"%s: disable auto-snap"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
literal|"%s"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_MOVE_POINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mouse_over_curve
argument_list|(
name|iscissors
argument_list|,
name|coords
operator|->
name|x
argument_list|,
name|coords
operator|->
name|y
argument_list|)
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|g_queue_peek_head
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_draw_tool_on_handle
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|,
name|display
argument_list|,
name|RINT
argument_list|(
name|coords
operator|->
name|x
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|coords
operator|->
name|y
argument_list|)
argument_list|,
name|GIMP_HANDLE_CIRCLE
argument_list|,
name|curve
operator|->
name|x1
argument_list|,
name|curve
operator|->
name|y1
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
name|_
argument_list|(
literal|"Click to close the"
literal|" curve"
argument_list|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_CONNECT
expr_stmt|;
block|}
else|else
block|{
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
name|_
argument_list|(
literal|"Click to add a point"
literal|" on this segment"
argument_list|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_ADD_POINT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iscissors
operator|->
name|connected
operator|&&
name|iscissors
operator|->
name|mask
condition|)
block|{
if|if
condition|(
name|gimp_pickable_get_opacity_at
argument_list|(
name|GIMP_PICKABLE
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|coords
operator|->
name|x
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|coords
operator|->
name|y
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|proximity
condition|)
block|{
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
name|_
argument_list|(
literal|"Click or press Enter to convert to"
literal|" a selection"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_SELECT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|proximity
condition|)
block|{
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
name|_
argument_list|(
literal|"Press Enter to convert to a"
literal|" selection"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_IMPOSSIBLE
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|WAITING
case|:
if|if
condition|(
name|proximity
condition|)
block|{
name|gchar
modifier|*
name|status
decl_stmt|;
name|status
operator|=
name|gimp_suggest_modifiers
argument_list|(
name|_
argument_list|(
literal|"Click or Click-Drag to add a"
literal|" point"
argument_list|)
argument_list|,
name|GDK_SHIFT_MASK
operator|&
operator|~
name|state
argument_list|,
name|_
argument_list|(
literal|"%s: disable auto-snap"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_tool_replace_status
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
literal|"%s"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_ADD_POINT
expr_stmt|;
break|break;
default|default:
comment|/* if NO_ACTION, keep parent's status bar message (selection tool) */
name|iscissors
operator|->
name|op
operator|=
name|ISCISSORS_OP_NONE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_cursor_update (GimpTool * tool,const GimpCoords * coords,GdkModifierType state,GimpDisplay * display)
name|gimp_iscissors_tool_cursor_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpCursorModifier
name|modifier
init|=
name|GIMP_CURSOR_MODIFIER_NONE
decl_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|op
condition|)
block|{
case|case
name|ISCISSORS_OP_SELECT
case|:
block|{
name|GimpSelectionOptions
modifier|*
name|options
decl_stmt|;
name|options
operator|=
name|GIMP_SELECTION_TOOL_GET_OPTIONS
argument_list|(
name|tool
argument_list|)
expr_stmt|;
comment|/* Do not overwrite the modifiers for add, subtract, intersect */
if|if
condition|(
name|options
operator|->
name|operation
operator|==
name|GIMP_CHANNEL_OP_REPLACE
condition|)
block|{
name|modifier
operator|=
name|GIMP_CURSOR_MODIFIER_SELECT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ISCISSORS_OP_MOVE_POINT
case|:
name|modifier
operator|=
name|GIMP_CURSOR_MODIFIER_MOVE
expr_stmt|;
break|break;
case|case
name|ISCISSORS_OP_ADD_POINT
case|:
name|modifier
operator|=
name|GIMP_CURSOR_MODIFIER_PLUS
expr_stmt|;
break|break;
case|case
name|ISCISSORS_OP_CONNECT
case|:
name|modifier
operator|=
name|GIMP_CURSOR_MODIFIER_JOIN
expr_stmt|;
break|break;
case|case
name|ISCISSORS_OP_IMPOSSIBLE
case|:
name|modifier
operator|=
name|GIMP_CURSOR_MODIFIER_BAD
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|modifier
operator|!=
name|GIMP_CURSOR_MODIFIER_NONE
condition|)
block|{
name|gimp_tool_set_cursor
argument_list|(
name|tool
argument_list|,
name|display
argument_list|,
name|GIMP_CURSOR_MOUSE
argument_list|,
name|GIMP_TOOL_CURSOR_ISCISSORS
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GIMP_TOOL_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|cursor_update
argument_list|(
name|tool
argument_list|,
name|coords
argument_list|,
name|state
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_iscissors_tool_key_press (GimpTool * tool,GdkEventKey * kevent,GimpDisplay * display)
name|gimp_iscissors_tool_key_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventKey
modifier|*
name|kevent
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
if|if
condition|(
name|display
operator|!=
name|tool
operator|->
name|display
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|kevent
operator|->
name|keyval
condition|)
block|{
case|case
name|GDK_Return
case|:
case|case
name|GDK_KP_Enter
case|:
case|case
name|GDK_ISO_Enter
case|:
if|if
condition|(
name|iscissors
operator|->
name|connected
operator|&&
name|iscissors
operator|->
name|mask
condition|)
block|{
name|gimp_iscissors_tool_apply
argument_list|(
name|iscissors
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
case|case
name|GDK_Escape
case|:
name|gimp_tool_control
argument_list|(
name|tool
argument_list|,
name|GIMP_TOOL_ACTION_HALT
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_apply (GimpIscissorsTool * iscissors,GimpDisplay * display)
name|gimp_iscissors_tool_apply
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
init|=
name|GIMP_TOOL
argument_list|(
name|iscissors
argument_list|)
decl_stmt|;
name|GimpSelectionOptions
modifier|*
name|options
init|=
name|GIMP_SELECTION_TOOL_GET_OPTIONS
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|gimp_display_get_image
argument_list|(
name|display
argument_list|)
decl_stmt|;
comment|/*  Undraw the curve  */
name|gimp_tool_control_halt
argument_list|(
name|tool
operator|->
name|control
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_stop
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|tool
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_channel_select_channel
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|image
argument_list|)
argument_list|,
name|tool
operator|->
name|tool_info
operator|->
name|blurb
argument_list|,
name|iscissors
operator|->
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|options
operator|->
name|operation
argument_list|,
name|options
operator|->
name|feather
argument_list|,
name|options
operator|->
name|feather_radius
argument_list|,
name|options
operator|->
name|feather_radius
argument_list|)
expr_stmt|;
name|gimp_iscissors_tool_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|gimp_image_flush
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_iscissors_tool_reset (GimpIscissorsTool * iscissors)
name|gimp_iscissors_tool_reset
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|)
block|{
comment|/*  Free and reset the curve list  */
name|iscissors_free_icurves
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
expr_stmt|;
comment|/*  free mask  */
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
block|{
name|g_object_unref
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* free the gradient map */
if|if
condition|(
name|iscissors
operator|->
name|gradient_map
condition|)
block|{
comment|/* release any tile we were using */
if|if
condition|(
name|cur_tile
condition|)
block|{
name|tile_release
argument_list|(
name|cur_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cur_tile
operator|=
name|NULL
expr_stmt|;
block|}
name|tile_manager_unref
argument_list|(
name|iscissors
operator|->
name|gradient_map
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|gradient_map
operator|=
name|NULL
expr_stmt|;
block|}
name|iscissors
operator|->
name|curve1
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|first_point
operator|=
name|TRUE
expr_stmt|;
name|iscissors
operator|->
name|connected
operator|=
name|FALSE
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_NOTHING
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|NO_ACTION
expr_stmt|;
comment|/*  Reset the dp buffers  */
if|if
condition|(
name|iscissors
operator|->
name|dp_buf
condition|)
block|{
name|temp_buf_free
argument_list|(
name|iscissors
operator|->
name|dp_buf
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|dp_buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_free_icurves (GQueue * curves)
name|iscissors_free_icurves
parameter_list|(
name|GQueue
modifier|*
name|curves
parameter_list|)
block|{
while|while
condition|(
operator|!
name|g_queue_is_empty
argument_list|(
name|curves
argument_list|)
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|g_queue_pop_head
argument_list|(
name|curves
argument_list|)
decl_stmt|;
if|if
condition|(
name|curve
operator|->
name|points
condition|)
name|g_ptr_array_free
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|ICurve
argument_list|,
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX need some scan-conversion routines from somewhere.  maybe. ? */
end_comment

begin_function
specifier|static
name|gint
DECL|function|mouse_over_vertex (GimpIscissorsTool * iscissors,gdouble x,gdouble y)
name|mouse_over_vertex
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
name|gint
name|curves_found
init|=
literal|0
decl_stmt|;
comment|/*  traverse through the list, returning non-zero if the current cursor    *  position is on an existing curve vertex.  Set the curve1 and curve2    *  variables to the two curves containing the vertex in question    */
name|iscissors
operator|->
name|curve1
operator|=
name|iscissors
operator|->
name|curve2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|list
operator|=
name|g_queue_peek_head_link
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|gimp_draw_tool_on_handle
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|iscissors
argument_list|)
argument_list|,
name|GIMP_TOOL
argument_list|(
name|iscissors
argument_list|)
operator|->
name|display
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|GIMP_HANDLE_CIRCLE
argument_list|,
name|curve
operator|->
name|x1
argument_list|,
name|curve
operator|->
name|y1
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|iscissors
operator|->
name|curve1
operator|=
name|curve
expr_stmt|;
if|if
condition|(
name|curves_found
operator|++
condition|)
return|return
name|curves_found
return|;
block|}
elseif|else
if|if
condition|(
name|gimp_draw_tool_on_handle
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|iscissors
argument_list|)
argument_list|,
name|GIMP_TOOL
argument_list|(
name|iscissors
argument_list|)
operator|->
name|display
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|GIMP_HANDLE_CIRCLE
argument_list|,
name|curve
operator|->
name|x2
argument_list|,
name|curve
operator|->
name|y2
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|GTK_ANCHOR_CENTER
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|iscissors
operator|->
name|curve2
operator|=
name|curve
expr_stmt|;
if|if
condition|(
name|curves_found
operator|++
condition|)
return|return
name|curves_found
return|;
block|}
block|}
return|return
name|curves_found
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|clicked_on_vertex (GimpIscissorsTool * iscissors,gdouble x,gdouble y)
name|clicked_on_vertex
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gint
name|curves_found
init|=
literal|0
decl_stmt|;
name|curves_found
operator|=
name|mouse_over_vertex
argument_list|(
name|iscissors
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|curves_found
operator|>
literal|1
condition|)
block|{
comment|/*  undraw the curve  */
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|iscissors
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/*  if only one curve was found, the curves are unconnected, and    *  the user only wants to move either the first or last point    *  disallow this for now.    */
if|if
condition|(
name|curves_found
operator|==
literal|1
condition|)
return|return
name|FALSE
return|;
return|return
name|clicked_on_curve
argument_list|(
name|iscissors
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|mouse_over_curve (GimpIscissorsTool * iscissors,gdouble x,gdouble y)
name|mouse_over_curve
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|GList
modifier|*
name|list
decl_stmt|;
comment|/*  traverse through the list, returning the curve segment's list element    *  if the current cursor position is on a curve...    */
for|for
control|(
name|list
operator|=
name|g_queue_peek_head_link
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|list
operator|->
name|data
decl_stmt|;
name|gpointer
modifier|*
name|pt
decl_stmt|;
name|gint
name|len
decl_stmt|;
name|pt
operator|=
name|curve
operator|->
name|points
operator|->
name|pdata
expr_stmt|;
name|len
operator|=
name|curve
operator|->
name|points
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|guint32
name|coords
init|=
name|GPOINTER_TO_INT
argument_list|(
operator|*
name|pt
argument_list|)
decl_stmt|;
name|gint
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|pt
operator|++
expr_stmt|;
name|tx
operator|=
name|coords
operator|&
literal|0x0000ffff
expr_stmt|;
name|ty
operator|=
name|coords
operator|>>
literal|16
expr_stmt|;
comment|/*  Is the specified point close enough to the curve?  */
if|if
condition|(
name|gimp_draw_tool_in_radius
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|iscissors
argument_list|)
argument_list|,
name|GIMP_TOOL
argument_list|(
name|iscissors
argument_list|)
operator|->
name|display
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|POINT_WIDTH
operator|/
literal|2
argument_list|)
condition|)
block|{
return|return
name|list
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|clicked_on_curve (GimpIscissorsTool * iscissors,gdouble x,gdouble y)
name|clicked_on_curve
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|GList
modifier|*
name|list
init|=
name|mouse_over_curve
argument_list|(
name|iscissors
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
comment|/*  traverse through the list, getting back the curve segment's list    *  element if the current cursor position is on a curve...    *  If this occurs, replace the curve with two new curves,    *  separated by a new vertex.    */
if|if
condition|(
name|list
condition|)
block|{
name|ICurve
modifier|*
name|curve
init|=
name|list
operator|->
name|data
decl_stmt|;
name|ICurve
modifier|*
name|new_curve
decl_stmt|;
comment|/*  undraw the curve  */
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
name|GIMP_DRAW_TOOL
argument_list|(
name|iscissors
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Create the new curve  */
name|new_curve
operator|=
name|g_slice_new
argument_list|(
name|ICurve
argument_list|)
expr_stmt|;
name|new_curve
operator|->
name|x2
operator|=
name|curve
operator|->
name|x2
expr_stmt|;
name|new_curve
operator|->
name|y2
operator|=
name|curve
operator|->
name|y2
expr_stmt|;
name|new_curve
operator|->
name|x1
operator|=
name|curve
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|new_curve
operator|->
name|y1
operator|=
name|curve
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|new_curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/*  Create the new link and supply the new curve as data  */
name|g_queue_insert_after
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|,
name|list
argument_list|,
name|new_curve
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|curve1
operator|=
name|new_curve
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|=
name|curve
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_curve (GimpTool * tool,ICurve * curve)
name|calculate_curve
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
block|{
name|GimpIscissorsTool
modifier|*
name|iscissors
init|=
name|GIMP_ISCISSORS_TOOL
argument_list|(
name|tool
argument_list|)
decl_stmt|;
name|GimpDisplay
modifier|*
name|display
init|=
name|tool
operator|->
name|display
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|gimp_display_get_image
argument_list|(
name|display
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dir
decl_stmt|;
name|gint
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|ewidth
decl_stmt|,
name|eheight
decl_stmt|;
comment|/*  Calculate the lowest cost path from one vertex to the next as specified    *  by the parameter "curve".    *    Here are the steps:    *      1)  Calculate the appropriate working area for this operation    *      2)  Allocate a temp buf for the dynamic programming array    *      3)  Run the dynamic programming algorithm to find the optimal path    *      4)  Translate the optimal path into pixels in the icurve data    *            structure.    */
comment|/*  Get the bounding box  */
name|xs
operator|=
name|CLAMP
argument_list|(
name|curve
operator|->
name|x1
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ys
operator|=
name|CLAMP
argument_list|(
name|curve
operator|->
name|y1
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xe
operator|=
name|CLAMP
argument_list|(
name|curve
operator|->
name|x2
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ye
operator|=
name|CLAMP
argument_list|(
name|curve
operator|->
name|y2
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|MIN
argument_list|(
name|xs
argument_list|,
name|xe
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MIN
argument_list|(
name|ys
argument_list|,
name|ye
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MAX
argument_list|(
name|xs
argument_list|,
name|xe
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  +1 because if xe = 199& xs = 0, x2 - x1, width = 200  */
name|y2
operator|=
name|MAX
argument_list|(
name|ys
argument_list|,
name|ye
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  expand the boundaries past the ending points by    *  some percentage of width and height.  This serves the following purpose:    *  It gives the algorithm more area to search so better solutions    *  are found.  This is particularly helpful in finding "bumps" which    *  fall outside the bounding box represented by the start and end    *  coordinates of the "curve".    */
name|ewidth
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|EXTEND_BY
operator|+
name|FIXED
expr_stmt|;
name|eheight
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
operator|*
name|EXTEND_BY
operator|+
name|FIXED
expr_stmt|;
if|if
condition|(
name|xe
operator|>=
name|xs
condition|)
name|x2
operator|+=
name|CLAMP
argument_list|(
name|ewidth
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
operator|-
name|x2
argument_list|)
expr_stmt|;
else|else
name|x1
operator|-=
name|CLAMP
argument_list|(
name|ewidth
argument_list|,
literal|0
argument_list|,
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ye
operator|>=
name|ys
condition|)
name|y2
operator|+=
name|CLAMP
argument_list|(
name|eheight
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
operator|-
name|y2
argument_list|)
expr_stmt|;
else|else
name|y1
operator|-=
name|CLAMP
argument_list|(
name|eheight
argument_list|,
literal|0
argument_list|,
name|y1
argument_list|)
expr_stmt|;
comment|/* blow away any previous points list we might have */
if|if
condition|(
name|curve
operator|->
name|points
condition|)
block|{
name|g_ptr_array_free
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  If the bounding box has width and height...  */
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
condition|)
block|{
name|width
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|height
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
comment|/* Initialise the gradient map tile manager for this image if we        * don't already have one. */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|gradient_map
condition|)
name|iscissors
operator|->
name|gradient_map
operator|=
name|gradient_map_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*  allocate the dynamic programming array  */
name|iscissors
operator|->
name|dp_buf
operator|=
name|temp_buf_resize
argument_list|(
name|iscissors
operator|->
name|dp_buf
argument_list|,
literal|4
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/*  find the optimal path of pixels from (x1, y1) to (x2, y2)  */
name|find_optimal_path
argument_list|(
name|iscissors
operator|->
name|gradient_map
argument_list|,
name|iscissors
operator|->
name|dp_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|)
expr_stmt|;
comment|/*  get a list of the pixels in the optimal path  */
name|curve
operator|->
name|points
operator|=
name|plot_pixels
argument_list|(
name|iscissors
argument_list|,
name|iscissors
operator|->
name|dp_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
comment|/*  If the bounding box has no width  */
elseif|else
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  plot a vertical line  */
name|y
operator|=
name|ys
expr_stmt|;
name|dir
operator|=
operator|(
name|ys
operator|>
name|ye
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|y
operator|!=
name|ye
condition|)
block|{
name|g_ptr_array_add
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|GINT_TO_POINTER
argument_list|(
operator|(
name|y
operator|<<
literal|16
operator|)
operator|+
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|+=
name|dir
expr_stmt|;
block|}
block|}
comment|/*  If the bounding box has no height  */
elseif|else
if|if
condition|(
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  plot a horizontal line  */
name|x
operator|=
name|xs
expr_stmt|;
name|dir
operator|=
operator|(
name|xs
operator|>
name|xe
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|xe
condition|)
block|{
name|g_ptr_array_add
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|GINT_TO_POINTER
argument_list|(
operator|(
name|ys
operator|<<
literal|16
operator|)
operator|+
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|dir
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* badly need to get a replacement - this is _way_ too expensive */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|gradient_map_value (TileManager * map,gint x,gint y,guint8 * grad,guint8 * dir)
name|gradient_map_value
parameter_list|(
name|TileManager
modifier|*
name|map
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guint8
modifier|*
name|grad
parameter_list|,
name|guint8
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
name|gint
name|cur_tilex
decl_stmt|;
specifier|static
name|gint
name|cur_tiley
decl_stmt|;
specifier|const
name|guint8
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|cur_tile
operator|||
name|x
operator|/
name|TILE_WIDTH
operator|!=
name|cur_tilex
operator|||
name|y
operator|/
name|TILE_HEIGHT
operator|!=
name|cur_tiley
condition|)
block|{
if|if
condition|(
name|cur_tile
condition|)
name|tile_release
argument_list|(
name|cur_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cur_tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_tile
condition|)
return|return
name|FALSE
return|;
name|cur_tilex
operator|=
name|x
operator|/
name|TILE_WIDTH
expr_stmt|;
name|cur_tiley
operator|=
name|y
operator|/
name|TILE_HEIGHT
expr_stmt|;
block|}
name|p
operator|=
name|tile_data_pointer
argument_list|(
name|cur_tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|grad
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|dir
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|calculate_link (TileManager * gradient_map,gint x,gint y,guint32 pixel,gint link)
name|calculate_link
parameter_list|(
name|TileManager
modifier|*
name|gradient_map
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|guint32
name|pixel
parameter_list|,
name|gint
name|link
parameter_list|)
block|{
name|gint
name|value
init|=
literal|0
decl_stmt|;
name|guint8
name|grad1
decl_stmt|,
name|dir1
decl_stmt|,
name|grad2
decl_stmt|,
name|dir2
decl_stmt|;
if|if
condition|(
operator|!
name|gradient_map_value
argument_list|(
name|gradient_map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|grad1
argument_list|,
operator|&
name|dir1
argument_list|)
condition|)
block|{
name|grad1
operator|=
literal|0
expr_stmt|;
name|dir1
operator|=
literal|255
expr_stmt|;
block|}
comment|/* Convert the gradient into a cost: large gradients are good, and    * so have low cost. */
name|grad1
operator|=
literal|255
operator|-
name|grad1
expr_stmt|;
comment|/*  calculate the contribution of the gradient magnitude  */
if|if
condition|(
name|link
operator|>
literal|1
condition|)
name|value
operator|+=
name|diagonal_weight
index|[
name|grad1
index|]
operator|*
name|OMEGA_G
expr_stmt|;
else|else
name|value
operator|+=
name|grad1
operator|*
name|OMEGA_G
expr_stmt|;
comment|/*  calculate the contribution of the gradient direction  */
name|x
operator|+=
call|(
name|gint8
call|)
argument_list|(
name|pixel
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|y
operator|+=
call|(
name|gint8
call|)
argument_list|(
operator|(
name|pixel
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gradient_map_value
argument_list|(
name|gradient_map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|grad2
argument_list|,
operator|&
name|dir2
argument_list|)
condition|)
block|{
name|grad2
operator|=
literal|0
expr_stmt|;
name|dir2
operator|=
literal|255
expr_stmt|;
block|}
name|value
operator|+=
operator|(
name|direction_value
index|[
name|dir1
index|]
index|[
name|link
index|]
operator|+
name|direction_value
index|[
name|dir2
index|]
index|[
name|link
index|]
operator|)
operator|*
name|OMEGA_D
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|GPtrArray
modifier|*
DECL|function|plot_pixels (GimpIscissorsTool * iscissors,TempBuf * dp_buf,gint x1,gint y1,gint xs,gint ys,gint xe,gint ye)
name|plot_pixels
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|xs
parameter_list|,
name|gint
name|ys
parameter_list|,
name|gint
name|xe
parameter_list|,
name|gint
name|ye
parameter_list|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guint32
name|coords
decl_stmt|;
name|gint
name|link
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|guint
modifier|*
name|data
decl_stmt|;
name|GPtrArray
modifier|*
name|list
decl_stmt|;
name|width
operator|=
name|dp_buf
operator|->
name|width
expr_stmt|;
comment|/*  Start the data pointer at the correct location  */
name|data
operator|=
operator|(
name|guint
operator|*
operator|)
name|temp_buf_get_data
argument_list|(
name|dp_buf
argument_list|)
operator|+
operator|(
name|ye
operator|-
name|y1
operator|)
operator|*
name|width
operator|+
operator|(
name|xe
operator|-
name|x1
operator|)
expr_stmt|;
name|x
operator|=
name|xe
expr_stmt|;
name|y
operator|=
name|ye
expr_stmt|;
name|list
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|coords
operator|=
operator|(
name|y
operator|<<
literal|16
operator|)
operator|+
name|x
expr_stmt|;
name|g_ptr_array_add
argument_list|(
name|list
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|coords
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|PIXEL_DIR
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|SEED_POINT
condition|)
return|return
name|list
return|;
name|x
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|1
index|]
operator|*
name|width
operator|+
name|move
index|[
name|link
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*  won't get here  */
return|return
name|NULL
return|;
block|}
end_function

begin_define
DECL|macro|PACK (x,y)
define|#
directive|define
name|PACK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((((y)& 0xff)<< 8) | ((x)& 0xff))
end_define

begin_define
DECL|macro|OFFSET (pixel)
define|#
directive|define
name|OFFSET
parameter_list|(
name|pixel
parameter_list|)
value|((gint8)((pixel)& 0xff) + \   ((gint8)(((pixel)& 0xff00)>> 8)) * dp_buf->width)
end_define

begin_function
specifier|static
name|void
DECL|function|find_optimal_path (TileManager * gradient_map,TempBuf * dp_buf,gint x1,gint y1,gint x2,gint y2,gint xs,gint ys)
name|find_optimal_path
parameter_list|(
name|TileManager
modifier|*
name|gradient_map
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|xs
parameter_list|,
name|gint
name|ys
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|link
decl_stmt|;
name|gint
name|linkdir
decl_stmt|;
name|gint
name|dirx
decl_stmt|,
name|diry
decl_stmt|;
name|gint
name|min_cost
decl_stmt|;
name|gint
name|new_cost
decl_stmt|;
name|gint
name|offset
decl_stmt|;
name|gint
name|cum_cost
index|[
literal|8
index|]
decl_stmt|;
name|gint
name|link_cost
index|[
literal|8
index|]
decl_stmt|;
name|gint
name|pixel_cost
index|[
literal|8
index|]
decl_stmt|;
name|guint32
name|pixel
index|[
literal|8
index|]
decl_stmt|;
name|guint32
modifier|*
name|data
decl_stmt|;
name|guint32
modifier|*
name|d
decl_stmt|;
comment|/*  initialize the dynamic programming buffer  */
name|data
operator|=
operator|(
name|guint32
operator|*
operator|)
name|temp_buf_data_clear
argument_list|(
name|dp_buf
argument_list|)
expr_stmt|;
comment|/*  what directions are we filling the array in according to?  */
name|dirx
operator|=
operator|(
name|xs
operator|-
name|x1
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|diry
operator|=
operator|(
name|ys
operator|-
name|y1
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|linkdir
operator|=
operator|(
name|dirx
operator|*
name|diry
operator|)
expr_stmt|;
name|y
operator|=
name|ys
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp_buf
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|xs
expr_stmt|;
name|d
operator|=
name|data
operator|+
operator|(
name|y
operator|-
name|y1
operator|)
operator|*
name|dp_buf
operator|->
name|width
operator|+
operator|(
name|x
operator|-
name|x1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dp_buf
operator|->
name|width
condition|;
name|j
operator|++
control|)
block|{
name|min_cost
operator|=
name|G_MAXINT
expr_stmt|;
comment|/* pixel[] array encodes how to get to a neigbour, if possible.            * 0 means no connection (eg edge).            * Rest packed as bottom two bytes: y offset then x offset.            * Initially, we assume we can't get anywhere. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|pixel
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  Find the valid neighboring pixels  */
comment|/*  the previous pixel  */
if|if
condition|(
name|j
condition|)
name|pixel
index|[
operator|(
operator|(
name|dirx
operator|==
literal|1
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
index|]
operator|=
name|PACK
argument_list|(
operator|-
name|dirx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  the previous row of pixels  */
if|if
condition|(
name|i
condition|)
block|{
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
literal|5
else|:
literal|1
operator|)
index|]
operator|=
name|PACK
argument_list|(
literal|0
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
name|link
operator|=
operator|(
name|linkdir
operator|==
literal|1
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
operator|(
name|link
operator|+
literal|4
operator|)
else|:
name|link
operator|)
index|]
operator|=
name|PACK
argument_list|(
operator|-
name|dirx
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
name|link
operator|=
operator|(
name|linkdir
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|dp_buf
operator|->
name|width
operator|-
literal|1
condition|)
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
operator|(
name|link
operator|+
literal|4
operator|)
else|:
name|link
operator|)
index|]
operator|=
name|PACK
argument_list|(
name|dirx
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
block|}
comment|/*  find the minimum cost of going through each neighbor to reach the            *  seed point...            */
name|link
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|pixel
index|[
name|k
index|]
condition|)
block|{
name|link_cost
index|[
name|k
index|]
operator|=
name|calculate_link
argument_list|(
name|gradient_map
argument_list|,
name|xs
operator|+
name|j
operator|*
name|dirx
argument_list|,
name|ys
operator|+
name|i
operator|*
name|diry
argument_list|,
name|pixel
index|[
name|k
index|]
argument_list|,
operator|(
operator|(
name|k
operator|>
literal|3
operator|)
condition|?
name|k
operator|-
literal|4
else|:
name|k
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|OFFSET
argument_list|(
name|pixel
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|pixel_cost
index|[
name|k
index|]
operator|=
name|PIXEL_COST
argument_list|(
name|d
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|cum_cost
index|[
name|k
index|]
operator|=
name|pixel_cost
index|[
name|k
index|]
operator|+
name|link_cost
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cum_cost
index|[
name|k
index|]
operator|<
name|min_cost
condition|)
block|{
name|min_cost
operator|=
name|cum_cost
index|[
name|k
index|]
expr_stmt|;
name|link
operator|=
name|k
expr_stmt|;
block|}
block|}
comment|/*  If anything can be done...  */
if|if
condition|(
name|link
operator|>=
literal|0
condition|)
block|{
comment|/*  set the cumulative cost of this pixel and the new direction  */
operator|*
name|d
operator|=
operator|(
name|cum_cost
index|[
name|link
index|]
operator|<<
literal|8
operator|)
operator|+
name|link
expr_stmt|;
comment|/*  possibly change the links from the other pixels to this pixel...                *  these changes occur if a neighboring pixel will receive a lower                *  cumulative cost by going through this pixel.                */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|pixel
index|[
name|k
index|]
operator|&&
name|k
operator|!=
name|link
condition|)
block|{
comment|/*  if the cumulative cost at the neighbor is greater than                      *  the cost through the link to the current pixel, change the                      *  neighbor's link to point to the current pixel.                      */
name|new_cost
operator|=
name|link_cost
index|[
name|k
index|]
operator|+
name|cum_cost
index|[
name|link
index|]
expr_stmt|;
if|if
condition|(
name|pixel_cost
index|[
name|k
index|]
operator|>
name|new_cost
condition|)
block|{
comment|/*  reverse the link direction   /-----------------------\ */
name|offset
operator|=
name|OFFSET
argument_list|(
name|pixel
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|d
index|[
name|offset
index|]
operator|=
operator|(
name|new_cost
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|k
operator|>
literal|3
operator|)
condition|?
name|k
operator|-
literal|4
else|:
name|k
operator|+
literal|4
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  Set the seed point  */
elseif|else
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|j
condition|)
operator|*
name|d
operator|=
name|SEED_POINT
expr_stmt|;
comment|/*  increment the data pointer and the x counter  */
name|d
operator|+=
name|dirx
expr_stmt|;
name|x
operator|+=
name|dirx
expr_stmt|;
block|}
comment|/*  increment the y counter  */
name|y
operator|+=
name|diry
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called to fill in a newly referenced tile in the gradient map */
end_comment

begin_function
specifier|static
name|void
DECL|function|gradmap_tile_validate (TileManager * tm,Tile * tile,GimpImage * image)
name|gradmap_tile_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
specifier|static
name|gboolean
name|first_gradient
init|=
name|TRUE
decl_stmt|;
name|GimpPickable
modifier|*
name|pickable
decl_stmt|;
name|Tile
modifier|*
name|srctile
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|;
name|PixelRegion
name|destPR
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|dw
decl_stmt|,
name|dh
decl_stmt|;
name|gint
name|sw
decl_stmt|,
name|sh
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gfloat
name|gradient
decl_stmt|;
name|guint8
modifier|*
name|tiledata
decl_stmt|;
name|guint8
modifier|*
name|gradmap
decl_stmt|;
if|if
condition|(
name|first_gradient
condition|)
block|{
name|gint
name|radius
init|=
name|GRADIENT_SEARCH
operator|>>
literal|1
decl_stmt|;
comment|/*  compute the distance weights  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GRADIENT_SEARCH
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|GRADIENT_SEARCH
condition|;
name|j
operator|++
control|)
name|distance_weights
index|[
name|i
operator|*
name|GRADIENT_SEARCH
operator|+
name|j
index|]
operator|=
literal|1.0
operator|/
operator|(
literal|1
operator|+
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|i
operator|-
name|radius
argument_list|)
operator|+
name|SQR
argument_list|(
name|j
operator|-
name|radius
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|first_gradient
operator|=
name|FALSE
expr_stmt|;
block|}
name|tile_manager_get_tile_coordinates
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|dw
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|dh
operator|=
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|pickable
operator|=
name|GIMP_PICKABLE
argument_list|(
name|gimp_image_get_projection
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_pickable_flush
argument_list|(
name|pickable
argument_list|)
expr_stmt|;
comment|/* get corresponding tile in the image */
name|srctile
operator|=
name|tile_manager_get_tile
argument_list|(
name|gimp_pickable_get_tiles
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srctile
condition|)
return|return;
name|sw
operator|=
name|tile_ewidth
argument_list|(
name|srctile
argument_list|)
expr_stmt|;
name|sh
operator|=
name|tile_eheight
argument_list|(
name|srctile
argument_list|)
expr_stmt|;
name|pixel_region_init_data
argument_list|(
operator|&
name|srcPR
argument_list|,
name|tile_data_pointer
argument_list|(
name|srctile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gimp_pickable_get_bytes
argument_list|(
name|pickable
argument_list|)
argument_list|,
name|gimp_pickable_get_bytes
argument_list|(
name|pickable
argument_list|)
operator|*
name|MIN
argument_list|(
name|dw
argument_list|,
name|sw
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MIN
argument_list|(
name|dw
argument_list|,
name|sw
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|dh
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX tile edges? */
comment|/*  Blur the source to get rid of noise  */
name|pixel_region_init_data
argument_list|(
operator|&
name|destPR
argument_list|,
name|maxgrad_conv0
argument_list|,
literal|4
argument_list|,
name|TILE_WIDTH
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcPR
operator|.
name|w
argument_list|,
name|srcPR
operator|.
name|h
argument_list|)
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|blur_32
argument_list|,
literal|3
argument_list|,
literal|32
argument_list|,
name|GIMP_NORMAL_CONVOL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Use the blurred region as the new source pixel region  */
name|pixel_region_init_data
argument_list|(
operator|&
name|srcPR
argument_list|,
name|maxgrad_conv0
argument_list|,
literal|4
argument_list|,
name|TILE_WIDTH
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcPR
operator|.
name|w
argument_list|,
name|srcPR
operator|.
name|h
argument_list|)
expr_stmt|;
comment|/*  Get the horizontal derivative  */
name|pixel_region_init_data
argument_list|(
operator|&
name|destPR
argument_list|,
name|maxgrad_conv1
argument_list|,
literal|4
argument_list|,
name|TILE_WIDTH
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcPR
operator|.
name|w
argument_list|,
name|srcPR
operator|.
name|h
argument_list|)
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|horz_deriv
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|GIMP_NEGATIVE_CONVOL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Get the vertical derivative  */
name|pixel_region_init_data
argument_list|(
operator|&
name|destPR
argument_list|,
name|maxgrad_conv2
argument_list|,
literal|4
argument_list|,
name|TILE_WIDTH
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcPR
operator|.
name|w
argument_list|,
name|srcPR
operator|.
name|h
argument_list|)
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|vert_deriv
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|GIMP_NEGATIVE_CONVOL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* calculate overall gradient */
name|tiledata
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srcPR
operator|.
name|h
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|guint8
modifier|*
name|datah
init|=
name|maxgrad_conv1
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
name|i
decl_stmt|;
specifier|const
name|guint8
modifier|*
name|datav
init|=
name|maxgrad_conv2
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
name|i
decl_stmt|;
name|gradmap
operator|=
name|tiledata
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|COST_WIDTH
operator|*
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srcPR
operator|.
name|w
condition|;
name|j
operator|++
control|)
block|{
name|gint8
name|hmax
init|=
name|datah
index|[
literal|0
index|]
operator|-
literal|128
decl_stmt|;
name|gint8
name|vmax
init|=
name|datav
index|[
literal|0
index|]
operator|-
literal|128
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<
name|srcPR
operator|.
name|bytes
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|datah
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|hmax
argument_list|)
condition|)
name|hmax
operator|=
name|datah
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|datav
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|vmax
argument_list|)
condition|)
name|vmax
operator|=
name|datav
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|j
operator|==
literal|0
operator|||
name|i
operator|==
name|srcPR
operator|.
name|h
operator|-
literal|1
operator|||
name|j
operator|==
name|srcPR
operator|.
name|w
operator|-
literal|1
condition|)
block|{
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
comment|/* 1 byte absolute magnitude first */
name|gradient
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|hmax
argument_list|)
operator|+
name|SQR
argument_list|(
name|vmax
argument_list|)
argument_list|)
expr_stmt|;
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
index|]
operator|=
name|gradient
operator|*
literal|255
operator|/
name|MAX_GRADIENT
expr_stmt|;
comment|/* then 1 byte direction */
if|if
condition|(
name|gradient
operator|>
name|MIN_GRADIENT
condition|)
block|{
name|gfloat
name|direction
decl_stmt|;
if|if
condition|(
operator|!
name|hmax
condition|)
name|direction
operator|=
operator|(
name|vmax
operator|>
literal|0
operator|)
condition|?
name|G_PI_2
else|:
operator|-
name|G_PI_2
expr_stmt|;
else|else
name|direction
operator|=
name|atan
argument_list|(
operator|(
name|gdouble
operator|)
name|vmax
operator|/
operator|(
name|gdouble
operator|)
name|hmax
argument_list|)
expr_stmt|;
comment|/* Scale the direction from between 0 and 254,                *  corresponding to -PI/2, PI/2 255 is reserved for                *  d9irectionless pixels */
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
call|(
name|guint8
call|)
argument_list|(
literal|254
operator|*
operator|(
name|direction
operator|+
name|G_PI_2
operator|)
operator|/
name|G_PI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
comment|/* reserved for weak gradient */
block|}
name|contin
label|:
name|datah
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|datav
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
block|}
name|tile_release
argument_list|(
name|srctile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|TileManager
modifier|*
DECL|function|gradient_map_new (GimpImage * image)
name|gradient_map_new
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|tm
operator|=
name|tile_manager_new
argument_list|(
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|guint8
argument_list|)
operator|*
name|COST_WIDTH
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|tm
argument_list|,
operator|(
name|TileValidateProc
operator|)
name|gradmap_tile_validate
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
name|tm
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_max_gradient (GimpIscissorsTool * iscissors,GimpImage * image,gint * x,gint * y)
name|find_max_gradient
parameter_list|(
name|GimpIscissorsTool
modifier|*
name|iscissors
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|gint
name|radius
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gfloat
name|max_gradient
decl_stmt|;
comment|/* Initialise the gradient map tile manager for this image if we    * don't already have one. */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|gradient_map
condition|)
name|iscissors
operator|->
name|gradient_map
operator|=
name|gradient_map_new
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|radius
operator|=
name|GRADIENT_SEARCH
operator|>>
literal|1
expr_stmt|;
comment|/*  calculate the extent of the search  */
name|cx
operator|=
name|CLAMP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|cy
operator|=
name|CLAMP
argument_list|(
operator|*
name|y
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|sx
operator|=
name|cx
operator|-
name|radius
expr_stmt|;
name|sy
operator|=
name|cy
operator|-
name|radius
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|cx
operator|-
name|radius
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|cy
operator|-
name|radius
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|cx
operator|+
name|radius
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_width
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|cy
operator|+
name|radius
argument_list|,
literal|0
argument_list|,
name|gimp_image_get_height
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  calculate the factor to multiply the distance from the cursor by  */
name|max_gradient
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|=
name|cx
expr_stmt|;
operator|*
name|y
operator|=
name|cy
expr_stmt|;
comment|/*  Find the point of max gradient  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|iscissors
operator|->
name|gradient_map
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* this iterates over 1, 2 or 4 tiles only */
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|srcPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|endx
operator|=
name|srcPR
operator|.
name|x
operator|+
name|srcPR
operator|.
name|w
expr_stmt|;
name|endy
operator|=
name|srcPR
operator|.
name|y
operator|+
name|srcPR
operator|.
name|h
expr_stmt|;
for|for
control|(
name|i
operator|=
name|srcPR
operator|.
name|y
init|;
name|i
operator|<
name|endy
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|guint8
modifier|*
name|gradient
init|=
name|srcPR
operator|.
name|data
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
operator|(
name|i
operator|-
name|srcPR
operator|.
name|y
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|srcPR
operator|.
name|x
init|;
name|j
operator|<
name|endx
condition|;
name|j
operator|++
control|)
block|{
name|gfloat
name|g
init|=
operator|*
name|gradient
decl_stmt|;
name|gradient
operator|+=
name|COST_WIDTH
expr_stmt|;
name|g
operator|*=
name|distance_weights
index|[
operator|(
name|i
operator|-
name|y1
operator|)
operator|*
name|GRADIENT_SEARCH
operator|+
operator|(
name|j
operator|-
name|x1
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|g
operator|>
name|max_gradient
condition|)
block|{
name|max_gradient
operator|=
name|g
expr_stmt|;
operator|*
name|x
operator|=
name|j
expr_stmt|;
operator|*
name|y
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

