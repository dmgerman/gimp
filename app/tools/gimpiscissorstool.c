begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This tool is based on a paper from SIGGRAPH '95:  *  "Intelligent Scissors for Image Composition", Eric N. Mortensen and  *   William A. Barrett, Brigham Young University.  *  * thanks to Professor D. Forsyth for prompting us to implement this tool. */
end_comment

begin_comment
comment|/* The history of this implementation is lonog and varied.  It was  * orignally done by Spencer and Peter, and worked fine in the 0.54  * (motif only) release of the gimp.  Later revisions (0.99.something  * until about 1.1.4) completely changed the algorithm used, until it  * bore little resemblance to the one described in the paper above.  * The 0.54 version of the algorithm was then forwards ported to 1.1.4  * by Austin Donnelly.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"draw_core.h"
end_include

begin_include
include|#
directive|include
file|"channel_pvt.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"iscissors.h"
end_include

begin_include
include|#
directive|include
file|"edit_selection.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"rect_select.h"
end_include

begin_include
include|#
directive|include
file|"selection_options.h"
end_include

begin_include
include|#
directive|include
file|"temp_buf.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_include
include|#
directive|include
file|"bezier_selectP.h"
end_include

begin_include
include|#
directive|include
file|"scan_convert.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpmath.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_define
DECL|macro|D (x)
define|#
directive|define
name|D
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TRC (x)
define|#
directive|define
name|TRC
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
DECL|macro|D (x)
define|#
directive|define
name|D
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  local structures  */
end_comment

begin_typedef
DECL|typedef|ICurve
typedef|typedef
name|struct
name|_ICurve
name|ICurve
typedef|;
end_typedef

begin_struct
DECL|struct|_ICurve
struct|struct
name|_ICurve
block|{
DECL|member|x1
DECL|member|y1
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
DECL|member|x2
DECL|member|y2
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
DECL|member|points
name|GPtrArray
modifier|*
name|points
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  The possible states...  */
end_comment

begin_typedef
DECL|enum|__anon2a3eaf0e0103
typedef|typedef
enum|enum
block|{
DECL|enumerator|NO_ACTION
name|NO_ACTION
block|,
DECL|enumerator|SEED_PLACEMENT
name|SEED_PLACEMENT
block|,
DECL|enumerator|SEED_ADJUSTMENT
name|SEED_ADJUSTMENT
block|,
DECL|enumerator|WAITING
name|WAITING
DECL|typedef|Iscissors_state
block|}
name|Iscissors_state
typedef|;
end_typedef

begin_comment
comment|/*  The possible drawing states...  */
end_comment

begin_typedef
DECL|enum|__anon2a3eaf0e0203
typedef|typedef
enum|enum
block|{
DECL|enumerator|DRAW_NOTHING
name|DRAW_NOTHING
init|=
literal|0x0
block|,
DECL|enumerator|DRAW_CURRENT_SEED
name|DRAW_CURRENT_SEED
init|=
literal|0x1
block|,
DECL|enumerator|DRAW_CURVE
name|DRAW_CURVE
init|=
literal|0x2
block|,
DECL|enumerator|DRAW_ACTIVE_CURVE
name|DRAW_ACTIVE_CURVE
init|=
literal|0x4
DECL|typedef|Iscissors_draw
block|}
name|Iscissors_draw
typedef|;
end_typedef

begin_define
DECL|macro|DRAW_ALL
define|#
directive|define
name|DRAW_ALL
value|(DRAW_CURRENT_SEED | DRAW_CURVE)
end_define

begin_typedef
DECL|typedef|Iscissors
typedef|typedef
name|struct
name|_iscissors
name|Iscissors
typedef|;
end_typedef

begin_struct
DECL|struct|_iscissors
struct|struct
name|_iscissors
block|{
DECL|member|core
name|DrawCore
modifier|*
name|core
decl_stmt|;
comment|/*  Core select object               */
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/*  upper left hand coordinate       */
DECL|member|ix
DECL|member|iy
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
comment|/*  initial coordinates              */
DECL|member|nx
DECL|member|ny
name|int
name|nx
decl_stmt|,
name|ny
decl_stmt|;
comment|/*  new coordinates                  */
DECL|member|dp_buf
name|TempBuf
modifier|*
name|dp_buf
decl_stmt|;
comment|/*  dynamic programming buffer              */
DECL|member|curve1
name|ICurve
modifier|*
name|curve1
decl_stmt|;
comment|/*  1st curve connected to current point    */
DECL|member|curve2
name|ICurve
modifier|*
name|curve2
decl_stmt|;
comment|/*  2nd curve connected to current point    */
DECL|member|curves
name|GSList
modifier|*
name|curves
decl_stmt|;
comment|/*  the list of curves                      */
DECL|member|first_point
name|gboolean
name|first_point
decl_stmt|;
comment|/*  is this the first point?                */
DECL|member|connected
name|gboolean
name|connected
decl_stmt|;
comment|/*  is the region closed?                   */
DECL|member|state
name|Iscissors_state
name|state
decl_stmt|;
comment|/*  state of iscissors               */
DECL|member|draw
name|Iscissors_draw
name|draw
decl_stmt|;
comment|/*  items to draw on a draw request         */
comment|/* XXX might be useful */
DECL|member|mask
name|Channel
modifier|*
name|mask
decl_stmt|;
comment|/*  selection mask                   */
DECL|member|gradient_map
name|TileManager
modifier|*
name|gradient_map
decl_stmt|;
comment|/*  lazily filled gradient map */
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|IScissorsOptions
typedef|typedef
name|struct
name|_IScissorsOptions
name|IScissorsOptions
typedef|;
end_typedef

begin_struct
DECL|struct|_IScissorsOptions
struct|struct
name|_IScissorsOptions
block|{
DECL|member|selection_options
name|SelectionOptions
name|selection_options
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**********************************************/
end_comment

begin_comment
comment|/*  Intelligent scissors selection apparatus  */
end_comment

begin_comment
comment|/*  Other defines...  */
end_comment

begin_define
DECL|macro|MAX_GRADIENT
define|#
directive|define
name|MAX_GRADIENT
value|179.606
end_define

begin_comment
DECL|macro|MAX_GRADIENT
comment|/* == sqrt(127^2 + 127^2) */
end_comment

begin_define
DECL|macro|GRADIENT_SEARCH
define|#
directive|define
name|GRADIENT_SEARCH
value|32
end_define

begin_comment
DECL|macro|GRADIENT_SEARCH
comment|/* how far to look when snapping to an edge */
end_comment

begin_define
DECL|macro|TARGET_HEIGHT
define|#
directive|define
name|TARGET_HEIGHT
value|25
end_define

begin_define
DECL|macro|TARGET_WIDTH
define|#
directive|define
name|TARGET_WIDTH
value|25
end_define

begin_define
DECL|macro|POINT_WIDTH
define|#
directive|define
name|POINT_WIDTH
value|8
end_define

begin_comment
DECL|macro|POINT_WIDTH
comment|/* size (in pixels) of seed handles */
end_comment

begin_define
DECL|macro|POINT_HALFWIDTH
define|#
directive|define
name|POINT_HALFWIDTH
value|(POINT_WIDTH / 2)
end_define

begin_define
DECL|macro|EXTEND_BY
define|#
directive|define
name|EXTEND_BY
value|0.2
end_define

begin_comment
DECL|macro|EXTEND_BY
comment|/* proportion to expand cost map by */
end_comment

begin_define
DECL|macro|FIXED
define|#
directive|define
name|FIXED
value|5
end_define

begin_comment
DECL|macro|FIXED
comment|/* additional fixed size to expand cost map */
end_comment

begin_define
DECL|macro|MIN_GRADIENT
define|#
directive|define
name|MIN_GRADIENT
value|63
end_define

begin_comment
DECL|macro|MIN_GRADIENT
comment|/* gradients< this are directionless */
end_comment

begin_define
DECL|macro|MAX_POINTS
define|#
directive|define
name|MAX_POINTS
value|2048
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LAPLACIAN
end_ifdef

begin_define
DECL|macro|COST_WIDTH
define|#
directive|define
name|COST_WIDTH
value|3
end_define

begin_comment
DECL|macro|COST_WIDTH
comment|/* number of bytes for each pixel in cost map  */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|COST_WIDTH
define|#
directive|define
name|COST_WIDTH
value|2
end_define

begin_comment
DECL|macro|COST_WIDTH
comment|/* number of bytes for each pixel in cost map  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|BLOCK_WIDTH
define|#
directive|define
name|BLOCK_WIDTH
value|64
end_define

begin_define
DECL|macro|BLOCK_HEIGHT
define|#
directive|define
name|BLOCK_HEIGHT
value|64
end_define

begin_define
DECL|macro|CONV_WIDTH
define|#
directive|define
name|CONV_WIDTH
value|(BLOCK_WIDTH + 2)
end_define

begin_define
DECL|macro|CONV_HEIGHT
define|#
directive|define
name|CONV_HEIGHT
value|(BLOCK_HEIGHT + 2)
end_define

begin_comment
comment|/* weight to give between laplacian (_Z), gradient (_G) and direction (_D) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LAPLACIAN
end_ifdef

begin_define
DECL|macro|OMEGA_Z
define|#
directive|define
name|OMEGA_Z
value|0.16
end_define

begin_define
DECL|macro|OMEGA_D
define|#
directive|define
name|OMEGA_D
value|0.42
end_define

begin_define
DECL|macro|OMEGA_G
define|#
directive|define
name|OMEGA_G
value|0.42
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|OMEGA_D
define|#
directive|define
name|OMEGA_D
value|0.2
end_define

begin_define
DECL|macro|OMEGA_G
define|#
directive|define
name|OMEGA_G
value|0.8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sentinel to mark seed point in ?cost? map */
end_comment

begin_define
DECL|macro|SEED_POINT
define|#
directive|define
name|SEED_POINT
value|9
end_define

begin_comment
comment|/*  Functional defines  */
end_comment

begin_define
DECL|macro|PIXEL_COST (x)
define|#
directive|define
name|PIXEL_COST
parameter_list|(
name|x
parameter_list|)
value|(x>> 8)
end_define

begin_define
DECL|macro|PIXEL_DIR (x)
define|#
directive|define
name|PIXEL_DIR
parameter_list|(
name|x
parameter_list|)
value|(x& 0x000000ff)
end_define

begin_comment
comment|/*  static variables  */
end_comment

begin_comment
comment|/*  where to move on a given link direction  */
end_comment

begin_decl_stmt
DECL|variable|move
specifier|static
name|int
name|move
index|[
literal|8
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IE:  * '---+---+---`  * | 7 | 5 | 6 |  * +---+---+---+  * | 4 |   | 0 |  * +---+---+---+  * | 2 | 1 | 3 |  * `---+---+---'  */
end_comment

begin_comment
comment|/*  points for drawing curves  */
end_comment

begin_decl_stmt
DECL|variable|curve_points
specifier|static
name|GdkPoint
name|curve_points
index|[
name|MAX_POINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  temporary convolution buffers --  */
end_comment

begin_macro
name|D
argument_list|(
argument|static unsigned int sent0 =
literal|0xd0d0d0d0
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
DECL|variable|maxgrad_conv0
specifier|static
name|unsigned
name|char
name|maxgrad_conv0
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_macro
name|D
argument_list|(
argument|static unsigned int sent1 =
literal|0xd1d1d1d1
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
DECL|variable|maxgrad_conv1
specifier|static
name|unsigned
name|char
name|maxgrad_conv1
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_macro
name|D
argument_list|(
argument|static unsigned int sent2 =
literal|0xd2d2d2d2
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
DECL|variable|maxgrad_conv2
specifier|static
name|unsigned
name|char
name|maxgrad_conv2
index|[
name|TILE_WIDTH
operator|*
name|TILE_HEIGHT
operator|*
literal|4
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_macro
name|D
argument_list|(
argument|static unsigned int sent3 =
literal|0xd3d3d3d3
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
DECL|variable|horz_deriv
specifier|static
name|int
name|horz_deriv
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|,
operator|-
literal|2
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vert_deriv
specifier|static
name|int
name|vert_deriv
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LAPLACIAN
end_ifdef

begin_decl_stmt
DECL|variable|laplacian
specifier|static
name|int
name|laplacian
index|[
literal|9
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
DECL|variable|blur_32
specifier|static
name|int
name|blur_32
index|[
literal|9
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|24
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|distance_weights
specifier|static
name|float
name|distance_weights
index|[
name|GRADIENT_SEARCH
operator|*
name|GRADIENT_SEARCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|diagonal_weight
specifier|static
name|int
name|diagonal_weight
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|direction_value
specifier|static
name|int
name|direction_value
index|[
literal|256
index|]
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|initialized
specifier|static
name|gboolean
name|initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_tile
specifier|static
name|Tile
modifier|*
name|cur_tile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* static variables */
end_comment

begin_decl_stmt
DECL|variable|iscissors_options
specifier|static
name|IScissorsOptions
modifier|*
name|iscissors_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|iscissors_button_press
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_button_release
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventButton
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_motion
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|GdkEventMotion
modifier|*
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_control
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|ToolAction
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_reset
parameter_list|(
name|Iscissors
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TileManager
modifier|*
name|gradient_map_new
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_optimal_path
parameter_list|(
name|TileManager
modifier|*
parameter_list|,
name|TempBuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_max_gradient
parameter_list|(
name|Iscissors
modifier|*
parameter_list|,
name|GImage
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_curve
parameter_list|(
name|Tool
modifier|*
parameter_list|,
name|ICurve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_draw_curve
parameter_list|(
name|GDisplay
modifier|*
parameter_list|,
name|Iscissors
modifier|*
parameter_list|,
name|ICurve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_free_icurves
parameter_list|(
name|GSList
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscissors_free_buffers
parameter_list|(
name|Iscissors
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clicked_on_vertex
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clicked_on_curve
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|precalculate_arrays
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GPtrArray
modifier|*
name|plot_pixels
parameter_list|(
name|Iscissors
modifier|*
parameter_list|,
name|TempBuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
DECL|function|iscissors_options_reset (void)
name|iscissors_options_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|IScissorsOptions
modifier|*
name|options
init|=
name|iscissors_options
decl_stmt|;
name|selection_options_reset
argument_list|(
operator|(
name|SelectionOptions
operator|*
operator|)
name|options
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|IScissorsOptions
modifier|*
DECL|function|iscissors_options_new (void)
name|iscissors_options_new
parameter_list|(
name|void
parameter_list|)
block|{
name|IScissorsOptions
modifier|*
name|options
decl_stmt|;
comment|/*  the new intelligent scissors tool options structure  */
name|options
operator|=
name|g_new
argument_list|(
name|IScissorsOptions
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|selection_options_init
argument_list|(
operator|(
name|SelectionOptions
operator|*
operator|)
name|options
argument_list|,
name|ISCISSORS
argument_list|,
name|iscissors_options_reset
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_iscissors (void)
name|tools_new_iscissors
parameter_list|(
name|void
parameter_list|)
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|Iscissors
modifier|*
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|iscissors_options
condition|)
block|{
name|iscissors_options
operator|=
name|iscissors_options_new
argument_list|()
expr_stmt|;
name|tools_register
argument_list|(
name|ISCISSORS
argument_list|,
operator|(
name|ToolOptions
operator|*
operator|)
name|iscissors_options
argument_list|)
expr_stmt|;
block|}
name|tool
operator|=
name|tools_new_tool
argument_list|(
name|ISCISSORS
argument_list|)
expr_stmt|;
name|private
operator|=
name|g_new
argument_list|(
name|Iscissors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|private
operator|->
name|core
operator|=
name|draw_core_new
argument_list|(
name|iscissors_draw
argument_list|)
expr_stmt|;
name|private
operator|->
name|curves
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|dp_buf
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|state
operator|=
name|NO_ACTION
expr_stmt|;
name|private
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|gradient_map
operator|=
name|NULL
expr_stmt|;
name|tool
operator|->
name|auto_snap_to
operator|=
name|FALSE
expr_stmt|;
comment|/*  Don't snap to guides   */
name|tool
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|private
expr_stmt|;
name|tool
operator|->
name|button_press_func
operator|=
name|iscissors_button_press
expr_stmt|;
name|tool
operator|->
name|button_release_func
operator|=
name|iscissors_button_release
expr_stmt|;
name|tool
operator|->
name|motion_func
operator|=
name|iscissors_motion
expr_stmt|;
name|tool
operator|->
name|cursor_update_func
operator|=
name|rect_select_cursor_update
expr_stmt|;
name|tool
operator|->
name|control_func
operator|=
name|iscissors_control
expr_stmt|;
name|iscissors_reset
argument_list|(
name|private
argument_list|)
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_iscissors (Tool * tool)
name|tools_free_iscissors
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"tools_free_iscissors\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  XXX? Undraw curve  */
comment|/*iscissors->draw = DRAW_CURVE;*/
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|draw_core_free
argument_list|(
name|iscissors
operator|->
name|core
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Local functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|iscissors_button_press (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|iscissors_button_press
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|int
name|grab_pointer
init|=
literal|0
decl_stmt|;
name|int
name|replace
decl_stmt|,
name|op
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|drawable
operator|=
name|gimage_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp_ptr
operator|!=
name|tool
operator|->
name|gdisp_ptr
condition|)
block|{
comment|/*iscissors->draw = DRAW_CURVE; XXX? */
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
block|}
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp_ptr
operator|=
name|gdisp_ptr
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|NO_ACTION
case|:
if|#
directive|if
literal|0
comment|/* XXX what's this supposed to do? */
block|if (!(bevent->state& GDK_SHIFT_MASK)&& 	  !(bevent->state& GDK_CONTROL_MASK)) 	if (selection_point_inside (gdisp->select, gdisp_ptr, bevent->x, bevent->y)) 	  { 	    init_edit_selection (tool, gdisp->select, gdisp_ptr, bevent->x, bevent->y); 	    return; 	  }
endif|#
directive|endif
name|iscissors
operator|->
name|state
operator|=
name|SEED_PLACEMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
name|grab_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|gdisp
operator|->
name|gimage
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|ix
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
comment|/*  Initialize the selection core only on starting the tool  */
name|draw_core_start
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|/*  Check if the mouse click occured on a vertex or the curve itself  */
if|if
condition|(
name|clicked_on_vertex
argument_list|(
name|tool
argument_list|)
condition|)
block|{
name|iscissors
operator|->
name|nx
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|ny
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|SEED_ADJUSTMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_ACTIVE_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  If the iscissors is connected, check if the click was inside  */
elseif|else
if|if
condition|(
name|iscissors
operator|->
name|connected
operator|&&
name|iscissors
operator|->
name|mask
operator|&&
name|channel_value
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|)
condition|)
block|{
comment|/*  Undraw the curve  */
name|tool
operator|->
name|state
operator|=
name|INACTIVE
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
name|op
operator|=
name|ADD
expr_stmt|;
elseif|else
if|if
condition|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
condition|)
name|op
operator|=
name|SUB
expr_stmt|;
else|else
block|{
name|op
operator|=
name|ADD
expr_stmt|;
name|replace
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SelectionOptions
operator|*
operator|)
name|iscissors_options
operator|)
operator|->
name|feather
condition|)
name|channel_feather
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|,
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
operator|(
operator|(
name|SelectionOptions
operator|*
operator|)
name|iscissors_options
operator|)
operator|->
name|feather_radius
argument_list|,
operator|(
operator|(
name|SelectionOptions
operator|*
operator|)
name|iscissors_options
operator|)
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|channel_combine_mask
argument_list|(
name|gimage_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|iscissors
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
name|selection_start
argument_list|(
name|gdisp
operator|->
name|select
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/*  if we're not connected, we're adding a new point  */
elseif|else
if|if
condition|(
operator|!
name|iscissors
operator|->
name|connected
condition|)
block|{
name|iscissors
operator|->
name|state
operator|=
name|SEED_PLACEMENT
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
name|grab_pointer
operator|=
literal|1
expr_stmt|;
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_convert (Iscissors * iscissors,gpointer gdisp_ptr)
name|iscissors_convert
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
init|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
decl_stmt|;
name|ScanConverter
modifier|*
name|sc
decl_stmt|;
name|ScanConvertPoint
modifier|*
name|pts
decl_stmt|;
name|guint
name|npts
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|ICurve
modifier|*
name|icurve
decl_stmt|;
name|guint
name|packed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
name|sc
operator|=
name|scan_converter_new
argument_list|(
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* go over the curves in reverse order, adding the points we have */
name|list
operator|=
name|iscissors
operator|->
name|curves
expr_stmt|;
name|index
operator|=
name|g_slist_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
condition|)
block|{
name|index
operator|--
expr_stmt|;
name|icurve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|g_slist_nth_data
argument_list|(
name|list
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|npts
operator|=
name|icurve
operator|->
name|points
operator|->
name|len
expr_stmt|;
name|pts
operator|=
name|g_new
argument_list|(
name|ScanConvertPoint
argument_list|,
name|npts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|packed
operator|=
name|GPOINTER_TO_INT
argument_list|(
name|g_ptr_array_index
argument_list|(
name|icurve
operator|->
name|points
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|=
name|packed
operator|&
literal|0x0000ffff
expr_stmt|;
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|=
name|packed
operator|>>
literal|16
expr_stmt|;
block|}
name|scan_converter_add_points
argument_list|(
name|sc
argument_list|,
name|npts
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|scan_converter_to_channel
argument_list|(
name|sc
argument_list|,
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|scan_converter_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|channel_invalidate_bounds
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_button_release (Tool * tool,GdkEventButton * bevent,gpointer gdisp_ptr)
name|iscissors_button_release
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|ICurve
modifier|*
name|curve
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"iscissors_button_release\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure X didn't skip the button release event -- as it's known    * to do */
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|WAITING
condition|)
return|return;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
comment|/* XXX why the flush? */
comment|/*  Undraw everything  */
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_CURRENT_SEED
expr_stmt|;
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_ACTIVE_CURVE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/*  First take care of the case where the user "cancels" the action  */
if|if
condition|(
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_BUTTON3_MASK
operator|)
condition|)
block|{
comment|/*  Progress to the next stage of intelligent selection  */
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
comment|/*  Add a new icurve  */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|first_point
condition|)
block|{
comment|/*  Determine if we're connecting to the first point  */
if|if
condition|(
name|iscissors
operator|->
name|curves
condition|)
block|{
name|curve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|iscissors
operator|->
name|curves
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|iscissors
operator|->
name|x
operator|-
name|curve
operator|->
name|x1
argument_list|)
operator|<
name|POINT_HALFWIDTH
operator|&&
name|abs
argument_list|(
name|iscissors
operator|->
name|y
operator|-
name|curve
operator|->
name|y1
argument_list|)
operator|<
name|POINT_HALFWIDTH
condition|)
block|{
name|iscissors
operator|->
name|x
operator|=
name|curve
operator|->
name|x1
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|curve
operator|->
name|y1
expr_stmt|;
name|iscissors
operator|->
name|connected
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/*  Create the new curve segment  */
if|if
condition|(
name|iscissors
operator|->
name|ix
operator|!=
name|iscissors
operator|->
name|x
operator|||
name|iscissors
operator|->
name|iy
operator|!=
name|iscissors
operator|->
name|y
condition|)
block|{
name|curve
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ICurve
argument_list|)
argument_list|)
expr_stmt|;
name|curve
operator|->
name|x1
operator|=
name|iscissors
operator|->
name|ix
expr_stmt|;
name|curve
operator|->
name|y1
operator|=
name|iscissors
operator|->
name|iy
expr_stmt|;
name|iscissors
operator|->
name|ix
operator|=
name|curve
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|curve
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"create new curve segment\n"
operator|)
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|curves
operator|=
name|g_slist_append
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curve
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"calculate curve\n"
operator|)
argument_list|)
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* this was our first point */
block|{
name|iscissors
operator|->
name|first_point
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
comment|/*  recalculate both curves  */
if|if
condition|(
name|iscissors
operator|->
name|curve1
condition|)
block|{
name|iscissors
operator|->
name|curve1
operator|->
name|x1
operator|=
name|iscissors
operator|->
name|nx
expr_stmt|;
name|iscissors
operator|->
name|curve1
operator|->
name|y1
operator|=
name|iscissors
operator|->
name|ny
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|iscissors
operator|->
name|curve1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iscissors
operator|->
name|curve2
condition|)
block|{
name|iscissors
operator|->
name|curve2
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|nx
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|ny
expr_stmt|;
name|calculate_curve
argument_list|(
name|tool
argument_list|,
name|iscissors
operator|->
name|curve2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|TRC
argument_list|(
operator|(
literal|"button_release: draw core resume\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  Draw only the boundary  */
name|iscissors
operator|->
name|state
operator|=
name|WAITING
expr_stmt|;
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/*  convert the curves into a region  */
if|if
condition|(
name|iscissors
operator|->
name|connected
condition|)
name|iscissors_convert
argument_list|(
name|iscissors
argument_list|,
name|gdisp_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_motion (Tool * tool,GdkEventMotion * mevent,gpointer gdisp_ptr)
name|iscissors_motion
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
operator|||
name|iscissors
operator|->
name|state
operator|==
name|NO_ACTION
condition|)
return|return;
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|SEED_PLACEMENT
condition|)
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURRENT_SEED
expr_stmt|;
elseif|else
if|if
condition|(
name|iscissors
operator|->
name|state
operator|==
name|SEED_ADJUSTMENT
condition|)
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_ACTIVE_CURVE
expr_stmt|;
name|draw_core_pause
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
comment|/*  Hold the shift key down to disable the auto-edge snap feature  */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|gdisp
operator|->
name|gimage
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscissors
operator|->
name|first_point
condition|)
block|{
name|iscissors
operator|->
name|ix
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|iy
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
block|}
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
comment|/*  Move the current seed to the location of the cursor  */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|find_max_gradient
argument_list|(
name|iscissors
argument_list|,
name|gdisp
operator|->
name|gimage
argument_list|,
operator|&
name|iscissors
operator|->
name|x
argument_list|,
operator|&
name|iscissors
operator|->
name|y
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|x
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|y
operator|=
name|BOUNDS
argument_list|(
name|iscissors
operator|->
name|y
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|nx
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|iscissors
operator|->
name|ny
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
break|break;
default|default :
break|break;
block|}
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_draw (Tool * tool)
name|iscissors_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|ICurve
modifier|*
name|curve
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|tx1
decl_stmt|,
name|ty1
decl_stmt|,
name|tx2
decl_stmt|,
name|ty2
decl_stmt|;
name|int
name|txn
decl_stmt|,
name|tyn
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"iscissors_draw\n"
operator|)
argument_list|)
expr_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|iscissors
operator|->
name|ix
argument_list|,
name|iscissors
operator|->
name|iy
argument_list|,
operator|&
name|tx1
argument_list|,
operator|&
name|ty1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  Draw the crosshairs target if we're placing a seed  */
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_CURRENT_SEED
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|iscissors
operator|->
name|x
argument_list|,
name|iscissors
operator|->
name|y
argument_list|,
operator|&
name|tx2
argument_list|,
operator|&
name|ty2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|tx2
operator|-
operator|(
name|TARGET_WIDTH
operator|>>
literal|1
operator|)
argument_list|,
name|ty2
argument_list|,
name|tx2
operator|+
operator|(
name|TARGET_WIDTH
operator|>>
literal|1
operator|)
argument_list|,
name|ty2
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|tx2
argument_list|,
name|ty2
operator|-
operator|(
name|TARGET_HEIGHT
operator|>>
literal|1
operator|)
argument_list|,
name|tx2
argument_list|,
name|ty2
operator|+
operator|(
name|TARGET_HEIGHT
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iscissors
operator|->
name|first_point
condition|)
name|gdk_draw_line
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
name|tx2
argument_list|,
name|ty2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_CURVE
operator|)
operator|&&
operator|!
name|iscissors
operator|->
name|first_point
condition|)
block|{
comment|/*  Draw a point at the init point coordinates  */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|connected
condition|)
name|gdk_draw_arc
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|tx1
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|ty1
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
comment|/*  Go through the list of icurves, and render each one...  */
name|list
operator|=
name|iscissors
operator|->
name|curves
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|curve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  plot the curve  */
name|iscissors_draw_curve
argument_list|(
name|gdisp
argument_list|,
name|iscissors
argument_list|,
name|curve
argument_list|)
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|curve
operator|->
name|x1
argument_list|,
name|curve
operator|->
name|y1
argument_list|,
operator|&
name|tx1
argument_list|,
operator|&
name|ty1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdk_draw_arc
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|tx1
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|ty1
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iscissors
operator|->
name|draw
operator|&
name|DRAW_ACTIVE_CURVE
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|iscissors
operator|->
name|nx
argument_list|,
name|iscissors
operator|->
name|ny
argument_list|,
operator|&
name|txn
argument_list|,
operator|&
name|tyn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  plot both curves, and the control point between them  */
if|if
condition|(
name|iscissors
operator|->
name|curve1
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|iscissors
operator|->
name|curve1
operator|->
name|x2
argument_list|,
name|iscissors
operator|->
name|curve1
operator|->
name|y2
argument_list|,
operator|&
name|tx1
argument_list|,
operator|&
name|ty1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
name|txn
argument_list|,
name|tyn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iscissors
operator|->
name|curve2
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|iscissors
operator|->
name|curve2
operator|->
name|x1
argument_list|,
name|iscissors
operator|->
name|curve2
operator|->
name|y1
argument_list|,
operator|&
name|tx2
argument_list|,
operator|&
name|ty2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|tx2
argument_list|,
name|ty2
argument_list|,
name|txn
argument_list|,
name|tyn
argument_list|)
expr_stmt|;
block|}
name|gdk_draw_arc
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
literal|1
argument_list|,
name|txn
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|tyn
operator|-
name|POINT_HALFWIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
name|POINT_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_draw_curve (GDisplay * gdisp,Iscissors * iscissors,ICurve * curve)
name|iscissors_draw_curve
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
block|{
name|gpointer
modifier|*
name|point
decl_stmt|;
name|guint
name|len
decl_stmt|;
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|int
name|npts
decl_stmt|;
name|guint32
name|coords
decl_stmt|;
comment|/* Uh, this shouldn't happen, but it does.  So we ignore it.    * Quality code, baby. */
if|if
condition|(
operator|!
name|curve
operator|->
name|points
condition|)
return|return;
name|npts
operator|=
literal|0
expr_stmt|;
name|point
operator|=
name|curve
operator|->
name|points
operator|->
name|pdata
expr_stmt|;
name|len
operator|=
name|curve
operator|->
name|points
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|coords
operator|=
name|GPOINTER_TO_INT
argument_list|(
operator|*
name|point
argument_list|)
expr_stmt|;
name|point
operator|++
expr_stmt|;
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
operator|(
name|coords
operator|&
literal|0x0000ffff
operator|)
argument_list|,
operator|(
name|coords
operator|>>
literal|16
operator|)
argument_list|,
operator|&
name|tx
argument_list|,
operator|&
name|ty
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|npts
operator|<
name|MAX_POINTS
condition|)
block|{
name|curve_points
index|[
name|npts
index|]
operator|.
name|x
operator|=
name|tx
expr_stmt|;
name|curve_points
index|[
name|npts
index|]
operator|.
name|y
operator|=
name|ty
expr_stmt|;
name|npts
operator|++
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"too many points in ICurve segment!"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*  draw the curve */
name|gdk_draw_lines
argument_list|(
name|iscissors
operator|->
name|core
operator|->
name|win
argument_list|,
name|iscissors
operator|->
name|core
operator|->
name|gc
argument_list|,
name|curve_points
argument_list|,
name|npts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_control (Tool * tool,ToolAction action,gpointer gdisp_ptr)
name|iscissors_control
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|ToolAction
name|action
parameter_list|,
name|gpointer
name|gdisp_ptr
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|Iscissors_draw
name|draw
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|iscissors
operator|->
name|state
condition|)
block|{
case|case
name|SEED_PLACEMENT
case|:
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_CURRENT_SEED
expr_stmt|;
break|break;
case|case
name|SEED_ADJUSTMENT
case|:
name|draw
operator|=
name|DRAW_CURVE
operator||
name|DRAW_ACTIVE_CURVE
expr_stmt|;
break|break;
default|default:
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
break|break;
block|}
name|iscissors
operator|->
name|draw
operator|=
name|draw
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|draw_core_pause
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|draw_core_stop
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|iscissors_reset
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_reset (Iscissors * iscissors)
name|iscissors_reset
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|)
block|{
name|TRC
argument_list|(
operator|(
literal|"iscissors_reset\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  Free and reset the curve list  */
if|if
condition|(
name|iscissors
operator|->
name|curves
condition|)
block|{
name|iscissors_free_icurves
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"g_slist_free (iscissors->curves);\n"
operator|)
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|iscissors
operator|->
name|curves
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|curves
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  free mask  */
if|if
condition|(
name|iscissors
operator|->
name|mask
condition|)
name|channel_delete
argument_list|(
name|iscissors
operator|->
name|mask
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/* free the gradient map */
if|if
condition|(
name|iscissors
operator|->
name|gradient_map
condition|)
block|{
comment|/* release any tile we were using */
if|if
condition|(
name|cur_tile
condition|)
block|{
name|TRC
argument_list|(
operator|(
literal|"tile_release\n"
operator|)
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|cur_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|cur_tile
operator|=
name|NULL
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"tile_manager_destroy (iscissors->gradient_map);\n"
operator|)
argument_list|)
expr_stmt|;
name|tile_manager_destroy
argument_list|(
name|iscissors
operator|->
name|gradient_map
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|gradient_map
operator|=
name|NULL
expr_stmt|;
block|}
name|iscissors
operator|->
name|curve1
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|=
name|NULL
expr_stmt|;
name|iscissors
operator|->
name|first_point
operator|=
name|TRUE
expr_stmt|;
name|iscissors
operator|->
name|connected
operator|=
name|FALSE
expr_stmt|;
name|iscissors
operator|->
name|state
operator|=
name|NO_ACTION
expr_stmt|;
comment|/*  Reset the dp buffers  */
name|iscissors_free_buffers
argument_list|(
name|iscissors
argument_list|)
expr_stmt|;
comment|/*  If they haven't already been initialized, precalculate the diagonal    *  weight and direction value arrays    */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|precalculate_arrays
argument_list|()
expr_stmt|;
name|initialized
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_free_icurves (GSList * list)
name|iscissors_free_icurves
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|)
block|{
name|ICurve
modifier|*
name|curve
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"iscissors_free_icurves\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|curve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|curve
operator|->
name|points
condition|)
block|{
name|TRC
argument_list|(
operator|(
literal|"g_ptr_array_free (curve->points);\n"
operator|)
argument_list|)
expr_stmt|;
name|g_ptr_array_free
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|TRC
argument_list|(
operator|(
literal|"g_free (curve);\n"
operator|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|iscissors_free_buffers (Iscissors * iscissors)
name|iscissors_free_buffers
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|)
block|{
if|if
condition|(
name|iscissors
operator|->
name|dp_buf
condition|)
name|temp_buf_free
argument_list|(
name|iscissors
operator|->
name|dp_buf
argument_list|)
expr_stmt|;
name|iscissors
operator|->
name|dp_buf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX need some scan-conversion routines from somewhere.  maybe. ? */
end_comment

begin_function
specifier|static
name|int
DECL|function|clicked_on_vertex (Tool * tool)
name|clicked_on_vertex
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|ICurve
modifier|*
name|curve
decl_stmt|;
name|int
name|curves_found
init|=
literal|0
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  traverse through the list, returning non-zero if the current cursor    *  position is on an existing curve vertex.  Set the curve1 and curve2    *  variables to the two curves containing the vertex in question    */
name|iscissors
operator|->
name|curve1
operator|=
name|iscissors
operator|->
name|curve2
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
name|iscissors
operator|->
name|curves
expr_stmt|;
while|while
condition|(
name|list
operator|&&
name|curves_found
operator|<
literal|2
condition|)
block|{
name|curve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|curve
operator|->
name|x1
operator|-
name|iscissors
operator|->
name|x
argument_list|)
operator|<
name|POINT_HALFWIDTH
operator|&&
name|abs
argument_list|(
name|curve
operator|->
name|y1
operator|-
name|iscissors
operator|->
name|y
argument_list|)
operator|<
name|POINT_HALFWIDTH
condition|)
block|{
name|iscissors
operator|->
name|curve1
operator|=
name|curve
expr_stmt|;
if|if
condition|(
name|curves_found
operator|++
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|abs
argument_list|(
name|curve
operator|->
name|x2
operator|-
name|iscissors
operator|->
name|x
argument_list|)
operator|<
name|POINT_HALFWIDTH
operator|&&
name|abs
argument_list|(
name|curve
operator|->
name|y2
operator|-
name|iscissors
operator|->
name|y
argument_list|)
operator|<
name|POINT_HALFWIDTH
condition|)
block|{
name|iscissors
operator|->
name|curve2
operator|=
name|curve
expr_stmt|;
if|if
condition|(
name|curves_found
operator|++
condition|)
return|return
literal|1
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  if only one curve was found, the curves are unconnected, and    *  the user only wants to move either the first or last point    *  disallow this for now.    */
if|if
condition|(
name|curves_found
operator|==
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*  no vertices were found at the cursor click point.  Now check whether    *  the click occured on a curve.  If so, create a new vertex there and    *  two curve segments to replace what used to be just one...    */
return|return
name|clicked_on_curve
argument_list|(
name|tool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|clicked_on_curve (Tool * tool)
name|clicked_on_curve
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|,
modifier|*
name|new_link
decl_stmt|;
name|gpointer
modifier|*
name|pt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ICurve
modifier|*
name|curve
decl_stmt|,
modifier|*
name|new_curve
decl_stmt|;
name|guint32
name|coords
decl_stmt|;
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  traverse through the list, returning non-zero if the current cursor    *  position is on a curve...  If this occurs, replace the curve with two    *  new curves, separated by the new vertex.    */
name|list
operator|=
name|iscissors
operator|->
name|curves
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|curve
operator|=
operator|(
name|ICurve
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|pt
operator|=
name|curve
operator|->
name|points
operator|->
name|pdata
expr_stmt|;
name|len
operator|=
name|curve
operator|->
name|points
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|coords
operator|=
name|GPOINTER_TO_INT
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|++
expr_stmt|;
name|tx
operator|=
name|coords
operator|&
literal|0x0000ffff
expr_stmt|;
name|ty
operator|=
name|coords
operator|>>
literal|16
expr_stmt|;
comment|/*  Is the specified point close enough to the curve?  */
if|if
condition|(
name|abs
argument_list|(
name|tx
operator|-
name|iscissors
operator|->
name|x
argument_list|)
operator|<
name|POINT_HALFWIDTH
operator|&&
name|abs
argument_list|(
name|ty
operator|-
name|iscissors
operator|->
name|y
argument_list|)
operator|<
name|POINT_HALFWIDTH
condition|)
block|{
comment|/*  Since we're modifying the curve, undraw the existing one  */
name|iscissors
operator|->
name|draw
operator|=
name|DRAW_CURVE
expr_stmt|;
name|draw_core_pause
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
comment|/*  Create the new curve  */
name|new_curve
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ICurve
argument_list|)
argument_list|)
expr_stmt|;
name|new_curve
operator|->
name|x2
operator|=
name|curve
operator|->
name|x2
expr_stmt|;
name|new_curve
operator|->
name|y2
operator|=
name|curve
operator|->
name|y2
expr_stmt|;
name|new_curve
operator|->
name|x1
operator|=
name|curve
operator|->
name|x2
operator|=
name|iscissors
operator|->
name|x
expr_stmt|;
name|new_curve
operator|->
name|y1
operator|=
name|curve
operator|->
name|y2
operator|=
name|iscissors
operator|->
name|y
expr_stmt|;
name|new_curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/*  Create the new link and supply the new curve as data  */
name|new_link
operator|=
name|g_slist_alloc
argument_list|()
expr_stmt|;
name|new_link
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|new_curve
expr_stmt|;
comment|/*  Insert the new link in the list  */
name|new_link
operator|->
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|new_link
expr_stmt|;
name|iscissors
operator|->
name|curve1
operator|=
name|new_curve
expr_stmt|;
name|iscissors
operator|->
name|curve2
operator|=
name|curve
expr_stmt|;
comment|/*  Redraw the curve  */
name|draw_core_resume
argument_list|(
name|iscissors
operator|->
name|core
argument_list|,
name|tool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|precalculate_arrays (void)
name|precalculate_arrays
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
comment|/*  The diagonal weight array  */
name|diagonal_weight
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|i
operator|*
name|G_SQRT2
argument_list|)
expr_stmt|;
comment|/*  The direction value array  */
name|direction_value
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
literal|127
operator|-
name|abs
argument_list|(
literal|127
operator|-
name|i
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|abs
argument_list|(
literal|127
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
name|abs
argument_list|(
literal|191
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
name|direction_value
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
name|abs
argument_list|(
literal|63
operator|-
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"i: %d, v0: %d, v1: %d, v2: %d, v3: %d\n"
operator|,
name|i
operator|,
name|direction_value
index|[
name|i
index|]
index|[
literal|0
index|]
operator|,
name|direction_value
index|[
name|i
index|]
index|[
literal|1
index|]
operator|,
name|direction_value
index|[
name|i
index|]
index|[
literal|2
index|]
operator|,
name|direction_value
index|[
name|i
index|]
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  set the 256th index of the direction_values to the hightest cost  */
name|direction_value
index|[
literal|255
index|]
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|1
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|2
index|]
operator|=
literal|255
expr_stmt|;
name|direction_value
index|[
literal|255
index|]
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_curve (Tool * tool,ICurve * curve)
name|calculate_curve
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|,
name|ICurve
modifier|*
name|curve
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|Iscissors
modifier|*
name|iscissors
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dir
decl_stmt|;
name|int
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|ewidth
decl_stmt|,
name|eheight
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"calculate_curve(%p, %p)\n"
operator|,
name|tool
operator|,
name|curve
operator|)
argument_list|)
expr_stmt|;
comment|/*  Calculate the lowest cost path from one vertex to the next as specified    *  by the parameter "curve".    *    Here are the steps:    *      1)  Calculate the appropriate working area for this operation    *      2)  Allocate a temp buf for the dynamic programming array    *      3)  Run the dynamic programming algorithm to find the optimal path    *      4)  Translate the optimal path into pixels in the icurve data    *            structure.    */
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|tool
operator|->
name|gdisp_ptr
expr_stmt|;
name|iscissors
operator|=
operator|(
name|Iscissors
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
comment|/*  Get the bounding box  */
name|xs
operator|=
name|BOUNDS
argument_list|(
name|curve
operator|->
name|x1
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ys
operator|=
name|BOUNDS
argument_list|(
name|curve
operator|->
name|y1
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xe
operator|=
name|BOUNDS
argument_list|(
name|curve
operator|->
name|x2
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ye
operator|=
name|BOUNDS
argument_list|(
name|curve
operator|->
name|y2
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|MINIMUM
argument_list|(
name|xs
argument_list|,
name|xe
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MINIMUM
argument_list|(
name|ys
argument_list|,
name|ye
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MAXIMUM
argument_list|(
name|xs
argument_list|,
name|xe
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  +1 because if xe = 199& xs = 0, x2 - x1, width = 200  */
name|y2
operator|=
name|MAXIMUM
argument_list|(
name|ys
argument_list|,
name|ye
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  expand the boundaries past the ending points by     *  some percentage of width and height.  This serves the following purpose:    *  It gives the algorithm more area to search so better solutions    *  are found.  This is particularly helpful in finding "bumps" which    *  fall outside the bounding box represented by the start and end    *  coordinates of the "curve".    */
name|ewidth
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|EXTEND_BY
operator|+
name|FIXED
expr_stmt|;
name|eheight
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
operator|*
name|EXTEND_BY
operator|+
name|FIXED
expr_stmt|;
if|if
condition|(
name|xe
operator|>=
name|xs
condition|)
name|x2
operator|+=
name|BOUNDS
argument_list|(
name|ewidth
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|-
name|x2
argument_list|)
expr_stmt|;
else|else
name|x1
operator|-=
name|BOUNDS
argument_list|(
name|ewidth
argument_list|,
literal|0
argument_list|,
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ye
operator|>=
name|ys
condition|)
name|y2
operator|+=
name|BOUNDS
argument_list|(
name|eheight
argument_list|,
literal|0
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|-
name|y2
argument_list|)
expr_stmt|;
else|else
name|y1
operator|-=
name|BOUNDS
argument_list|(
name|eheight
argument_list|,
literal|0
argument_list|,
name|y1
argument_list|)
expr_stmt|;
comment|/* blow away any previous points list we might have */
if|if
condition|(
name|curve
operator|->
name|points
condition|)
block|{
name|TRC
argument_list|(
operator|(
literal|"1229: g_ptr_array_free (curve->points);\n"
operator|)
argument_list|)
expr_stmt|;
name|g_ptr_array_free
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  If the bounding box has width and height...  */
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
condition|)
block|{
name|width
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|height
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
comment|/* Initialise the gradient map tile manager for this image if we        * don't already have one. */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|gradient_map
condition|)
name|iscissors
operator|->
name|gradient_map
operator|=
name|gradient_map_new
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"dp buf resize\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  allocate the dynamic programming array  */
name|iscissors
operator|->
name|dp_buf
operator|=
name|temp_buf_resize
argument_list|(
name|iscissors
operator|->
name|dp_buf
argument_list|,
literal|4
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"find_optimal_path\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  find the optimal path of pixels from (x1, y1) to (x2, y2)  */
name|find_optimal_path
argument_list|(
name|iscissors
operator|->
name|gradient_map
argument_list|,
name|iscissors
operator|->
name|dp_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|)
expr_stmt|;
comment|/*  get a list of the pixels in the optimal path  */
name|TRC
argument_list|(
operator|(
literal|"plot_pixels\n"
operator|)
argument_list|)
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|plot_pixels
argument_list|(
name|iscissors
argument_list|,
name|iscissors
operator|->
name|dp_buf
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
comment|/*  If the bounding box has no width  */
elseif|else
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  plot a vertical line  */
name|y
operator|=
name|ys
expr_stmt|;
name|dir
operator|=
operator|(
name|ys
operator|>
name|ye
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|y
operator|!=
name|ye
condition|)
block|{
name|g_ptr_array_add
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|GINT_TO_POINTER
argument_list|(
operator|(
name|y
operator|<<
literal|16
operator|)
operator|+
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|+=
name|dir
expr_stmt|;
block|}
block|}
comment|/*  If the bounding box has no height  */
elseif|else
if|if
condition|(
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  plot a horizontal line  */
name|x
operator|=
name|xs
expr_stmt|;
name|dir
operator|=
operator|(
name|xs
operator|>
name|xe
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|curve
operator|->
name|points
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|xe
condition|)
block|{
name|g_ptr_array_add
argument_list|(
name|curve
operator|->
name|points
argument_list|,
name|GINT_TO_POINTER
argument_list|(
operator|(
name|ys
operator|<<
literal|16
operator|)
operator|+
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|dir
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* badly need to get a replacement - this is _way_ too expensive */
end_comment

begin_function
specifier|static
name|int
DECL|function|gradient_map_value (TileManager * map,int x,int y,guint8 * grad,guint8 * dir)
name|gradient_map_value
parameter_list|(
name|TileManager
modifier|*
name|map
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guint8
modifier|*
name|grad
parameter_list|,
name|guint8
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
name|int
name|cur_tilex
decl_stmt|;
specifier|static
name|int
name|cur_tiley
decl_stmt|;
name|guint8
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|cur_tile
operator|||
name|x
operator|/
name|TILE_WIDTH
operator|!=
name|cur_tilex
operator|||
name|y
operator|/
name|TILE_HEIGHT
operator|!=
name|cur_tiley
condition|)
block|{
if|if
condition|(
name|cur_tile
condition|)
name|tile_release
argument_list|(
name|cur_tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cur_tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_tile
condition|)
return|return
literal|0
return|;
name|cur_tilex
operator|=
name|x
operator|/
name|TILE_WIDTH
expr_stmt|;
name|cur_tiley
operator|=
name|y
operator|/
name|TILE_HEIGHT
expr_stmt|;
block|}
name|p
operator|=
name|tile_data_pointer
argument_list|(
name|cur_tile
argument_list|,
name|x
operator|%
name|TILE_WIDTH
argument_list|,
name|y
operator|%
name|TILE_HEIGHT
argument_list|)
expr_stmt|;
operator|*
name|grad
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|dir
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|calculate_link (TileManager * gradient_map,int x,int y,guint32 pixel,int link)
name|calculate_link
parameter_list|(
name|TileManager
modifier|*
name|gradient_map
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guint32
name|pixel
parameter_list|,
name|int
name|link
parameter_list|)
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|guint8
name|grad1
decl_stmt|,
name|dir1
decl_stmt|,
name|grad2
decl_stmt|,
name|dir2
decl_stmt|;
if|if
condition|(
operator|!
name|gradient_map_value
argument_list|(
name|gradient_map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|grad1
argument_list|,
operator|&
name|dir1
argument_list|)
condition|)
block|{
name|grad1
operator|=
literal|0
expr_stmt|;
name|dir1
operator|=
literal|255
expr_stmt|;
block|}
comment|/* Convert the gradient into a cost: large gradients are good, and    * so have low cost. */
name|grad1
operator|=
literal|255
operator|-
name|grad1
expr_stmt|;
comment|/*  calculate the contribution of the gradient magnitude  */
if|if
condition|(
name|link
operator|>
literal|1
condition|)
name|value
operator|+=
name|diagonal_weight
index|[
name|grad1
index|]
operator|*
name|OMEGA_G
expr_stmt|;
else|else
name|value
operator|+=
name|grad1
operator|*
name|OMEGA_G
expr_stmt|;
comment|/*  calculate the contribution of the gradient direction  */
name|x
operator|+=
call|(
name|gint8
call|)
argument_list|(
name|pixel
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|y
operator|+=
call|(
name|gint8
call|)
argument_list|(
operator|(
name|pixel
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gradient_map_value
argument_list|(
name|gradient_map
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|grad2
argument_list|,
operator|&
name|dir2
argument_list|)
condition|)
block|{
name|grad2
operator|=
literal|0
expr_stmt|;
name|dir2
operator|=
literal|255
expr_stmt|;
block|}
name|value
operator|+=
operator|(
name|direction_value
index|[
name|dir1
index|]
index|[
name|link
index|]
operator|+
name|direction_value
index|[
name|dir2
index|]
index|[
name|link
index|]
operator|)
operator|*
name|OMEGA_D
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|GPtrArray
modifier|*
DECL|function|plot_pixels (Iscissors * iscissors,TempBuf * dp_buf,int x1,int y1,int xs,int ys,int xe,int ye)
name|plot_pixels
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|xs
parameter_list|,
name|int
name|ys
parameter_list|,
name|int
name|xe
parameter_list|,
name|int
name|ye
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|guint32
name|coords
decl_stmt|;
name|int
name|link
decl_stmt|;
name|int
name|width
decl_stmt|;
name|unsigned
name|int
modifier|*
name|data
decl_stmt|;
name|GPtrArray
modifier|*
name|list
decl_stmt|;
name|width
operator|=
name|dp_buf
operator|->
name|width
expr_stmt|;
comment|/*  Start the data pointer at the correct location  */
name|data
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|temp_buf_data
argument_list|(
name|dp_buf
argument_list|)
operator|+
operator|(
name|ye
operator|-
name|y1
operator|)
operator|*
name|width
operator|+
operator|(
name|xe
operator|-
name|x1
operator|)
expr_stmt|;
name|x
operator|=
name|xe
expr_stmt|;
name|y
operator|=
name|ye
expr_stmt|;
name|list
operator|=
name|g_ptr_array_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|coords
operator|=
operator|(
name|y
operator|<<
literal|16
operator|)
operator|+
name|x
expr_stmt|;
name|g_ptr_array_add
argument_list|(
name|list
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|coords
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|PIXEL_DIR
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|SEED_POINT
condition|)
return|return
name|list
return|;
name|x
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|+=
name|move
index|[
name|link
index|]
index|[
literal|1
index|]
operator|*
name|width
operator|+
name|move
index|[
name|link
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*  won't get here  */
return|return
name|NULL
return|;
block|}
end_function

begin_define
DECL|macro|PACK (x,y)
define|#
directive|define
name|PACK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((((y)& 0xff)<< 8) | ((x)& 0xff))
end_define

begin_define
DECL|macro|OFFSET (pixel)
define|#
directive|define
name|OFFSET
parameter_list|(
name|pixel
parameter_list|)
value|((gint8)((pixel)& 0xff) + \   ((gint8)(((pixel)& 0xff00)>> 8)) * dp_buf->width)
end_define

begin_function
specifier|static
name|void
DECL|function|find_optimal_path (TileManager * gradient_map,TempBuf * dp_buf,int x1,int y1,int x2,int y2,int xs,int ys)
name|find_optimal_path
parameter_list|(
name|TileManager
modifier|*
name|gradient_map
parameter_list|,
name|TempBuf
modifier|*
name|dp_buf
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
name|int
name|xs
parameter_list|,
name|int
name|ys
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|link
decl_stmt|;
name|int
name|linkdir
decl_stmt|;
name|int
name|dirx
decl_stmt|,
name|diry
decl_stmt|;
name|int
name|min_cost
decl_stmt|;
name|int
name|new_cost
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|cum_cost
index|[
literal|8
index|]
decl_stmt|;
name|int
name|link_cost
index|[
literal|8
index|]
decl_stmt|;
name|int
name|pixel_cost
index|[
literal|8
index|]
decl_stmt|;
name|guint32
name|pixel
index|[
literal|8
index|]
decl_stmt|;
name|guint32
modifier|*
name|data
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"find_optimal_path (%p, %p, [%d,%d-%d,%d] %d, %d)\n"
operator|,
name|gradient_map
operator|,
name|dp_buf
operator|,
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
operator|,
name|xs
operator|,
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/*  initialize the dynamic programming buffer  */
name|data
operator|=
operator|(
name|guint32
operator|*
operator|)
name|temp_buf_data
argument_list|(
name|dp_buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp_buf
operator|->
name|height
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dp_buf
operator|->
name|width
condition|;
name|j
operator|++
control|)
operator|*
name|data
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*  0 cumulative cost, 0 direction  */
comment|/*  what directions are we filling the array in according to?  */
name|dirx
operator|=
operator|(
name|xs
operator|-
name|x1
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|diry
operator|=
operator|(
name|ys
operator|-
name|y1
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|linkdir
operator|=
operator|(
name|dirx
operator|*
name|diry
operator|)
expr_stmt|;
name|y
operator|=
name|ys
expr_stmt|;
comment|/*  Start the data pointer at the correct location  */
name|data
operator|=
operator|(
name|guint32
operator|*
operator|)
name|temp_buf_data
argument_list|(
name|dp_buf
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"find_optimal_path: mainloop\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp_buf
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|xs
expr_stmt|;
name|d
operator|=
name|data
operator|+
operator|(
name|y
operator|-
name|y1
operator|)
operator|*
name|dp_buf
operator|->
name|width
operator|+
operator|(
name|x
operator|-
name|x1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dp_buf
operator|->
name|width
condition|;
name|j
operator|++
control|)
block|{
name|min_cost
operator|=
name|G_MAXINT
expr_stmt|;
comment|/* pixel[] array encodes how to get to a neigbour, if possible. 	   * 0 means no connection (eg edge). 	   * Rest packed as bottom two bytes: y offset then x offset. 	   * Initially, we assume we can't get anywhere. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|pixel
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  Find the valid neighboring pixels  */
comment|/*  the previous pixel  */
if|if
condition|(
name|j
condition|)
name|pixel
index|[
operator|(
operator|(
name|dirx
operator|==
literal|1
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
index|]
operator|=
name|PACK
argument_list|(
operator|-
name|dirx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  the previous row of pixels  */
if|if
condition|(
name|i
condition|)
block|{
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
literal|5
else|:
literal|1
operator|)
index|]
operator|=
name|PACK
argument_list|(
literal|0
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
name|link
operator|=
operator|(
name|linkdir
operator|==
literal|1
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
operator|(
name|link
operator|+
literal|4
operator|)
else|:
name|link
operator|)
index|]
operator|=
name|PACK
argument_list|(
operator|-
name|dirx
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
name|link
operator|=
operator|(
name|linkdir
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|dp_buf
operator|->
name|width
operator|-
literal|1
condition|)
name|pixel
index|[
operator|(
operator|(
name|diry
operator|==
literal|1
operator|)
condition|?
operator|(
name|link
operator|+
literal|4
operator|)
else|:
name|link
operator|)
index|]
operator|=
name|PACK
argument_list|(
name|dirx
argument_list|,
operator|-
name|diry
argument_list|)
expr_stmt|;
block|}
comment|/*  find the minimum cost of going through each neighbor to reach the 	   *  seed point... 	   */
name|link
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|pixel
index|[
name|k
index|]
condition|)
block|{
name|link_cost
index|[
name|k
index|]
operator|=
name|calculate_link
argument_list|(
name|gradient_map
argument_list|,
name|xs
operator|+
name|j
operator|*
name|dirx
argument_list|,
name|ys
operator|+
name|i
operator|*
name|diry
argument_list|,
name|pixel
index|[
name|k
index|]
argument_list|,
operator|(
operator|(
name|k
operator|>
literal|3
operator|)
condition|?
name|k
operator|-
literal|4
else|:
name|k
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|OFFSET
argument_list|(
name|pixel
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|pixel_cost
index|[
name|k
index|]
operator|=
name|PIXEL_COST
argument_list|(
name|d
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|cum_cost
index|[
name|k
index|]
operator|=
name|pixel_cost
index|[
name|k
index|]
operator|+
name|link_cost
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cum_cost
index|[
name|k
index|]
operator|<
name|min_cost
condition|)
block|{
name|min_cost
operator|=
name|cum_cost
index|[
name|k
index|]
expr_stmt|;
name|link
operator|=
name|k
expr_stmt|;
block|}
block|}
comment|/*  If anything can be done...  */
if|if
condition|(
name|link
operator|>=
literal|0
condition|)
block|{
comment|/*  set the cumulative cost of this pixel and the new direction  */
operator|*
name|d
operator|=
operator|(
name|cum_cost
index|[
name|link
index|]
operator|<<
literal|8
operator|)
operator|+
name|link
expr_stmt|;
comment|/*  possibly change the links from the other pixels to this pixel... 	       *  these changes occur if a neighboring pixel will receive a lower 	       *  cumulative cost by going through this pixel.   	       */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|pixel
index|[
name|k
index|]
operator|&&
name|k
operator|!=
name|link
condition|)
block|{
comment|/*  if the cumulative cost at the neighbor is greater than 		     *  the cost through the link to the current pixel, change the 		     *  neighbor's link to point to the current pixel. 		     */
name|new_cost
operator|=
name|link_cost
index|[
name|k
index|]
operator|+
name|cum_cost
index|[
name|link
index|]
expr_stmt|;
if|if
condition|(
name|pixel_cost
index|[
name|k
index|]
operator|>
name|new_cost
condition|)
block|{
comment|/*  reverse the link direction   /-----------------------\ */
name|offset
operator|=
name|OFFSET
argument_list|(
name|pixel
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|d
index|[
name|offset
index|]
operator|=
operator|(
name|new_cost
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|k
operator|>
literal|3
operator|)
condition|?
name|k
operator|-
literal|4
else|:
name|k
operator|+
literal|4
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  Set the seed point  */
elseif|else
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|j
condition|)
operator|*
name|d
operator|=
name|SEED_POINT
expr_stmt|;
comment|/*  increment the data pointer and the x counter  */
name|d
operator|+=
name|dirx
expr_stmt|;
name|x
operator|+=
name|dirx
expr_stmt|;
block|}
comment|/*  increment the y counter  */
name|y
operator|+=
name|diry
expr_stmt|;
block|}
name|TRC
argument_list|(
operator|(
literal|"done: find_optimal_path\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to fill in a newly referenced tile in the gradient map */
end_comment

begin_function
specifier|static
name|void
DECL|function|gradmap_tile_validate (TileManager * tm,Tile * tile)
name|gradmap_tile_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
specifier|static
name|gboolean
name|first_gradient
init|=
name|TRUE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|dw
decl_stmt|,
name|dh
decl_stmt|;
name|int
name|sw
decl_stmt|,
name|sh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|b
decl_stmt|;
name|float
name|gradient
decl_stmt|;
name|guint8
modifier|*
name|gradmap
decl_stmt|;
name|guint8
modifier|*
name|tiledata
decl_stmt|;
name|guint8
modifier|*
name|datah
decl_stmt|,
modifier|*
name|datav
decl_stmt|;
name|gint8
name|hmax
decl_stmt|,
name|vmax
decl_stmt|;
name|Tile
modifier|*
name|srctile
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gimage
operator|=
operator|(
name|GImage
operator|*
operator|)
name|tile_manager_get_user_data
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_gradient
condition|)
block|{
name|int
name|radius
init|=
name|GRADIENT_SEARCH
operator|>>
literal|1
decl_stmt|;
comment|/*  compute the distance weights  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GRADIENT_SEARCH
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|GRADIENT_SEARCH
condition|;
name|j
operator|++
control|)
name|distance_weights
index|[
name|i
operator|*
name|GRADIENT_SEARCH
operator|+
name|j
index|]
operator|=
literal|1.0
operator|/
operator|(
literal|1
operator|+
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|i
operator|-
name|radius
argument_list|)
operator|+
name|SQR
argument_list|(
name|j
operator|-
name|radius
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|first_gradient
operator|=
name|FALSE
expr_stmt|;
block|}
name|tile_manager_get_tile_coordinates
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|dw
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|dh
operator|=
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|TRC
argument_list|(
operator|(
literal|"fill req for tile %p @ (%d, %d)\n"
operator|,
name|tile
operator|,
name|x
operator|,
name|y
operator|)
argument_list|)
expr_stmt|;
comment|/* get corresponding tile in the gimage */
name|srctile
operator|=
name|tile_manager_get_tile
argument_list|(
name|gimp_image_composite
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srctile
condition|)
block|{
name|g_warning
argument_list|(
literal|"bad tile coords?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sw
operator|=
name|tile_ewidth
argument_list|(
name|srctile
argument_list|)
expr_stmt|;
name|sh
operator|=
name|tile_eheight
argument_list|(
name|srctile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dw
operator|!=
name|sw
operator|||
name|dh
operator|!=
name|sh
condition|)
name|g_warning
argument_list|(
literal|"dw:%d sw:%d  dh:%d sh:%d\n"
argument_list|,
name|dw
argument_list|,
name|sw
argument_list|,
name|dh
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|w
operator|=
name|MIN
argument_list|(
name|dw
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|h
operator|=
name|MIN
argument_list|(
name|dh
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|bytes
operator|=
name|gimp_image_composite_bytes
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|data
operator|=
name|tile_data_pointer
argument_list|(
name|srctile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|rowstride
operator|=
name|srcPR
operator|.
name|w
operator|*
name|srcPR
operator|.
name|bytes
expr_stmt|;
comment|/* XXX tile edges? */
comment|/*  Blur the source to get rid of noise  */
name|destPR
operator|.
name|rowstride
operator|=
name|TILE_WIDTH
operator|*
literal|4
expr_stmt|;
name|destPR
operator|.
name|data
operator|=
name|maxgrad_conv0
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|blur_32
argument_list|,
literal|3
argument_list|,
literal|32
argument_list|,
name|NORMAL_CONVOL
argument_list|)
expr_stmt|;
comment|/*  Set the "src" temp buf up as the new source Pixel Region  */
name|srcPR
operator|.
name|rowstride
operator|=
name|destPR
operator|.
name|rowstride
expr_stmt|;
name|srcPR
operator|.
name|data
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
comment|/*  Get the horizontal derivative  */
name|destPR
operator|.
name|data
operator|=
name|maxgrad_conv1
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|horz_deriv
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|NEGATIVE_CONVOL
argument_list|)
expr_stmt|;
comment|/*  Get the vertical derivative  */
name|destPR
operator|.
name|data
operator|=
name|maxgrad_conv2
expr_stmt|;
name|convolve_region
argument_list|(
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|,
name|vert_deriv
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|NEGATIVE_CONVOL
argument_list|)
expr_stmt|;
comment|/* calculate overall gradient */
name|tiledata
operator|=
name|tile_data_pointer
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srcPR
operator|.
name|h
condition|;
name|i
operator|++
control|)
block|{
name|datah
operator|=
name|maxgrad_conv1
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
name|i
expr_stmt|;
name|datav
operator|=
name|maxgrad_conv2
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
name|i
expr_stmt|;
name|gradmap
operator|=
name|tiledata
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|*
name|COST_WIDTH
operator|*
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srcPR
operator|.
name|w
condition|;
name|j
operator|++
control|)
block|{
name|hmax
operator|=
name|datah
index|[
literal|0
index|]
operator|-
literal|128
expr_stmt|;
name|vmax
operator|=
name|datav
index|[
literal|0
index|]
operator|-
literal|128
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<
name|srcPR
operator|.
name|bytes
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|datah
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|hmax
argument_list|)
condition|)
name|hmax
operator|=
name|datah
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|datav
index|[
name|b
index|]
operator|-
literal|128
argument_list|)
operator|>
name|abs
argument_list|(
name|vmax
argument_list|)
condition|)
name|vmax
operator|=
name|datav
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|j
operator|==
literal|0
operator|||
name|i
operator|==
name|srcPR
operator|.
name|h
operator|-
literal|1
operator|||
name|j
operator|==
name|srcPR
operator|.
name|w
operator|-
literal|1
condition|)
block|{
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
index|]
operator|=
literal|0
expr_stmt|;
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
comment|/* 1 byte absolute magitude first */
name|gradient
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|hmax
argument_list|)
operator|+
name|SQR
argument_list|(
name|vmax
argument_list|)
argument_list|)
expr_stmt|;
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
index|]
operator|=
name|gradient
operator|*
literal|255
operator|/
name|MAX_GRADIENT
expr_stmt|;
comment|/* then 1 byte direction */
if|if
condition|(
name|gradient
operator|>
name|MIN_GRADIENT
condition|)
block|{
name|float
name|direction
decl_stmt|;
if|if
condition|(
operator|!
name|hmax
condition|)
name|direction
operator|=
operator|(
name|vmax
operator|>
literal|0
operator|)
condition|?
name|G_PI_2
else|:
operator|-
name|G_PI_2
expr_stmt|;
else|else
name|direction
operator|=
name|atan
argument_list|(
operator|(
name|double
operator|)
name|vmax
operator|/
operator|(
name|double
operator|)
name|hmax
argument_list|)
expr_stmt|;
comment|/* Scale the direction from between 0 and 254, 	       *  corresponding to -PI/2, PI/2 255 is reserved for 	       *  directionless pixels */
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
call|(
name|guint8
call|)
argument_list|(
literal|254
operator|*
operator|(
name|direction
operator|+
name|G_PI_2
operator|)
operator|/
name|G_PI
argument_list|)
expr_stmt|;
block|}
else|else
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
comment|/* reserved for weak gradient */
name|contin
label|:
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|g
init|=
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
index|]
decl_stmt|;
name|int
name|d
init|=
name|gradmap
index|[
name|j
operator|*
name|COST_WIDTH
operator|+
literal|1
index|]
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"%c%c"
operator|,
literal|'a'
operator|+
operator|(
name|g
operator|*
literal|25
operator|/
literal|255
operator|)
operator|,
literal|'0'
operator|+
operator|(
name|d
operator|/
literal|25
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|datah
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
name|datav
operator|+=
name|srcPR
operator|.
name|bytes
expr_stmt|;
block|}
name|TRC
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|TRC
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|tile_release
argument_list|(
name|srctile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|TileManager
modifier|*
DECL|function|gradient_map_new (GImage * gimage)
name|gradient_map_new
parameter_list|(
name|GImage
modifier|*
name|gimage
parameter_list|)
block|{
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|tm
operator|=
name|tile_manager_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|guint8
argument_list|)
operator|*
name|COST_WIDTH
argument_list|)
expr_stmt|;
name|tile_manager_set_user_data
argument_list|(
name|tm
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|tm
argument_list|,
name|gradmap_tile_validate
argument_list|)
expr_stmt|;
return|return
name|tm
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_max_gradient (Iscissors * iscissors,GImage * gimage,int * x,int * y)
name|find_max_gradient
parameter_list|(
name|Iscissors
modifier|*
name|iscissors
parameter_list|,
name|GImage
modifier|*
name|gimage
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
block|{
name|PixelRegion
name|srcPR
decl_stmt|;
name|int
name|radius
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
name|guint8
modifier|*
name|gradient
decl_stmt|;
name|float
name|g
decl_stmt|,
name|max_gradient
decl_stmt|;
name|TRC
argument_list|(
operator|(
literal|"find_max_gradient(%d, %d)\n"
operator|,
operator|*
name|x
operator|,
operator|*
name|y
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialise the gradient map tile manager for this image if we    * don't already have one. */
if|if
condition|(
operator|!
name|iscissors
operator|->
name|gradient_map
condition|)
name|iscissors
operator|->
name|gradient_map
operator|=
name|gradient_map_new
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|radius
operator|=
name|GRADIENT_SEARCH
operator|>>
literal|1
expr_stmt|;
comment|/*  calculate the extent of the search  */
name|cx
operator|=
name|BOUNDS
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|cy
operator|=
name|BOUNDS
argument_list|(
operator|*
name|y
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|sx
operator|=
name|cx
operator|-
name|radius
expr_stmt|;
name|sy
operator|=
name|cy
operator|-
name|radius
expr_stmt|;
name|x1
operator|=
name|BOUNDS
argument_list|(
name|cx
operator|-
name|radius
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|cy
operator|-
name|radius
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|cx
operator|+
name|radius
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|cy
operator|+
name|radius
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/*  calculate the factor to multiply the distance from the cursor by  */
name|max_gradient
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|=
name|cx
expr_stmt|;
operator|*
name|y
operator|=
name|cy
expr_stmt|;
comment|/*  Find the point of max gradient  */
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|iscissors
operator|->
name|gradient_map
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* this iterates over 1, 2 or 4 tiles only */
for|for
control|(
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|srcPR
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|endx
operator|=
name|srcPR
operator|.
name|x
operator|+
name|srcPR
operator|.
name|w
expr_stmt|;
name|endy
operator|=
name|srcPR
operator|.
name|y
operator|+
name|srcPR
operator|.
name|h
expr_stmt|;
for|for
control|(
name|i
operator|=
name|srcPR
operator|.
name|y
init|;
name|i
operator|<
name|endy
condition|;
name|i
operator|++
control|)
block|{
name|gradient
operator|=
name|srcPR
operator|.
name|data
operator|+
name|srcPR
operator|.
name|rowstride
operator|*
operator|(
name|i
operator|-
name|srcPR
operator|.
name|y
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|srcPR
operator|.
name|x
init|;
name|j
operator|<
name|endx
condition|;
name|j
operator|++
control|)
block|{
name|g
operator|=
operator|*
name|gradient
expr_stmt|;
name|gradient
operator|+=
name|COST_WIDTH
expr_stmt|;
name|g
operator|*=
name|distance_weights
index|[
operator|(
name|i
operator|-
name|y1
operator|)
operator|*
name|GRADIENT_SEARCH
operator|+
operator|(
name|j
operator|-
name|x1
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|g
operator|>
name|max_gradient
condition|)
block|{
name|max_gradient
operator|=
name|g
expr_stmt|;
operator|*
name|x
operator|=
name|j
expr_stmt|;
operator|*
name|y
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
name|TRC
argument_list|(
operator|(
literal|"done: find_max_gradient(%d, %d)\n"
operator|,
operator|*
name|x
operator|,
operator|*
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of iscissors.c */
end_comment

end_unit

