begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  *   * This file Copyright (C) 1999 Simon Budig  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Complete new path-tool by Simon Budig<Simon.Budig@unix-ag.org>  *   * a path manipulation core independent of the underlying formula:  * implement bezier-curves, intelligent scissors-curves, splines...  *   * A Path is a collection of curves, which are constructed from  * segments between two anchors.  */
end_comment

begin_comment
comment|/* #include<math.h>   #include "path_curves.h" #include "config.h" #include "libgimp/gimpintl.h" */
end_comment

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdk.h>
end_include

begin_include
include|#
directive|include
file|"apptypes.h"
end_include

begin_include
include|#
directive|include
file|"path_curves.h"
end_include

begin_include
include|#
directive|include
file|"path_tool.h"
end_include

begin_comment
comment|/*  * Every new curve-type has to have a parameter between 0 and 1, and  * should go from a starting to a target point.  */
end_comment

begin_comment
comment|/* Some defines... */
end_comment

begin_define
DECL|macro|PATH_TOOL_WIDTH
define|#
directive|define
name|PATH_TOOL_WIDTH
value|8
end_define

begin_define
DECL|macro|PATH_TOOL_HALFWIDTH
define|#
directive|define
name|PATH_TOOL_HALFWIDTH
value|4
end_define

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_comment
comment|/* Small functions to determine coordinates, iterate over path/curve/segment */
end_comment

begin_function_decl
name|void
name|path_segment_get_coordinates
parameter_list|(
name|PathSegment
modifier|*
parameter_list|,
name|gdouble
parameter_list|,
name|gint
modifier|*
parameter_list|,
name|gint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_traverse_path
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathTraverseFunc
parameter_list|,
name|CurveTraverseFunc
parameter_list|,
name|SegmentTraverseFunc
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_traverse_curve
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
parameter_list|,
name|CurveTraverseFunc
parameter_list|,
name|SegmentTraverseFunc
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_traverse_segment
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
parameter_list|,
name|PathSegment
modifier|*
parameter_list|,
name|SegmentTraverseFunc
parameter_list|,
name|gpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdouble
name|path_locate_point
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
modifier|*
parameter_list|,
name|PathSegment
modifier|*
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdouble
name|path_tool_on_curve
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|NPath
modifier|*
modifier|*
name|ret_pathP
parameter_list|,
name|PathCurve
modifier|*
modifier|*
name|ret_curveP
parameter_list|,
name|PathSegment
modifier|*
modifier|*
name|ret_segmentP
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tools to manipulate paths, curves, segments */
end_comment

begin_function_decl
name|PathCurve
modifier|*
name|path_add_curve
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PathSegment
modifier|*
name|path_append_segment
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
parameter_list|,
name|SegmentType
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PathSegment
modifier|*
name|path_prepend_segment
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
parameter_list|,
name|SegmentType
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PathSegment
modifier|*
name|path_split_segment
parameter_list|(
name|PathSegment
modifier|*
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_join_curves
parameter_list|(
name|PathSegment
modifier|*
parameter_list|,
name|PathSegment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_flip_curve
parameter_list|(
name|PathCurve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_free_path
parameter_list|(
name|NPath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_free_curve
parameter_list|(
name|PathCurve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_free_segment
parameter_list|(
name|PathSegment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_delete_segment
parameter_list|(
name|PathSegment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_print
parameter_list|(
name|NPath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_offset_active
parameter_list|(
name|NPath
modifier|*
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_set_flags
parameter_list|(
name|GimpPathTool
modifier|*
parameter_list|,
name|NPath
modifier|*
parameter_list|,
name|PathCurve
modifier|*
parameter_list|,
name|PathSegment
modifier|*
parameter_list|,
name|guint32
parameter_list|,
name|guint32
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* High level image-manipulation functions */
end_comment

begin_function_decl
name|void
name|path_stroke
parameter_list|(
name|GimpPathTool
modifier|*
parameter_list|,
name|NPath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|path_to_selection
parameter_list|(
name|GimpPathTool
modifier|*
parameter_list|,
name|NPath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions necessary for the tool */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void     path_tool_button_press    (Tool *, GdkEventButton *, gpointer); void     path_tool_button_release  (Tool *, GdkEventButton *, gpointer); void     path_tool_motion          (Tool *, GdkEventMotion *, gpointer); void     path_tool_cursor_update   (Tool *, GdkEventMotion *, gpointer); void     path_tool_control         (Tool *, ToolAction,       gpointer); void     path_tool_draw            (Tool *); void     path_tool_draw_curve      (Tool *, PathCurve *); void     path_tool_draw_segment    (Tool *, PathSegment *);  gdouble  path_tool_on_curve        (Tool *, gint, gint, gint, 				    NPath**, PathCurve**, PathSegment**); gboolean path_tool_on_anchors      (Tool *, gint, gint, gint, 				    NPath**, PathCurve**, PathSegment**); gint     path_tool_on_handles      (Tool *, gint, gint, gint, 		                    NPath **, PathCurve **, PathSegment **);  gint path_tool_button_press_canvas (Tool *, GdkEventButton *, GDisplay *); gint path_tool_button_press_anchor (Tool *, GdkEventButton *, GDisplay *); gint path_tool_button_press_handle (Tool *, GdkEventButton *, GDisplay *); gint path_tool_button_press_curve  (Tool *, GdkEventButton *, GDisplay *); void path_tool_motion_anchor       (Tool *, GdkEventMotion *, GDisplay *); void path_tool_motion_handle       (Tool *, GdkEventMotion *, GDisplay *); void path_tool_motion_curve        (Tool *, GdkEventMotion *, GDisplay *);
endif|#
directive|endif
end_endif

begin_comment
comment|/*  the path tool options  */
end_comment

begin_decl_stmt
DECL|variable|path_options
specifier|static
name|ToolOptions
modifier|*
name|path_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *   *   * Here we go!  *   *   */
end_comment

begin_comment
comment|/*  * These functions are for applying a function over a complete  * path/curve/segment. They can pass information to each other  * with a arbitrary data structure  *  * The idea behind the three different functions is:  *  if pathfunc != NULL  *     call pathfunc for every curve  *  else  *     if curvefunc != NULL  *        call curvefunc for every segment  *     else  *        call segmentfunc for every point  *  */
end_comment

begin_function
name|void
DECL|function|path_traverse_path (NPath * path,PathTraverseFunc pathfunc,CurveTraverseFunc curvefunc,SegmentTraverseFunc segmentfunc,gpointer data)
name|path_traverse_path
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathTraverseFunc
name|pathfunc
parameter_list|,
name|CurveTraverseFunc
name|curvefunc
parameter_list|,
name|SegmentTraverseFunc
name|segmentfunc
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|PathCurve
modifier|*
name|cur_curve
decl_stmt|;
if|if
condition|(
name|path
operator|&&
name|path
operator|->
name|curves
condition|)
block|{
name|cur_curve
operator|=
name|path
operator|->
name|curves
expr_stmt|;
if|if
condition|(
name|pathfunc
condition|)
do|do
block|{
call|(
modifier|*
name|pathfunc
call|)
argument_list|(
name|path
argument_list|,
name|cur_curve
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cur_curve
operator|=
name|cur_curve
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|cur_curve
operator|&&
name|cur_curve
operator|!=
name|path
operator|->
name|curves
condition|)
do|;
else|else
do|do
block|{
name|path_traverse_curve
argument_list|(
name|path
argument_list|,
name|cur_curve
argument_list|,
name|curvefunc
argument_list|,
name|segmentfunc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cur_curve
operator|=
name|cur_curve
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|cur_curve
operator|&&
name|cur_curve
operator|!=
name|path
operator|->
name|curves
condition|)
do|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_traverse_curve (NPath * path,PathCurve * curve,CurveTraverseFunc curvefunc,SegmentTraverseFunc segmentfunc,gpointer data)
name|path_traverse_curve
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|CurveTraverseFunc
name|curvefunc
parameter_list|,
name|SegmentTraverseFunc
name|segmentfunc
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|PathSegment
modifier|*
name|cur_segment
decl_stmt|;
if|if
condition|(
name|curve
operator|&&
name|curve
operator|->
name|segments
condition|)
block|{
name|cur_segment
operator|=
name|curve
operator|->
name|segments
expr_stmt|;
if|if
condition|(
name|curvefunc
condition|)
do|do
block|{
call|(
modifier|*
name|curvefunc
call|)
argument_list|(
name|path
argument_list|,
name|curve
argument_list|,
name|cur_segment
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cur_segment
operator|=
name|cur_segment
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|cur_segment
operator|&&
name|cur_segment
operator|!=
name|curve
operator|->
name|segments
condition|)
do|;
else|else
do|do
block|{
name|path_traverse_segment
argument_list|(
name|path
argument_list|,
name|curve
argument_list|,
name|cur_segment
argument_list|,
name|segmentfunc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cur_segment
operator|=
name|cur_segment
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|cur_segment
operator|&&
name|cur_segment
operator|!=
name|curve
operator|->
name|segments
condition|)
do|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_traverse_segment (NPath * path,PathCurve * curve,PathSegment * segment,SegmentTraverseFunc function,gpointer data)
name|path_traverse_segment
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|SegmentTraverseFunc
name|function
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_traverse_segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
comment|/* XXX: here we need path_curve_get_point(s) */
comment|/* Something like:     * for i = 1 to subsamples {     *   (x,y) = get_coordinates(i / subsamples)     *   (* function) (....)     * }     */
block|}
end_function

begin_comment
comment|/**************************************************************  * Helper functions for manipulating the data-structures:  */
end_comment

begin_function
name|PathCurve
modifier|*
DECL|function|path_add_curve (NPath * cur_path,gint x,gint y)
name|path_add_curve
parameter_list|(
name|NPath
modifier|*
name|cur_path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|PathCurve
modifier|*
name|tmp
init|=
name|cur_path
operator|->
name|curves
decl_stmt|;
name|PathCurve
modifier|*
name|new_curve
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_add_curve\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
if|if
condition|(
name|cur_path
condition|)
block|{
name|new_curve
operator|=
name|g_new
argument_list|(
name|PathCurve
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_curve
operator|->
name|parent
operator|=
name|cur_path
expr_stmt|;
name|new_curve
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|new_curve
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|new_curve
operator|->
name|cur_segment
operator|=
name|NULL
expr_stmt|;
name|new_curve
operator|->
name|segments
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|tmp
operator|->
name|prev
operator|=
name|new_curve
expr_stmt|;
name|cur_path
operator|->
name|curves
operator|=
name|cur_path
operator|->
name|cur_curve
operator|=
name|new_curve
expr_stmt|;
name|new_curve
operator|->
name|segments
operator|=
name|path_prepend_segment
argument_list|(
name|cur_path
argument_list|,
name|new_curve
argument_list|,
name|SEGMENT_BEZIER
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_add_curve called without valid path\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return
name|new_curve
return|;
block|}
end_function

begin_function
name|PathSegment
modifier|*
DECL|function|path_append_segment (NPath * cur_path,PathCurve * cur_curve,SegmentType type,gint x,gint y)
name|path_append_segment
parameter_list|(
name|NPath
modifier|*
name|cur_path
parameter_list|,
name|PathCurve
modifier|*
name|cur_curve
parameter_list|,
name|SegmentType
name|type
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|PathSegment
modifier|*
name|tmp
init|=
name|cur_curve
operator|->
name|segments
decl_stmt|;
name|PathSegment
modifier|*
name|new_segment
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_append_segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
if|if
condition|(
name|cur_curve
condition|)
block|{
name|tmp
operator|=
name|cur_curve
operator|->
name|segments
expr_stmt|;
while|while
condition|(
name|tmp
operator|&&
name|tmp
operator|->
name|next
operator|&&
name|tmp
operator|->
name|next
operator|!=
name|cur_curve
operator|->
name|segments
condition|)
block|{
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|new_segment
operator|=
name|g_new
argument_list|(
name|PathSegment
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_segment
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_segment
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|new_segment
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|new_segment
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_segment
operator|->
name|parent
operator|=
name|cur_curve
expr_stmt|;
name|new_segment
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_segment
operator|->
name|prev
operator|=
name|tmp
expr_stmt|;
name|new_segment
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|tmp
operator|->
name|next
operator|=
name|new_segment
expr_stmt|;
name|cur_curve
operator|->
name|cur_segment
operator|=
name|new_segment
expr_stmt|;
name|path_curve_init_segment
argument_list|(
name|new_segment
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_append_segment called with a closed curve\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_append_segment called without valid curve\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return
name|new_segment
return|;
block|}
end_function

begin_function
name|PathSegment
modifier|*
DECL|function|path_prepend_segment (NPath * cur_path,PathCurve * cur_curve,SegmentType type,gint x,gint y)
name|path_prepend_segment
parameter_list|(
name|NPath
modifier|*
name|cur_path
parameter_list|,
name|PathCurve
modifier|*
name|cur_curve
parameter_list|,
name|SegmentType
name|type
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|PathSegment
modifier|*
name|tmp
init|=
name|cur_curve
operator|->
name|segments
decl_stmt|;
name|PathSegment
modifier|*
name|new_segment
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_prepend_segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
if|if
condition|(
name|cur_curve
condition|)
block|{
name|tmp
operator|=
name|cur_curve
operator|->
name|segments
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|new_segment
operator|=
name|g_new
argument_list|(
name|PathSegment
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_segment
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_segment
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|new_segment
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|new_segment
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_segment
operator|->
name|parent
operator|=
name|cur_curve
expr_stmt|;
name|new_segment
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|new_segment
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|new_segment
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|tmp
operator|->
name|prev
operator|=
name|new_segment
expr_stmt|;
name|cur_curve
operator|->
name|segments
operator|=
name|new_segment
expr_stmt|;
name|cur_curve
operator|->
name|cur_segment
operator|=
name|new_segment
expr_stmt|;
name|path_curve_init_segment
argument_list|(
name|new_segment
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_prepend_segment called with a closed curve\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_prepend_segment called without valid curve\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return
name|new_segment
return|;
block|}
end_function

begin_function
name|PathSegment
modifier|*
DECL|function|path_split_segment (PathSegment * segment,gdouble position)
name|path_split_segment
parameter_list|(
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gdouble
name|position
parameter_list|)
block|{
name|PathSegment
modifier|*
name|new_segment
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_split_segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
if|if
condition|(
name|segment
operator|&&
name|segment
operator|->
name|next
condition|)
block|{
name|new_segment
operator|=
name|g_new
argument_list|(
name|PathSegment
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_segment
operator|->
name|type
operator|=
name|segment
operator|->
name|type
expr_stmt|;
name|path_curve_get_point
argument_list|(
name|segment
argument_list|,
name|position
argument_list|,
operator|&
operator|(
name|new_segment
operator|->
name|x
operator|)
argument_list|,
operator|&
operator|(
name|new_segment
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|new_segment
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_segment
operator|->
name|parent
operator|=
name|segment
operator|->
name|parent
expr_stmt|;
name|new_segment
operator|->
name|next
operator|=
name|segment
operator|->
name|next
expr_stmt|;
name|new_segment
operator|->
name|prev
operator|=
name|segment
expr_stmt|;
name|new_segment
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|path_curve_init_segment
argument_list|(
name|new_segment
argument_list|)
expr_stmt|;
name|new_segment
operator|->
name|next
operator|->
name|prev
operator|=
name|new_segment
expr_stmt|;
name|segment
operator|->
name|next
operator|=
name|new_segment
expr_stmt|;
return|return
name|new_segment
return|;
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_split_segment without valid segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Join two arbitrary endpoints and free the parent from the second  * segment, if it differs from the first parents.  */
end_comment

begin_function
name|void
DECL|function|path_join_curves (PathSegment * segment1,PathSegment * segment2)
name|path_join_curves
parameter_list|(
name|PathSegment
modifier|*
name|segment1
parameter_list|,
name|PathSegment
modifier|*
name|segment2
parameter_list|)
block|{
name|PathCurve
modifier|*
name|curve1
decl_stmt|,
modifier|*
name|curve2
decl_stmt|;
name|PathSegment
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|segment1
operator|->
name|next
operator|&&
name|segment1
operator|->
name|prev
operator|)
operator|||
operator|(
name|segment2
operator|->
name|next
operator|&&
name|segment2
operator|->
name|prev
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Error: path_join_curves called with a closed segment\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return;
block|}
if|if
condition|(
name|segment1
operator|->
name|parent
operator|==
name|segment2
operator|->
name|parent
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Joining beginning and end of the same curve...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
if|if
condition|(
name|segment2
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|segment2
operator|->
name|next
operator|=
name|segment1
expr_stmt|;
name|segment1
operator|->
name|prev
operator|=
name|segment2
expr_stmt|;
block|}
else|else
block|{
name|segment2
operator|->
name|prev
operator|=
name|segment1
expr_stmt|;
name|segment1
operator|->
name|next
operator|=
name|segment2
expr_stmt|;
block|}
comment|/* XXX: Probably some segment-updates needed */
return|return;
block|}
if|if
condition|(
name|segment1
operator|->
name|next
operator|==
name|NULL
operator|&&
name|segment2
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Flipping second curve (next, next)...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
name|path_flip_curve
argument_list|(
name|segment2
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* segment2 = segment2->parent->segments;        */
block|}
if|if
condition|(
name|segment1
operator|->
name|prev
operator|==
name|NULL
operator|&&
name|segment2
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Flipping second curve (prev, prev)...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
name|path_flip_curve
argument_list|(
name|segment2
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* segment2 = segment2->parent->segments;        * while (segment2->next)        * segment2 = segment2->next;        */
block|}
if|if
condition|(
name|segment1
operator|->
name|next
operator|==
name|NULL
operator|&&
name|segment2
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Appending second to first curve...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
name|curve1
operator|=
name|segment1
operator|->
name|parent
expr_stmt|;
name|curve2
operator|=
name|segment2
operator|->
name|parent
expr_stmt|;
name|segment1
operator|->
name|next
operator|=
name|segment2
expr_stmt|;
name|segment2
operator|->
name|prev
operator|=
name|segment1
expr_stmt|;
name|curve2
operator|->
name|segments
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|prev
condition|)
name|curve2
operator|->
name|prev
operator|->
name|next
operator|=
name|curve2
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|next
condition|)
name|curve2
operator|->
name|next
operator|->
name|prev
operator|=
name|curve2
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|parent
operator|->
name|curves
operator|==
name|curve2
condition|)
name|curve2
operator|->
name|parent
operator|->
name|curves
operator|=
name|curve2
operator|->
name|next
expr_stmt|;
name|path_free_curve
argument_list|(
name|curve2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|segment2
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tmp
operator|->
name|parent
operator|=
name|curve1
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
comment|/* XXX: Probably some segment-updates needed */
return|return;
block|}
if|if
condition|(
name|segment1
operator|->
name|prev
operator|==
name|NULL
operator|&&
name|segment2
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Prepending second to first curve...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
name|curve1
operator|=
name|segment1
operator|->
name|parent
expr_stmt|;
name|curve2
operator|=
name|segment2
operator|->
name|parent
expr_stmt|;
name|segment1
operator|->
name|prev
operator|=
name|segment2
expr_stmt|;
name|segment2
operator|->
name|next
operator|=
name|segment1
expr_stmt|;
name|curve2
operator|->
name|segments
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|prev
condition|)
name|curve2
operator|->
name|prev
operator|->
name|next
operator|=
name|curve2
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|next
condition|)
name|curve2
operator|->
name|next
operator|->
name|prev
operator|=
name|curve2
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curve2
operator|->
name|parent
operator|->
name|curves
operator|==
name|curve2
condition|)
name|curve2
operator|->
name|parent
operator|->
name|curves
operator|=
name|curve2
operator|->
name|next
expr_stmt|;
name|path_free_curve
argument_list|(
name|curve2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|segment2
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tmp
operator|->
name|parent
operator|=
name|curve1
expr_stmt|;
name|curve1
operator|->
name|segments
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|prev
expr_stmt|;
block|}
return|return;
comment|/* XXX: Probably some segment-updates needed */
block|}
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cant join these curves yet...\nThis should not happen."
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
block|}
end_function

begin_comment
comment|/*  * This function reverses the order of the anchors. This is  * necessary for some joining operations.  */
end_comment

begin_function
name|void
DECL|function|path_flip_curve (PathCurve * curve)
name|path_flip_curve
parameter_list|(
name|PathCurve
modifier|*
name|curve
parameter_list|)
block|{
name|gpointer
modifier|*
name|end_data
decl_stmt|;
name|SegmentType
name|end_type
decl_stmt|;
name|PathSegment
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
operator|!
name|curve
operator|&&
operator|!
name|curve
operator|->
name|segments
condition|)
block|{
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"path_flip_curve: No curve o no segments to flip!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
return|return;
block|}
name|tmp
operator|=
name|curve
operator|->
name|segments
expr_stmt|;
while|while
condition|(
name|tmp
operator|->
name|next
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|end_data
operator|=
name|tmp
operator|->
name|data
expr_stmt|;
name|end_type
operator|=
name|tmp
operator|->
name|type
expr_stmt|;
name|tmp
operator|->
name|parent
operator|->
name|segments
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tmp2
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|tmp
operator|->
name|prev
expr_stmt|;
name|tmp
operator|->
name|prev
operator|=
name|tmp2
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|next
condition|)
block|{
name|tmp
operator|->
name|type
operator|=
name|tmp
operator|->
name|next
operator|->
name|type
expr_stmt|;
name|tmp
operator|->
name|data
operator|=
name|tmp
operator|->
name|next
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|type
operator|=
name|end_type
expr_stmt|;
name|tmp
operator|->
name|data
operator|=
name|end_data
expr_stmt|;
block|}
name|path_curve_flip_segment
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_free_path (NPath * path)
name|path_free_path
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|)
block|{
name|PathCurve
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|tmp2
operator|=
name|path
operator|->
name|curves
expr_stmt|;
while|while
condition|(
operator|(
name|tmp1
operator|=
name|tmp2
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tmp2
operator|=
name|tmp1
operator|->
name|next
expr_stmt|;
name|path_free_curve
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
block|}
name|g_string_free
argument_list|(
name|path
operator|->
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_free_curve (PathCurve * curve)
name|path_free_curve
parameter_list|(
name|PathCurve
modifier|*
name|curve
parameter_list|)
block|{
name|PathSegment
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
name|curve
condition|)
block|{
name|tmp2
operator|=
name|curve
operator|->
name|segments
expr_stmt|;
comment|/* break closed curves */
if|if
condition|(
name|tmp2
operator|&&
name|tmp2
operator|->
name|prev
condition|)
name|tmp2
operator|->
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|tmp1
operator|=
name|tmp2
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tmp2
operator|=
name|tmp1
operator|->
name|next
expr_stmt|;
name|path_free_segment
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_free_segment (PathSegment * segment)
name|path_free_segment
parameter_list|(
name|PathSegment
modifier|*
name|segment
parameter_list|)
block|{
if|if
condition|(
name|segment
condition|)
block|{
comment|/* Clear the active flag to keep path_tool->single_active_segment        * consistent */
name|path_set_flags
argument_list|(
name|NULL
argument_list|,
name|segment
operator|->
name|parent
operator|->
name|parent
argument_list|,
name|segment
operator|->
name|parent
argument_list|,
name|segment
argument_list|,
literal|0
argument_list|,
name|SEGMENT_ACTIVE
argument_list|)
expr_stmt|;
name|path_curve_cleanup_segment
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_delete_curve (PathCurve * curve)
name|path_delete_curve
parameter_list|(
name|PathCurve
modifier|*
name|curve
parameter_list|)
block|{
if|if
condition|(
name|curve
condition|)
block|{
if|if
condition|(
name|curve
operator|->
name|next
condition|)
name|curve
operator|->
name|next
operator|->
name|prev
operator|=
name|curve
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curve
operator|->
name|prev
condition|)
name|curve
operator|->
name|prev
operator|->
name|next
operator|=
name|curve
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curve
operator|==
name|curve
operator|->
name|parent
operator|->
name|curves
condition|)
block|{
name|curve
operator|->
name|parent
operator|->
name|curves
operator|=
name|curve
operator|->
name|next
expr_stmt|;
block|}
name|path_free_curve
argument_list|(
name|curve
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_delete_segment (PathSegment * segment)
name|path_delete_segment
parameter_list|(
name|PathSegment
modifier|*
name|segment
parameter_list|)
block|{
if|if
condition|(
name|segment
condition|)
block|{
if|if
condition|(
name|segment
operator|->
name|next
condition|)
name|segment
operator|->
name|next
operator|->
name|prev
operator|=
name|segment
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|prev
condition|)
name|segment
operator|->
name|prev
operator|->
name|next
operator|=
name|segment
operator|->
name|next
expr_stmt|;
comment|/* If the remaining curve is closed and has a        * single point only, open it.        */
if|if
condition|(
name|segment
operator|->
name|next
operator|==
name|segment
operator|->
name|prev
operator|&&
name|segment
operator|->
name|next
condition|)
name|segment
operator|->
name|next
operator|->
name|next
operator|=
name|segment
operator|->
name|next
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|segment
operator|->
name|parent
operator|->
name|segments
condition|)
name|segment
operator|->
name|parent
operator|->
name|segments
operator|=
name|segment
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|parent
operator|->
name|segments
operator|==
name|NULL
condition|)
name|path_delete_curve
argument_list|(
name|segment
operator|->
name|parent
argument_list|)
expr_stmt|;
name|path_free_segment
argument_list|(
name|segment
argument_list|)
expr_stmt|;
comment|/*        * here we have to update the surrounding segments        */
comment|/* XXX: Please add path_curve_update_segment here */
block|}
block|}
end_function

begin_comment
comment|/*  * A function to determine, which object is hit by the cursor  */
end_comment

begin_function
name|gint
DECL|function|path_tool_cursor_position (NPath * path,gint x,gint y,gint halfwidth,NPath ** pathP,PathCurve ** curveP,PathSegment ** segmentP,gdouble * positionP,gint * handle_idP)
name|path_tool_cursor_position
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|NPath
modifier|*
modifier|*
name|pathP
parameter_list|,
name|PathCurve
modifier|*
modifier|*
name|curveP
parameter_list|,
name|PathSegment
modifier|*
modifier|*
name|segmentP
parameter_list|,
name|gdouble
modifier|*
name|positionP
parameter_list|,
name|gint
modifier|*
name|handle_idP
parameter_list|)
block|{
name|gdouble
name|pos
decl_stmt|;
name|gint
name|handle_id
decl_stmt|;
if|if
condition|(
name|path_tool_on_anchors
argument_list|(
name|path
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|pathP
argument_list|,
name|curveP
argument_list|,
name|segmentP
argument_list|)
condition|)
return|return
name|ON_ANCHOR
return|;
name|handle_id
operator|=
name|path_tool_on_handles
argument_list|(
name|path
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|pathP
argument_list|,
name|curveP
argument_list|,
name|segmentP
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle_id
condition|)
block|{
if|if
condition|(
name|handle_idP
condition|)
operator|(
operator|*
name|handle_idP
operator|)
operator|=
name|handle_id
expr_stmt|;
return|return
name|ON_HANDLE
return|;
block|}
name|pos
operator|=
name|path_tool_on_curve
argument_list|(
name|path
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|pathP
argument_list|,
name|curveP
argument_list|,
name|segmentP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|positionP
condition|)
operator|(
operator|*
name|positionP
operator|)
operator|=
name|pos
expr_stmt|;
return|return
name|ON_CURVE
return|;
block|}
return|return
name|ON_CANVAS
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/**************************************************************  * The click-callbacks for the tool  */
end_comment

begin_ifdef
unit|void path_tool_button_press (Tool           *tool, 			GdkEventButton *bevent, 			GDisplay       *gdisp) {    PathTool * path_tool;    gint grab_pointer=0;    gint x, y, halfwidth, dummy;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "path_tool_button_press\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|path_tool = (PathTool *) tool->private;    tool->gdisp = gdisp;
comment|/* Transform window-coordinates to canvas-coordinates */
end_comment

begin_ifdef
unit|gdisplay_untransform_coords (gdisp, bevent->x, bevent->y,&x,&y, TRUE, 0);
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf(stderr, "Clickcoordinates %d, %d\n",x,y);
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|path_tool->click_x = x;    path_tool->click_y = y;    path_tool->click_modifier = bevent->state;
comment|/* get halfwidth in image coord */
end_comment

begin_comment
unit|gdisplay_untransform_coords (gdisp, bevent->x + PATH_TOOL_HALFWIDTH, 0,&halfwidth,&dummy, TRUE, 0);    halfwidth -= x;    path_tool->click_halfwidth = halfwidth;        if (!path_tool->cur_path->curves)       draw_core_start (path_tool->core, gdisp->canvas->window, tool);
comment|/* determine point, where clicked,     * switch accordingly.     */
end_comment

begin_ifdef
unit|path_tool->click_type = path_tool_cursor_position (tool, x, y, halfwidth,&(path_tool->click_path),&(path_tool->click_curve),&(path_tool->click_segment),&(path_tool->click_position),&(path_tool->click_handle_id));       switch (path_tool->click_type)    {    case ON_CANVAS:       grab_pointer = path_tool_button_press_canvas(tool, bevent, gdisp);       break;     case ON_ANCHOR:       grab_pointer = path_tool_button_press_anchor(tool, bevent, gdisp);       break;     case ON_HANDLE:       grab_pointer = path_tool_button_press_handle(tool, bevent, gdisp);       break;     case ON_CURVE:       grab_pointer = path_tool_button_press_curve(tool, bevent, gdisp);       break;     default:       g_message("Huh? Whats happening here? (button_press_*)");    }       if (grab_pointer)       gdk_pointer_grab (gdisp->canvas->window, FALSE, 		        GDK_POINTER_MOTION_HINT_MASK | 			GDK_BUTTON1_MOTION_MASK | 			GDK_BUTTON_RELEASE_MASK, 			NULL, NULL, bevent->time);     tool->state = ACTIVE;  }  gint path_tool_button_press_anchor (Tool *tool,                                GdkEventButton *bevent,                                GDisplay *gdisp) {    static guint32 last_click_time=0;    gboolean doubleclick=FALSE;    PathTool *path_tool = tool->private;        NPath * cur_path = path_tool->cur_path;    PathSegment *p_sas;    gint grab_pointer;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf(stderr, "path_tool_button_press_anchor:\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|grab_pointer = 1;     if (!cur_path) {
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Fatal error: No current Path\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|return 0;    }
comment|/*      * We have to determine, if this was a doubleclick for ourself, because     * disp_callback.c ignores the GDK_[23]BUTTON_EVENT's and adding them to     * the switch statement confuses some tools.     */
end_comment

begin_ifdef
unit|if (bevent->time - last_click_time< 250) {       doubleclick=TRUE;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Doppelclick!\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|} else       doubleclick=FALSE;    last_click_time = bevent->time;      draw_core_pause (path_tool->core, tool);
comment|/* The user pressed on an anchor:     *  normally this activates this anchor     *  + SHIFT toggles the activity of an anchor.     *  if this anchor is at the end of an open curve and the other     *  end is active, close the curve.     *       *  Doubleclick (de)activates the whole curve (not Path!).     */
end_comment

begin_ifdef
unit|p_sas = path_tool->single_active_segment;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "p_sas: %p\n", p_sas);
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|if (path_tool->click_modifier& GDK_SHIFT_MASK) {       if (path_tool->active_count == 1&& p_sas&& p_sas != path_tool->click_segment&&           (p_sas->next == NULL || p_sas->prev == NULL)&& 	  (path_tool->click_segment->next == NULL || path_tool->click_segment->prev == NULL)) {
comment|/* 	  * if this is the end of an open curve and the single active segment was another 	  * open end, connect those ends. 	  */
end_comment

begin_comment
unit|path_join_curves (path_tool->click_segment, p_sas); 	 path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve, 	                 NULL, 0, SEGMENT_ACTIVE);       }        if (doubleclick)
comment|/* 	  * Doubleclick set the whole curve to the same state, depending on the 	  * state of the clicked anchor. 	  */
end_comment

begin_comment
unit|if (path_tool->click_segment->flags& SEGMENT_ACTIVE) 	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve, 		            NULL, SEGMENT_ACTIVE, 0); 	 else 	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve,      		            NULL, 0, SEGMENT_ACTIVE);       else
comment|/* 	  * Toggle the state of the clicked anchor. 	  */
end_comment

begin_comment
unit|if (path_tool->click_segment->flags& SEGMENT_ACTIVE) 	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve, 	 	            path_tool->click_segment, 0, SEGMENT_ACTIVE); 	 else 	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve, 		            path_tool->click_segment, SEGMENT_ACTIVE, 0);    }
comment|/*     * Delete anchors, when CONTROL is pressed     */
end_comment

begin_comment
unit|else if (path_tool->click_modifier& GDK_CONTROL_MASK)    {       if (path_tool->click_segment->flags& SEGMENT_ACTIVE)       { 	 if (path_tool->click_segment->prev) 	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve,    		            path_tool->click_segment->prev, SEGMENT_ACTIVE, 0);      	 else if (path_tool->click_segment->next)    	    path_set_flags (path_tool, path_tool->click_path, path_tool->click_curve, 		            path_tool->click_segment->next, SEGMENT_ACTIVE, 0);       }        path_delete_segment (path_tool->click_segment);       path_tool->click_segment = NULL;
comment|/* Maybe CTRL-ALT Click should remove the whole curve? Or the active points? */
end_comment

begin_ifdef
unit|}    else if (!(path_tool->click_segment->flags& SEGMENT_ACTIVE))    {       path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE);       path_set_flags (path_tool, cur_path, path_tool->click_curve, path_tool->click_segment, SEGMENT_ACTIVE, 0);    }         draw_core_resume(path_tool->core, tool);     return grab_pointer; }   gint path_tool_button_press_handle (Tool *tool,                                GdkEventButton *bevent,                                GDisplay *gdisp) {    static guint32 last_click_time=0;    gboolean doubleclick=FALSE;    PathTool *path_tool = tool->private;        NPath * cur_path = path_tool->cur_path;    gint grab_pointer;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf(stderr, "path_tool_button_press_handle:\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|grab_pointer = 1;     if (!cur_path) {
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Fatal error: No current Path\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|return 0;    }
comment|/*      * We have to determine, if this was a doubleclick for ourself, because     * disp_callback.c ignores the GDK_[23]BUTTON_EVENT's and adding them to     * the switch statement confuses some tools.     */
end_comment

begin_ifdef
unit|if (bevent->time - last_click_time< 250) {       doubleclick=TRUE;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Doppelclick!\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|} else       doubleclick=FALSE;    last_click_time = bevent->time;     return grab_pointer; }  gint path_tool_button_press_canvas (Tool *tool,                                GdkEventButton *bevent,                                GDisplay *gdisp) {    PathTool *path_tool = tool->private;        NPath * cur_path = path_tool->cur_path;    PathCurve * cur_curve;    PathSegment * cur_segment;    gint grab_pointer;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf(stderr, "path_tool_button_press_canvas:\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|grab_pointer = 1;        if (!cur_path) {
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Fatal error: No current Path\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|return 0;    }        draw_core_pause (path_tool->core, tool);        if (path_tool->active_count == 1&& path_tool->single_active_segment != NULL&& (path_tool->single_active_segment->prev == NULL || path_tool->single_active_segment->next == NULL)) {       cur_segment = path_tool->single_active_segment;       cur_curve = cur_segment->parent;        path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE);        if (cur_segment->next == NULL) 	 cur_curve->cur_segment = path_append_segment(cur_path, cur_curve, SEGMENT_BEZIER, path_tool->click_x, path_tool->click_y);       else 	 cur_curve->cur_segment = path_prepend_segment(cur_path, cur_curve, SEGMENT_BEZIER, path_tool->click_x, path_tool->click_y);       if (cur_curve->cur_segment) { 	 path_set_flags (path_tool, cur_path, cur_curve, cur_curve->cur_segment, SEGMENT_ACTIVE, 0);       }    } else {       if (path_tool->active_count == 0) { 	 path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE); 	 cur_path->cur_curve = path_add_curve(cur_path, path_tool->click_x, path_tool->click_y); 	 path_set_flags (path_tool, cur_path, cur_path->cur_curve, cur_path->cur_curve->segments, SEGMENT_ACTIVE, 0);       } else { 	 path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE);       }    }        draw_core_resume(path_tool->core, tool);     return 0; }  gint path_tool_button_press_curve (Tool *tool, 			      GdkEventButton *bevent, 			      GDisplay *gdisp) {    PathTool *path_tool = tool->private;        NPath * cur_path = path_tool->cur_path;    PathSegment * cur_segment;    gint grab_pointer;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf(stderr, "path_tool_button_press_curve:\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|grab_pointer = 1;        if (!cur_path) {
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "Fatal error: No current NPath\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|return 0;    }        draw_core_pause (path_tool->core, tool);        if (path_tool->click_modifier& GDK_SHIFT_MASK) {       cur_segment = path_curve_insert_anchor (path_tool, path_tool->click_segment, path_tool->click_position);       path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE);       path_set_flags (path_tool, cur_path, path_tool->click_curve, cur_segment, SEGMENT_ACTIVE, 0);       path_tool->click_type = ON_ANCHOR;       path_tool->click_segment = cur_segment;     } else {       path_set_flags (path_tool, cur_path, NULL, NULL, 0, SEGMENT_ACTIVE);       path_set_flags (path_tool, cur_path, path_tool->click_curve, path_tool->click_segment, SEGMENT_ACTIVE, 0);       path_set_flags (path_tool, cur_path, path_tool->click_curve, path_tool->click_segment->next, SEGMENT_ACTIVE, 0);    }    draw_core_resume(path_tool->core, tool);     return 0; }  void path_tool_button_release (Tool           *tool, 			  GdkEventButton *bevent, 			  GDisplay       *gdisp) {    PathTool * path_tool;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "path_tool_button_release\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|path_tool = (PathTool *) tool->private;        path_tool->state&= ~PATH_TOOL_DRAG;     gdk_pointer_ungrab (bevent->time);    gdk_flush (); }
comment|/**************************************************************  * The motion-callbacks for the tool  */
end_comment

begin_comment
unit|void path_tool_motion (Tool           *tool, 		  GdkEventMotion *mevent, 		  GDisplay       *gdisp) {    PathTool * path_tool;     if (gtk_events_pending()) return;        path_tool = (PathTool *) tool->private;     switch (path_tool->click_type) {    case ON_ANCHOR:       path_tool_motion_anchor (tool, mevent, gdisp);       break;    case ON_HANDLE:       path_tool_motion_handle (tool, mevent, gdisp);       break;    case ON_CURVE:       path_tool_motion_curve (tool, mevent, gdisp);       break;    default:       return;    }  }  void path_tool_motion_anchor (Tool           *tool, 		         GdkEventMotion *mevent, 		         GDisplay       *gdisp) {    PathTool * path_tool;    gdouble dx, dy, d;    gint x,y;    static gint dxsum = 0;    static gint dysum = 0;        path_tool = (PathTool *) tool->private;
comment|/*     * Dont do anything, if the user clicked with pressed CONTROL-Key,     * because he deleted an anchor.     */
end_comment

begin_comment
unit|if (path_tool->click_modifier& GDK_CONTROL_MASK)       return;        if (!(path_tool->state& PATH_TOOL_DRAG))    {       path_tool->state |= PATH_TOOL_DRAG;       dxsum = 0;       dysum = 0;    }     gdisplay_untransform_coords (gdisp, mevent->x, mevent->y,&x,&y, TRUE, 0);        dx = x - path_tool->click_x - dxsum;    dy = y - path_tool->click_y - dysum;
comment|/* restrict to horizontal/vertical lines, if modifiers are pressed     * I'm not sure, if this is intuitive for the user. Esp. When moving     * an endpoint of an curve I'd expect, that the *line* is     * horiz/vertical - not the delta to the point, where the point was     * originally...     */
end_comment

begin_comment
unit|if (mevent->state& GDK_MOD1_MASK)    {       if (mevent->state& GDK_CONTROL_MASK)       { 	 d  = (fabs(dx) + fabs(dy)) / 2;   	 d  = (fabs(x - path_tool->click_x) + fabs(y - path_tool->click_y)) / 2;   	  	 dx = ((x< path_tool->click_x) ? -d : d ) - dxsum; 	 dy = ((y< path_tool->click_y) ? -d : d ) - dysum;       }       else 	 dx = - dxsum;    }    else if (mevent->state& GDK_CONTROL_MASK)       dy = - dysum;         path_tool->draw |= PATH_TOOL_REDRAW_ACTIVE;        draw_core_pause(path_tool->core, tool);     path_offset_active (path_tool->cur_path, dx, dy);     dxsum += dx;    dysum += dy;     draw_core_resume (path_tool->core, tool);        path_tool->draw&= ~PATH_TOOL_REDRAW_ACTIVE;  }  void path_tool_motion_handle (Tool           *tool, 		         GdkEventMotion *mevent, 		         GDisplay       *gdisp) {    PathTool * path_tool;    gdouble dx, dy;    gint x,y;    static gint dxsum = 0;    static gint dysum = 0;        path_tool = (PathTool *) tool->private;
comment|/*     * Dont do anything, if the user clicked with pressed CONTROL-Key,     * because he moved the handle to the anchor an anchor.      * XXX: Not yet! :-)     */
end_comment

begin_ifdef
unit|if (path_tool->click_modifier& GDK_CONTROL_MASK)       return;        if (!(path_tool->state& PATH_TOOL_DRAG))    {       path_tool->state |= PATH_TOOL_DRAG;       dxsum = 0;       dysum = 0;    }     gdisplay_untransform_coords (gdisp, mevent->x, mevent->y,&x,&y, TRUE, 0);        dx = x - path_tool->click_x - dxsum;    dy = y - path_tool->click_y - dysum;        path_tool->draw |= PATH_TOOL_REDRAW_ACTIVE;        draw_core_pause(path_tool->core, tool);     path_curve_drag_handle (path_tool, path_tool->click_segment, dx, dy, path_tool->click_handle_id);     dxsum += dx;    dysum += dy;     draw_core_resume (path_tool->core, tool);        path_tool->draw&= ~PATH_TOOL_REDRAW_ACTIVE;  }      void path_tool_motion_curve (Tool           *tool, 		        GdkEventMotion *mevent, 		        GDisplay       *gdisp) {    PathTool * path_tool;    gdouble dx, dy;    gint x,y;    static gint dxsum = 0;    static gint dysum = 0;        path_tool = (PathTool *) tool->private;        if (!(path_tool->state& PATH_TOOL_DRAG))    {       path_tool->state |= PATH_TOOL_DRAG;       dxsum = 0;       dysum = 0;    }     gdisplay_untransform_coords (gdisp, mevent->x, mevent->y,&x,&y, TRUE, 0);        dx = x - path_tool->click_x - dxsum;    dy = y - path_tool->click_y - dysum;        path_tool->draw |= PATH_TOOL_REDRAW_ACTIVE;        draw_core_pause(path_tool->core, tool);     path_curve_drag_segment (path_tool, path_tool->click_segment, path_tool->click_position, dx, dy);     dxsum += dx;    dysum += dy;     draw_core_resume (path_tool->core, tool);        path_tool->draw&= ~PATH_TOOL_REDRAW_ACTIVE;  }      void path_tool_cursor_update (Tool           *tool, 			 GdkEventMotion *mevent, 			 GDisplay       *gdisp) {    PathTool *path_tool;    gint     x, y, halfwidth, dummy, cursor_location;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_comment
comment|/* fprintf (stderr, "path_tool_cursor_update\n");     */
end_comment

begin_endif
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|path_tool = (PathTool *) tool->private;     gdisplay_untransform_coords (gdisp, mevent->x, mevent->y,&x,&y, TRUE, 0);
comment|/* get halfwidth in image coord */
end_comment

begin_comment
unit|gdisplay_untransform_coords (gdisp, mevent->x + PATH_TOOL_HALFWIDTH, 0,&halfwidth,&dummy, TRUE, 0);    halfwidth -= x;     cursor_location = path_tool_cursor_position (tool, x, y, halfwidth, NULL, NULL, NULL, NULL, NULL);     switch (cursor_location) {    case ON_CANVAS:       gdisplay_install_tool_cursor (gdisp, GIMP_MOUSE1AP_CURSOR);       break;    case ON_ANCHOR:       gdisplay_install_tool_cursor (gdisp, GDK_FLEUR);       break;    case ON_HANDLE:       gdisplay_install_tool_cursor (gdisp, GDK_CROSSHAIR);       break;    case ON_CURVE:       gdisplay_install_tool_cursor (gdisp, GDK_CROSSHAIR);       break;    default:       gdisplay_install_tool_cursor (gdisp, GDK_QUESTION_ARROW);       break;    } }
comment|/**************************************************************  * Tool-control functions  */
end_comment

begin_ifdef
unit|void path_tool_control (Tool       *tool, 		   ToolAction  action, 		   GDisplay   *gdisp) {    PathTool * path_tool;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "path_tool_control\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|path_tool = (PathTool *) tool->private;     switch (action)      {      case PAUSE:         draw_core_pause (path_tool->core, tool);         break;       case RESUME:         draw_core_resume (path_tool->core, tool);         break;       case HALT:
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "path_tool_control: HALT\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|draw_core_stop (path_tool->core, tool);         tool->state = INACTIVE;         break;       default:         break;      }
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "path_tool_control: end\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_comment
unit|}  Tool * tools_new_path_tool (void) {    Tool * tool;    PathTool * private;
comment|/*  The tool options  */
end_comment

begin_ifdef
unit|if (! path_options)       {          path_options = tool_options_new (_("Path Tool"));          tools_register (PATH_TOOL, (ToolOptions *) path_options);       }     tool = tools_new_tool (PATH_TOOL);    private = g_new0 (PathTool, 1);     private->click_type       = ON_CANVAS;    private->click_x         = 0;    private->click_y         = 0;    private->click_halfwidth = 0;    private->click_modifier  = 0;    private->click_path      = NULL;    private->click_curve     = NULL;    private->click_segment   = NULL;    private->click_position  = -1;     private->active_count    = 0;    private->single_active_segment = NULL;     private->state           = 0;    private->draw            = PATH_TOOL_REDRAW_ALL;    private->core            = draw_core_new (path_tool_draw);    private->cur_path        = g_new0(NPath, 1);    private->scanlines       = NULL;      tool->private = (void *) private;      tool->button_press_func   = path_tool_button_press;    tool->button_release_func = path_tool_button_release;    tool->motion_func         = path_tool_motion;    tool->cursor_update_func  = path_tool_cursor_update;    tool->control_func        = path_tool_control;     private->cur_path->curves    = NULL;    private->cur_path->cur_curve = NULL;    private->cur_path->name      = g_string_new("Path 0");    private->cur_path->state     = 0;    private->cur_path->path_tool = private;        return tool; }  void tools_free_path_tool (Tool *tool) {    GDisplay * gdisp;    PathTool * path_tool;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "tools_free_path_tool start\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_ifdef
unit|path_tool = (PathTool *) tool->private;    gdisp = tool->gdisp;     if (tool->state == ACTIVE)    {       draw_core_stop (path_tool->core, tool);    }        path_free_path (path_tool->cur_path);     draw_core_free (path_tool->core);        g_free (path_tool);
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
end_ifdef

begin_endif
unit|fprintf (stderr, "tools_free_path_tool end\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
end_endif

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************  * Set of function to determine, if the click was on a segment  */
end_comment

begin_typedef
DECL|struct|__anon28d398bc0108
typedef|typedef
struct|struct
block|{
DECL|member|path
name|NPath
modifier|*
name|path
decl_stmt|;
DECL|member|curve
name|PathCurve
modifier|*
name|curve
decl_stmt|;
DECL|member|segment
name|PathSegment
modifier|*
name|segment
decl_stmt|;
DECL|member|testx
name|gint
name|testx
decl_stmt|;
DECL|member|testy
name|gint
name|testy
decl_stmt|;
DECL|member|halfwidth
name|gint
name|halfwidth
decl_stmt|;
DECL|member|distance
name|gint
name|distance
decl_stmt|;
DECL|member|position
name|gdouble
name|position
decl_stmt|;
DECL|member|found
name|gboolean
name|found
decl_stmt|;
DECL|typedef|Path_on_curve_type
block|}
name|Path_on_curve_type
typedef|;
end_typedef

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_tool_on_curve_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer ptr)
name|path_tool_on_curve_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|ptr
parameter_list|)
block|{
name|gint
name|distance
decl_stmt|;
name|gdouble
name|position
decl_stmt|;
name|Path_on_curve_type
modifier|*
name|data
init|=
operator|(
name|Path_on_curve_type
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|segment
operator|&&
name|segment
operator|->
name|next
operator|&&
name|data
operator|&&
name|data
operator|->
name|distance
operator|>
literal|0
condition|)
block|{
name|position
operator|=
name|path_curve_on_segment
argument_list|(
name|segment
argument_list|,
name|data
operator|->
name|testx
argument_list|,
name|data
operator|->
name|testy
argument_list|,
name|data
operator|->
name|halfwidth
argument_list|,
operator|&
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|>=
literal|0
operator|&&
name|distance
operator|<
name|data
operator|->
name|distance
condition|)
block|{
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|curve
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|segment
expr_stmt|;
name|data
operator|->
name|distance
operator|=
name|distance
expr_stmt|;
name|data
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|gdouble
DECL|function|path_tool_on_curve (NPath * path,gint x,gint y,gint halfwidth,NPath ** ret_pathP,PathCurve ** ret_curveP,PathSegment ** ret_segmentP)
name|path_tool_on_curve
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|NPath
modifier|*
modifier|*
name|ret_pathP
parameter_list|,
name|PathCurve
modifier|*
modifier|*
name|ret_curveP
parameter_list|,
name|PathSegment
modifier|*
modifier|*
name|ret_segmentP
parameter_list|)
block|{
name|Path_on_curve_type
modifier|*
name|data
init|=
name|g_new
argument_list|(
name|Path_on_curve_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gdouble
name|position
decl_stmt|;
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|testx
operator|=
name|x
expr_stmt|;
name|data
operator|->
name|testy
operator|=
name|y
expr_stmt|;
name|data
operator|->
name|halfwidth
operator|=
name|halfwidth
expr_stmt|;
name|data
operator|->
name|distance
operator|=
name|halfwidth
operator|*
name|halfwidth
operator|+
literal|1
expr_stmt|;
name|data
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|FALSE
expr_stmt|;
name|path_traverse_path
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|path_tool_on_curve_helper
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_pathP
condition|)
operator|*
name|ret_pathP
operator|=
name|data
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ret_curveP
condition|)
operator|*
name|ret_curveP
operator|=
name|data
operator|->
name|curve
expr_stmt|;
if|if
condition|(
name|ret_segmentP
condition|)
operator|*
name|ret_segmentP
operator|=
name|data
operator|->
name|segment
expr_stmt|;
name|position
operator|=
name|data
operator|->
name|position
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|position
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * Set of function to determine, if the click was on an anchor  */
end_comment

begin_typedef
DECL|struct|__anon28d398bc0208
typedef|typedef
struct|struct
block|{
DECL|member|path
name|NPath
modifier|*
name|path
decl_stmt|;
DECL|member|curve
name|PathCurve
modifier|*
name|curve
decl_stmt|;
DECL|member|segment
name|PathSegment
modifier|*
name|segment
decl_stmt|;
DECL|member|testx
name|gint
name|testx
decl_stmt|;
DECL|member|testy
name|gint
name|testy
decl_stmt|;
DECL|member|distance
name|gint
name|distance
decl_stmt|;
DECL|member|found
name|gboolean
name|found
decl_stmt|;
DECL|typedef|Path_on_anchors_type
block|}
name|Path_on_anchors_type
typedef|;
end_typedef

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_tool_on_anchors_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer ptr)
name|path_tool_on_anchors_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|ptr
parameter_list|)
block|{
name|gint
name|distance
decl_stmt|;
name|Path_on_anchors_type
modifier|*
name|data
init|=
operator|(
name|Path_on_anchors_type
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|segment
operator|&&
name|data
operator|&&
name|data
operator|->
name|distance
operator|>
literal|0
condition|)
block|{
name|distance
operator|=
operator|(
operator|(
name|data
operator|->
name|testx
operator|-
name|segment
operator|->
name|x
operator|)
operator|*
operator|(
name|data
operator|->
name|testx
operator|-
name|segment
operator|->
name|x
operator|)
operator|+
operator|(
name|data
operator|->
name|testy
operator|-
name|segment
operator|->
name|y
operator|)
operator|*
operator|(
name|data
operator|->
name|testy
operator|-
name|segment
operator|->
name|y
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|distance
operator|<
name|data
operator|->
name|distance
condition|)
block|{
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|curve
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|segment
expr_stmt|;
name|data
operator|->
name|distance
operator|=
name|distance
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|gboolean
DECL|function|path_tool_on_anchors (NPath * path,gint x,gint y,gint halfwidth,NPath ** ret_pathP,PathCurve ** ret_curveP,PathSegment ** ret_segmentP)
name|path_tool_on_anchors
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|NPath
modifier|*
modifier|*
name|ret_pathP
parameter_list|,
name|PathCurve
modifier|*
modifier|*
name|ret_curveP
parameter_list|,
name|PathSegment
modifier|*
modifier|*
name|ret_segmentP
parameter_list|)
block|{
name|Path_on_anchors_type
modifier|*
name|data
init|=
name|g_new
argument_list|(
name|Path_on_anchors_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gboolean
name|ret_found
decl_stmt|;
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|testx
operator|=
name|x
expr_stmt|;
name|data
operator|->
name|testy
operator|=
name|y
expr_stmt|;
name|data
operator|->
name|distance
operator|=
name|halfwidth
operator|*
name|halfwidth
operator|+
literal|1
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|FALSE
expr_stmt|;
name|path_traverse_path
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|path_tool_on_anchors_helper
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_pathP
condition|)
operator|*
name|ret_pathP
operator|=
name|data
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ret_curveP
condition|)
operator|*
name|ret_curveP
operator|=
name|data
operator|->
name|curve
expr_stmt|;
if|if
condition|(
name|ret_segmentP
condition|)
operator|*
name|ret_segmentP
operator|=
name|data
operator|->
name|segment
expr_stmt|;
name|ret_found
operator|=
name|data
operator|->
name|found
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_found
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * Set of function to determine, if the click was on an handle  */
end_comment

begin_typedef
DECL|struct|__anon28d398bc0308
typedef|typedef
struct|struct
block|{
DECL|member|path
name|NPath
modifier|*
name|path
decl_stmt|;
DECL|member|curve
name|PathCurve
modifier|*
name|curve
decl_stmt|;
DECL|member|segment
name|PathSegment
modifier|*
name|segment
decl_stmt|;
DECL|member|testx
name|gint
name|testx
decl_stmt|;
DECL|member|testy
name|gint
name|testy
decl_stmt|;
DECL|member|halfwidth
name|gint
name|halfwidth
decl_stmt|;
DECL|member|handle_id
name|gint
name|handle_id
decl_stmt|;
DECL|member|found
name|gboolean
name|found
decl_stmt|;
DECL|typedef|Path_on_handles_type
block|}
name|Path_on_handles_type
typedef|;
end_typedef

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_tool_on_handles_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer ptr)
name|path_tool_on_handles_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|ptr
parameter_list|)
block|{
name|Path_on_handles_type
modifier|*
name|data
init|=
operator|(
name|Path_on_handles_type
operator|*
operator|)
name|ptr
decl_stmt|;
name|gint
name|handle
decl_stmt|;
if|if
condition|(
name|segment
operator|&&
name|data
operator|&&
operator|!
name|data
operator|->
name|found
condition|)
block|{
name|handle
operator|=
name|path_curve_on_handle
argument_list|(
name|segment
argument_list|,
name|data
operator|->
name|testx
argument_list|,
name|data
operator|->
name|testy
argument_list|,
name|data
operator|->
name|halfwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|curve
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|segment
expr_stmt|;
name|data
operator|->
name|handle_id
operator|=
name|handle
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|gint
DECL|function|path_tool_on_handles (NPath * path,gint x,gint y,gint halfwidth,NPath ** ret_pathP,PathCurve ** ret_curveP,PathSegment ** ret_segmentP)
name|path_tool_on_handles
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|NPath
modifier|*
modifier|*
name|ret_pathP
parameter_list|,
name|PathCurve
modifier|*
modifier|*
name|ret_curveP
parameter_list|,
name|PathSegment
modifier|*
modifier|*
name|ret_segmentP
parameter_list|)
block|{
name|Path_on_handles_type
modifier|*
name|data
init|=
name|g_new
argument_list|(
name|Path_on_handles_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gint
name|handle_ret
decl_stmt|;
name|data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|data
operator|->
name|curve
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|segment
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|testx
operator|=
name|x
expr_stmt|;
name|data
operator|->
name|testy
operator|=
name|y
expr_stmt|;
name|data
operator|->
name|halfwidth
operator|=
name|halfwidth
expr_stmt|;
name|data
operator|->
name|handle_id
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|found
operator|=
name|FALSE
expr_stmt|;
name|path_traverse_path
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|path_tool_on_handles_helper
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_pathP
condition|)
operator|*
name|ret_pathP
operator|=
name|data
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ret_curveP
condition|)
operator|*
name|ret_curveP
operator|=
name|data
operator|->
name|curve
expr_stmt|;
if|if
condition|(
name|ret_segmentP
condition|)
operator|*
name|ret_segmentP
operator|=
name|data
operator|->
name|segment
expr_stmt|;
name|handle_ret
operator|=
name|data
operator|->
name|handle_id
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|handle_ret
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * Set of function to offset all active anchors  */
end_comment

begin_typedef
DECL|struct|__anon28d398bc0408
typedef|typedef
struct|struct
block|{
DECL|member|dx
name|gdouble
name|dx
decl_stmt|;
DECL|member|dy
name|gdouble
name|dy
decl_stmt|;
DECL|typedef|Path_offset_active_type
block|}
name|Path_offset_active_type
typedef|;
end_typedef

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_offset_active_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer ptr)
name|path_offset_active_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|ptr
parameter_list|)
block|{
name|Path_offset_active_type
modifier|*
name|data
init|=
operator|(
name|Path_offset_active_type
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|segment
operator|&&
name|data
operator|&&
operator|(
name|segment
operator|->
name|flags
operator|&
name|SEGMENT_ACTIVE
operator|)
condition|)
block|{
name|segment
operator|->
name|x
operator|+=
name|data
operator|->
name|dx
expr_stmt|;
name|segment
operator|->
name|y
operator|+=
name|data
operator|->
name|dy
expr_stmt|;
block|}
comment|/* XXX: Do a segment_update here! */
block|}
end_function

begin_function
name|void
DECL|function|path_offset_active (NPath * path,gdouble dx,gdouble dy)
name|path_offset_active
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|gdouble
name|dx
parameter_list|,
name|gdouble
name|dy
parameter_list|)
block|{
name|Path_offset_active_type
modifier|*
name|data
init|=
name|g_new
argument_list|(
name|Path_offset_active_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|data
operator|->
name|dx
operator|=
name|dx
expr_stmt|;
name|data
operator|->
name|dy
operator|=
name|dy
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|path_traverse_path
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|path_offset_active_helper
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************  * Set of function to set the state of all anchors  */
end_comment

begin_typedef
DECL|struct|__anon28d398bc0508
typedef|typedef
struct|struct
block|{
DECL|member|bits_set
name|guint32
name|bits_set
decl_stmt|;
DECL|member|bits_clear
name|guint32
name|bits_clear
decl_stmt|;
DECL|member|path_tool
name|GimpPathTool
modifier|*
name|path_tool
decl_stmt|;
DECL|typedef|Path_set_flags_type
block|}
name|Path_set_flags_type
typedef|;
end_typedef

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_set_flags_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer ptr)
name|path_set_flags_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|ptr
parameter_list|)
block|{
name|Path_set_flags_type
modifier|*
name|tmp
init|=
operator|(
name|Path_set_flags_type
operator|*
operator|)
name|ptr
decl_stmt|;
name|guint32
name|oldflags
decl_stmt|;
name|guint
name|tmp_uint
decl_stmt|;
if|if
condition|(
name|segment
condition|)
block|{
name|oldflags
operator|=
name|segment
operator|->
name|flags
expr_stmt|;
name|segment
operator|->
name|flags
operator|&=
operator|~
operator|(
name|tmp
operator|->
name|bits_clear
operator|)
expr_stmt|;
name|segment
operator|->
name|flags
operator||=
name|tmp
operator|->
name|bits_set
expr_stmt|;
comment|/*         * Some black magic: We try to remember, which is the single active        * segment.  We count, how many segments are active (in        * path_tool->active_count) and XOR path_tool->single_active_segment        * every time we select or deselect an anchor. So if exactly one anchor        * is active, path_tool->single_active_segment points to it.        */
if|#
directive|if
literal|0
comment|/* If SEGMENT_ACTIVE state has changed change the PathTool data        * accordingly.        */
block|if (((segment->flags ^ oldflags)& SEGMENT_ACTIVE)&& tmp&& tmp->path_tool) { 	 if (segment->flags& SEGMENT_ACTIVE) 	    tmp->path_tool->active_count++; 	 else 	    tmp->path_tool->active_count--;
comment|/* Does this work on all (16|32|64)-bit Machines? */
block|tmp_uint = GPOINTER_TO_UINT(tmp->path_tool->single_active_segment);          tmp_uint ^= GPOINTER_TO_UINT(segment); 	 tmp->path_tool->single_active_segment = GUINT_TO_POINTER(tmp_uint);       }
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
DECL|function|path_set_flags (GimpPathTool * path_tool,NPath * path,PathCurve * curve,PathSegment * segment,guint32 bits_set,guint32 bits_clear)
name|path_set_flags
parameter_list|(
name|GimpPathTool
modifier|*
name|path_tool
parameter_list|,
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|guint32
name|bits_set
parameter_list|,
name|guint32
name|bits_clear
parameter_list|)
block|{
name|Path_set_flags_type
modifier|*
name|tmp
init|=
name|g_new
argument_list|(
name|Path_set_flags_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|bits_set
operator|=
name|bits_set
expr_stmt|;
name|tmp
operator|->
name|bits_clear
operator|=
name|bits_clear
expr_stmt|;
name|tmp
operator|->
name|path_tool
operator|=
name|path_tool
expr_stmt|;
if|if
condition|(
name|segment
condition|)
name|path_set_flags_helper
argument_list|(
name|path
argument_list|,
name|curve
argument_list|,
name|segment
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curve
condition|)
name|path_traverse_curve
argument_list|(
name|path
argument_list|,
name|curve
argument_list|,
name|path_set_flags_helper
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
condition|)
name|path_traverse_path
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|path_set_flags_helper
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************  * Set of functions to draw the segments to the window  */
end_comment

begin_comment
comment|/* This is a CurveTraverseFunc */
end_comment

begin_function
name|void
DECL|function|path_tool_draw_helper (NPath * path,PathCurve * curve,PathSegment * segment,gpointer tool_ptr)
name|path_tool_draw_helper
parameter_list|(
name|NPath
modifier|*
name|path
parameter_list|,
name|PathCurve
modifier|*
name|curve
parameter_list|,
name|PathSegment
modifier|*
name|segment
parameter_list|,
name|gpointer
name|tool_ptr
parameter_list|)
block|{
if|#
directive|if
literal|0
block|Tool     * tool = (Tool *) tool_ptr;    GDisplay * gdisp;    PathTool * path_tool;    DrawCore * core;    gint x1, y1;    gboolean draw = TRUE;        if (!tool) {
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
block|fprintf (stderr, "Fatal Error: path_tool_draw_segment called without valid tool *\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
block|return;    }        gdisp = tool->gdisp;     path_tool = (PathTool *) tool->private;    core = path_tool->core;        if (path_tool->draw& PATH_TOOL_REDRAW_ACTIVE)       draw = (segment->flags& SEGMENT_ACTIVE || (segment->next&& segment->next->flags& SEGMENT_ACTIVE));     if (segment&& draw)     {       gdisplay_transform_coords (gdisp, (gint) segment->x, (gint) segment->y,&x1,&y1, FALSE);       if (segment->flags& SEGMENT_ACTIVE)          gdk_draw_arc (core->win, core->gc, 0, 	               x1 - PATH_TOOL_HALFWIDTH, y1 - PATH_TOOL_HALFWIDTH, 		       PATH_TOOL_WIDTH, PATH_TOOL_WIDTH, 0, 23040);       else          gdk_draw_arc (core->win, core->gc, 1, 	               x1 - PATH_TOOL_HALFWIDTH, y1 - PATH_TOOL_HALFWIDTH, 		       PATH_TOOL_WIDTH, PATH_TOOL_WIDTH, 0, 23040);              path_curve_draw_handles (tool, segment);           if (segment->next)       {          path_curve_draw_segment (tool, segment);       }    }
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
block|else if (!segment)       fprintf(stderr, "path_tool_draw_segment: no segment to draw\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|path_tool_draw (Tool * tool)
name|path_tool_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
if|#
directive|if
literal|0
block|GDisplay * gdisp;    NPath * cur_path;    PathTool * path_tool;
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
block|fprintf (stderr, "path_tool_draw\n");
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
block|gdisp = tool->gdisp;    path_tool = tool->private;    cur_path = path_tool->cur_path;        path_traverse_path (cur_path, NULL, path_tool_draw_helper, NULL, tool);
ifdef|#
directive|ifdef
name|PATH_TOOL_DEBUG
comment|/* fprintf (stderr, "path_tool_draw end.\n");     */
endif|#
directive|endif
endif|PATH_TOOL_DEBUG
endif|#
directive|endif
block|}
end_function

end_unit

