begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"libgimpwidgets/gimpwidgets.h"
end_include

begin_include
include|#
directive|include
file|"tools-types.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp-transform-utils.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpdrawable-transform.h"
end_include

begin_include
include|#
directive|include
file|"core/gimp-utils.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpvectors.h"
end_include

begin_include
include|#
directive|include
file|"vectors/gimpstroke.h"
end_include

begin_include
include|#
directive|include
file|"widgets/gimphelp-ids.h"
end_include

begin_include
include|#
directive|include
file|"display/gimpcanvasgroup.h"
end_include

begin_include
include|#
directive|include
file|"display/gimpdisplay.h"
end_include

begin_include
include|#
directive|include
file|"display/gimpdisplayshell.h"
end_include

begin_include
include|#
directive|include
file|"display/gimpdisplayshell-transform.h"
end_include

begin_include
include|#
directive|include
file|"gimpunifiedtransformtool.h"
end_include

begin_include
include|#
directive|include
file|"gimptoolcontrol.h"
end_include

begin_include
include|#
directive|include
file|"gimptransformoptions.h"
end_include

begin_include
include|#
directive|include
file|"gimp-intl.h"
end_include

begin_comment
comment|/*  index into trans_info array  */
end_comment

begin_enum
enum|enum
DECL|enum|__anon2882ca3c0103
block|{
DECL|enumerator|X0
name|X0
block|,
DECL|enumerator|Y0
name|Y0
block|,
DECL|enumerator|X1
name|X1
block|,
DECL|enumerator|Y1
name|Y1
block|,
DECL|enumerator|X2
name|X2
block|,
DECL|enumerator|Y2
name|Y2
block|,
DECL|enumerator|X3
name|X3
block|,
DECL|enumerator|Y3
name|Y3
block|,
DECL|enumerator|PIVOT_X
name|PIVOT_X
block|,
DECL|enumerator|PIVOT_Y
name|PIVOT_Y
block|, }
enum|;
end_enum

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_dialog
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_dialog_update
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_prepare
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_motion
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_recalc_matrix
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_unified_transform_tool_get_undo_desc
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TransformAction
name|gimp_unified_transform_tool_pick_function
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_unified_transform_tool_draw_gui
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|,
name|gint
name|handle_w
parameter_list|,
name|gint
name|handle_h
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_TYPE (GimpUnifiedTransformTool,gimp_unified_transform_tool,GIMP_TYPE_TRANSFORM_TOOL)
name|G_DEFINE_TYPE
argument_list|(
argument|GimpUnifiedTransformTool
argument_list|,
argument|gimp_unified_transform_tool
argument_list|,
argument|GIMP_TYPE_TRANSFORM_TOOL
argument_list|)
end_macro

begin_function
name|void
name|gimp_unified_transform_tool_register
parameter_list|(
name|GimpToolRegisterCallback
name|callback
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
call|(
modifier|*
name|callback
call|)
argument_list|(
name|GIMP_TYPE_UNIFIED_TRANSFORM_TOOL
argument_list|,
name|GIMP_TYPE_TRANSFORM_OPTIONS
argument_list|,
name|gimp_transform_options_gui
argument_list|,
name|GIMP_CONTEXT_BACKGROUND_MASK
argument_list|,
literal|"gimp-unified-transform-tool"
argument_list|,
name|_
argument_list|(
literal|"Unified Transform"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unified Transform Tool: "
literal|"Transform the layer, selection or path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"_Unified Transform"
argument_list|)
argument_list|,
literal|"<shift>L"
argument_list|,
name|NULL
argument_list|,
name|GIMP_HELP_TOOL_UNIFIED_TRANSFORM
argument_list|,
name|GIMP_STOCK_TOOL_UNIFIED_TRANSFORM
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_class_init (GimpUnifiedTransformToolClass * klass)
name|gimp_unified_transform_tool_class_init
parameter_list|(
name|GimpUnifiedTransformToolClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpTransformToolClass
modifier|*
name|trans_class
init|=
name|GIMP_TRANSFORM_TOOL_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|trans_class
operator|->
name|dialog
operator|=
name|gimp_unified_transform_tool_dialog
expr_stmt|;
name|trans_class
operator|->
name|dialog_update
operator|=
name|gimp_unified_transform_tool_dialog_update
expr_stmt|;
name|trans_class
operator|->
name|prepare
operator|=
name|gimp_unified_transform_tool_prepare
expr_stmt|;
name|trans_class
operator|->
name|motion
operator|=
name|gimp_unified_transform_tool_motion
expr_stmt|;
name|trans_class
operator|->
name|recalc_matrix
operator|=
name|gimp_unified_transform_tool_recalc_matrix
expr_stmt|;
name|trans_class
operator|->
name|get_undo_desc
operator|=
name|gimp_unified_transform_tool_get_undo_desc
expr_stmt|;
name|trans_class
operator|->
name|pick_function
operator|=
name|gimp_unified_transform_tool_pick_function
expr_stmt|;
name|trans_class
operator|->
name|draw_gui
operator|=
name|gimp_unified_transform_tool_draw_gui
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_init (GimpUnifiedTransformTool * unified_tool)
name|gimp_unified_transform_tool_init
parameter_list|(
name|GimpUnifiedTransformTool
modifier|*
name|unified_tool
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
init|=
name|GIMP_TOOL
argument_list|(
name|unified_tool
argument_list|)
decl_stmt|;
name|GimpTransformTool
modifier|*
name|tr_tool
init|=
name|GIMP_TRANSFORM_TOOL
argument_list|(
name|unified_tool
argument_list|)
decl_stmt|;
name|gimp_tool_control_set_tool_cursor
argument_list|(
name|tool
operator|->
name|control
argument_list|,
name|GIMP_TOOL_CURSOR_UNIFIED_TRANSFORM
argument_list|)
expr_stmt|;
name|tr_tool
operator|->
name|progress_text
operator|=
name|_
argument_list|(
literal|"Unified transform"
argument_list|)
expr_stmt|;
name|tr_tool
operator|->
name|use_grid
operator|=
name|TRUE
expr_stmt|;
name|tr_tool
operator|->
name|use_handles
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|point_is_inside_polygon (gint n,gdouble * x,gdouble * y,gdouble px,gdouble py)
name|point_is_inside_polygon
parameter_list|(
name|gint
name|n
parameter_list|,
name|gdouble
modifier|*
name|x
parameter_list|,
name|gdouble
modifier|*
name|y
parameter_list|,
name|gdouble
name|px
parameter_list|,
name|gdouble
name|py
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gboolean
name|odd
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|j
operator|=
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
index|[
name|i
index|]
operator|<
name|py
operator|&&
name|y
index|[
name|j
index|]
operator|>=
name|py
operator|)
operator|||
operator|(
name|y
index|[
name|j
index|]
operator|<
name|py
operator|&&
name|y
index|[
name|i
index|]
operator|>=
name|py
operator|)
condition|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|+
operator|(
name|py
operator|-
name|y
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|y
index|[
name|j
index|]
operator|-
name|y
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|x
index|[
name|j
index|]
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|<
name|px
condition|)
name|odd
operator|=
operator|!
name|odd
expr_stmt|;
block|}
block|}
return|return
name|odd
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|point_is_inside_polygon_pos (GimpVector2 * pos,GimpVector2 point)
name|point_is_inside_polygon_pos
parameter_list|(
name|GimpVector2
modifier|*
name|pos
parameter_list|,
name|GimpVector2
name|point
parameter_list|)
block|{
return|return
name|point_is_inside_polygon
argument_list|(
literal|4
argument_list|,
operator|(
name|gdouble
index|[
literal|4
index|]
operator|)
block|{
name|pos
index|[
literal|0
index|]
operator|.
name|x
block|,
name|pos
index|[
literal|1
index|]
operator|.
name|x
block|,
name|pos
index|[
literal|3
index|]
operator|.
name|x
block|,
name|pos
index|[
literal|2
index|]
operator|.
name|x
block|}
argument_list|,
operator|(
name|gdouble
index|[
literal|4
index|]
operator|)
block|{
name|pos
index|[
literal|0
index|]
operator|.
name|y
block|,
name|pos
index|[
literal|1
index|]
operator|.
name|y
block|,
name|pos
index|[
literal|3
index|]
operator|.
name|y
block|,
name|pos
index|[
literal|2
index|]
operator|.
name|y
block|}
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|get_friendly_operation_name (TransformAction op)
name|get_friendly_operation_name
parameter_list|(
name|TransformAction
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|TRANSFORM_HANDLE_NONE
case|:
return|return
literal|""
return|;
case|case
name|TRANSFORM_HANDLE_NW_P
case|:
case|case
name|TRANSFORM_HANDLE_NE_P
case|:
case|case
name|TRANSFORM_HANDLE_SW_P
case|:
case|case
name|TRANSFORM_HANDLE_SE_P
case|:
return|return
literal|"Change perspective"
return|;
case|case
name|TRANSFORM_HANDLE_NW
case|:
case|case
name|TRANSFORM_HANDLE_NE
case|:
case|case
name|TRANSFORM_HANDLE_SW
case|:
case|case
name|TRANSFORM_HANDLE_SE
case|:
return|return
literal|"Scale"
return|;
case|case
name|TRANSFORM_HANDLE_N
case|:
case|case
name|TRANSFORM_HANDLE_S
case|:
case|case
name|TRANSFORM_HANDLE_E
case|:
case|case
name|TRANSFORM_HANDLE_W
case|:
return|return
literal|"Scale"
return|;
case|case
name|TRANSFORM_HANDLE_CENTER
case|:
return|return
literal|"Move"
return|;
case|case
name|TRANSFORM_HANDLE_PIVOT
case|:
return|return
literal|"Move pivot"
return|;
case|case
name|TRANSFORM_HANDLE_N_S
case|:
case|case
name|TRANSFORM_HANDLE_S_S
case|:
case|case
name|TRANSFORM_HANDLE_E_S
case|:
case|case
name|TRANSFORM_HANDLE_W_S
case|:
return|return
literal|"Shear"
return|;
case|case
name|TRANSFORM_HANDLE_ROTATION
case|:
return|return
literal|"Rotate"
return|;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|TransformAction
DECL|function|gimp_unified_transform_tool_pick_function (GimpTransformTool * tr_tool,const GimpCoords * coords,GdkModifierType state,GimpDisplay * display)
name|gimp_unified_transform_tool_pick_function
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|,
specifier|const
name|GimpCoords
modifier|*
name|coords
parameter_list|,
name|GdkModifierType
name|state
parameter_list|,
name|GimpDisplay
modifier|*
name|display
parameter_list|)
block|{
name|TransformAction
name|ret
init|=
name|TRANSFORM_HANDLE_NONE
decl_stmt|,
name|i
decl_stmt|;
name|GimpTool
modifier|*
name|tool
init|=
name|GIMP_TOOL
argument_list|(
name|tr_tool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TRANSFORM_HANDLE_NONE
operator|+
literal|1
init|;
name|i
operator|<
name|TRANSFORM_HANDLE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tr_tool
operator|->
name|handles
index|[
name|i
index|]
operator|&&
name|gimp_canvas_item_hit
argument_list|(
name|tr_tool
operator|->
name|handles
index|[
name|i
index|]
argument_list|,
name|coords
operator|->
name|x
argument_list|,
name|coords
operator|->
name|y
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|TRANSFORM_HANDLE_NONE
condition|)
block|{
comment|/* points passed in clockwise order */
if|if
condition|(
name|point_is_inside_polygon
argument_list|(
literal|4
argument_list|,
operator|(
name|gdouble
index|[
literal|4
index|]
operator|)
block|{
name|tr_tool
operator|->
name|tx1
operator|,
name|tr_tool
operator|->
name|tx2
operator|,
name|tr_tool
operator|->
name|tx4
operator|,
name|tr_tool
operator|->
name|tx3
block|}
operator|,
operator|(
name|gdouble
index|[
literal|4
index|]
operator|)
block|{
name|tr_tool
operator|->
name|ty1
block|,
name|tr_tool
operator|->
name|ty2
block|,
name|tr_tool
operator|->
name|ty4
block|,
name|tr_tool
operator|->
name|ty3
block|}
operator|,
name|coords
operator|->
name|x
operator|,
name|coords
operator|->
name|y
block|)
block|)
function|ret
init|=
name|TRANSFORM_HANDLE_CENTER
function|;
end_function

begin_else
else|else
name|ret
operator|=
name|TRANSFORM_HANDLE_ROTATION
expr_stmt|;
end_else

begin_expr_stmt
unit|}    gimp_tool_pop_status
operator|(
name|tool
operator|,
name|tool
operator|->
name|display
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ret
operator|!=
name|TRANSFORM_HANDLE_NONE
condition|)
name|gimp_tool_push_status
argument_list|(
name|tool
argument_list|,
name|tool
operator|->
name|display
argument_list|,
literal|"%s"
argument_list|,
name|get_friendly_operation_name
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|ret
return|;
end_return

begin_function
unit|}  static
name|void
DECL|function|gimp_unified_transform_tool_draw_gui (GimpTransformTool * tr_tool,gint handle_w,gint handle_h)
name|gimp_unified_transform_tool_draw_gui
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|,
name|gint
name|handle_w
parameter_list|,
name|gint
name|handle_h
parameter_list|)
block|{
name|GimpDrawTool
modifier|*
name|draw_tool
init|=
name|GIMP_DRAW_TOOL
argument_list|(
name|tr_tool
argument_list|)
decl_stmt|;
name|GimpCanvasGroup
modifier|*
name|stroke_group
decl_stmt|;
name|gint
name|d
decl_stmt|,
name|i
decl_stmt|;
name|gdouble
name|tx
index|[]
init|=
block|{
name|tr_tool
operator|->
name|tx1
block|,
name|tr_tool
operator|->
name|tx2
block|,
name|tr_tool
operator|->
name|tx3
block|,
name|tr_tool
operator|->
name|tx4
block|}
decl_stmt|,
name|ty
index|[]
init|=
block|{
name|tr_tool
operator|->
name|ty1
block|,
name|tr_tool
operator|->
name|ty2
block|,
name|tr_tool
operator|->
name|ty3
block|,
name|tr_tool
operator|->
name|ty4
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/*  draw the scale handles  */
name|tr_tool
operator|->
name|handles
index|[
name|TRANSFORM_HANDLE_NW
operator|+
name|i
index|]
operator|=
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_SQUARE
argument_list|,
name|tx
index|[
name|i
index|]
argument_list|,
name|ty
index|[
name|i
index|]
argument_list|,
name|handle_w
operator|*
literal|1.5
argument_list|,
name|handle_h
operator|*
literal|1.5
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
comment|/*  draw the perspective handles  */
name|tr_tool
operator|->
name|handles
index|[
name|TRANSFORM_HANDLE_NW_P
operator|+
name|i
index|]
operator|=
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_SQUARE
argument_list|,
name|tx
index|[
name|i
index|]
argument_list|,
name|ty
index|[
name|i
index|]
argument_list|,
name|handle_w
operator|*
literal|0.8
argument_list|,
name|handle_h
operator|*
literal|0.8
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
block|}
comment|/*  draw the side handles  */
name|tx
index|[
literal|0
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx1
operator|+
name|tr_tool
operator|->
name|tx2
operator|)
operator|/
literal|2.0
expr_stmt|;
name|ty
index|[
literal|0
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty1
operator|+
name|tr_tool
operator|->
name|ty2
operator|)
operator|/
literal|2.0
expr_stmt|;
name|tx
index|[
literal|1
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx3
operator|+
name|tr_tool
operator|->
name|tx4
operator|)
operator|/
literal|2.0
expr_stmt|;
name|ty
index|[
literal|1
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty3
operator|+
name|tr_tool
operator|->
name|ty4
operator|)
operator|/
literal|2.0
expr_stmt|;
name|tx
index|[
literal|2
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx2
operator|+
name|tr_tool
operator|->
name|tx4
operator|)
operator|/
literal|2.0
expr_stmt|;
name|ty
index|[
literal|2
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty2
operator|+
name|tr_tool
operator|->
name|ty4
operator|)
operator|/
literal|2.0
expr_stmt|;
name|tx
index|[
literal|3
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx3
operator|+
name|tr_tool
operator|->
name|tx1
operator|)
operator|/
literal|2.0
expr_stmt|;
name|ty
index|[
literal|3
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty3
operator|+
name|tr_tool
operator|->
name|ty1
operator|)
operator|/
literal|2.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tr_tool
operator|->
name|handles
index|[
name|TRANSFORM_HANDLE_N
operator|+
name|i
index|]
operator|=
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_SQUARE
argument_list|,
name|tx
index|[
name|i
index|]
argument_list|,
name|ty
index|[
name|i
index|]
argument_list|,
name|handle_w
argument_list|,
name|handle_h
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
comment|/*  draw the shear handles  */
name|tx
index|[
literal|0
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx1
operator|*
literal|2.0
operator|+
name|tr_tool
operator|->
name|tx2
operator|*
literal|3.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|ty
index|[
literal|0
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty1
operator|*
literal|2.0
operator|+
name|tr_tool
operator|->
name|ty2
operator|*
literal|3.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|tx
index|[
literal|1
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx3
operator|*
literal|3.0
operator|+
name|tr_tool
operator|->
name|tx4
operator|*
literal|2.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|ty
index|[
literal|1
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty3
operator|*
literal|3.0
operator|+
name|tr_tool
operator|->
name|ty4
operator|*
literal|2.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|tx
index|[
literal|2
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx2
operator|*
literal|2.0
operator|+
name|tr_tool
operator|->
name|tx4
operator|*
literal|3.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|ty
index|[
literal|2
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty2
operator|*
literal|2.0
operator|+
name|tr_tool
operator|->
name|ty4
operator|*
literal|3.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|tx
index|[
literal|3
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|tx3
operator|*
literal|3.0
operator|+
name|tr_tool
operator|->
name|tx1
operator|*
literal|2.0
operator|)
operator|/
literal|5.0
expr_stmt|;
name|ty
index|[
literal|3
index|]
operator|=
operator|(
name|tr_tool
operator|->
name|ty3
operator|*
literal|3.0
operator|+
name|tr_tool
operator|->
name|ty1
operator|*
literal|2.0
operator|)
operator|/
literal|5.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tr_tool
operator|->
name|handles
index|[
name|TRANSFORM_HANDLE_N_S
operator|+
name|i
index|]
operator|=
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_FILLED_DIAMOND
argument_list|,
name|tx
index|[
name|i
index|]
argument_list|,
name|ty
index|[
name|i
index|]
argument_list|,
name|handle_w
argument_list|,
name|handle_h
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
comment|/*  draw the rotation center axis handle  */
name|d
operator|=
name|MIN
argument_list|(
name|handle_w
argument_list|,
name|handle_h
argument_list|)
operator|*
literal|2.0
expr_stmt|;
comment|/* so you can grab it from under the center handle */
name|stroke_group
operator|=
name|gimp_draw_tool_add_stroke_group
argument_list|(
name|draw_tool
argument_list|)
expr_stmt|;
name|tr_tool
operator|->
name|handles
index|[
name|TRANSFORM_HANDLE_PIVOT
index|]
operator|=
name|GIMP_CANVAS_ITEM
argument_list|(
name|stroke_group
argument_list|)
expr_stmt|;
name|gimp_draw_tool_push_group
argument_list|(
name|draw_tool
argument_list|,
name|stroke_group
argument_list|)
expr_stmt|;
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_SQUARE
argument_list|,
name|tr_tool
operator|->
name|tpx
argument_list|,
name|tr_tool
operator|->
name|tpy
argument_list|,
name|d
argument_list|,
name|d
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
name|gimp_draw_tool_add_handle
argument_list|(
name|draw_tool
argument_list|,
name|GIMP_HANDLE_CROSS
argument_list|,
name|tr_tool
operator|->
name|tpx
argument_list|,
name|tr_tool
operator|->
name|tpy
argument_list|,
name|d
argument_list|,
name|d
argument_list|,
name|GIMP_HANDLE_ANCHOR_CENTER
argument_list|)
expr_stmt|;
name|gimp_draw_tool_pop_group
argument_list|(
name|draw_tool
argument_list|)
expr_stmt|;
comment|/* draw an item at 40,80 in screen coordinates */
comment|//gint x, y;
comment|//gimp_display_shell_untransform_xy (gimp_display_get_shell (tool->display),
comment|//                                 40, 80,&x,&y, TRUE);
comment|//gimp_draw_tool_add_handle (draw_tool,
comment|//                           GIMP_HANDLE_SQUARE,
comment|//                           x, y,
comment|//                           5, 5,
comment|//                           GIMP_HANDLE_ANCHOR_CENTER);
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_dialog (GimpTransformTool * tr_tool)
name|gimp_unified_transform_tool_dialog
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
block|{
name|GimpUnifiedTransformTool
modifier|*
name|unified
init|=
name|GIMP_UNIFIED_TRANSFORM_TOOL
argument_list|(
name|tr_tool
argument_list|)
decl_stmt|;
name|GtkWidget
modifier|*
name|content_area
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|content_area
operator|=
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|tr_tool
operator|->
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"Transform Matrix"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|content_area
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|3
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
block|{
name|GtkWidget
modifier|*
name|label
init|=
name|gtk_label_new
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|label
argument_list|)
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gtk_label_set_width_chars
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
name|x
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|GTK_EXPAND
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|unified
operator|->
name|label
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_dialog_update (GimpTransformTool * tr_tool)
name|gimp_unified_transform_tool_dialog_update
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
block|{
name|GimpUnifiedTransformTool
modifier|*
name|unified
init|=
name|GIMP_UNIFIED_TRANSFORM_TOOL
argument_list|(
name|tr_tool
argument_list|)
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|3
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
block|{
name|gchar
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|g_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%10.5f"
argument_list|,
name|tr_tool
operator|->
name|transform
operator|.
name|coeff
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|gtk_label_set_text
argument_list|(
name|GTK_LABEL
argument_list|(
name|unified
operator|->
name|label
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_prepare (GimpTransformTool * tr_tool)
name|gimp_unified_transform_tool_prepare
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
block|{
name|tr_tool
operator|->
name|trans_info
index|[
name|PIVOT_X
index|]
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|tr_tool
operator|->
name|x1
operator|+
name|tr_tool
operator|->
name|x2
argument_list|)
operator|/
literal|2.0
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|PIVOT_Y
index|]
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|tr_tool
operator|->
name|y1
operator|+
name|tr_tool
operator|->
name|y2
argument_list|)
operator|/
literal|2.0
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|X0
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|x1
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|Y0
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|y1
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|X1
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|x2
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|Y1
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|y1
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|X2
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|x1
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|Y2
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|y2
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|X3
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|x2
expr_stmt|;
name|tr_tool
operator|->
name|trans_info
index|[
name|Y3
index|]
operator|=
operator|(
name|gdouble
operator|)
name|tr_tool
operator|->
name|y2
expr_stmt|;
block|}
end_function

begin_function
DECL|function|transform_is_convex (GimpVector2 * pos)
specifier|static
name|gboolean
name|transform_is_convex
parameter_list|(
name|GimpVector2
modifier|*
name|pos
parameter_list|)
block|{
return|return
name|gimp_transform_polygon_is_convex
argument_list|(
name|pos
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|pos
index|[
literal|0
index|]
operator|.
name|y
argument_list|,
name|pos
index|[
literal|1
index|]
operator|.
name|x
argument_list|,
name|pos
index|[
literal|1
index|]
operator|.
name|y
argument_list|,
name|pos
index|[
literal|2
index|]
operator|.
name|x
argument_list|,
name|pos
index|[
literal|2
index|]
operator|.
name|y
argument_list|,
name|pos
index|[
literal|3
index|]
operator|.
name|x
argument_list|,
name|pos
index|[
literal|3
index|]
operator|.
name|y
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|dotprod (GimpVector2 a,GimpVector2 b)
specifier|static
specifier|inline
name|gdouble
name|dotprod
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|GimpVector2
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|x
operator|*
name|b
operator|.
name|x
operator|+
name|a
operator|.
name|y
operator|*
name|b
operator|.
name|y
return|;
block|}
end_function

begin_function
DECL|function|norm (GimpVector2 a)
specifier|static
specifier|inline
name|gdouble
name|norm
parameter_list|(
name|GimpVector2
name|a
parameter_list|)
block|{
return|return
name|sqrt
argument_list|(
name|dotprod
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|vectorsubtract (GimpVector2 a,GimpVector2 b)
specifier|static
specifier|inline
name|GimpVector2
name|vectorsubtract
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|GimpVector2
name|b
parameter_list|)
block|{
name|GimpVector2
name|c
decl_stmt|;
name|c
operator|.
name|x
operator|=
name|a
operator|.
name|x
operator|-
name|b
operator|.
name|x
expr_stmt|;
name|c
operator|.
name|y
operator|=
name|a
operator|.
name|y
operator|-
name|b
operator|.
name|y
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
DECL|function|vectoradd (GimpVector2 a,GimpVector2 b)
specifier|static
specifier|inline
name|GimpVector2
name|vectoradd
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|GimpVector2
name|b
parameter_list|)
block|{
name|GimpVector2
name|c
decl_stmt|;
name|c
operator|.
name|x
operator|=
name|a
operator|.
name|x
operator|+
name|b
operator|.
name|x
expr_stmt|;
name|c
operator|.
name|y
operator|=
name|a
operator|.
name|y
operator|+
name|b
operator|.
name|y
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
DECL|function|scalemult (GimpVector2 a,gdouble b)
specifier|static
specifier|inline
name|GimpVector2
name|scalemult
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|gdouble
name|b
parameter_list|)
block|{
name|GimpVector2
name|c
decl_stmt|;
name|c
operator|.
name|x
operator|=
name|a
operator|.
name|x
operator|*
name|b
expr_stmt|;
name|c
operator|.
name|y
operator|=
name|a
operator|.
name|y
operator|*
name|b
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
DECL|function|vectorproject (GimpVector2 a,GimpVector2 b)
specifier|static
specifier|inline
name|GimpVector2
name|vectorproject
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|GimpVector2
name|b
parameter_list|)
block|{
return|return
name|scalemult
argument_list|(
name|b
argument_list|,
name|dotprod
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|/
name|dotprod
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* finds the clockwise angle between the vectors given, 0-2Ï */
end_comment

begin_function
DECL|function|calcangle (GimpVector2 a,GimpVector2 b)
specifier|static
specifier|inline
name|gdouble
name|calcangle
parameter_list|(
name|GimpVector2
name|a
parameter_list|,
name|GimpVector2
name|b
parameter_list|)
block|{
name|gdouble
name|angle
decl_stmt|,
name|angle2
decl_stmt|,
name|length
init|=
name|norm
argument_list|(
name|a
argument_list|)
operator|*
name|norm
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|angle
operator|=
name|acos
argument_list|(
name|dotprod
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|/
name|length
argument_list|)
expr_stmt|;
name|angle2
operator|=
name|b
operator|.
name|y
expr_stmt|;
name|b
operator|.
name|y
operator|=
operator|-
name|b
operator|.
name|x
expr_stmt|;
name|b
operator|.
name|x
operator|=
name|angle2
expr_stmt|;
name|angle2
operator|=
name|acos
argument_list|(
name|dotprod
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|/
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|angle2
operator|>
name|G_PI
operator|/
literal|2.
operator|)
condition|?
name|angle
else|:
literal|2
operator|*
name|G_PI
operator|-
name|angle
operator|)
return|;
block|}
end_function

begin_function
DECL|function|rotate2d (GimpVector2 p,gdouble angle)
specifier|static
specifier|inline
name|GimpVector2
name|rotate2d
parameter_list|(
name|GimpVector2
name|p
parameter_list|,
name|gdouble
name|angle
parameter_list|)
block|{
name|GimpVector2
name|ret
decl_stmt|;
name|ret
operator|.
name|x
operator|=
name|cos
argument_list|(
name|angle
argument_list|)
operator|*
name|p
operator|.
name|x
operator|-
name|sin
argument_list|(
name|angle
argument_list|)
operator|*
name|p
operator|.
name|y
expr_stmt|;
name|ret
operator|.
name|y
operator|=
name|sin
argument_list|(
name|angle
argument_list|)
operator|*
name|p
operator|.
name|x
operator|+
name|cos
argument_list|(
name|angle
argument_list|)
operator|*
name|p
operator|.
name|y
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|lineintersect (GimpVector2 p1,GimpVector2 p2,GimpVector2 q1,GimpVector2 q2)
specifier|static
specifier|inline
name|GimpVector2
name|lineintersect
parameter_list|(
name|GimpVector2
name|p1
parameter_list|,
name|GimpVector2
name|p2
parameter_list|,
name|GimpVector2
name|q1
parameter_list|,
name|GimpVector2
name|q2
parameter_list|)
block|{
name|gdouble
name|denom
decl_stmt|,
name|u
decl_stmt|;
name|GimpVector2
name|p
decl_stmt|;
name|denom
operator|=
operator|(
name|q2
operator|.
name|y
operator|-
name|q1
operator|.
name|y
operator|)
operator|*
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
operator|-
operator|(
name|q2
operator|.
name|x
operator|-
name|q1
operator|.
name|x
operator|)
operator|*
operator|(
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
operator|)
expr_stmt|;
if|if
condition|(
name|denom
operator|==
literal|0.0
condition|)
block|{
name|p
operator|.
name|x
operator|=
operator|(
name|p1
operator|.
name|x
operator|+
name|p2
operator|.
name|x
operator|+
name|q1
operator|.
name|x
operator|+
name|q2
operator|.
name|x
operator|)
operator|/
literal|4
expr_stmt|;
name|p
operator|.
name|y
operator|=
operator|(
name|p1
operator|.
name|y
operator|+
name|p2
operator|.
name|y
operator|+
name|q1
operator|.
name|y
operator|+
name|q2
operator|.
name|y
operator|)
operator|/
literal|4
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
operator|(
name|q2
operator|.
name|x
operator|-
name|q1
operator|.
name|x
operator|)
operator|*
operator|(
name|p1
operator|.
name|y
operator|-
name|q1
operator|.
name|y
operator|)
operator|-
operator|(
name|q2
operator|.
name|y
operator|-
name|q1
operator|.
name|y
operator|)
operator|*
operator|(
name|p1
operator|.
name|x
operator|-
name|q1
operator|.
name|x
operator|)
expr_stmt|;
name|u
operator|/=
name|denom
expr_stmt|;
name|p
operator|.
name|x
operator|=
name|p1
operator|.
name|x
operator|+
name|u
operator|*
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
expr_stmt|;
name|p
operator|.
name|y
operator|=
name|p1
operator|.
name|y
operator|+
name|u
operator|*
operator|(
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
operator|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
DECL|function|getpivotdelta (GimpTransformTool * tr_tool,GimpVector2 * oldpos,GimpVector2 * newpos,GimpVector2 pivot)
specifier|static
specifier|inline
name|GimpVector2
name|getpivotdelta
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|,
name|GimpVector2
modifier|*
name|oldpos
parameter_list|,
name|GimpVector2
modifier|*
name|newpos
parameter_list|,
name|GimpVector2
name|pivot
parameter_list|)
block|{
name|GimpMatrix3
name|transform_before
decl_stmt|,
name|transform_after
decl_stmt|;
name|GimpVector2
name|delta
decl_stmt|;
name|gimp_matrix3_identity
argument_list|(
operator|&
name|transform_before
argument_list|)
expr_stmt|;
name|gimp_matrix3_identity
argument_list|(
operator|&
name|transform_after
argument_list|)
expr_stmt|;
name|gimp_transform_matrix_perspective
argument_list|(
operator|&
name|transform_before
argument_list|,
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y1
argument_list|,
name|tr_tool
operator|->
name|x2
operator|-
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y2
operator|-
name|tr_tool
operator|->
name|y1
argument_list|,
name|oldpos
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|oldpos
index|[
literal|0
index|]
operator|.
name|y
argument_list|,
name|oldpos
index|[
literal|1
index|]
operator|.
name|x
argument_list|,
name|oldpos
index|[
literal|1
index|]
operator|.
name|y
argument_list|,
name|oldpos
index|[
literal|2
index|]
operator|.
name|x
argument_list|,
name|oldpos
index|[
literal|2
index|]
operator|.
name|y
argument_list|,
name|oldpos
index|[
literal|3
index|]
operator|.
name|x
argument_list|,
name|oldpos
index|[
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|gimp_transform_matrix_perspective
argument_list|(
operator|&
name|transform_after
argument_list|,
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y1
argument_list|,
name|tr_tool
operator|->
name|x2
operator|-
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y2
operator|-
name|tr_tool
operator|->
name|y1
argument_list|,
name|newpos
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|newpos
index|[
literal|0
index|]
operator|.
name|y
argument_list|,
name|newpos
index|[
literal|1
index|]
operator|.
name|x
argument_list|,
name|newpos
index|[
literal|1
index|]
operator|.
name|y
argument_list|,
name|newpos
index|[
literal|2
index|]
operator|.
name|x
argument_list|,
name|newpos
index|[
literal|2
index|]
operator|.
name|y
argument_list|,
name|newpos
index|[
literal|3
index|]
operator|.
name|x
argument_list|,
name|newpos
index|[
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|gimp_matrix3_invert
argument_list|(
operator|&
name|transform_before
argument_list|)
expr_stmt|;
name|gimp_matrix3_mult
argument_list|(
operator|&
name|transform_after
argument_list|,
operator|&
name|transform_before
argument_list|)
expr_stmt|;
name|gimp_matrix3_transform_point
argument_list|(
operator|&
name|transform_before
argument_list|,
name|pivot
operator|.
name|x
argument_list|,
name|pivot
operator|.
name|y
argument_list|,
operator|&
name|delta
operator|.
name|x
argument_list|,
operator|&
name|delta
operator|.
name|y
argument_list|)
expr_stmt|;
name|delta
operator|=
name|vectorsubtract
argument_list|(
name|delta
argument_list|,
name|pivot
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_motion (GimpTransformTool * transform_tool)
name|gimp_unified_transform_tool_motion
parameter_list|(
name|GimpTransformTool
modifier|*
name|transform_tool
parameter_list|)
block|{
name|gdouble
modifier|*
name|x
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|y
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|newpivot_x
decl_stmt|,
modifier|*
name|newpivot_y
decl_stmt|;
name|GimpVector2
name|oldpos
index|[
literal|5
index|]
decl_stmt|,
name|newpos
index|[
literal|4
index|]
decl_stmt|;
name|GimpVector2
name|cur
init|=
block|{
operator|.
name|x
operator|=
name|transform_tool
operator|->
name|curx
block|,
operator|.
name|y
operator|=
name|transform_tool
operator|->
name|cury
block|}
decl_stmt|;
name|GimpVector2
name|mouse
init|=
block|{
operator|.
name|x
operator|=
name|transform_tool
operator|->
name|mousex
block|,
operator|.
name|y
operator|=
name|transform_tool
operator|->
name|mousey
block|}
decl_stmt|;
name|GimpVector2
name|d
decl_stmt|;
name|GimpVector2
name|pivot
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GimpTransformOptions
modifier|*
name|options
init|=
name|GIMP_TRANSFORM_TOOL_GET_OPTIONS
argument_list|(
name|transform_tool
argument_list|)
decl_stmt|;
name|gboolean
name|fixedpivot
init|=
name|options
operator|->
name|fixedpivot
decl_stmt|;
name|TransformAction
name|function
init|=
name|transform_tool
operator|->
name|function
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
operator|&
name|transform_tool
operator|->
name|trans_info
index|[
name|X0
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
operator|&
name|transform_tool
operator|->
name|trans_info
index|[
name|Y0
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|newpos
index|[
name|i
index|]
operator|.
name|x
operator|=
name|oldpos
index|[
name|i
index|]
operator|.
name|x
operator|=
name|transform_tool
operator|->
name|prev_trans_info
index|[
literal|0
index|]
index|[
name|X0
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|newpos
index|[
name|i
index|]
operator|.
name|y
operator|=
name|oldpos
index|[
name|i
index|]
operator|.
name|y
operator|=
name|transform_tool
operator|->
name|prev_trans_info
index|[
literal|0
index|]
index|[
name|Y0
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
comment|/* put center point in this array too */
name|oldpos
index|[
literal|4
index|]
operator|.
name|x
operator|=
operator|(
name|oldpos
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|oldpos
index|[
literal|1
index|]
operator|.
name|x
operator|+
name|oldpos
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|oldpos
index|[
literal|3
index|]
operator|.
name|x
operator|)
operator|/
literal|4.
expr_stmt|;
name|oldpos
index|[
literal|4
index|]
operator|.
name|y
operator|=
operator|(
name|oldpos
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|oldpos
index|[
literal|1
index|]
operator|.
name|y
operator|+
name|oldpos
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|oldpos
index|[
literal|3
index|]
operator|.
name|y
operator|)
operator|/
literal|4.
expr_stmt|;
name|d
operator|=
name|vectorsubtract
argument_list|(
name|cur
argument_list|,
name|mouse
argument_list|)
expr_stmt|;
name|newpivot_x
operator|=
operator|&
name|transform_tool
operator|->
name|trans_info
index|[
name|PIVOT_X
index|]
expr_stmt|;
name|newpivot_y
operator|=
operator|&
name|transform_tool
operator|->
name|trans_info
index|[
name|PIVOT_Y
index|]
expr_stmt|;
name|pivot
operator|.
name|x
operator|=
name|transform_tool
operator|->
name|prev_trans_info
index|[
literal|0
index|]
index|[
name|PIVOT_X
index|]
expr_stmt|;
name|pivot
operator|.
name|y
operator|=
name|transform_tool
operator|->
name|prev_trans_info
index|[
literal|0
index|]
index|[
name|PIVOT_Y
index|]
expr_stmt|;
comment|/* move */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_CENTER
condition|)
block|{
if|if
condition|(
name|options
operator|->
name|constrain_move
condition|)
block|{
comment|/* snap to 45 degree vectors from starting point */
name|gdouble
name|angle
init|=
literal|16.
operator|*
name|calcangle
argument_list|(
operator|(
name|GimpVector2
operator|)
block|{
literal|1.
block|,
literal|0.
block|}
argument_list|,
name|d
argument_list|)
operator|/
operator|(
literal|2.
operator|*
name|G_PI
operator|)
decl_stmt|;
name|gdouble
name|dist
init|=
name|norm
argument_list|(
name|d
argument_list|)
operator|/
name|sqrt
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|angle
operator|<
literal|1.
operator|||
name|angle
operator|>=
literal|15.
condition|)
name|d
operator|.
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|3.
condition|)
name|d
operator|.
name|y
operator|=
operator|-
operator|(
name|d
operator|.
name|x
operator|=
name|dist
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|5.
condition|)
name|d
operator|.
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|7.
condition|)
name|d
operator|.
name|x
operator|=
name|d
operator|.
name|y
operator|=
operator|-
name|dist
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|9.
condition|)
name|d
operator|.
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|11.
condition|)
name|d
operator|.
name|x
operator|=
operator|-
operator|(
name|d
operator|.
name|y
operator|=
name|dist
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|13.
condition|)
name|d
operator|.
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|angle
operator|<
literal|15.
condition|)
name|d
operator|.
name|x
operator|=
name|d
operator|.
name|y
operator|=
name|dist
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|i
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* rotate */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_ROTATION
condition|)
block|{
name|gdouble
name|angle
init|=
name|calcangle
argument_list|(
name|vectorsubtract
argument_list|(
name|cur
argument_list|,
name|pivot
argument_list|)
argument_list|,
name|vectorsubtract
argument_list|(
name|mouse
argument_list|,
name|pivot
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|options
operator|->
name|constrain_rotate
condition|)
block|{
comment|/* round to 15 degree multiple */
name|angle
operator|/=
literal|2
operator|*
name|G_PI
operator|/
literal|24.
expr_stmt|;
name|angle
operator|=
name|round
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|angle
operator|*=
literal|2
operator|*
name|G_PI
operator|/
literal|24.
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectoradd
argument_list|(
name|pivot
argument_list|,
name|rotate2d
argument_list|(
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|i
index|]
argument_list|,
name|pivot
argument_list|)
argument_list|,
name|angle
argument_list|)
argument_list|)
expr_stmt|;
name|fixedpivot
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* move rotation axis */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_PIVOT
condition|)
block|{
name|pivot
operator|=
name|vectoradd
argument_list|(
name|pivot
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|cornersnap
condition|)
block|{
comment|/* snap to corner points and center */
name|gint
name|closest
init|=
literal|0
decl_stmt|;
name|gdouble
name|closest_dist
init|=
name|G_MAXDOUBLE
decl_stmt|,
name|dist
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|dist
operator|=
name|norm
argument_list|(
name|vectorsubtract
argument_list|(
name|pivot
argument_list|,
name|oldpos
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|closest_dist
condition|)
block|{
name|closest_dist
operator|=
name|dist
expr_stmt|;
name|closest
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|closest_dist
operator|*
name|gimp_display_get_shell
argument_list|(
name|GIMP_TOOL
argument_list|(
name|transform_tool
argument_list|)
operator|->
name|display
argument_list|)
operator|->
name|scale_x
operator|<
literal|50
condition|)
block|{
name|pivot
operator|=
name|oldpos
index|[
name|closest
index|]
expr_stmt|;
block|}
block|}
name|fixedpivot
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* scaling via corner */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NW
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_NE
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_SE
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_SW
condition|)
block|{
comment|/* Scaling through scale handles means translating one corner point,        * with all sides at constant angles. */
name|gint
name|this
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|,
name|opposite
decl_stmt|;
comment|/* 0: northwest, 1: northeast, 2: southwest, 3: southeast */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NW
condition|)
block|{
name|this
operator|=
literal|0
expr_stmt|;
name|left
operator|=
literal|1
expr_stmt|;
name|right
operator|=
literal|2
expr_stmt|;
name|opposite
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NE
condition|)
block|{
name|this
operator|=
literal|1
expr_stmt|;
name|left
operator|=
literal|3
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
name|opposite
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_SW
condition|)
block|{
name|this
operator|=
literal|2
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|3
expr_stmt|;
name|opposite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_SE
condition|)
block|{
name|this
operator|=
literal|3
expr_stmt|;
name|left
operator|=
literal|2
expr_stmt|;
name|right
operator|=
literal|1
expr_stmt|;
name|opposite
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|g_assert_not_reached
argument_list|()
expr_stmt|;
comment|/* when the keep aspect transformation constraint is enabled, the        * translation shall only be along the diagonal that runs trough        * this corner point. */
if|if
condition|(
name|options
operator|->
name|constrain_scale
condition|)
block|{
comment|/* restrict to movement along the diagonal */
name|GimpVector2
name|diag
init|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|this
index|]
argument_list|,
name|oldpos
index|[
name|opposite
index|]
argument_list|)
decl_stmt|;
name|d
operator|=
name|vectorproject
argument_list|(
name|d
argument_list|,
name|diag
argument_list|)
expr_stmt|;
block|}
comment|/* Move the corner being interacted with */
comment|/*    rp---------tp        *   /           /\<- d, the interaction vector        *  /           /  tp        * op----------/        *        */
name|newpos
index|[
name|this
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Where the corner to the right and left would go, need these to form        * lines to intersect with the sides */
comment|/*    rp----------/        *   /\          /\        *  /  nr       /  nt        * op----------lp        *              \        *               nl        */
name|newpos
index|[
name|right
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|right
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|newpos
index|[
name|left
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|left
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Now we just need to find the intersection of op-rp and nr-nt.        *    rp----------/        *   /           /        *  /  nr==========nt        * op----------/        *        */
name|newpos
index|[
name|right
index|]
operator|=
name|lineintersect
argument_list|(
name|newpos
index|[
name|right
index|]
argument_list|,
name|newpos
index|[
name|this
index|]
argument_list|,
name|oldpos
index|[
name|opposite
index|]
argument_list|,
name|oldpos
index|[
name|right
index|]
argument_list|)
expr_stmt|;
name|newpos
index|[
name|left
index|]
operator|=
name|lineintersect
argument_list|(
name|newpos
index|[
name|left
index|]
argument_list|,
name|newpos
index|[
name|this
index|]
argument_list|,
name|oldpos
index|[
name|opposite
index|]
argument_list|,
name|oldpos
index|[
name|left
index|]
argument_list|)
expr_stmt|;
comment|/*    /-----------/        *   /           /        *  rp============nt        * op----------/        *        */
comment|/*        *        *  /--------------/        * /--------------/        *        */
if|if
condition|(
name|options
operator|->
name|frompivot_scale
operator|&&
name|transform_is_convex
argument_list|(
name|newpos
argument_list|)
operator|&&
name|transform_is_convex
argument_list|(
name|oldpos
argument_list|)
condition|)
block|{
comment|/* transform the pivot point before the interaction and after, and move everything by            * this difference */
comment|//TODO the handle doesn't actually end up where the mouse cursor is
name|GimpVector2
name|delta
init|=
name|getpivotdelta
argument_list|(
name|transform_tool
argument_list|,
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectorsubtract
argument_list|(
name|newpos
index|[
name|i
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fixedpivot
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* scaling via sides */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_N
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_E
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_S
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_W
condition|)
block|{
name|gint
name|this_l
decl_stmt|,
name|this_r
decl_stmt|,
name|opp_l
decl_stmt|,
name|opp_r
decl_stmt|;
name|GimpVector2
name|side_l
decl_stmt|,
name|side_r
decl_stmt|,
name|midline
decl_stmt|;
comment|/* 0: northwest, 1: northeast, 2: southwest, 3: southeast */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_N
condition|)
block|{
name|this_l
operator|=
literal|1
expr_stmt|;
name|this_r
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_E
condition|)
block|{
name|this_l
operator|=
literal|3
expr_stmt|;
name|this_r
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_S
condition|)
block|{
name|this_l
operator|=
literal|2
expr_stmt|;
name|this_r
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_W
condition|)
block|{
name|this_l
operator|=
literal|0
expr_stmt|;
name|this_r
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|g_assert_not_reached
argument_list|()
expr_stmt|;
name|opp_l
operator|=
literal|3
operator|-
name|this_r
expr_stmt|;
name|opp_r
operator|=
literal|3
operator|-
name|this_l
expr_stmt|;
name|side_l
operator|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|opp_l
index|]
argument_list|,
name|oldpos
index|[
name|this_l
index|]
argument_list|)
expr_stmt|;
name|side_r
operator|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|opp_r
index|]
argument_list|,
name|oldpos
index|[
name|this_r
index|]
argument_list|)
expr_stmt|;
name|midline
operator|=
name|vectoradd
argument_list|(
name|side_l
argument_list|,
name|side_r
argument_list|)
expr_stmt|;
comment|/* restrict to movement along the midline */
name|d
operator|=
name|vectorproject
argument_list|(
name|d
argument_list|,
name|midline
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|constrain_scale
condition|)
block|{
name|GimpVector2
name|before
decl_stmt|,
name|after
decl_stmt|,
name|effective_pivot
init|=
name|pivot
decl_stmt|;
name|gdouble
name|distance
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|frompivot_scale
condition|)
block|{
comment|/* center of the opposite side is pivot */
name|effective_pivot
operator|=
name|scalemult
argument_list|(
name|vectoradd
argument_list|(
name|oldpos
index|[
name|opp_l
index|]
argument_list|,
name|oldpos
index|[
name|opp_r
index|]
argument_list|)
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
block|}
comment|/* get the difference between the distance from the pivot to where            * interaction started and the distance from the pivot to where            * cursor is now, and scale all corners distance from the pivot            * with this factor */
name|before
operator|=
name|vectorsubtract
argument_list|(
name|effective_pivot
argument_list|,
name|mouse
argument_list|)
expr_stmt|;
name|after
operator|=
name|vectorsubtract
argument_list|(
name|effective_pivot
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|after
operator|=
name|vectorproject
argument_list|(
name|after
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|distance
operator|=
literal|0.5
operator|*
operator|(
name|after
operator|.
name|x
operator|/
name|before
operator|.
name|x
operator|+
name|after
operator|.
name|y
operator|/
name|before
operator|.
name|y
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectoradd
argument_list|(
name|effective_pivot
argument_list|,
name|scalemult
argument_list|(
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|i
index|]
argument_list|,
name|effective_pivot
argument_list|)
argument_list|,
name|distance
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just move the side */
name|newpos
index|[
name|this_l
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this_l
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|newpos
index|[
name|this_r
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this_r
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|->
name|constrain_scale
operator|&&
name|options
operator|->
name|frompivot_scale
operator|&&
name|transform_is_convex
argument_list|(
name|newpos
argument_list|)
operator|&&
name|transform_is_convex
argument_list|(
name|oldpos
argument_list|)
condition|)
block|{
name|GimpVector2
name|delta
init|=
name|getpivotdelta
argument_list|(
name|transform_tool
argument_list|,
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectorsubtract
argument_list|(
name|newpos
index|[
name|i
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fixedpivot
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* shear */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_N_S
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_E_S
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_S_S
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_W_S
condition|)
block|{
name|gint
name|this_l
decl_stmt|,
name|this_r
decl_stmt|,
name|opp_l
decl_stmt|,
name|opp_r
decl_stmt|;
name|GimpVector2
name|po
decl_stmt|,
name|zero
init|=
block|{
operator|.
name|x
operator|=
literal|0.0
block|,
operator|.
name|y
operator|=
literal|0.0
block|}
decl_stmt|;
comment|/* set up indices for this edge and the opposite edge */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_N_S
condition|)
block|{
name|this_l
operator|=
literal|1
expr_stmt|;
name|this_r
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_W_S
condition|)
block|{
name|this_l
operator|=
literal|0
expr_stmt|;
name|this_r
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_S_S
condition|)
block|{
name|this_l
operator|=
literal|2
expr_stmt|;
name|this_r
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_E_S
condition|)
block|{
name|this_l
operator|=
literal|3
expr_stmt|;
name|this_r
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|g_assert_not_reached
argument_list|()
expr_stmt|;
name|opp_l
operator|=
literal|3
operator|-
name|this_l
expr_stmt|;
name|opp_r
operator|=
literal|3
operator|-
name|this_r
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|frompivot_shear
condition|)
name|po
operator|=
name|vectorsubtract
argument_list|(
name|zero
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|po
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|constrain_shear
condition|)
block|{
comment|/* restrict to movement along the side */
name|GimpVector2
name|side
init|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|this_r
index|]
argument_list|,
name|oldpos
index|[
name|this_l
index|]
argument_list|)
decl_stmt|;
name|d
operator|=
name|vectorproject
argument_list|(
name|d
argument_list|,
name|side
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|->
name|constrain_shear
operator|&&
name|options
operator|->
name|frompivot_shear
condition|)
block|{
comment|/* restrict to movement along the opposite side */
name|GimpVector2
name|side
init|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|opp_r
index|]
argument_list|,
name|oldpos
index|[
name|opp_l
index|]
argument_list|)
decl_stmt|;
name|po
operator|=
name|vectorproject
argument_list|(
name|po
argument_list|,
name|side
argument_list|)
expr_stmt|;
block|}
comment|/* We have to set opp unconditionally, or the opposite edge will stay        * in place when you toggle the frompivot constraint during an action */
name|newpos
index|[
name|this_l
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this_l
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|newpos
index|[
name|this_r
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this_r
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|newpos
index|[
name|opp_l
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|opp_l
index|]
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|newpos
index|[
name|opp_r
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|opp_r
index|]
argument_list|,
name|po
argument_list|)
expr_stmt|;
block|}
comment|/* perspective transform */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NW_P
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_NE_P
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_SE_P
operator|||
name|function
operator|==
name|TRANSFORM_HANDLE_SW_P
condition|)
block|{
name|gint
name|this
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|,
name|opposite
decl_stmt|;
comment|/* 0: northwest, 1: northeast, 2: southwest, 3: southeast */
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NW_P
condition|)
block|{
name|this
operator|=
literal|0
expr_stmt|;
name|left
operator|=
literal|1
expr_stmt|;
name|right
operator|=
literal|2
expr_stmt|;
name|opposite
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_NE_P
condition|)
block|{
name|this
operator|=
literal|1
expr_stmt|;
name|left
operator|=
literal|3
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
name|opposite
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_SW_P
condition|)
block|{
name|this
operator|=
literal|2
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|3
expr_stmt|;
name|opposite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|==
name|TRANSFORM_HANDLE_SE_P
condition|)
block|{
name|this
operator|=
literal|3
expr_stmt|;
name|left
operator|=
literal|2
expr_stmt|;
name|right
operator|=
literal|1
expr_stmt|;
name|opposite
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|g_assert_not_reached
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|constrain_perspective
condition|)
block|{
comment|/* when the constrain transformation constraint is enabled, the              translation shall only be either along the side angles of the              two sides that run to this corner point, or along the              diagonal that runs trough this corner point. */
name|GimpVector2
name|proj
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|rej
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|this
condition|)
continue|continue;
comment|/* get the vectors along the sides and the diagonal */
name|proj
index|[
name|i
index|]
operator|=
name|vectorsubtract
argument_list|(
name|oldpos
index|[
name|this
index|]
argument_list|,
name|oldpos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* project d on each candidate vector and see                * which has the shortest rejection */
name|proj
index|[
name|i
index|]
operator|=
name|vectorproject
argument_list|(
name|d
argument_list|,
name|proj
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rej
index|[
name|i
index|]
operator|=
name|norm
argument_list|(
name|vectorsubtract
argument_list|(
name|d
argument_list|,
name|proj
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rej
index|[
name|left
index|]
operator|<
name|rej
index|[
name|right
index|]
operator|&&
name|rej
index|[
name|left
index|]
operator|<
name|rej
index|[
name|opposite
index|]
condition|)
name|d
operator|=
name|proj
index|[
name|left
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|rej
index|[
name|right
index|]
operator|<
name|rej
index|[
name|opposite
index|]
condition|)
name|d
operator|=
name|proj
index|[
name|right
index|]
expr_stmt|;
else|else
name|d
operator|=
name|proj
index|[
name|opposite
index|]
expr_stmt|;
block|}
name|newpos
index|[
name|this
index|]
operator|=
name|vectoradd
argument_list|(
name|oldpos
index|[
name|this
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|frompivot_perspective
operator|&&
name|transform_is_convex
argument_list|(
name|newpos
argument_list|)
operator|&&
name|transform_is_convex
argument_list|(
name|oldpos
argument_list|)
condition|)
block|{
name|GimpVector2
name|delta
init|=
name|getpivotdelta
argument_list|(
name|transform_tool
argument_list|,
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|newpos
index|[
name|i
index|]
operator|=
name|vectorsubtract
argument_list|(
name|newpos
index|[
name|i
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fixedpivot
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|x
index|[
name|i
index|]
operator|=
name|newpos
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
operator|*
name|y
index|[
name|i
index|]
operator|=
name|newpos
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* this will have been set to TRUE if an operation used the pivot in addition to being a user option */
if|if
condition|(
operator|!
name|fixedpivot
operator|&&
name|transform_is_convex
argument_list|(
name|newpos
argument_list|)
operator|&&
name|transform_is_convex
argument_list|(
name|oldpos
argument_list|)
operator|&&
name|point_is_inside_polygon_pos
argument_list|(
name|oldpos
argument_list|,
name|pivot
argument_list|)
condition|)
block|{
name|GimpVector2
name|delta
init|=
name|getpivotdelta
argument_list|(
name|transform_tool
argument_list|,
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
name|pivot
operator|=
name|vectoradd
argument_list|(
name|pivot
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* set unconditionally: if options get toggled during operation, we have to move pivot back */
operator|*
name|newpivot_x
operator|=
name|pivot
operator|.
name|x
expr_stmt|;
operator|*
name|newpivot_y
operator|=
name|pivot
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_unified_transform_tool_recalc_matrix (GimpTransformTool * tr_tool)
name|gimp_unified_transform_tool_recalc_matrix
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
block|{
name|tr_tool
operator|->
name|px
operator|=
name|tr_tool
operator|->
name|trans_info
index|[
name|PIVOT_X
index|]
expr_stmt|;
name|tr_tool
operator|->
name|py
operator|=
name|tr_tool
operator|->
name|trans_info
index|[
name|PIVOT_Y
index|]
expr_stmt|;
name|gimp_matrix3_identity
argument_list|(
operator|&
name|tr_tool
operator|->
name|transform
argument_list|)
expr_stmt|;
name|gimp_transform_matrix_perspective
argument_list|(
operator|&
name|tr_tool
operator|->
name|transform
argument_list|,
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y1
argument_list|,
name|tr_tool
operator|->
name|x2
operator|-
name|tr_tool
operator|->
name|x1
argument_list|,
name|tr_tool
operator|->
name|y2
operator|-
name|tr_tool
operator|->
name|y1
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|X0
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|Y0
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|X1
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|Y1
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|X2
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|Y2
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|X3
index|]
argument_list|,
name|tr_tool
operator|->
name|trans_info
index|[
name|Y3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_unified_transform_tool_get_undo_desc (GimpTransformTool * tr_tool)
name|gimp_unified_transform_tool_get_undo_desc
parameter_list|(
name|GimpTransformTool
modifier|*
name|tr_tool
parameter_list|)
block|{
return|return
name|g_strdup
argument_list|(
name|C_
argument_list|(
literal|"undo-type"
argument_list|,
literal|"Unified Transform"
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

