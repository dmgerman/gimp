begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdkkeysyms.h>
end_include

begin_include
include|#
directive|include
file|"libgimpwidgets/gimpwidgets.h"
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"tools-types.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpchannel.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpmarshal.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpcontext.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage.h"
end_include

begin_include
include|#
directive|include
file|"core/gimpimage-mask.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"pdb/procedural_db.h"
end_include

begin_include
include|#
directive|include
file|"gui/paths-dialog.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"pixel_region.h"
end_include

begin_include
include|#
directive|include
file|"gimpeditselectiontool.h"
end_include

begin_include
include|#
directive|include
file|"gimpbezierselecttool.h"
end_include

begin_include
include|#
directive|include
file|"selection_options.h"
end_include

begin_include
include|#
directive|include
file|"tool_options.h"
end_include

begin_include
include|#
directive|include
file|"tool_manager.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_define
DECL|macro|WANT_BEZIER_SELECT_BITS
define|#
directive|define
name|WANT_BEZIER_SELECT_BITS
end_define

begin_include
include|#
directive|include
file|"icons.h"
end_include

begin_define
DECL|macro|STATUSBAR_SIZE
define|#
directive|define
name|STATUSBAR_SIZE
value|128
end_define

begin_comment
comment|/* Old local stuff that (at worst) shouldn't break anything */
end_comment

begin_define
DECL|macro|BEZIER_DRAW_CURVE
define|#
directive|define
name|BEZIER_DRAW_CURVE
value|1
end_define

begin_define
DECL|macro|BEZIER_DRAW_CURRENT
define|#
directive|define
name|BEZIER_DRAW_CURRENT
value|2
end_define

begin_define
DECL|macro|BEZIER_DRAW_HANDLES
define|#
directive|define
name|BEZIER_DRAW_HANDLES
value|4
end_define

begin_define
DECL|macro|BEZIER_DRAW_ALL
define|#
directive|define
name|BEZIER_DRAW_ALL
value|(BEZIER_DRAW_CURVE | BEZIER_DRAW_HANDLES)
end_define

begin_define
DECL|macro|BEZIER_WIDTH
define|#
directive|define
name|BEZIER_WIDTH
value|8
end_define

begin_define
DECL|macro|BEZIER_HALFWIDTH
define|#
directive|define
name|BEZIER_HALFWIDTH
value|4
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|SUPERSAMPLE2
define|#
directive|define
name|SUPERSAMPLE2
value|9
end_define

begin_comment
comment|/*  the bezier select structures  */
end_comment

begin_typedef
DECL|typedef|BezierMatrix
typedef|typedef
name|gdouble
name|BezierMatrix
index|[
literal|4
index|]
index|[
literal|4
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon292f01580108
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|stroke_points
name|gdouble
modifier|*
name|stroke_points
decl_stmt|;
DECL|member|num_stroke_points
name|gint
name|num_stroke_points
decl_stmt|;
comment|/* num of valid points */
DECL|member|len_stroke_points
name|gint
name|len_stroke_points
decl_stmt|;
comment|/* allocated length */
DECL|member|next_curve
name|gpointer
name|next_curve
decl_stmt|;
comment|/* Next curve in list -- we draw all curves  				     * separately. 				     */
DECL|typedef|BezierRenderPnts
block|}
name|BezierRenderPnts
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon292f01580208
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|firstpnt
name|gboolean
name|firstpnt
decl_stmt|;
DECL|member|curdist
name|gdouble
name|curdist
decl_stmt|;
DECL|member|dist
name|gdouble
name|dist
decl_stmt|;
DECL|member|gradient
name|gdouble
modifier|*
name|gradient
decl_stmt|;
DECL|member|x
name|gint
modifier|*
name|x
decl_stmt|;
DECL|member|y
name|gint
modifier|*
name|y
decl_stmt|;
DECL|member|lastx
name|gdouble
name|lastx
decl_stmt|;
DECL|member|lasty
name|gdouble
name|lasty
decl_stmt|;
DECL|member|found
name|gboolean
name|found
decl_stmt|;
DECL|typedef|BezierDistance
block|}
name|BezierDistance
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon292f01580308
block|{
DECL|member|curve_count
name|CountCurves
name|curve_count
decl_stmt|;
comment|/* Must be the first element */
DECL|member|x
name|gint
name|x
decl_stmt|;
DECL|member|y
name|gint
name|y
decl_stmt|;
DECL|member|halfwidth
name|gint
name|halfwidth
decl_stmt|;
DECL|member|found
name|gint
name|found
decl_stmt|;
DECL|typedef|BezierCheckPnts
block|}
name|BezierCheckPnts
typedef|;
end_typedef

begin_comment
comment|/*  the bezier selection tool options  */
end_comment

begin_decl_stmt
DECL|variable|bezier_options
specifier|static
name|SelectionOptions
modifier|*
name|bezier_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  local variables  */
end_comment

begin_decl_stmt
DECL|variable|basis
specifier|static
name|BezierMatrix
name|basis
init|=
block|{
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
operator|-
literal|6
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static BezierMatrix basis = {   { -1/6.0,  3/6.0, -3/6.0,  1/6.0 },   {  3/6.0, -6/6.0,  3/6.0,  0 },   { -3/6.0,  0,  3/6.0,  0 },   {  1/6.0,  4/6.0,  1,  0 }, }; */
end_comment

begin_comment
comment|/*  Global Static Variable to maintain informations about the "context"  */
end_comment

begin_decl_stmt
DECL|variable|curSel
specifier|static
name|GimpBezierSelectTool
modifier|*
name|curSel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curTool
specifier|static
name|GimpTool
modifier|*
name|curTool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curGdisp
specifier|static
name|GDisplay
modifier|*
name|curGdisp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curCore
specifier|static
name|GimpDrawTool
modifier|*
name|curCore
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ModeEdit
specifier|static
name|gint
name|ModeEdit
init|=
name|EXTEND_NEW
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
DECL|enum|__anon292f01580403
block|{
DECL|enumerator|BEZIER_SELECT
name|BEZIER_SELECT
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_decl_stmt
DECL|variable|parent_class
specifier|static
name|GimpSelectionToolClass
modifier|*
name|parent_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bezier_select_signals
specifier|static
name|guint
name|bezier_select_signals
index|[
name|LAST_SIGNAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_class_init
parameter_list|(
name|GimpBezierSelectToolClass
modifier|*
name|klass
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_init
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_select
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_button_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_button_release
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_motion
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_control
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|ToolAction
name|action
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_bezier_select_tool_cursor_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_select_draw
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_offset_point
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|bezier_check_point
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_handles
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gboolean
name|do_all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_current
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_point
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gboolean
name|fill
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_line
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt1
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gint
name|space
parameter_list|,
name|GimpBezierSelectPointsFunc
name|points_func
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_draw_segment_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_compose
parameter_list|(
name|BezierMatrix
name|a
parameter_list|,
name|BezierMatrix
name|b
parameter_list|,
name|BezierMatrix
name|ab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gboolean
name|antialias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GSList
modifier|*
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|gint
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|test_add_point_on_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gint
name|space
parameter_list|,
name|gint
name|xpos
parameter_list|,
name|gint
name|ypos
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_to_sel_internal
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|op
parameter_list|,
name|gboolean
name|replace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|start
parameter_list|,
name|gint
name|end
parameter_list|,
name|gdouble
name|error
parameter_list|,
name|BezierRenderPnts
modifier|*
name|rpnts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_stack_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|stroke_interpolatable
parameter_list|(
name|gint
name|offx
parameter_list|,
name|gint
name|offy
parameter_list|,
name|gint
name|l_offx
parameter_list|,
name|gint
name|l_offy
parameter_list|,
name|gdouble
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|count_points_on_curve
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|bezier_edit_point_on_curve
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|bezier_add_point_on_segment
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpBezierSelectPoint
modifier|*
name|find_start_open_curve
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bsel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bezier_start_new_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Public functions */
end_comment

begin_function
name|void
DECL|function|gimp_bezier_select_tool_register (void)
name|gimp_bezier_select_tool_register
parameter_list|(
name|void
parameter_list|)
block|{
name|tool_manager_register_tool
argument_list|(
name|GIMP_TYPE_BEZIER_SELECT_TOOL
argument_list|,
name|FALSE
argument_list|,
literal|"gimp:bezier_select_tool"
argument_list|,
name|_
argument_list|(
literal|"Bezier Select"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select regions using Bezier curves"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"/Tools/Selection Tools/Bezier Select"
argument_list|)
argument_list|,
literal|"B"
argument_list|,
name|NULL
argument_list|,
literal|"tools/bezier_select.html"
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
name|bezier_select_bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|GtkType
DECL|function|gimp_bezier_select_tool_get_type (void)
name|gimp_bezier_select_tool_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GtkType
name|bezier_select_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_select_type
condition|)
block|{
name|GtkTypeInfo
name|bezier_select_info
init|=
block|{
literal|"GimpBezierSelectTool"
block|,
sizeof|sizeof
argument_list|(
name|GimpBezierSelectTool
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|GimpBezierSelectToolClass
argument_list|)
block|,
operator|(
name|GtkClassInitFunc
operator|)
name|gimp_bezier_select_tool_class_init
block|,
operator|(
name|GtkObjectInitFunc
operator|)
name|gimp_bezier_select_tool_init
block|,
comment|/* reserved_1 */
name|NULL
block|,
comment|/* reserved_2 */
name|NULL
block|}
decl_stmt|;
name|bezier_select_type
operator|=
name|gtk_type_unique
argument_list|(
name|GIMP_TYPE_SELECTION_TOOL
argument_list|,
operator|&
name|bezier_select_info
argument_list|)
expr_stmt|;
block|}
return|return
name|bezier_select_type
return|;
block|}
end_function

begin_comment
comment|/* Private functions */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_class_init (GimpBezierSelectToolClass * klass)
name|gimp_bezier_select_tool_class_init
parameter_list|(
name|GimpBezierSelectToolClass
modifier|*
name|klass
parameter_list|)
block|{
name|GtkObjectClass
modifier|*
name|object_class
decl_stmt|;
name|GimpToolClass
modifier|*
name|tool_class
decl_stmt|;
name|GimpDrawToolClass
modifier|*
name|draw_tool_class
decl_stmt|;
name|object_class
operator|=
operator|(
name|GtkObjectClass
operator|*
operator|)
name|klass
expr_stmt|;
name|tool_class
operator|=
operator|(
name|GimpToolClass
operator|*
operator|)
name|klass
expr_stmt|;
name|draw_tool_class
operator|=
operator|(
name|GimpDrawToolClass
operator|*
operator|)
name|klass
expr_stmt|;
name|parent_class
operator|=
name|gtk_type_class
argument_list|(
name|GIMP_TYPE_SELECTION_TOOL
argument_list|)
expr_stmt|;
name|bezier_select_signals
index|[
name|BEZIER_SELECT
index|]
operator|=
name|gtk_signal_new
argument_list|(
literal|"bezier_select"
argument_list|,
name|GTK_RUN_FIRST
argument_list|,
name|object_class
operator|->
name|type
argument_list|,
name|GTK_SIGNAL_OFFSET
argument_list|(
name|GimpBezierSelectToolClass
argument_list|,
name|bezier_select
argument_list|)
argument_list|,
name|gimp_marshal_NONE__INT_INT_INT_INT
argument_list|,
name|GTK_TYPE_NONE
argument_list|,
literal|4
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|,
name|GTK_TYPE_INT
argument_list|)
expr_stmt|;
name|gtk_object_class_add_signals
argument_list|(
name|object_class
argument_list|,
name|bezier_select_signals
argument_list|,
name|LAST_SIGNAL
argument_list|)
expr_stmt|;
name|object_class
operator|->
name|destroy
operator|=
name|gimp_bezier_select_tool_destroy
expr_stmt|;
name|tool_class
operator|->
name|button_press
operator|=
name|gimp_bezier_select_tool_button_press
expr_stmt|;
name|tool_class
operator|->
name|button_release
operator|=
name|gimp_bezier_select_tool_button_release
expr_stmt|;
name|tool_class
operator|->
name|motion
operator|=
name|gimp_bezier_select_tool_motion
expr_stmt|;
name|tool_class
operator|->
name|control
operator|=
name|gimp_bezier_select_tool_control
expr_stmt|;
name|tool_class
operator|->
name|cursor_update
operator|=
name|gimp_bezier_select_tool_cursor_update
expr_stmt|;
name|draw_tool_class
operator|->
name|draw
operator|=
name|bezier_select_draw
expr_stmt|;
comment|/*  klass->bezier_select       = gimp_bezier_select_tool_real_bezier_select; */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_init (GimpBezierSelectTool * bezier_select)
name|gimp_bezier_select_tool_init
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_select
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
decl_stmt|;
name|GimpDrawTool
modifier|*
name|draw_tool
decl_stmt|;
name|GimpSelectionTool
modifier|*
name|select_tool
decl_stmt|;
name|tool
operator|=
name|GIMP_TOOL
argument_list|(
name|bezier_select
argument_list|)
expr_stmt|;
name|draw_tool
operator|=
name|GIMP_DRAW_TOOL
argument_list|(
name|bezier_select
argument_list|)
expr_stmt|;
name|select_tool
operator|=
name|GIMP_SELECTION_TOOL
argument_list|(
name|bezier_select
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_options
condition|)
block|{
name|bezier_options
operator|=
name|selection_options_new
argument_list|(
name|GIMP_TYPE_BEZIER_SELECT_TOOL
argument_list|,
name|selection_options_reset
argument_list|)
expr_stmt|;
name|tool_manager_register_tool_options
argument_list|(
name|GIMP_TYPE_BEZIER_SELECT_TOOL
argument_list|,
operator|(
name|ToolOptions
operator|*
operator|)
name|bezier_options
argument_list|)
expr_stmt|;
block|}
name|bezier_select
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|bezier_select
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
name|tool
operator|->
name|tool_cursor
operator|=
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
expr_stmt|;
name|tool
operator|->
name|preserve
operator|=
name|FALSE
expr_stmt|;
comment|/*  Don't preserve on drawable change  */
name|curCore
operator|=
name|draw_tool
expr_stmt|;
name|curSel
operator|=
name|bezier_select
expr_stmt|;
name|curTool
operator|=
name|tool
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_select
argument_list|)
expr_stmt|;
name|paths_new_bezier_select_tool
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_destroy (GtkObject * object)
name|gimp_bezier_select_tool_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|GTK_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|destroy
condition|)
name|GTK_OBJECT_CLASS
argument_list|(
name|parent_class
argument_list|)
operator|->
name|destroy
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_button_press (GimpTool * tool,GdkEventButton * bevent,GDisplay * gdisp)
name|gimp_bezier_select_tool_button_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|curve_start
decl_stmt|;
name|gboolean
name|grab_pointer
decl_stmt|;
name|gint
name|op
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|tool
operator|->
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|bezier_sel
operator|=
name|GIMP_BEZIER_SELECT_TOOL
argument_list|(
name|tool
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
name|FALSE
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp
operator|!=
name|tool
operator|->
name|gdisp
condition|)
block|{
name|gimp_draw_tool_stop
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|curTool
operator|=
name|active_tool
expr_stmt|;
name|curSel
operator|=
name|bezier_sel
expr_stmt|;
name|curGdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp
expr_stmt|;
name|curCore
operator|=
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
expr_stmt|;
switch|switch
condition|(
name|bezier_sel
operator|->
name|state
condition|)
block|{
case|case
name|BEZIER_START
case|:
if|if
condition|(
name|ModeEdit
operator|!=
name|EXTEND_NEW
condition|)
break|break;
name|grab_pointer
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp
operator|=
name|gdisp
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
comment|/*bezier_sel->draw_mode = BEZIER_DRAW_CURVE; | BEZIER_DRAW_HANDLES;*/
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|gimp_draw_tool_start
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER_ADD
case|:
name|grab_pointer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_EDIT
condition|)
block|{
comment|/* erase the handles */
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
block|{
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|gimp_bezier_select_tool_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
comment|/* 	  if(bezier_sel->num_points< 6) */
comment|/* 	    return; */
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
comment|/*kkk*/
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/*kkk*/
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grab_pointer
condition|)
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|gimp_bezier_select_tool_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<
literal|5
condition|)
return|return;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
block|{
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|gimp_bezier_select_tool_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
name|curve_start
operator|=
name|find_start_open_curve
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|curve_start
operator|&&
name|bezier_check_point
argument_list|(
name|curve_start
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|curve_start
expr_stmt|;
name|curve_start
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|curve_start
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|curve_start
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|pointflags
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_EDIT
case|:
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|gimp_fatal_error
argument_list|(
literal|"gimp_bezier_select_tool_button_press(): Tried to edit "
literal|"on open bezier curve in edit selection"
argument_list|)
expr_stmt|;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
operator|&&
name|bezier_sel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|grab_pointer
operator|&&
name|gimp_channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|gboolean
name|replace
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|CHANNEL_OP_ADD
expr_stmt|;
name|replace
operator|=
name|TRUE
expr_stmt|;
block|}
name|bezier_to_sel_internal
argument_list|(
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|gdisp
argument_list|,
name|op
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* draw the handles */
if|if
condition|(
operator|!
name|grab_pointer
condition|)
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
name|bezier_start_new_segment
argument_list|(
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
comment|/* Don't bother doing this if we don't have any points */
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
name|paths_first_button_press
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_button_release (GimpTool * tool,GdkEventButton * bevent,GDisplay * gdisp)
name|gimp_bezier_select_tool_button_release
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp
expr_stmt|;
name|bezier_sel
operator|=
name|GIMP_BEZIER_SELECT_TOOL
argument_list|(
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|&=
operator|~
operator|(
name|BEZIER_DRAG
operator|)
expr_stmt|;
name|gdk_pointer_ungrab
argument_list|(
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp
argument_list|,
name|SUBDIVIDE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Here ?*/
name|paths_newpoint_current
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_motion (GimpTool * tool,GdkEventMotion * mevent,GDisplay * gdisp)
name|gimp_bezier_select_tool_motion
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
specifier|static
name|gint
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|anchor
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|opposite_control
decl_stmt|;
name|gint
name|offsetx
decl_stmt|;
name|gint
name|offsety
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|tool
operator|->
name|state
operator|!=
name|ACTIVE
condition|)
return|return;
name|bezier_sel
operator|=
name|GIMP_BEZIER_SELECT_TOOL
argument_list|(
name|tool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|cur_anchor
operator|||
operator|!
name|bezier_sel
operator|->
name|cur_control
condition|)
return|return;
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
block|}
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the first point then change the state and "remember" the point.    */
if|if
condition|(
operator|!
operator|(
name|bezier_sel
operator|->
name|state
operator|&
name|BEZIER_DRAG
operator|)
condition|)
block|{
name|bezier_sel
operator|->
name|state
operator||=
name|BEZIER_DRAG
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
comment|/* The Alt key is down... Move all the points of the bezier curve */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|tmp
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
comment|/* Only move this curve */
name|GimpBezierSelectPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|cur_anchor
decl_stmt|;
comment|/* g_print ("moving only one curve\n"); */
name|tmp
operator|=
name|start_pt
expr_stmt|;
do|do
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|!=
name|start_pt
operator|&&
name|tmp
condition|)
do|;
comment|/* Check if need to go backwards because curve is open */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
condition|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
decl_stmt|;
name|tmp
operator|=
name|start_pt
expr_stmt|;
do|do
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|prev
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|!=
name|start_pt
operator|&&
name|tmp
condition|)
do|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tmp
operator|&&
name|num_points
condition|)
block|{
name|bezier_offset_point
argument_list|(
name|tmp
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|next_curve
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|next_curve
expr_stmt|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
condition|)
block|{
comment|/* the control key is down ... move the current anchor point */
comment|/* we must also move the neighboring control points appropriately */
name|offsetx
operator|=
name|x
operator|-
name|lastx
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|lasty
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the control key is not down ... we move the current control point */
name|offsetx
operator|=
name|x
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|y
operator|-
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
expr_stmt|;
name|bezier_offset_point
argument_list|(
name|bezier_sel
operator|->
name|cur_control
argument_list|,
name|offsetx
argument_list|,
name|offsety
argument_list|)
expr_stmt|;
comment|/* if the shift key is not down then we align the opposite control */
comment|/* point...ie the opposite control point acts like a mirror of the */
comment|/* current control point */
if|if
condition|(
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|anchor
operator|=
name|NULL
expr_stmt|;
name|opposite_control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
block|{
name|anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
name|opposite_control
operator|=
name|anchor
operator|->
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|gimp_fatal_error
argument_list|(
literal|"bezier_select_motion(): Encountered orphaned "
literal|"bezier control point"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opposite_control
condition|)
block|{
name|offsetx
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|x
operator|-
name|anchor
operator|->
name|x
expr_stmt|;
name|offsety
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|y
operator|-
name|anchor
operator|->
name|y
expr_stmt|;
name|opposite_control
operator|->
name|x
operator|=
name|anchor
operator|->
name|x
operator|-
name|offsetx
expr_stmt|;
name|opposite_control
operator|->
name|y
operator|=
name|anchor
operator|->
name|y
operator|-
name|offsety
expr_stmt|;
block|}
block|}
block|}
comment|/* As we're moving all the control points of the curve,      we have to redraw all !!!      */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|bezier_select_load (GDisplay * gdisp,GimpBezierSelectPoint * pts,gint num_pts,gint closed)
name|bezier_select_load
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pts
parameter_list|,
name|gint
name|num_pts
parameter_list|,
name|gint
name|closed
parameter_list|)
block|{
name|GimpTool
modifier|*
name|tool
decl_stmt|;
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
comment|/*  select the bezier tool  */
name|gimp_context_set_tool
argument_list|(
name|gimp_context_get_user
argument_list|()
argument_list|,
name|tool_manager_get_info_by_type
argument_list|(
name|GIMP_TYPE_BEZIER_SELECT_TOOL
argument_list|)
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp
operator|=
name|gdisp
expr_stmt|;
name|bezier_sel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|tool
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|pts
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|pts
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
name|num_pts
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp
argument_list|,
name|SUBDIVIDE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_draw_tool_start
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|GimpBezierSelectPoint
modifier|*
DECL|function|valid_curve_segment (GimpBezierSelectPoint * points)
name|valid_curve_segment
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|)
block|{
comment|/* Valid curve segment is made up of four points */
if|if
condition|(
name|points
operator|&&
name|points
operator|->
name|next
operator|&&
name|points
operator|->
name|next
operator|->
name|next
operator|&&
name|points
operator|->
name|next
operator|->
name|next
operator|->
name|next
condition|)
block|{
return|return
name|points
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpBezierSelectPoint
modifier|*
DECL|function|next_anchor (GimpBezierSelectPoint * points,GimpBezierSelectPoint ** next_curve)
name|next_anchor
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
modifier|*
name|next_curve
parameter_list|)
block|{
name|gint
name|loop
decl_stmt|;
operator|*
name|next_curve
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|3
condition|;
name|loop
operator|++
control|)
block|{
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
block|{
operator|*
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
block|}
block|}
return|return
name|valid_curve_segment
argument_list|(
name|points
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_draw_curve (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPointsFunc func,gint coord,gpointer data)
name|bezier_draw_curve
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPointsFunc
name|func
parameter_list|,
name|gint
name|coord
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|CountCurves
modifier|*
name|cnt
init|=
operator|(
name|CountCurves
operator|*
operator|)
name|data
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
comment|/*   printSel(bezier_sel); */
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_counts
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|coord
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
comment|/* 	  g_print ("next_anchor = %p\n",points); */
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|++
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* must be last curve since only this one is allowed< 4 		      * points. 		      */
block|}
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|bezier_select_reset (GimpBezierSelectTool * bezier_sel)
name|bezier_select_reset
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|temp_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
do|do
block|{
name|temp_pt
operator|=
name|points
expr_stmt|;
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|next_curve
condition|)
block|{
name|g_warning
argument_list|(
literal|"Curve points out of sync"
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|temp_pt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|points
operator|=
name|next_curve
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
comment|/* we are starting the curve */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* draw everything by default */
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* the curve is initally open */
name|bezier_sel
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
comment|/* initially there are no points */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
comment|/* intially there are no points */
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/* empty mask */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_select_free (GimpBezierSelectTool * bezier_sel)
name|bezier_select_free
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the curve that points to this curve. This makes to_check point  * the start of a curve.   */
end_comment

begin_function
specifier|static
name|GimpBezierSelectPoint
modifier|*
DECL|function|check_for_next_curve (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * to_check)
name|check_for_next_curve
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|to_check
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
operator|==
name|to_check
condition|)
return|return
name|points
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|count_points_on_curve (GimpBezierSelectPoint * points)
name|count_points_on_curve
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|start
init|=
name|points
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|points
operator|->
name|next
operator|!=
name|start
condition|)
block|{
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Find the start of the last open curve, if curve already closed  * this is an error..  */
end_comment

begin_function
specifier|static
name|GimpBezierSelectPoint
modifier|*
DECL|function|find_start_open_curve (GimpBezierSelectTool * bsel)
name|find_start_open_curve
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bsel
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|start_pnt
init|=
name|NULL
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|this_pnt
init|=
name|bsel
operator|->
name|last_point
decl_stmt|;
comment|/* Could be one of the first points */
if|if
condition|(
operator|!
name|bsel
operator|->
name|last_point
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bsel
operator|->
name|closed
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Bezier path already closed."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Step backwards until the prev point is null.    * in this case this is the start of the open curve.    * The start_pnt stuff is to stop us going around forever.    * If we even have a closed curve then we are in seroius     * trouble.    */
while|while
condition|(
name|this_pnt
operator|->
name|prev
operator|&&
name|start_pnt
operator|!=
name|this_pnt
condition|)
block|{
if|if
condition|(
operator|!
name|start_pnt
condition|)
name|start_pnt
operator|=
name|this_pnt
expr_stmt|;
name|this_pnt
operator|=
name|this_pnt
operator|->
name|prev
expr_stmt|;
block|}
comment|/* Must be an anchor to be the start */
if|if
condition|(
name|start_pnt
operator|==
name|this_pnt
operator|||
name|this_pnt
operator|->
name|type
operator|!=
name|BEZIER_ANCHOR
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Corrupt curve"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*   g_print ("Returned start pnt of curve %p is %p\n",bsel->last_point,this_pnt); */
return|return
name|this_pnt
return|;
block|}
end_function

begin_comment
comment|/* Delete a whole curve. Watch out for special cases.  * start_pnt must always be the start point if the curve to delete.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|delete_whole_curve (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * start_pnt)
name|delete_whole_curve
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|start_pnt
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|tmppnt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
init|=
name|NULL
decl_stmt|;
comment|/* Next curve this one  				   * points at (if any)  				   */
name|GimpBezierSelectPoint
modifier|*
name|prev_curve
decl_stmt|;
comment|/* Does a curve point to this one? */
name|gint
name|cnt_pnts
init|=
literal|0
decl_stmt|;
comment|/* Count how many pnts deleted */
name|gint
name|reset_last
init|=
name|FALSE
decl_stmt|;
comment|/* shift and del means delete whole curve */
comment|/* Three cases, this is first curve, middle curve     * or end curve.    */
comment|/* Does this curve have another chained on the end?     * or is this curve pointed to another one?    */
comment|/*   g_print ("delete_whole_curve::\n"); */
name|tmppnt
operator|=
name|start_pnt
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tmppnt
operator|->
name|next_curve
condition|)
block|{
name|next_curve
operator|=
name|tmppnt
operator|->
name|next_curve
expr_stmt|;
break|break;
block|}
name|tmppnt
operator|=
name|tmppnt
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tmppnt
operator|!=
name|start_pnt
operator|&&
name|tmppnt
condition|)
do|;
name|prev_curve
operator|=
name|check_for_next_curve
argument_list|(
name|bezier_sel
argument_list|,
name|start_pnt
argument_list|)
expr_stmt|;
comment|/* First curve ?*/
if|if
condition|(
name|bezier_sel
operator|->
name|points
operator|==
name|start_pnt
condition|)
block|{
name|bezier_sel
operator|->
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
else|else
block|{
comment|/* better have a previous curve else how did we get here? */
name|prev_curve
operator|->
name|next_curve
operator|=
name|next_curve
expr_stmt|;
block|}
comment|/* start_pnt points to the curve we should free .. ignoring the next_curve */
name|tmppnt
operator|=
name|start_pnt
expr_stmt|;
do|do
block|{
name|GimpBezierSelectPoint
modifier|*
name|fpnt
decl_stmt|;
name|fpnt
operator|=
name|tmppnt
expr_stmt|;
name|tmppnt
operator|=
name|tmppnt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|fpnt
operator|==
name|bezier_sel
operator|->
name|last_point
condition|)
name|reset_last
operator|=
name|TRUE
expr_stmt|;
name|g_free
argument_list|(
name|fpnt
argument_list|)
expr_stmt|;
name|cnt_pnts
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|tmppnt
operator|!=
name|start_pnt
operator|&&
name|tmppnt
condition|)
do|;
name|bezier_sel
operator|->
name|num_points
operator|-=
name|cnt_pnts
expr_stmt|;
comment|/* if deleted curve was unclosed then must have been the last curve     * and thus this curve becomes closed.    */
if|if
condition|(
operator|!
name|tmppnt
operator|&&
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<=
literal|0
condition|)
block|{
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
comment|/* The last point could have been on this curve as well... */
if|if
condition|(
name|reset_last
condition|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|l_pnt
init|=
name|NULL
decl_stmt|;
name|gint
name|num_points
init|=
name|bezier_sel
operator|->
name|num_points
decl_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|l_pnt
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|last_point
operator|=
name|l_pnt
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|bezier_edit_point_on_curve (gint x,gint y,gint halfwidth,GDisplay * gdisp,GimpBezierSelectTool * bezier_sel,GimpTool * tool,GdkEventButton * bevent)
name|bezier_edit_point_on_curve
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|)
block|{
name|gboolean
name|grab_pointer
init|=
name|FALSE
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|last_curve
init|=
name|NULL
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
comment|/* find if the button press occurred on a point */
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|finded
init|=
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_op
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|end_op
decl_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|||
operator|(
name|point_counts
operator|<=
literal|7
operator|)
condition|)
block|{
comment|/* Case 1: GDK_SHIFT_MASK - The user explicitly wishes 			 the present curve to go away.  			 Case 2: The current implementation cannot cope with 			 less than 7 points ie: 2 anchors points and 			 4 controls: the minimal closed curve. 			 Since the user wishes less than this implementation 			 minimum, we take this for an implicit wish that 			 the entire curve go away. G'bye dear curve.  		      */
name|delete_whole_curve
argument_list|(
name|bezier_sel
argument_list|,
name|start_pt
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|finded
operator|->
name|prev
operator|||
operator|!
name|finded
operator|->
name|prev
operator|->
name|prev
condition|)
block|{
comment|/* This is the first point on the curve */
comment|/* Clear current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
comment|/* Where are we?  reset to first point... */
comment|/*if(last_curve == NULL)*/
if|if
condition|(
name|start_pt
operator|==
name|bezier_sel
operator|->
name|points
condition|)
block|{
name|finded
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|=
name|finded
operator|->
name|next
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|points
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|finded
operator|=
name|last_curve
operator|->
name|next_curve
expr_stmt|;
name|last_curve
operator|->
name|next_curve
operator|=
name|finded
operator|->
name|next
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|last_curve
operator|->
name|next_curve
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|num_points
operator|-=
literal|3
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
operator|&&
operator|(
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|||
name|finded
operator|==
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|->
name|prev
operator|)
condition|)
block|{
comment|/* This is the last point on the curve */
comment|/* Clear current anchor and control */
comment|/* Where are we?  reset to last point... */
name|finded
operator|=
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|-=
literal|3
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|prev
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|finded
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
block|{
if|if
condition|(
name|finded
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_CONTROL
condition|)
name|finded
operator|=
name|finded
operator|->
name|prev
expr_stmt|;
else|else
name|finded
operator|=
name|finded
operator|->
name|next
expr_stmt|;
block|}
name|start_op
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
name|end_op
operator|=
name|finded
operator|->
name|next
operator|->
name|next
expr_stmt|;
comment|/* we can use next_curve here since we are going to  		       * drop out the bottom anyways. 		       */
name|next_curve
operator|=
name|check_for_next_curve
argument_list|(
name|bezier_sel
argument_list|,
name|finded
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_curve
condition|)
block|{
comment|/* Deleteing first point of next curve*/
name|next_curve
operator|->
name|next_curve
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
else|else
comment|/* Can't be both first and a next curve!*/
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|points
operator|==
name|finded
condition|)
block|{
comment|/* g_print ("Deleting first point %p\n",finded); */
name|bezier_sel
operator|->
name|points
operator|=
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
block|}
comment|/* Make sure the chain of curves is preserved */
if|if
condition|(
name|finded
operator|->
name|prev
operator|->
name|next_curve
condition|)
block|{
comment|/* g_print ("Moving curve on next_curve %p\n",finded->prev->next_curve); */
comment|/* last point on closed multi-path */
name|finded
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
operator|->
name|next_curve
operator|=
name|finded
operator|->
name|prev
operator|->
name|next_curve
expr_stmt|;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
operator|==
name|finded
operator|->
name|prev
condition|)
block|{
comment|/* g_print ("Deleting last point %p\n",finded->prev); */
name|bezier_sel
operator|->
name|last_point
operator|=
name|bezier_sel
operator|->
name|last_point
operator|->
name|prev
operator|->
name|prev
operator|->
name|prev
expr_stmt|;
block|}
name|start_op
operator|->
name|next
operator|=
name|end_op
expr_stmt|;
name|end_op
operator|->
name|prev
operator|=
name|start_op
expr_stmt|;
comment|/* 		  if ( (bezier_sel->last_point == finded) ||  */
comment|/* 		       (bezier_sel->last_point == finded->next) ||  */
comment|/* 		       (bezier_sel->last_point  == finded->prev)) */
comment|/* 		    { */
comment|/* 		      bezier_sel->last_point = start_op->prev->prev; */
comment|/* 		      bezier_sel->points = start_op->prev; */
comment|/* 		    } */
name|bezier_sel
operator|->
name|num_points
operator|-=
literal|3
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|prev
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
operator|->
name|next
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|finded
argument_list|)
expr_stmt|;
comment|/* Clear current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* set the current anchor and control points */
switch|switch
condition|(
name|points
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|points
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|&&
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
operator|->
name|type
operator|==
name|BEZIER_ANCHOR
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|next
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|bezier_sel
operator|->
name|cur_control
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
if|if
condition|(
name|next_curve
condition|)
name|last_curve
operator|=
name|points
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
return|return
name|grab_pointer
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|bezier_add_point_on_segment (gint x,gint y,gint halfwidth,GDisplay * gdisp,GimpBezierSelectTool * bezier_sel,GimpTool * tool)
name|bezier_add_point_on_segment
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
init|=
name|bezier_sel
operator|->
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
do|do
block|{
do|do
block|{
if|if
condition|(
name|test_add_point_on_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
name|FALSE
return|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
return|return
name|FALSE
return|;
name|next_curve
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_start_new_segment (GimpBezierSelectTool * bezier_sel,gint x,gint y)
name|bezier_start_new_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
comment|/* Must be closed to do this! */
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
return|return;
name|bezier_sel
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
comment|/* End is no longer closed !*/
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_MOVE
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_button_press (GimpTool * tool,GdkEventButton * bevent,GDisplay * gdisp)
name|bezier_select_button_press
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventButton
modifier|*
name|bevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|curve_start
decl_stmt|;
name|gboolean
name|grab_pointer
decl_stmt|;
name|gint
name|op
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|tool
operator|->
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|bezier_sel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|tool
expr_stmt|;
name|grab_pointer
operator|=
name|FALSE
expr_stmt|;
comment|/*  If the tool was being used in another image...reset it  */
if|if
condition|(
name|tool
operator|->
name|state
operator|==
name|ACTIVE
operator|&&
name|gdisp
operator|!=
name|tool
operator|->
name|gdisp
condition|)
block|{
name|gimp_draw_tool_stop
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
argument_list|,
name|bevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|bevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|curTool
operator|=
name|active_tool
expr_stmt|;
name|curSel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|curTool
expr_stmt|;
name|curGdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|gdisp
expr_stmt|;
name|active_tool
operator|->
name|gdisp
operator|=
name|gdisp
expr_stmt|;
name|curCore
operator|=
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
expr_stmt|;
switch|switch
condition|(
name|bezier_sel
operator|->
name|state
condition|)
block|{
case|case
name|BEZIER_START
case|:
if|if
condition|(
name|ModeEdit
operator|!=
name|EXTEND_NEW
condition|)
break|break;
name|grab_pointer
operator|=
name|TRUE
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|tool
operator|->
name|gdisp
operator|=
name|gdisp
expr_stmt|;
comment|/*       if (bevent->state& GDK_MOD1_MASK) */
comment|/* 	{ */
comment|/* 	  init_edit_selection (tool, gdisp, bevent, EDIT_MASK_TRANSLATE); */
comment|/* 	  break; */
comment|/* 	} */
comment|/*       else if (!(bevent->state& GDK_SHIFT_MASK)&& !(bevent->state& GDK_CONTROL_MASK)) */
comment|/* 	if (! (layer_is_floating_sel (gimp_image_get_active_layer (gdisp->gimage)))&& */
comment|/* 	    gdisplay_mask_value (gdisp, bevent->x, bevent->y)> HALF_WAY) */
comment|/* 	  { */
comment|/* 	    init_edit_selection (tool, gdisp, bevent, EDIT_MASK_TO_LAYER_TRANSLATE); */
comment|/* 	    break; */
comment|/* 	  } */
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_ADD
expr_stmt|;
comment|/*bezier_sel->draw_mode = BEZIER_DRAW_CURVE; | BEZIER_DRAW_HANDLES;*/
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|gimp_draw_tool_start
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER_ADD
case|:
name|grab_pointer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_EDIT
condition|)
block|{
comment|/* erase the handles */
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
else|else
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
block|{
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|bezier_select_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_REMOVE
condition|)
block|{
comment|/* 	  if(bezier_sel->num_points< 6) */
comment|/* 	    return; */
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
comment|/*kkk*/
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/*kkk*/
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grab_pointer
condition|)
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|bezier_select_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|<
literal|5
condition|)
return|return;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
condition|)
block|{
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
comment|/* recursive call */
name|bezier_select_button_press
argument_list|(
name|tool
argument_list|,
name|bevent
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
operator|&&
name|bezier_check_point
argument_list|(
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|cur_control
operator|=
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|prev
expr_stmt|;
break|break;
block|}
block|}
name|curve_start
operator|=
name|find_start_open_curve
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|curve_start
operator|&&
name|bezier_check_point
argument_list|(
name|curve_start
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
block|{
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|curve_start
expr_stmt|;
name|curve_start
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|curve_start
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|curve_start
operator|->
name|next
expr_stmt|;
name|bezier_sel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|state
operator|=
name|BEZIER_EDIT
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|cur_anchor
condition|)
name|bezier_sel
operator|->
name|cur_anchor
operator|->
name|pointflags
operator|=
literal|1
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_ANCHOR
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_add_point
argument_list|(
name|bezier_sel
argument_list|,
name|BEZIER_CONTROL
argument_list|,
operator|(
name|gdouble
operator|)
name|x
argument_list|,
operator|(
name|gdouble
operator|)
name|y
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_CURRENT
operator||
name|BEZIER_DRAW_HANDLES
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_EDIT
case|:
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|gimp_fatal_error
argument_list|(
literal|"bezier_select_button_press(): Tried to edit "
literal|"on open bezier curve in edit selection"
argument_list|)
expr_stmt|;
comment|/* erase the handles */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
comment|/* unset the current anchor and control */
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|ModeEdit
operator|==
name|EXTEND_ADD
condition|)
block|{
if|if
condition|(
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|grab_pointer
operator|=
name|bezier_add_point_on_segment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grab_pointer
operator|=
name|bezier_edit_point_on_curve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|,
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|bevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab_pointer
operator|&&
name|bezier_sel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|grab_pointer
operator|&&
name|gimp_channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|gboolean
name|replace
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_ADD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_SUB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|bevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
name|op
operator|=
name|CHANNEL_OP_INTERSECT
expr_stmt|;
else|else
block|{
name|op
operator|=
name|CHANNEL_OP_ADD
expr_stmt|;
name|replace
operator|=
name|TRUE
expr_stmt|;
block|}
name|bezier_to_sel_internal
argument_list|(
name|bezier_sel
argument_list|,
name|tool
argument_list|,
name|gdisp
argument_list|,
name|op
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* draw the handles */
if|if
condition|(
operator|!
name|grab_pointer
condition|)
block|{
name|paths_dialog_set_default_op
argument_list|()
expr_stmt|;
name|bezier_start_new_segment
argument_list|(
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|grab_pointer
condition|)
name|gdk_pointer_grab
argument_list|(
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|FALSE
argument_list|,
name|GDK_POINTER_MOTION_HINT_MASK
operator||
name|GDK_BUTTON1_MOTION_MASK
operator||
name|GDK_BUTTON_RELEASE_MASK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bevent
operator|->
name|time
argument_list|)
expr_stmt|;
comment|/* Don't bother doing this if we don't have any points */
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>
literal|0
condition|)
name|paths_first_button_press
argument_list|(
name|bezier_sel
argument_list|,
name|gdisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 0 if not on control point, else BEZIER_ANCHOR or BEZIER_CONTROL */
end_comment

begin_function
specifier|static
name|gint
DECL|function|bezier_on_control_point (GDisplay * gdisp,GimpBezierSelectTool * bezier_sel,gint x,gint y,gint halfwidth)
name|bezier_on_control_point
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|num_points
decl_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
if|if
condition|(
name|bezier_check_point
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
condition|)
return|return
name|points
operator|->
name|type
return|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_check_points (GimpBezierSelectTool * bezier_sel,GdkPoint * points,gint n_points,gpointer data)
name|bezier_check_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|BezierCheckPnts
modifier|*
name|chkpnts
init|=
name|data
decl_stmt|;
name|gint
name|halfwidth
init|=
name|chkpnts
operator|->
name|halfwidth
decl_stmt|;
name|gint
name|loop
decl_stmt|;
name|gint
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
comment|/* Quick exit if already found */
if|if
condition|(
name|chkpnts
operator|->
name|found
condition|)
return|return;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|n_points
condition|;
name|loop
operator|++
control|)
block|{
name|l
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|points
index|[
name|loop
index|]
operator|.
name|y
operator|+
name|halfwidth
expr_stmt|;
comment|/*       g_print ("x,y = [%d,%d] halfwidth %d l,r,t,d [%d,%d,%d,%d]\n", */
comment|/* 	     points[loop].x, */
comment|/* 	     points[loop].y, */
comment|/* 	     halfwidth, */
comment|/* 	     l,r,t,b); */
if|if
condition|(
operator|(
name|chkpnts
operator|->
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|chkpnts
operator|->
name|y
operator|<=
name|b
operator|)
condition|)
block|{
name|chkpnts
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|points_in_box (GimpBezierSelectPoint * points,gint x,gint y)
name|points_in_box
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
comment|/* below code adapted from Wm. Randolph Franklin<wrf@ecse.rpi.edu>    */
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|c
init|=
literal|0
decl_stmt|;
name|gdouble
name|yp
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|xp
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|xp
index|[
name|i
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|yp
index|[
name|i
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* Check if straight line ..below don't work if it is! */
if|if
condition|(
operator|(
name|xp
index|[
literal|0
index|]
operator|==
name|xp
index|[
literal|1
index|]
operator|&&
name|yp
index|[
literal|0
index|]
operator|==
name|yp
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|xp
index|[
literal|2
index|]
operator|==
name|xp
index|[
literal|3
index|]
operator|&&
name|yp
index|[
literal|0
index|]
operator|==
name|yp
index|[
literal|1
index|]
operator|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|3
init|;
name|i
operator|<
literal|4
condition|;
name|j
operator|=
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|yp
index|[
name|i
index|]
operator|<=
name|y
operator|)
operator|&&
operator|(
name|y
operator|<
name|yp
index|[
name|j
index|]
operator|)
operator|)
operator|||
operator|(
operator|(
name|yp
index|[
name|j
index|]
operator|<=
name|y
operator|)
operator|&&
operator|(
name|y
operator|<
name|yp
index|[
name|i
index|]
operator|)
operator|)
operator|)
operator|&&
operator|(
name|x
operator|<
operator|(
name|xp
index|[
name|j
index|]
operator|-
name|xp
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|y
operator|-
name|yp
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|yp
index|[
name|j
index|]
operator|-
name|yp
index|[
name|i
index|]
operator|)
operator|+
name|xp
index|[
name|i
index|]
operator|)
condition|)
name|c
operator|=
operator|!
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_point_on_curve (GDisplay * gdisp,GimpBezierSelectTool * bezier_sel,gint x,gint y,gint halfwidth)
name|bezier_point_on_curve
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|BezierCheckPnts
name|chkpnts
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|CountCurves
modifier|*
name|cnt
init|=
operator|(
name|CountCurves
operator|*
operator|)
operator|&
name|chkpnts
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
name|chkpnts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|chkpnts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|chkpnts
operator|.
name|halfwidth
operator|=
name|halfwidth
expr_stmt|;
name|chkpnts
operator|.
name|found
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_counts
operator|>=
literal|4
condition|)
block|{
do|do
block|{
if|if
condition|(
name|points_in_box
argument_list|(
name|points
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|IMAGE_COORDS
argument_list|,
name|bezier_check_points
argument_list|,
operator|&
name|chkpnts
argument_list|)
expr_stmt|;
block|}
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
comment|/* 	  g_print ("next_anchor = %p\n",points); */
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
if|if
condition|(
name|cnt
condition|)
name|cnt
operator|->
name|count
operator|++
expr_stmt|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
else|else
break|break;
comment|/* must be last curve since only this one is allowed< 4 		    * points. 		    */
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
return|return
name|chkpnts
operator|.
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_cursor_update (GimpTool * tool,GdkEventMotion * mevent,GDisplay * gdisp)
name|gimp_bezier_select_tool_cursor_update
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GdkEventMotion
modifier|*
name|mevent
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|GimpDrawTool
modifier|*
name|draw_tool
decl_stmt|;
name|gboolean
name|on_curve
decl_stmt|;
name|gboolean
name|on_control_pnt
decl_stmt|;
name|gboolean
name|in_selection_area
decl_stmt|;
name|gint
name|halfwidth
decl_stmt|,
name|dummy
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|bezier_sel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|tool
expr_stmt|;
name|draw_tool
operator|=
name|GIMP_DRAW_TOOL
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdisp
operator|!=
name|tool
operator|->
name|gdisp
operator|||
name|draw_tool
operator|->
name|draw_state
operator|==
name|INVISIBLE
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
argument_list|,
name|mevent
operator|->
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get halfwidth in image coord */
name|gdisplay_untransform_coords
argument_list|(
name|gdisp
argument_list|,
name|mevent
operator|->
name|x
operator|+
name|BEZIER_HALFWIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|halfwidth
argument_list|,
operator|&
name|dummy
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halfwidth
operator|-=
name|x
expr_stmt|;
name|on_control_pnt
operator|=
name|bezier_on_control_point
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
expr_stmt|;
name|on_curve
operator|=
name|bezier_point_on_curve
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|halfwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|mask
operator|&&
name|bezier_sel
operator|->
name|closed
operator|&&
name|gimp_channel_value
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|!
name|on_control_pnt
operator|&&
operator|(
operator|!
name|on_curve
operator|||
name|ModeEdit
operator|!=
name|EXTEND_ADD
operator|)
condition|)
block|{
name|in_selection_area
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
operator|&&
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_RECT_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_PLUS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|!
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_RECT_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_MINUS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_CONTROL_MASK
operator|)
operator|&&
operator|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
operator|)
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_RECT_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_INTERSECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_RECT_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_MOD1_MASK
condition|)
block|{
comment|/* Moving curve */
if|if
condition|(
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
comment|/* moving on 1 curve */
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_MOVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_MOVE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ModeEdit
condition|)
block|{
case|case
name|EXTEND_NEW
case|:
if|if
condition|(
name|on_control_pnt
operator|&&
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_CONTROL
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("add to curve cursor\n"); */
block|}
elseif|else
if|if
condition|(
name|on_curve
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("edit control point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTEND_ADD
case|:
if|if
condition|(
name|on_curve
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_PLUS
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("add to curve cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("default no action cursor\n"); */
block|}
break|break;
case|case
name|EXTEND_EDIT
case|:
if|if
condition|(
name|on_control_pnt
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_CONTROL
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("edit control point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("default no action cursor\n"); */
block|}
break|break;
case|case
name|EXTEND_REMOVE
case|:
if|if
condition|(
name|on_control_pnt
operator|&&
name|mevent
operator|->
name|state
operator|&
name|GDK_SHIFT_MASK
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_MINUS
argument_list|)
expr_stmt|;
comment|/*            g_print ("delete whole curve cursor\n"); */
block|}
elseif|else
if|if
condition|(
name|on_control_pnt
condition|)
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_MINUS
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("remove point cursor\n"); */
block|}
else|else
block|{
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
comment|/* 	      g_print ("default no action cursor\n"); */
block|}
break|break;
default|default:
name|g_print
argument_list|(
literal|"In default\n"
argument_list|)
expr_stmt|;
name|gdisplay_install_tool_cursor
argument_list|(
name|gdisp
argument_list|,
name|GIMP_MOUSE_CURSOR
argument_list|,
name|GIMP_BEZIER_SELECT_TOOL_CURSOR
argument_list|,
name|GIMP_CURSOR_MODIFIER_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_bezier_select_tool_control (GimpTool * tool,ToolAction action,GDisplay * gdisp)
name|gimp_bezier_select_tool_control
parameter_list|(
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|ToolAction
name|action
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|tool
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PAUSE
case|:
name|gimp_draw_tool_pause
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME
case|:
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
case|case
name|HALT
case|:
name|gimp_draw_tool_stop
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|bezier_draw (GDisplay * gdisp,GimpBezierSelectTool * bezier_sel)
name|bezier_draw
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|num_points
decl_stmt|;
name|gint
name|draw_curve
decl_stmt|;
name|gint
name|draw_handles
decl_stmt|;
name|gint
name|draw_current
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|draw_mode
condition|)
return|return;
name|draw_curve
operator|=
name|bezier_sel
operator|->
name|draw_mode
operator|&
name|BEZIER_DRAW_CURVE
expr_stmt|;
name|draw_current
operator|=
name|bezier_sel
operator|->
name|draw_mode
operator|&
name|BEZIER_DRAW_CURRENT
expr_stmt|;
name|draw_handles
operator|=
name|bezier_sel
operator|->
name|draw_mode
operator|&
name|BEZIER_DRAW_HANDLES
expr_stmt|;
comment|/* reset to the default drawing state of drawing the curve and handles */
name|bezier_sel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
comment|/* transform the points from image space to screen space */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
while|while
condition|(
name|points
operator|&&
name|num_points
condition|)
block|{
name|gdisplay_transform_coords
argument_list|(
name|gdisp
argument_list|,
name|points
operator|->
name|x
argument_list|,
name|points
operator|->
name|y
argument_list|,
operator|&
name|points
operator|->
name|sx
argument_list|,
operator|&
name|points
operator|->
name|sy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
name|num_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|draw_curve
condition|)
block|{
name|bezier_draw_curve
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|draw_current
condition|)
block|{
name|bezier_draw_current
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|draw_handles
condition|)
block|{
name|bezier_draw_handles
argument_list|(
name|bezier_sel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_select_draw (GimpDrawTool * draw_tool)
name|bezier_select_draw
parameter_list|(
name|GimpDrawTool
modifier|*
name|draw_tool
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GimpTool
modifier|*
name|tool
decl_stmt|;
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
decl_stmt|;
name|bezier_sel
operator|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|draw_tool
expr_stmt|;
name|tool
operator|=
name|GIMP_TOOL
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|gdisp
operator|=
name|tool
operator|->
name|gdisp
expr_stmt|;
name|bezier_draw
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_add_point (GimpBezierSelectTool * bezier_sel,gint type,gdouble x,gdouble y)
name|bezier_add_point
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|type
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|newpt
decl_stmt|;
name|newpt
operator|=
name|g_new0
argument_list|(
name|GimpBezierSelectPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|newpt
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|newpt
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|newpt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|newpt
operator|->
name|next_curve
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|BEZIER_MOVE
operator|&&
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
comment|/*       g_print ("Adding move point\n"); */
name|newpt
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|->
name|next_curve
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|BEZIER_MOVE
condition|)
block|{
name|newpt
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
comment|/* 	  g_print ("Adding MOVE point to null curve\n"); */
block|}
if|if
condition|(
name|bezier_sel
operator|->
name|last_point
condition|)
block|{
name|bezier_sel
operator|->
name|last_point
operator|->
name|next
operator|=
name|newpt
expr_stmt|;
name|newpt
operator|->
name|prev
operator|=
name|bezier_sel
operator|->
name|last_point
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
else|else
block|{
name|bezier_sel
operator|->
name|points
operator|=
name|newpt
expr_stmt|;
name|bezier_sel
operator|->
name|last_point
operator|=
name|newpt
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|newpt
expr_stmt|;
break|break;
case|case
name|BEZIER_CONTROL
case|:
name|bezier_sel
operator|->
name|cur_control
operator|=
name|newpt
expr_stmt|;
break|break;
block|}
block|}
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_offset_point (GimpBezierSelectPoint * pt,gint x,gint y)
name|bezier_offset_point
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|x
operator|+=
name|x
expr_stmt|;
name|pt
operator|->
name|y
operator|+=
name|y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bezier_check_point (GimpBezierSelectPoint * pt,gint x,gint y,gint halfwidth)
name|bezier_check_point
parameter_list|(
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|gint
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|l
operator|=
name|pt
operator|->
name|x
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|pt
operator|->
name|x
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|pt
operator|->
name|y
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|pt
operator|->
name|y
operator|+
name|halfwidth
expr_stmt|;
return|return
operator|(
operator|(
name|x
operator|>=
name|l
operator|)
operator|&&
operator|(
name|x
operator|<=
name|r
operator|)
operator|&&
operator|(
name|y
operator|>=
name|t
operator|)
operator|&&
operator|(
name|y
operator|<=
name|b
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_handles (GimpBezierSelectTool * bezier_sel,gboolean do_all)
name|bezier_draw_handles
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gboolean
name|do_all
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|gint
name|num_points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|bezier_sel
operator|->
name|num_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|<=
literal|0
condition|)
return|return;
while|while
condition|(
name|num_points
operator|&&
name|num_points
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|points
operator|==
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
comment|/* 	g_print ("bezier_draw_handles:: found cur_anchor %p\n",points); */
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|next
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
operator|->
name|prev
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|next
argument_list|)
expr_stmt|;
name|bezier_draw_line
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|points
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	g_print ("bezier_draw_handles:: not found cur_anchor %p\n",points); */
if|if
condition|(
name|do_all
operator|||
name|points
operator|->
name|pointflags
operator|==
literal|1
condition|)
block|{
name|bezier_draw_point
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|points
operator|->
name|pointflags
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|points
condition|)
block|{
if|if
condition|(
name|points
operator|->
name|next_curve
condition|)
name|points
operator|=
name|points
operator|->
name|next_curve
expr_stmt|;
else|else
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
name|num_points
operator|-=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_current (GimpBezierSelectTool * bezier_sel)
name|bezier_draw_current
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|!=
name|bezier_sel
operator|->
name|cur_anchor
condition|)
block|{
name|points
operator|=
name|bezier_sel
operator|->
name|cur_anchor
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|points
condition|)
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|bezier_sel
operator|->
name|cur_anchor
argument_list|,
name|SUBDIVIDE
argument_list|,
name|SCREEN_COORDS
argument_list|,
name|bezier_draw_segment_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_point (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * pt,gboolean fill)
name|bezier_draw_point
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gboolean
name|fill
parameter_list|)
block|{
name|GimpDrawTool
modifier|*
name|draw_tool
decl_stmt|;
name|draw_tool
operator|=
name|GIMP_DRAW_TOOL
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
switch|switch
condition|(
name|pt
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER_ANCHOR
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_arc
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|TRUE
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_arc
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|FALSE
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
literal|0
argument_list|,
literal|23040
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BEZIER_CONTROL
case|:
if|if
condition|(
name|fill
condition|)
block|{
name|gdk_draw_rectangle
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|TRUE
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdk_draw_rectangle
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|FALSE
argument_list|,
name|pt
operator|->
name|sx
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|pt
operator|->
name|sy
operator|-
name|BEZIER_HALFWIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|,
name|BEZIER_WIDTH
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_line (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * pt1,GimpBezierSelectPoint * pt2)
name|bezier_draw_line
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt1
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt2
parameter_list|)
block|{
name|GimpDrawTool
modifier|*
name|draw_tool
decl_stmt|;
name|draw_tool
operator|=
name|GIMP_DRAW_TOOL
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt1
operator|&&
name|pt2
condition|)
block|{
name|gdk_draw_line
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|pt1
operator|->
name|sx
argument_list|,
name|pt1
operator|->
name|sy
argument_list|,
name|pt2
operator|->
name|sx
argument_list|,
name|pt2
operator|->
name|sy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * points,gint subdivisions,gint space,GimpBezierSelectPointsFunc points_func,gpointer data)
name|bezier_draw_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gint
name|space
parameter_list|,
name|GimpBezierSelectPointsFunc
name|points_func
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
specifier|static
name|GdkPoint
name|gdk_points
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|gint
name|n_points
init|=
literal|256
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|gdouble
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|gdouble
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|gint
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|gint
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|gimp_fatal_error
argument_list|(
literal|"bezier_draw_segment(): Bad bezier segment"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
operator|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
operator|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|gimp_fatal_error
argument_list|(
literal|"bezier_draw_segment(): Unknown coordinate space: %d"
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|x
operator|=
operator|(
name|lastx
operator|)
expr_stmt|;
name|gdk_points
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|(
name|lasty
operator|)
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then draw it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
comment|/* add the point to the point buffer */
name|gdk_points
index|[
name|index
index|]
operator|.
name|x
operator|=
operator|(
name|newx
operator|)
expr_stmt|;
name|gdk_points
index|[
name|index
index|]
operator|.
name|y
operator|=
operator|(
name|newy
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* if the point buffer is full put it to the screen and zero it out */
if|if
condition|(
name|index
operator|>=
name|n_points
condition|)
block|{
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* if there are points in the buffer, then put them on the screen */
if|if
condition|(
name|index
condition|)
call|(
modifier|*
name|points_func
call|)
argument_list|(
name|bezier_sel
argument_list|,
name|gdk_points
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_points (GimpBezierSelectTool * bezier_sel,GdkPoint * points,gint n_points,gpointer data)
name|bezier_draw_segment_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|GimpDrawTool
modifier|*
name|draw_tool
decl_stmt|;
name|draw_tool
operator|=
name|GIMP_DRAW_TOOL
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
name|gdk_draw_points
argument_list|(
name|draw_tool
operator|->
name|win
argument_list|,
name|draw_tool
operator|->
name|gc
argument_list|,
name|points
argument_list|,
name|n_points
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_compose (BezierMatrix a,BezierMatrix b,BezierMatrix ab)
name|bezier_compose
parameter_list|(
name|BezierMatrix
name|a
parameter_list|,
name|BezierMatrix
name|b
parameter_list|,
name|BezierMatrix
name|ab
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ab
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|a
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|b
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|b
index|[
literal|1
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|b
index|[
literal|2
index|]
index|[
name|j
index|]
operator|+
name|a
index|[
name|i
index|]
index|[
literal|3
index|]
operator|*
name|b
index|[
literal|3
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
DECL|variable|start_convert
specifier|static
name|int
name|start_convert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|width
DECL|variable|height
specifier|static
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lastx
specifier|static
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lasty
specifier|static
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|bezier_convert (GimpBezierSelectTool * bezier_sel,GDisplay * gdisp,gint subdivisions,gboolean antialias)
name|bezier_convert
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gboolean
name|antialias
parameter_list|)
block|{
name|PixelRegion
name|maskPR
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|gint
name|draw_type
decl_stmt|;
name|gint
modifier|*
name|vals
decl_stmt|,
name|val
decl_stmt|;
name|gint
name|start
decl_stmt|,
name|end
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|x2
decl_stmt|,
name|w
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
name|gimp_fatal_error
argument_list|(
literal|"bezier_convert(): tried to convert an open bezier curve"
argument_list|)
expr_stmt|;
comment|/* destroy previous mask */
if|if
condition|(
name|bezier_sel
operator|->
name|mask
condition|)
block|{
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get the new mask's maximum extents */
if|if
condition|(
name|antialias
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
operator|*
name|SUPERSAMPLE
expr_stmt|;
name|draw_type
operator|=
name|AA_IMAGE_COORDS
expr_stmt|;
comment|/* allocate value array  */
name|vals
operator|=
operator|(
name|int
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|width
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|gdisp
operator|->
name|gimage
operator|->
name|height
expr_stmt|;
name|draw_type
operator|=
name|IMAGE_COORDS
expr_stmt|;
name|vals
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new mask */
name|bezier_sel
operator|->
name|mask
operator|=
name|gimp_channel_new_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|width
argument_list|,
name|gdisp
operator|->
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|gtk_object_ref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_object_sink
argument_list|(
name|GTK_OBJECT
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate room for the scanlines */
name|bezier_sel
operator|->
name|scanlines
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GSList
operator|*
argument_list|)
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* zero out the scanlines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* scan convert the curve */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
do|do
block|{
name|start_convert
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|subdivisions
argument_list|,
name|draw_type
argument_list|,
name|bezier_convert_points
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  advance to the next segment  */
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|gimp_drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|gimp_drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|=
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
expr_stmt|;
comment|/*  zero the vals array  */
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
name|i
operator|%
name|SUPERSAMPLE
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|x
operator|=
operator|(
name|long
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/*           if (!list) 	    g_message ("cannot properly scanline convert bezier curve: %d", i);           else */
block|{
comment|/*  bounds checking  */
name|x
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
operator|(
name|long
operator|)
name|list
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|w
operator|=
name|x2
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|antialias
condition|)
name|gimp_channel_add_segment
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|x
argument_list|,
name|i
argument_list|,
name|w
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
name|vals
index|[
name|j
operator|+
name|x
index|]
operator|+=
literal|255
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|antialias
operator|&&
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|SUPERSAMPLE
operator|)
condition|)
block|{
name|b
operator|=
name|buf
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|width
expr_stmt|;
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|+=
name|SUPERSAMPLE
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SUPERSAMPLE
condition|;
name|x
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
operator|*
name|b
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|/
name|SUPERSAMPLE2
argument_list|)
expr_stmt|;
block|}
name|pixel_region_set_row
argument_list|(
operator|&
name|maskPR
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|/
name|SUPERSAMPLE
operator|)
argument_list|,
name|gimp_drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antialias
condition|)
block|{
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|)
expr_stmt|;
name|bezier_sel
operator|->
name|scanlines
operator|=
name|NULL
expr_stmt|;
name|gimp_channel_invalidate_bounds
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_points (GimpBezierSelectTool * bezier_sel,GdkPoint * points,gint n_points,gpointer data)
name|bezier_convert_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|start_convert
condition|)
name|start_convert
operator|=
literal|0
expr_stmt|;
else|else
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|n_points
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bezier_convert_line
argument_list|(
name|bezier_sel
operator|->
name|scanlines
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|=
name|points
index|[
name|n_points
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|points
index|[
name|n_points
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_convert_line (GSList ** scanlines,gint x1,gint y1,gint x2,gint y2)
name|bezier_convert_line
parameter_list|(
name|GSList
modifier|*
modifier|*
name|scanlines
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gint
name|error
decl_stmt|,
name|inc
decl_stmt|;
name|gint
name|tmp
decl_stmt|;
name|gdouble
name|slope
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|y1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y2
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|double
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
operator|+
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
call|(
name|double
call|)
argument_list|(
literal|0
operator|-
name|y2
argument_list|)
operator|/
name|slope
argument_list|)
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y2
operator|>=
name|height
condition|)
block|{
if|if
condition|(
name|y1
operator|>=
name|height
condition|)
return|return;
if|if
condition|(
name|x2
operator|==
name|x1
condition|)
block|{
name|y2
operator|=
name|height
expr_stmt|;
block|}
else|else
block|{
name|slope
operator|=
call|(
name|double
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
call|(
name|double
call|)
argument_list|(
name|height
operator|-
name|y1
argument_list|)
operator|/
name|slope
argument_list|)
expr_stmt|;
name|y2
operator|=
name|height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
return|return;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|scanlines
operator|=
operator|&
name|scanlines
index|[
name|y1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|dx
else|:
name|dx
operator|)
operator|>
operator|(
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
operator|)
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|dx
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|x1
operator|!=
name|x2
condition|)
block|{
name|error
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dx
expr_stmt|;
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
block|}
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
operator|-
name|dy
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|y1
operator|++
operator|<
name|y2
condition|)
block|{
operator|*
name|scanlines
operator|=
name|bezier_insert_in_list
argument_list|(
operator|*
name|scanlines
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|scanlines
operator|++
expr_stmt|;
name|error
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|error
operator|-=
name|dy
expr_stmt|;
name|x1
operator|+=
name|inc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GSList
modifier|*
DECL|function|bezier_insert_in_list (GSList * list,gint x)
name|bezier_insert_in_list
parameter_list|(
name|GSList
modifier|*
name|list
parameter_list|,
name|gint
name|x
parameter_list|)
block|{
name|GSList
modifier|*
name|orig
init|=
name|list
decl_stmt|;
name|GSList
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
return|;
while|while
condition|(
name|list
condition|)
block|{
name|rest
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|long
operator|)
name|list
operator|->
name|data
condition|)
block|{
name|rest
operator|=
name|g_slist_prepend
argument_list|(
name|rest
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|list
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
expr_stmt|;
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rest
condition|)
block|{
name|g_slist_append
argument_list|(
name|list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|bezier_tool_selected (void)
name|bezier_tool_selected
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|active_tool
operator|&&
name|GIMP_IS_BEZIER_SELECT_TOOL
argument_list|(
name|active_tool
argument_list|)
operator|&&
name|active_tool
operator|->
name|state
operator|==
name|ACTIVE
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_paste_bezierselect_to_current (GDisplay * gdisp,GimpBezierSelectTool * bsel)
name|bezier_paste_bezierselect_to_current
parameter_list|(
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|GimpBezierSelectTool
modifier|*
name|bsel
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|pts
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GimpTool
modifier|*
name|tool
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|bpnt
init|=
name|NULL
decl_stmt|;
name|gint
name|need_move
init|=
literal|0
decl_stmt|;
comment|/*   g_print ("bezier_paste_bezierselect_to_current::\n"); */
comment|/*   printSel(bsel); */
comment|/*  If the tool was being used before clear it */
if|if
condition|(
name|active_tool
operator|&&
name|GIMP_IS_BEZIER_SELECT_TOOL
argument_list|(
name|active_tool
argument_list|)
operator|&&
name|active_tool
operator|->
name|state
operator|==
name|ACTIVE
condition|)
block|{
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
init|=
operator|(
name|GimpBezierSelectTool
operator|*
operator|)
name|active_tool
decl_stmt|;
if|if
condition|(
name|bezier_sel
condition|)
block|{
name|gimp_draw_tool_stop
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|curSel
argument_list|)
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|bezier_sel
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_context_set_tool
argument_list|(
name|gimp_context_get_user
argument_list|()
argument_list|,
name|tool_manager_get_info_by_type
argument_list|(
name|GIMP_TYPE_BEZIER_SELECT_TOOL
argument_list|)
argument_list|)
expr_stmt|;
name|active_tool
operator|->
name|paused_count
operator|=
literal|0
expr_stmt|;
name|active_tool
operator|->
name|gdisp
operator|=
name|gdisp
expr_stmt|;
name|active_tool
operator|->
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|tool
operator|=
name|active_tool
expr_stmt|;
name|bezier_select_reset
argument_list|(
name|curSel
argument_list|)
expr_stmt|;
name|gimp_draw_tool_start
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|curSel
argument_list|,
name|gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|)
expr_stmt|;
name|tool
operator|->
name|state
operator|=
name|ACTIVE
expr_stmt|;
name|pts
operator|=
operator|(
name|GimpBezierSelectPoint
operator|*
operator|)
name|bsel
operator|->
name|points
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bsel
operator|->
name|num_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_move
condition|)
block|{
name|bezier_add_point
argument_list|(
name|curSel
argument_list|,
name|BEZIER_MOVE
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
name|need_move
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bezier_add_point
argument_list|(
name|curSel
argument_list|,
name|pts
operator|->
name|type
argument_list|,
name|pts
operator|->
name|x
argument_list|,
name|pts
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bpnt
operator|==
name|NULL
condition|)
name|bpnt
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
if|if
condition|(
name|pts
operator|->
name|next_curve
condition|)
block|{
comment|/* 	  g_print ("bezier_paste_bezierselect_to_current:: Close last curve off \n"); */
name|curSel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
name|curSel
operator|->
name|cur_anchor
operator|=
name|NULL
expr_stmt|;
name|curSel
operator|->
name|cur_control
operator|=
name|NULL
expr_stmt|;
name|bpnt
operator|=
name|NULL
expr_stmt|;
name|need_move
operator|=
literal|1
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next_curve
expr_stmt|;
block|}
else|else
block|{
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bsel
operator|->
name|closed
condition|)
block|{
name|curSel
operator|->
name|last_point
operator|->
name|next
operator|=
name|bpnt
expr_stmt|;
name|bpnt
operator|->
name|prev
operator|=
name|curSel
operator|->
name|last_point
expr_stmt|;
name|curSel
operator|->
name|cur_anchor
operator|=
name|curSel
operator|->
name|points
expr_stmt|;
name|curSel
operator|->
name|cur_control
operator|=
name|curSel
operator|->
name|points
operator|->
name|next
expr_stmt|;
name|curSel
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curTool
operator|->
name|gdisp
condition|)
name|bezier_convert
argument_list|(
name|curSel
argument_list|,
name|curTool
operator|->
name|gdisp
argument_list|,
name|SUBDIVIDE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/*   g_print ("After pasting...\n"); */
comment|/*   printSel(curSel); */
if|if
condition|(
name|bsel
operator|->
name|num_points
operator|==
literal|0
condition|)
block|{
name|curSel
operator|->
name|state
operator|=
name|BEZIER_START
expr_stmt|;
name|curSel
operator|->
name|draw_mode
operator|=
literal|0
expr_stmt|;
name|gimp_draw_tool_stop
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|curSel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curSel
operator|->
name|state
operator|=
name|bsel
operator|->
name|state
expr_stmt|;
name|curSel
operator|->
name|draw_mode
operator|=
name|BEZIER_DRAW_ALL
expr_stmt|;
name|gimp_draw_tool_resume
argument_list|(
operator|(
name|GimpDrawTool
operator|*
operator|)
name|curSel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_to_sel_internal (GimpBezierSelectTool * bezier_sel,GimpTool * tool,GDisplay * gdisp,gint op,gint replace)
name|bezier_to_sel_internal
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpTool
modifier|*
name|tool
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|op
parameter_list|,
name|gint
name|replace
parameter_list|)
block|{
comment|/*  If we're antialiased, then recompute the mask...    */
if|if
condition|(
name|bezier_options
operator|->
name|antialias
condition|)
name|bezier_convert
argument_list|(
name|bezier_sel
argument_list|,
name|tool
operator|->
name|gdisp
argument_list|,
name|SUBDIVIDE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace
condition|)
name|gimage_mask_clear
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
else|else
name|gimage_mask_undo
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|bezier_options
operator|->
name|feather
condition|)
name|gimp_channel_feather
argument_list|(
name|bezier_sel
operator|->
name|mask
argument_list|,
name|gimp_image_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|bezier_options
operator|->
name|feather_radius
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|gimp_channel_combine_mask
argument_list|(
name|gimp_image_get_mask
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
argument_list|,
name|bezier_sel
operator|->
name|mask
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  show selection on all views  */
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|test_add_point_on_segment (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * pt,gint subdivisions,gint space,gint xpos,gint ypos,gint halfwidth)
name|test_add_point_on_segment
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|pt
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gint
name|space
parameter_list|,
name|gint
name|xpos
parameter_list|,
name|gint
name|ypos
parameter_list|,
name|gint
name|halfwidth
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|gdouble
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|gdouble
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|gint
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
name|gint
name|newx
decl_stmt|,
name|newy
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gdouble
name|ratio
decl_stmt|;
comment|/* construct the geometry matrix from the segment assumes that a    * valid segment containing 4 points is passed in ALT ignore invalid    * segments since we might be working on an open curve    */
name|points
operator|=
name|pt
expr_stmt|;
name|ratio
operator|=
operator|-
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|AA_IMAGE_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|RINT
argument_list|(
name|points
operator|->
name|x
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|RINT
argument_list|(
name|points
operator|->
name|y
operator|*
name|SUPERSAMPLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCREEN_COORDS
case|:
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|sx
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|sy
expr_stmt|;
break|break;
default|default:
name|gimp_fatal_error
argument_list|(
literal|"test_add_point_on_segment(): Unknown coordinate space: %d"
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
block|}
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times n can be adjusted to give a finer or    * coarser curve    */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward    * diffencing deltas    */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
name|newx
operator|=
name|ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newy
operator|=
name|ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* if this point is different than the last one...then test it */
if|if
condition|(
operator|(
name|lastx
operator|!=
name|newx
operator|)
operator|||
operator|(
name|lasty
operator|!=
name|newy
operator|)
condition|)
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|b
decl_stmt|,
name|t
decl_stmt|;
name|l
operator|=
name|newx
operator|-
name|halfwidth
expr_stmt|;
name|r
operator|=
name|newx
operator|+
name|halfwidth
expr_stmt|;
name|t
operator|=
name|newy
operator|-
name|halfwidth
expr_stmt|;
name|b
operator|=
name|newy
operator|+
name|halfwidth
expr_stmt|;
if|if
condition|(
operator|(
name|xpos
operator|>=
name|l
operator|)
operator|&&
operator|(
name|xpos
operator|<=
name|r
operator|)
operator|&&
operator|(
name|ypos
operator|>=
name|t
operator|)
operator|&&
operator|(
name|ypos
operator|<=
name|b
operator|)
condition|)
block|{
comment|/* so we found one point in the square hit */
name|ratio
operator|=
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|subdivisions
expr_stmt|;
comment|/* We found the exact point on the curve, so take it ...*/
if|if
condition|(
operator|(
name|xpos
operator|==
name|newx
operator|)
operator|&&
operator|(
name|ypos
operator|==
name|newy
operator|)
condition|)
break|break;
comment|/* To Implement: keep each time the nearest point of the 	       * curve from where we've clicked in the case where we 	       * haven't click exactely on the curve. 	       */
block|}
block|}
name|lastx
operator|=
name|newx
expr_stmt|;
name|lasty
operator|=
name|newy
expr_stmt|;
block|}
comment|/* we found a point on the curve */
if|if
condition|(
name|ratio
operator|>=
literal|0.0
condition|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|pts
decl_stmt|,
modifier|*
name|pt1
decl_stmt|,
modifier|*
name|pt2
decl_stmt|,
modifier|*
name|pt3
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|P00
decl_stmt|,
modifier|*
name|P01
decl_stmt|,
modifier|*
name|P02
decl_stmt|,
modifier|*
name|P03
decl_stmt|;
name|GimpBezierSelectPoint
name|P10
decl_stmt|,
name|P11
decl_stmt|,
name|P12
decl_stmt|;
name|GimpBezierSelectPoint
name|P20
decl_stmt|,
name|P21
decl_stmt|;
name|GimpBezierSelectPoint
name|P30
decl_stmt|;
name|pts
operator|=
name|pt
expr_stmt|;
name|P00
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P01
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P02
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|pts
operator|->
name|next
expr_stmt|;
name|P03
operator|=
name|pts
expr_stmt|;
comment|/* De Casteljau algorithme  	 [Advanced Animation& Randering Technics / Alan& Mark WATT] 	 [ADDISON WESLEY ref 54412] 	 Iteratif way of drawing a Bezier curve by geometrical approch  	  	 P0x represent the four controls points ( anchor / control /control /anchor )  	 P30 represent the new anchor point to add on the curve  	 P2x represent the new control points of P30 	 P1x represent the new values of the control points P01 and P02  	 so if we moves ratio from 0 to 1 we draw the all curve between P00 and P03       */
name|P10
operator|.
name|x
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|x
operator|+
name|ratio
operator|*
name|P01
operator|->
name|x
argument_list|)
expr_stmt|;
name|P10
operator|.
name|y
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P00
operator|->
name|y
operator|+
name|ratio
operator|*
name|P01
operator|->
name|y
argument_list|)
expr_stmt|;
name|P11
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|x
operator|+
name|ratio
operator|*
name|P02
operator|->
name|x
expr_stmt|;
name|P11
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P01
operator|->
name|y
operator|+
name|ratio
operator|*
name|P02
operator|->
name|y
expr_stmt|;
name|P12
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|x
operator|+
name|ratio
operator|*
name|P03
operator|->
name|x
expr_stmt|;
name|P12
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P02
operator|->
name|y
operator|+
name|ratio
operator|*
name|P03
operator|->
name|y
expr_stmt|;
name|P20
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|x
operator|+
name|ratio
operator|*
name|P11
operator|.
name|x
expr_stmt|;
name|P20
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P10
operator|.
name|y
operator|+
name|ratio
operator|*
name|P11
operator|.
name|y
expr_stmt|;
name|P21
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|x
operator|+
name|ratio
operator|*
name|P12
operator|.
name|x
expr_stmt|;
name|P21
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P11
operator|.
name|y
operator|+
name|ratio
operator|*
name|P12
operator|.
name|y
expr_stmt|;
name|P30
operator|.
name|x
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|x
operator|+
name|ratio
operator|*
name|P21
operator|.
name|x
expr_stmt|;
name|P30
operator|.
name|y
operator|=
operator|(
literal|1
operator|-
name|ratio
operator|)
operator|*
name|P20
operator|.
name|y
operator|+
name|ratio
operator|*
name|P21
operator|.
name|y
expr_stmt|;
name|P01
operator|->
name|x
operator|=
name|P10
operator|.
name|x
expr_stmt|;
name|P01
operator|->
name|y
operator|=
name|P10
operator|.
name|y
expr_stmt|;
name|P02
operator|->
name|x
operator|=
name|P12
operator|.
name|x
expr_stmt|;
name|P02
operator|->
name|y
operator|=
name|P12
operator|.
name|y
expr_stmt|;
comment|/* All the computes are done, let's insert the new point on the curve */
name|pt1
operator|=
name|g_new0
argument_list|(
name|GimpBezierSelectPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|g_new0
argument_list|(
name|GimpBezierSelectPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|g_new0
argument_list|(
name|GimpBezierSelectPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pt1
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt2
operator|->
name|type
operator|=
name|BEZIER_ANCHOR
expr_stmt|;
name|pt3
operator|->
name|type
operator|=
name|BEZIER_CONTROL
expr_stmt|;
name|pt1
operator|->
name|x
operator|=
name|P20
operator|.
name|x
expr_stmt|;
name|pt1
operator|->
name|y
operator|=
name|P20
operator|.
name|y
expr_stmt|;
name|pt2
operator|->
name|x
operator|=
name|P30
operator|.
name|x
expr_stmt|;
name|pt2
operator|->
name|y
operator|=
name|P30
operator|.
name|y
expr_stmt|;
name|pt3
operator|->
name|x
operator|=
name|P21
operator|.
name|x
expr_stmt|;
name|pt3
operator|->
name|y
operator|=
name|P21
operator|.
name|y
expr_stmt|;
name|pt3
operator|->
name|next_curve
operator|=
name|P01
operator|->
name|next_curve
expr_stmt|;
name|P01
operator|->
name|next
operator|=
name|pt1
expr_stmt|;
name|pt1
operator|->
name|prev
operator|=
name|P01
expr_stmt|;
name|pt1
operator|->
name|next
operator|=
name|pt2
expr_stmt|;
name|pt2
operator|->
name|prev
operator|=
name|pt1
expr_stmt|;
name|pt2
operator|->
name|next
operator|=
name|pt3
expr_stmt|;
name|pt3
operator|->
name|prev
operator|=
name|pt2
expr_stmt|;
name|pt3
operator|->
name|next
operator|=
name|P02
expr_stmt|;
name|P02
operator|->
name|prev
operator|=
name|pt3
expr_stmt|;
name|bezier_sel
operator|->
name|num_points
operator|+=
literal|3
expr_stmt|;
name|bezier_sel
operator|->
name|cur_anchor
operator|=
name|pt2
expr_stmt|;
name|bezier_sel
operator|->
name|cur_control
operator|=
name|pt1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_select_mode (gint mode)
name|bezier_select_mode
parameter_list|(
name|gint
name|mode
parameter_list|)
block|{
name|ModeEdit
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The curve has to be closed to do a selection. */
end_comment

begin_function
name|void
DECL|function|bezier_to_selection (GimpBezierSelectTool * bezier_sel,GDisplay * gdisp)
name|bezier_to_selection
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|)
block|{
comment|/* Call the internal function */
if|if
condition|(
operator|!
name|bezier_sel
operator|->
name|closed
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Curve not closed!"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* force the passed selection to be the current selection...    * This loads it into curSel for this image    */
name|bezier_paste_bezierselect_to_current
argument_list|(
name|gdisp
argument_list|,
name|bezier_sel
argument_list|)
expr_stmt|;
name|bezier_to_sel_internal
argument_list|(
name|curSel
argument_list|,
operator|(
name|GimpTool
operator|*
operator|)
name|curTool
argument_list|,
name|gdisp
argument_list|,
name|CHANNEL_OP_ADD
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check whether vectors (offx, offy), (l_offx, l_offy) have the same angle. */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|stroke_interpolatable (gint offx,gint offy,gint l_offx,gint l_offy,gdouble error)
name|stroke_interpolatable
parameter_list|(
name|gint
name|offx
parameter_list|,
name|gint
name|offy
parameter_list|,
name|gint
name|l_offx
parameter_list|,
name|gint
name|l_offy
parameter_list|,
name|gdouble
name|error
parameter_list|)
block|{
if|if
condition|(
operator|(
name|offx
operator|==
name|l_offx
operator|)
operator|&
operator|(
name|offy
operator|==
name|l_offy
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|offx
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offx
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|offx
operator|==
name|l_offx
condition|)
return|return
operator|(
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|&
operator|(
literal|0
operator|<=
name|offy
operator|)
operator|)
operator||
operator|(
operator|(
name|offy
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offy
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|offy
operator|==
literal|0
operator|)
operator||
operator|(
name|l_offy
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|offy
operator|==
name|l_offy
condition|)
return|return
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
comment|/* At this point, we can assert: offx, offy, l_offx, l_offy != 0 */
elseif|else
if|if
condition|(
operator|(
operator|(
literal|0
operator|<
name|offx
operator|)
operator|&
operator|(
literal|0
operator|<
name|l_offx
operator|)
operator|)
operator||
operator|(
operator|(
name|offx
operator|<
literal|0
operator|)
operator|&
operator|(
name|l_offx
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|gdouble
name|grad1
decl_stmt|,
name|grad2
decl_stmt|;
if|if
condition|(
name|ABS
argument_list|(
name|offy
argument_list|)
operator|<
name|ABS
argument_list|(
name|offx
argument_list|)
condition|)
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offy
operator|/
operator|(
name|gdouble
operator|)
name|offx
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offy
operator|/
operator|(
name|gdouble
operator|)
name|l_offx
expr_stmt|;
block|}
else|else
block|{
name|grad1
operator|=
operator|(
name|gdouble
operator|)
name|offx
operator|/
operator|(
name|gdouble
operator|)
name|offy
expr_stmt|;
name|grad2
operator|=
operator|(
name|gdouble
operator|)
name|l_offx
operator|/
operator|(
name|gdouble
operator|)
name|l_offy
expr_stmt|;
block|}
comment|/* printf ("error: %f / %f\n", ABS (grad1 - grad2), error); */
return|return
name|ABS
argument_list|(
name|grad1
operator|-
name|grad2
argument_list|)
operator|<=
name|error
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points_aux (GdkPoint * points,gint start,gint end,gdouble error,BezierRenderPnts * rpnts)
name|bezier_stack_points_aux
parameter_list|(
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|start
parameter_list|,
name|gint
name|end
parameter_list|,
name|gdouble
name|error
parameter_list|,
name|BezierRenderPnts
modifier|*
name|rpnts
parameter_list|)
block|{
specifier|const
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|med
decl_stmt|;
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|,
name|l_offx
decl_stmt|,
name|l_offy
decl_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
return|return;
comment|/* BASE CASE: stack the end point */
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|==
name|points
index|[
name|end
index|]
operator|.
name|y
operator|)
condition|)
return|return;
name|rpnts
operator|->
name|num_stroke_points
operator|++
expr_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|len_stroke_points
operator|<=
name|rpnts
operator|->
name|num_stroke_points
condition|)
block|{
name|rpnts
operator|->
name|len_stroke_points
operator|+=
name|expand_size
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|g_renew
argument_list|(
name|double
argument_list|,
name|rpnts
operator|->
name|stroke_points
argument_list|,
literal|2
operator|*
name|rpnts
operator|->
name|len_stroke_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
block|{
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
index|[
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
operator|-
name|start
operator|<=
literal|32
condition|)
block|{
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, check whether to divide the segment recursively */
name|offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
name|med
operator|=
operator|(
name|end
operator|+
name|start
operator|)
operator|/
literal|2
expr_stmt|;
name|l_offx
operator|=
name|points
index|[
name|med
index|]
operator|.
name|x
operator|-
name|points
index|[
name|start
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|med
index|]
operator|.
name|y
operator|-
name|points
index|[
name|start
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
name|l_offx
operator|=
name|points
index|[
name|end
index|]
operator|.
name|x
operator|-
name|points
index|[
name|med
index|]
operator|.
name|x
expr_stmt|;
name|l_offy
operator|=
name|points
index|[
name|end
index|]
operator|.
name|y
operator|-
name|points
index|[
name|med
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|stroke_interpolatable
argument_list|(
name|offx
argument_list|,
name|offy
argument_list|,
name|l_offx
argument_list|,
name|l_offy
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|start
argument_list|,
name|med
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|med
argument_list|,
name|end
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, the curve can be represented by a points pair: (start, end).      So, add the last point to stroke_points. */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
name|end
argument_list|,
name|end
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_stack_points (GimpBezierSelectTool * bezier_sel,GdkPoint * points,gint n_points,gpointer data)
name|bezier_stack_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GdkPoint
modifier|*
name|points
parameter_list|,
name|gint
name|n_points
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|BezierRenderPnts
modifier|*
name|rpnts
init|=
name|data
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|expand_size
init|=
literal|32
decl_stmt|;
name|gint
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|gdouble
name|error
decl_stmt|;
if|if
condition|(
name|n_points
operator|<
literal|2
condition|)
comment|/* Does this happen? */
return|return;
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
operator|==
name|NULL
condition|)
comment|/*  initialize it here */
block|{
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|expand_size
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
literal|2
operator|*
name|rpnts
operator|->
name|len_stroke_points
argument_list|)
expr_stmt|;
block|}
name|maxx
operator|=
name|minx
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|maxy
operator|=
name|miny
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_points
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxx
operator|<
name|points
index|[
name|i
index|]
operator|.
name|x
condition|)
name|maxx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|maxy
operator|<
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
name|maxy
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* allow one pixel fluctuation */
name|error
operator|=
literal|2.0
operator|/
name|MAX
argument_list|(
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0.0
expr_stmt|;
comment|/* ALT */
comment|/* add the start point */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
comment|/* divide segments recursively */
name|bezier_stack_points_aux
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|n_points
operator|-
literal|1
argument_list|,
name|error
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
comment|/* printf ("n_points: %d\n", n_points); */
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|bezier_gen_points (GimpBezierSelectTool * bezier_sel,gint open_path,BezierRenderPnts * rpnts)
name|bezier_gen_points
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|open_path
parameter_list|,
name|BezierRenderPnts
modifier|*
name|rpnts
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|next_rpnts
init|=
name|rpnts
decl_stmt|;
name|gint
name|point_counts
init|=
literal|0
decl_stmt|;
comment|/* stack points */
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
name|point_counts
operator|=
name|count_points_on_curve
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_counts
operator|<
literal|4
condition|)
return|return
name|TRUE
return|;
do|do
block|{
name|bezier_draw_segment
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|AA_IMAGE_COORDS
argument_list|,
name|bezier_stack_points
argument_list|,
operator|(
name|gpointer
operator|)
name|next_rpnts
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
if|if
condition|(
name|next_curve
condition|)
block|{
name|next_rpnts
operator|->
name|next_curve
operator|=
name|g_new0
argument_list|(
name|BezierRenderPnts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_rpnts
operator|=
name|next_rpnts
operator|->
name|next_curve
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
DECL|function|bezier_stroke (GimpBezierSelectTool * bezier_sel,GDisplay * gdisp,gint subdivisions,gint open_path)
name|bezier_stroke
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GDisplay
modifier|*
name|gdisp
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|gint
name|open_path
parameter_list|)
block|{
name|Argument
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|next_rpnts
decl_stmt|;
name|BezierRenderPnts
modifier|*
name|rpnts
decl_stmt|;
name|rpnts
operator|=
name|g_new0
argument_list|(
name|BezierRenderPnts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  Start an undo group  */
name|undo_push_group_start
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|,
name|PAINT_CORE_UNDO
argument_list|)
expr_stmt|;
name|bezier_gen_points
argument_list|(
name|bezier_sel
argument_list|,
name|open_path
argument_list|,
name|rpnts
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rpnts
operator|->
name|stroke_points
condition|)
block|{
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|gdouble
modifier|*
name|ptr
decl_stmt|;
name|drawable
operator|=
name|gimp_image_active_drawable
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|rpnts
operator|->
name|stroke_points
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|rpnts
operator|->
name|stroke_points
operator|+
operator|(
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
operator|)
condition|)
block|{
operator|*
name|ptr
operator|/=
name|SUPERSAMPLE
expr_stmt|;
operator|*
name|ptr
operator|++
operator|-=
name|offset_x
expr_stmt|;
operator|*
name|ptr
operator|/=
name|SUPERSAMPLE
expr_stmt|;
operator|*
name|ptr
operator|++
operator|-=
name|offset_y
expr_stmt|;
block|}
comment|/* Stroke with the correct tool */
name|return_vals
operator|=
name|procedural_db_run_proc
argument_list|(
name|tool_manager_active_get_PDB_string
argument_list|()
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PDB_DRAWABLE
argument_list|,
name|gimp_drawable_get_ID
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|PDB_INT32
argument_list|,
operator|(
name|gint32
operator|)
name|rpnts
operator|->
name|num_stroke_points
operator|*
literal|2
argument_list|,
name|PDB_FLOATARRAY
argument_list|,
name|rpnts
operator|->
name|stroke_points
argument_list|,
name|PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
operator|&&
name|return_vals
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|!=
name|PDB_SUCCESS
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Paintbrush operation failed."
argument_list|)
argument_list|)
expr_stmt|;
name|procedural_db_destroy_args
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|rpnts
operator|->
name|stroke_points
argument_list|)
expr_stmt|;
block|}
name|next_rpnts
operator|=
name|rpnts
operator|->
name|next_curve
expr_stmt|;
name|rpnts
operator|->
name|stroke_points
operator|=
name|NULL
expr_stmt|;
name|rpnts
operator|->
name|len_stroke_points
operator|=
name|rpnts
operator|->
name|num_stroke_points
operator|=
literal|0
expr_stmt|;
name|g_free
argument_list|(
name|rpnts
argument_list|)
expr_stmt|;
name|rpnts
operator|=
name|next_rpnts
expr_stmt|;
block|}
do|while
condition|(
name|rpnts
condition|)
do|;
comment|/*  End an undo group  */
name|undo_push_group_end
argument_list|(
name|gdisp
operator|->
name|gimage
argument_list|)
expr_stmt|;
name|gdisplays_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_segment_for_distance (GimpBezierSelectTool * bezier_sel,GimpBezierSelectPoint * points,gint subdivisions,BezierDistance * bdist)
name|bezier_draw_segment_for_distance
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|GimpBezierSelectPoint
modifier|*
name|points
parameter_list|,
name|gint
name|subdivisions
parameter_list|,
name|BezierDistance
modifier|*
name|bdist
parameter_list|)
block|{
name|BezierMatrix
name|geometry
decl_stmt|;
name|BezierMatrix
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|BezierMatrix
name|deltas
decl_stmt|;
name|gdouble
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|dx2
decl_stmt|,
name|dx3
decl_stmt|;
name|gdouble
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|dy2
decl_stmt|,
name|dy3
decl_stmt|;
name|gdouble
name|d
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* construct the geometry matrix from the segment */
comment|/* assumes that a valid segment containing 4 points is passed in */
if|if
condition|(
name|bdist
operator|->
name|found
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|points
condition|)
name|gimp_fatal_error
argument_list|(
literal|"bezier_draw_segment_for_distance(): Bad bezier segment"
argument_list|)
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|geometry
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|points
operator|->
name|next
expr_stmt|;
block|}
comment|/* subdivide the curve n times */
comment|/* n can be adjusted to give a finer or coarser curve */
name|d
operator|=
literal|1.0
operator|/
name|subdivisions
expr_stmt|;
name|d2
operator|=
name|d
operator|*
name|d
expr_stmt|;
name|d3
operator|=
name|d
operator|*
name|d
operator|*
name|d
expr_stmt|;
comment|/* construct a temporary matrix for determining the forward diffencing deltas */
name|tmp2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|d3
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|d2
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|tmp2
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|d2
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|6
operator|*
name|d3
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp2
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compose the basis and geometry matrices */
name|bezier_compose
argument_list|(
name|basis
argument_list|,
name|geometry
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* compose the above results to get the deltas matrix */
name|bezier_compose
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
comment|/* extract the x deltas */
name|x
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* extract the y deltas */
name|y
operator|=
name|deltas
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy
operator|=
name|deltas
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy2
operator|=
name|deltas
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dy3
operator|=
name|deltas
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* loop over the curve */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdivisions
condition|;
name|i
operator|++
control|)
block|{
comment|/* increment the x values */
name|x
operator|+=
name|dx
expr_stmt|;
name|dx
operator|+=
name|dx2
expr_stmt|;
name|dx2
operator|+=
name|dx3
expr_stmt|;
comment|/* increment the y values */
name|y
operator|+=
name|dy
expr_stmt|;
name|dy
operator|+=
name|dy2
expr_stmt|;
name|dy2
operator|+=
name|dy3
expr_stmt|;
comment|/*       g_print ("x = %g, y = %g\n",x,y); */
comment|/* if this point is different than the last one...then draw it */
comment|/* Note :        * It assumes the data is the place we want the         * floating version of the coords to be stuffed.        * These are needed when we calculate the gradient of the         * curve.        */
if|if
condition|(
operator|!
name|bdist
operator|->
name|firstpnt
condition|)
block|{
name|gdouble
name|rx
init|=
name|x
decl_stmt|;
name|gdouble
name|ry
init|=
name|y
decl_stmt|;
name|gdouble
name|dx
init|=
name|bdist
operator|->
name|lastx
operator|-
name|rx
decl_stmt|;
name|gdouble
name|dy
init|=
name|bdist
operator|->
name|lasty
operator|-
name|ry
decl_stmt|;
name|bdist
operator|->
name|curdist
operator|+=
name|sqrt
argument_list|(
operator|(
name|dx
operator|*
name|dx
operator|)
operator|+
operator|(
name|dy
operator|*
name|dy
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdist
operator|->
name|curdist
operator|>=
name|bdist
operator|->
name|dist
condition|)
block|{
operator|*
operator|(
name|bdist
operator|->
name|x
operator|)
operator|=
name|ROUND
argument_list|(
operator|(
name|rx
operator|+
name|dx
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bdist
operator|->
name|y
operator|)
operator|=
name|ROUND
argument_list|(
operator|(
name|ry
operator|+
name|dy
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0.0
condition|)
operator|*
operator|(
name|bdist
operator|->
name|gradient
operator|)
operator|=
name|G_MAXDOUBLE
expr_stmt|;
else|else
operator|*
operator|(
name|bdist
operator|->
name|gradient
operator|)
operator|=
name|dy
operator|/
name|dx
expr_stmt|;
comment|/* 	      g_print ("found x = %d, y = %d\n",*(bdist->x),*(bdist->y)); */
name|bdist
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|bdist
operator|->
name|lastx
operator|=
name|rx
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
name|ry
expr_stmt|;
block|}
else|else
block|{
name|bdist
operator|->
name|firstpnt
operator|=
name|FALSE
expr_stmt|;
name|bdist
operator|->
name|lastx
operator|=
name|x
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
name|y
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bezier_draw_curve_for_distance (GimpBezierSelectTool * bezier_sel,BezierDistance * distance)
name|bezier_draw_curve_for_distance
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|BezierDistance
modifier|*
name|distance
parameter_list|)
block|{
name|GimpBezierSelectPoint
modifier|*
name|points
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|start_pt
decl_stmt|;
name|GimpBezierSelectPoint
modifier|*
name|next_curve
decl_stmt|;
name|points
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
name|start_pt
operator|=
name|bezier_sel
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|bezier_sel
operator|->
name|num_points
operator|>=
literal|4
condition|)
block|{
do|do
block|{
do|do
block|{
name|bezier_draw_segment_for_distance
argument_list|(
name|bezier_sel
argument_list|,
name|points
argument_list|,
name|SUBDIVIDE
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|points
operator|=
name|next_anchor
argument_list|(
name|points
argument_list|,
operator|&
name|next_curve
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|points
operator|!=
name|start_pt
operator|&&
name|points
condition|)
do|;
name|start_pt
operator|=
name|next_curve
expr_stmt|;
name|points
operator|=
name|next_curve
expr_stmt|;
block|}
do|while
condition|(
name|next_curve
condition|)
do|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|bezier_distance_along (GimpBezierSelectTool * bezier_sel,gint open_path,gdouble dist,gint * x,gint * y,gdouble * gradient)
name|bezier_distance_along
parameter_list|(
name|GimpBezierSelectTool
modifier|*
name|bezier_sel
parameter_list|,
name|gint
name|open_path
parameter_list|,
name|gdouble
name|dist
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gdouble
modifier|*
name|gradient
parameter_list|)
block|{
comment|/* Render the curve as points then walk along it... */
name|BezierDistance
modifier|*
name|bdist
decl_stmt|;
name|gint
name|ret
decl_stmt|;
name|bdist
operator|=
name|g_new0
argument_list|(
name|BezierDistance
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bdist
operator|->
name|firstpnt
operator|=
name|TRUE
expr_stmt|;
name|bdist
operator|->
name|curdist
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|lastx
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|lasty
operator|=
literal|0.0
expr_stmt|;
name|bdist
operator|->
name|dist
operator|=
name|dist
expr_stmt|;
name|bdist
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|bdist
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|bdist
operator|->
name|gradient
operator|=
name|gradient
expr_stmt|;
name|bdist
operator|->
name|found
operator|=
name|FALSE
expr_stmt|;
name|bezier_draw_curve_for_distance
argument_list|(
name|bezier_sel
argument_list|,
name|bdist
argument_list|)
expr_stmt|;
name|ret
operator|=
name|bdist
operator|->
name|found
expr_stmt|;
name|g_free
argument_list|(
name|bdist
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

