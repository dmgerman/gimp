begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"gimpbrushlist.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"paint_core.h"
end_include

begin_include
include|#
directive|include
file|"patterns.h"
end_include

begin_include
include|#
directive|include
file|"clone.h"
end_include

begin_include
include|#
directive|include
file|"selection.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_define
DECL|macro|TARGET_HEIGHT
define|#
directive|define
name|TARGET_HEIGHT
value|15
end_define

begin_define
DECL|macro|TARGET_WIDTH
define|#
directive|define
name|TARGET_WIDTH
value|15
end_define

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon29793d7f0103
block|{
DECL|enumerator|ImageClone
name|ImageClone
block|,
DECL|enumerator|PatternClone
name|PatternClone
DECL|typedef|CloneType
block|}
name|CloneType
typedef|;
end_typedef

begin_comment
comment|/*  forward function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|clone_draw
parameter_list|(
name|Tool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clone_motion
parameter_list|(
name|PaintCore
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|CloneType
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clone_line_image
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|GImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clone_line_pattern
parameter_list|(
name|GImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|GPatternP
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|clone_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|non_gui_src_drawable
specifier|static
name|GimpDrawable
modifier|*
name|non_gui_src_drawable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|non_gui_offset_x
specifier|static
name|int
name|non_gui_offset_x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|non_gui_offset_y
specifier|static
name|int
name|non_gui_offset_y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|non_gui_type
specifier|static
name|CloneType
name|non_gui_type
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|typedef|CloneOptions
typedef|typedef
name|struct
name|_CloneOptions
name|CloneOptions
typedef|;
end_typedef

begin_struct
DECL|struct|_CloneOptions
struct|struct
name|_CloneOptions
block|{
DECL|member|type
name|CloneType
name|type
decl_stmt|;
DECL|member|aligned
name|int
name|aligned
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  local variables  */
end_comment

begin_decl_stmt
DECL|variable|src_x
specifier|static
name|int
name|src_x
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|src_x
comment|/*                         */
end_comment

begin_decl_stmt
DECL|variable|src_y
specifier|static
name|int
name|src_y
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|src_y
comment|/*  position of clone src  */
end_comment

begin_decl_stmt
DECL|variable|dest_x
specifier|static
name|int
name|dest_x
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|dest_x
comment|/*                         */
end_comment

begin_decl_stmt
DECL|variable|dest_y
specifier|static
name|int
name|dest_y
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|dest_y
comment|/*  position of clone src  */
end_comment

begin_decl_stmt
DECL|variable|offset_x
specifier|static
name|int
name|offset_x
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|offset_x
comment|/*                         */
end_comment

begin_decl_stmt
DECL|variable|offset_y
specifier|static
name|int
name|offset_y
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|offset_y
comment|/*  offset for cloning     */
end_comment

begin_decl_stmt
DECL|variable|first
specifier|static
name|int
name|first
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|trans_tx
DECL|variable|trans_ty
specifier|static
name|int
name|trans_tx
decl_stmt|,
name|trans_ty
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|trans_tx
DECL|variable|trans_ty
comment|/*  transformed target  */
end_comment

begin_decl_stmt
DECL|variable|the_src_gdisp
specifier|static
name|GDisplay
modifier|*
name|the_src_gdisp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|the_src_gdisp
comment|/*  ID of source gdisplay  */
end_comment

begin_decl_stmt
DECL|variable|src_drawable_
specifier|static
name|GimpDrawable
modifier|*
name|src_drawable_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|src_drawable_
comment|/*  source drawable */
end_comment

begin_decl_stmt
DECL|variable|clone_options
specifier|static
name|CloneOptions
modifier|*
name|clone_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|clone_toggle_update (GtkWidget * widget,gpointer data)
name|clone_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_type_callback (GtkWidget * w,gpointer client_data)
name|clone_type_callback
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|client_data
parameter_list|)
block|{
name|clone_options
operator|->
name|type
operator|=
operator|(
name|CloneType
operator|)
name|client_data
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CloneOptions
modifier|*
DECL|function|create_clone_options (void)
name|create_clone_options
parameter_list|(
name|void
parameter_list|)
block|{
name|CloneOptions
modifier|*
name|options
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|aligned_toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_frame
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_box
decl_stmt|;
name|GtkWidget
modifier|*
name|radio_button
decl_stmt|;
name|GSList
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|button_names
index|[
literal|2
index|]
init|=
block|{
literal|"Image Source"
block|,
literal|"Pattern Source"
block|}
decl_stmt|;
comment|/*  the new options structure  */
name|options
operator|=
operator|(
name|CloneOptions
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CloneOptions
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|->
name|type
operator|=
name|ImageClone
expr_stmt|;
name|options
operator|->
name|aligned
operator|=
name|TRUE
expr_stmt|;
comment|/*  the main vbox  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  the main label  */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Clone Tool Options"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/*  the radio frame and box  */
name|radio_frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Source"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|radio_frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|radio_box
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|radio_frame
argument_list|)
argument_list|,
name|radio_box
argument_list|)
expr_stmt|;
comment|/*  the radio buttons  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|radio_button
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|group
argument_list|,
name|button_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|radio_button
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|radio_button
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|clone_type_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|radio_box
argument_list|)
argument_list|,
name|radio_button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|radio_button
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|radio_box
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|radio_frame
argument_list|)
expr_stmt|;
comment|/*  the aligned toggle button  */
name|aligned_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Aligned"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|aligned_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|aligned_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|clone_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|aligned
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|aligned_toggle
argument_list|)
argument_list|,
name|options
operator|->
name|aligned
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|aligned_toggle
argument_list|)
expr_stmt|;
comment|/*  Register this selection options widget with the main tools options dialog  */
name|tools_register_options
argument_list|(
name|CLONE
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
name|void
modifier|*
DECL|function|clone_paint_func (PaintCore * paint_core,GimpDrawable * drawable,int state)
name|clone_paint_func
parameter_list|(
name|PaintCore
modifier|*
name|paint_core
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|GDisplay
modifier|*
name|gdisp
decl_stmt|;
name|GDisplay
modifier|*
name|src_gdisp
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gdisp
operator|=
operator|(
name|GDisplay
operator|*
operator|)
name|active_tool
operator|->
name|gdisp_ptr
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MOTION_PAINT
case|:
name|x1
operator|=
name|paint_core
operator|->
name|curx
expr_stmt|;
name|y1
operator|=
name|paint_core
operator|->
name|cury
expr_stmt|;
name|x2
operator|=
name|paint_core
operator|->
name|lastx
expr_stmt|;
name|y2
operator|=
name|paint_core
operator|->
name|lasty
expr_stmt|;
comment|/*  If the control key is down, move the src target and return */
if|if
condition|(
name|paint_core
operator|->
name|state
operator|&
name|ControlMask
condition|)
block|{
name|src_x
operator|=
name|x1
expr_stmt|;
name|src_y
operator|=
name|y1
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*  otherwise, update the target  */
else|else
block|{
name|dest_x
operator|=
name|x1
expr_stmt|;
name|dest_y
operator|=
name|y1
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|offset_x
operator|=
name|src_x
operator|-
name|dest_x
expr_stmt|;
name|offset_y
operator|=
name|src_y
operator|-
name|dest_y
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|src_x
operator|=
name|dest_x
operator|+
name|offset_x
expr_stmt|;
name|src_y
operator|=
name|dest_y
operator|+
name|offset_y
expr_stmt|;
block|}
name|clone_motion
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|src_drawable_
argument_list|,
name|clone_options
operator|->
name|type
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
name|draw_core_pause
argument_list|(
name|paint_core
operator|->
name|core
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_PAINT
case|:
if|if
condition|(
name|paint_core
operator|->
name|state
operator|&
name|ControlMask
condition|)
block|{
name|the_src_gdisp
operator|=
name|gdisp
expr_stmt|;
name|src_drawable_
operator|=
name|drawable
expr_stmt|;
name|src_x
operator|=
name|paint_core
operator|->
name|curx
expr_stmt|;
name|src_y
operator|=
name|paint_core
operator|->
name|cury
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clone_options
operator|->
name|aligned
operator|==
name|FALSE
condition|)
name|first
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|clone_options
operator|->
name|type
operator|==
name|PatternClone
condition|)
if|if
condition|(
operator|!
name|get_active_pattern
argument_list|()
condition|)
name|g_message
argument_list|(
literal|"No patterns available for this operation."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINISH_PAINT
case|:
name|draw_core_stop
argument_list|(
name|paint_core
operator|->
name|core
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
break|break;
default|default :
break|break;
block|}
comment|/*  Calculate the coordinates of the target  */
name|src_gdisp
operator|=
name|the_src_gdisp
expr_stmt|;
if|if
condition|(
operator|!
name|src_gdisp
condition|)
block|{
name|the_src_gdisp
operator|=
name|gdisp
expr_stmt|;
name|src_gdisp
operator|=
name|the_src_gdisp
expr_stmt|;
block|}
comment|/*  Find the target cursor's location onscreen  */
name|gdisplay_transform_coords
argument_list|(
name|src_gdisp
argument_list|,
name|src_x
argument_list|,
name|src_y
argument_list|,
operator|&
name|trans_tx
argument_list|,
operator|&
name|trans_ty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|INIT_PAINT
condition|)
comment|/*  Initialize the tool drawing core  */
name|draw_core_start
argument_list|(
name|paint_core
operator|->
name|core
argument_list|,
name|src_gdisp
operator|->
name|canvas
operator|->
name|window
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|MOTION_PAINT
condition|)
name|draw_core_resume
argument_list|(
name|paint_core
operator|->
name|core
argument_list|,
name|active_tool
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_clone ()
name|tools_new_clone
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|PaintCore
modifier|*
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|clone_options
condition|)
name|clone_options
operator|=
name|create_clone_options
argument_list|()
expr_stmt|;
name|tool
operator|=
name|paint_core_new
argument_list|(
name|CLONE
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
name|PaintCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|private
operator|->
name|paint_func
operator|=
name|clone_paint_func
expr_stmt|;
name|private
operator|->
name|core
operator|->
name|draw_func
operator|=
name|clone_draw
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_clone (Tool * tool)
name|tools_free_clone
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|paint_core_free
argument_list|(
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_draw (Tool * tool)
name|clone_draw
parameter_list|(
name|Tool
modifier|*
name|tool
parameter_list|)
block|{
name|PaintCore
modifier|*
name|paint_core
decl_stmt|;
name|paint_core
operator|=
operator|(
name|PaintCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|clone_options
operator|->
name|type
operator|==
name|ImageClone
condition|)
block|{
name|gdk_draw_line
argument_list|(
name|paint_core
operator|->
name|core
operator|->
name|win
argument_list|,
name|paint_core
operator|->
name|core
operator|->
name|gc
argument_list|,
name|trans_tx
operator|-
operator|(
name|TARGET_WIDTH
operator|>>
literal|1
operator|)
argument_list|,
name|trans_ty
argument_list|,
name|trans_tx
operator|+
operator|(
name|TARGET_WIDTH
operator|>>
literal|1
operator|)
argument_list|,
name|trans_ty
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|paint_core
operator|->
name|core
operator|->
name|win
argument_list|,
name|paint_core
operator|->
name|core
operator|->
name|gc
argument_list|,
name|trans_tx
argument_list|,
name|trans_ty
operator|-
operator|(
name|TARGET_HEIGHT
operator|>>
literal|1
operator|)
argument_list|,
name|trans_tx
argument_list|,
name|trans_ty
operator|+
operator|(
name|TARGET_HEIGHT
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_motion (PaintCore * paint_core,GimpDrawable * drawable,GimpDrawable * src_drawable,CloneType type,int offset_x,int offset_y)
name|clone_motion
parameter_list|(
name|PaintCore
modifier|*
name|paint_core
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpDrawable
modifier|*
name|src_drawable
parameter_list|,
name|CloneType
name|type
parameter_list|,
name|int
name|offset_x
parameter_list|,
name|int
name|offset_y
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GImage
modifier|*
name|src_gimage
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|TempBuf
modifier|*
name|orig
decl_stmt|;
name|TempBuf
modifier|*
name|area
decl_stmt|;
name|void
modifier|*
name|pr
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|has_alpha
decl_stmt|;
name|PixelRegion
name|srcPR
decl_stmt|,
name|destPR
decl_stmt|;
name|GPatternP
name|pattern
decl_stmt|;
name|pr
operator|=
name|NULL
expr_stmt|;
name|pattern
operator|=
name|NULL
expr_stmt|;
comment|/*  Make sure we still have a source!  */
if|if
condition|(
operator|!
name|src_drawable
operator|||
operator|(
operator|!
operator|(
name|src_gimage
operator|=
name|drawable_gimage
argument_list|(
name|src_drawable
argument_list|)
operator|)
operator|&&
name|type
operator|==
name|ImageClone
operator|)
operator|||
operator|!
operator|(
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"Select source image before cloning"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  Get a region which can be used to paint to  */
if|if
condition|(
operator|!
operator|(
name|area
operator|=
name|paint_core_get_paint_area
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|)
operator|)
condition|)
return|return;
comment|/*  Determine whether the source image has an alpha channel  */
name|has_alpha
operator|=
name|drawable_has_alpha
argument_list|(
name|src_drawable
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ImageClone
case|:
comment|/*  Set the paint area to transparent  */
name|memset
argument_list|(
name|temp_buf_data
argument_list|(
name|area
argument_list|)
argument_list|,
literal|0
argument_list|,
name|area
operator|->
name|width
operator|*
name|area
operator|->
name|height
operator|*
name|area
operator|->
name|bytes
argument_list|)
expr_stmt|;
comment|/*  If the source gimage is different from the destination,        *  then we should copy straight from the destination image        *  to the canvas.        *  Otherwise, we need a call to get_orig_image to make sure        *  we get a copy of the unblemished (offset) image        */
if|if
condition|(
name|src_drawable
operator|!=
name|drawable
condition|)
block|{
name|x1
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|x
operator|+
name|offset_x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|src_drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|y
operator|+
name|offset_y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|src_drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|x
operator|+
name|offset_x
operator|+
name|area
operator|->
name|width
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|src_drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|y
operator|+
name|offset_y
operator|+
name|area
operator|->
name|height
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|src_drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x2
operator|-
name|x1
operator|)
operator|||
operator|!
operator|(
name|y2
operator|-
name|y1
operator|)
condition|)
return|return;
name|pixel_region_init
argument_list|(
operator|&
name|srcPR
argument_list|,
name|drawable_data
argument_list|(
name|src_drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|x
operator|+
name|offset_x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|y
operator|+
name|offset_y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|x
operator|+
name|offset_x
operator|+
name|area
operator|->
name|width
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BOUNDS
argument_list|(
name|area
operator|->
name|y
operator|+
name|offset_y
operator|+
name|area
operator|->
name|height
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x2
operator|-
name|x1
operator|)
operator|||
operator|!
operator|(
name|y2
operator|-
name|y1
operator|)
condition|)
return|return;
comment|/*  get the original image  */
name|orig
operator|=
name|paint_core_get_orig_image
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|srcPR
operator|.
name|bytes
operator|=
name|orig
operator|->
name|bytes
expr_stmt|;
name|srcPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|srcPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|srcPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|srcPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|srcPR
operator|.
name|rowstride
operator|=
name|srcPR
operator|.
name|bytes
operator|*
name|orig
operator|->
name|width
expr_stmt|;
name|srcPR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
name|offset_x
operator|=
name|x1
operator|-
operator|(
name|area
operator|->
name|x
operator|+
name|offset_x
operator|)
expr_stmt|;
name|offset_y
operator|=
name|y1
operator|-
operator|(
name|area
operator|->
name|y
operator|+
name|offset_y
operator|)
expr_stmt|;
comment|/*  configure the destination  */
name|destPR
operator|.
name|bytes
operator|=
name|area
operator|->
name|bytes
expr_stmt|;
name|destPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|destPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|destPR
operator|.
name|w
operator|=
name|srcPR
operator|.
name|w
expr_stmt|;
name|destPR
operator|.
name|h
operator|=
name|srcPR
operator|.
name|h
expr_stmt|;
name|destPR
operator|.
name|rowstride
operator|=
name|destPR
operator|.
name|bytes
operator|*
name|area
operator|->
name|width
expr_stmt|;
name|destPR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|area
argument_list|)
operator|+
name|offset_y
operator|*
name|destPR
operator|.
name|rowstride
operator|+
name|offset_x
operator|*
name|destPR
operator|.
name|bytes
expr_stmt|;
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|2
argument_list|,
operator|&
name|srcPR
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|PatternClone
case|:
name|pattern
operator|=
name|get_active_pattern
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return;
name|destPR
operator|.
name|bytes
operator|=
name|area
operator|->
name|bytes
expr_stmt|;
name|destPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|destPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|destPR
operator|.
name|w
operator|=
name|area
operator|->
name|width
expr_stmt|;
name|destPR
operator|.
name|h
operator|=
name|area
operator|->
name|height
expr_stmt|;
name|destPR
operator|.
name|rowstride
operator|=
name|destPR
operator|.
name|bytes
operator|*
name|area
operator|->
name|width
expr_stmt|;
name|destPR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|pr
operator|=
name|pixel_regions_register
argument_list|(
literal|1
argument_list|,
operator|&
name|destPR
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pixel_regions_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|s
operator|=
name|srcPR
operator|.
name|data
expr_stmt|;
name|d
operator|=
name|destPR
operator|.
name|data
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|destPR
operator|.
name|h
condition|;
name|y
operator|++
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ImageClone
case|:
name|clone_line_image
argument_list|(
name|gimage
argument_list|,
name|src_gimage
argument_list|,
name|drawable
argument_list|,
name|src_drawable
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|has_alpha
argument_list|,
name|srcPR
operator|.
name|bytes
argument_list|,
name|destPR
operator|.
name|bytes
argument_list|,
name|destPR
operator|.
name|w
argument_list|)
expr_stmt|;
name|s
operator|+=
name|srcPR
operator|.
name|rowstride
expr_stmt|;
break|break;
case|case
name|PatternClone
case|:
name|clone_line_pattern
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pattern
argument_list|,
name|d
argument_list|,
name|area
operator|->
name|x
operator|+
name|offset_x
argument_list|,
name|area
operator|->
name|y
operator|+
name|y
operator|+
name|offset_y
argument_list|,
name|destPR
operator|.
name|bytes
argument_list|,
name|destPR
operator|.
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|+=
name|destPR
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
comment|/*  paste the newly painted canvas to the gimage which is being worked on  */
name|paint_core_paste_canvas
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
call|(
name|int
call|)
argument_list|(
name|gimp_brush_get_opacity
argument_list|()
operator|*
literal|255
argument_list|)
argument_list|,
name|gimp_brush_get_paint_mode
argument_list|()
argument_list|,
name|SOFT
argument_list|,
name|CONSTANT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_line_image (GImage * dest,GImage * src,GimpDrawable * d_drawable,GimpDrawable * s_drawable,unsigned char * s,unsigned char * d,int has_alpha,int src_bytes,int dest_bytes,int width)
name|clone_line_image
parameter_list|(
name|GImage
modifier|*
name|dest
parameter_list|,
name|GImage
modifier|*
name|src
parameter_list|,
name|GimpDrawable
modifier|*
name|d_drawable
parameter_list|,
name|GimpDrawable
modifier|*
name|s_drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|has_alpha
parameter_list|,
name|int
name|src_bytes
parameter_list|,
name|int
name|dest_bytes
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|unsigned
name|char
name|rgb
index|[
literal|3
index|]
decl_stmt|;
name|int
name|src_alpha
decl_stmt|,
name|dest_alpha
decl_stmt|;
name|src_alpha
operator|=
name|src_bytes
operator|-
literal|1
expr_stmt|;
name|dest_alpha
operator|=
name|dest_bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
name|gimage_get_color
argument_list|(
name|src
argument_list|,
name|drawable_type
argument_list|(
name|s_drawable
argument_list|)
argument_list|,
name|rgb
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|gimage_transform_color
argument_list|(
name|dest
argument_list|,
name|d_drawable
argument_list|,
name|rgb
argument_list|,
name|d
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha
condition|)
name|d
index|[
name|dest_alpha
index|]
operator|=
name|s
index|[
name|src_alpha
index|]
expr_stmt|;
else|else
name|d
index|[
name|dest_alpha
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
name|s
operator|+=
name|src_bytes
expr_stmt|;
name|d
operator|+=
name|dest_bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_line_pattern (GImage * dest,GimpDrawable * drawable,GPatternP pattern,unsigned char * d,int x,int y,int bytes,int width)
name|clone_line_pattern
parameter_list|(
name|GImage
modifier|*
name|dest
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GPatternP
name|pattern
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|bytes
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pat
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|color
decl_stmt|,
name|alpha
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  Make sure x, y are positive  */
while|while
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|+=
name|pattern
operator|->
name|mask
operator|->
name|width
expr_stmt|;
while|while
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|+=
name|pattern
operator|->
name|mask
operator|->
name|height
expr_stmt|;
comment|/*  Get a pointer to the appropriate scanline of the pattern buffer  */
name|pat
operator|=
name|temp_buf_data
argument_list|(
name|pattern
operator|->
name|mask
argument_list|)
operator|+
operator|(
name|y
operator|%
name|pattern
operator|->
name|mask
operator|->
name|height
operator|)
operator|*
name|pattern
operator|->
name|mask
operator|->
name|width
operator|*
name|pattern
operator|->
name|mask
operator|->
name|bytes
expr_stmt|;
name|color
operator|=
operator|(
name|pattern
operator|->
name|mask
operator|->
name|bytes
operator|==
literal|3
operator|)
condition|?
name|RGB
else|:
name|GRAY
expr_stmt|;
name|alpha
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|pat
operator|+
operator|(
operator|(
name|i
operator|+
name|x
operator|)
operator|%
name|pattern
operator|->
name|mask
operator|->
name|width
operator|)
operator|*
name|pattern
operator|->
name|mask
operator|->
name|bytes
expr_stmt|;
name|gimage_transform_color
argument_list|(
name|dest
argument_list|,
name|drawable
argument_list|,
name|p
argument_list|,
name|d
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|d
index|[
name|alpha
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
name|d
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|clone_non_gui_paint_func (PaintCore * paint_core,GimpDrawable * drawable,int state)
name|clone_non_gui_paint_func
parameter_list|(
name|PaintCore
modifier|*
name|paint_core
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|clone_motion
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|non_gui_src_drawable
argument_list|,
name|non_gui_type
argument_list|,
name|non_gui_offset_x
argument_list|,
name|non_gui_offset_y
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  The clone procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|clone_args
name|ProcArg
name|clone_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the drawable"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"src_drawable"
block|,
literal|"the source drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"clone_type"
block|,
literal|"the type of clone: { IMAGE-CLONE (0), PATTERN-CLONE (1) }"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"src_x"
block|,
literal|"the x coordinate in the source image"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"src_y"
block|,
literal|"the y coordinate in the source image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"array of stroke coordinates: {s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y}"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|clone_proc
name|ProcRecord
name|clone_proc
init|=
block|{
literal|"gimp_clone"
block|,
literal|"Clone from the source to the dest drawable using the current brush"
block|,
literal|"This tool clones (copies) from the source drawable starting at the specified source coordinates to the dest drawable.  If the \"clone_type\" argument is set to PATTERN-CLONE, then the current pattern is used as the source and the \"src_drawable\" argument is ignored.  Pattern cloning assumes a tileable pattern and mods the sum of the src coordinates and subsequent stroke offsets with the width and height of the pattern.  For image cloning, if the sum of the src coordinates and subsequent stroke offsets exceeds the extents of the src drawable, then no paint is transferred.  The clone tool is capable of transforming between any image types including RGB->Indexed--although converting from any type to indexed is significantly slower."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|8
block|,
name|clone_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|clone_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|clone_invoker (Argument * args)
name|clone_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpDrawable
modifier|*
name|src_drawable
decl_stmt|;
name|double
name|src_x
decl_stmt|,
name|src_y
decl_stmt|;
name|int
name|num_strokes
decl_stmt|;
name|double
modifier|*
name|stroke_array
decl_stmt|;
name|CloneType
name|int_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|num_strokes
operator|=
literal|0
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
operator|||
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the src drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|src_drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_drawable
operator|==
name|NULL
operator|||
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|src_drawable
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
else|else
name|non_gui_src_drawable
operator|=
name|src_drawable
expr_stmt|;
block|}
comment|/*  the clone type  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
switch|switch
condition|(
name|int_value
condition|)
block|{
case|case
literal|0
case|:
name|non_gui_type
operator|=
name|ImageClone
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|non_gui_type
operator|=
name|PatternClone
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/*  x, y offsets  */
if|if
condition|(
name|success
condition|)
block|{
name|src_x
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
name|src_y
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
block|}
comment|/*  num strokes  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|6
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>
literal|0
condition|)
name|num_strokes
operator|=
name|int_value
operator|/
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  point array  */
if|if
condition|(
name|success
condition|)
name|stroke_array
operator|=
operator|(
name|double
operator|*
operator|)
name|args
index|[
literal|7
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
comment|/*  init the paint core  */
name|success
operator|=
name|paint_core_init
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
name|stroke_array
index|[
literal|0
index|]
argument_list|,
name|stroke_array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/*  set the paint core's paint func  */
name|non_gui_paint_core
operator|.
name|paint_func
operator|=
name|clone_non_gui_paint_func
expr_stmt|;
name|non_gui_paint_core
operator|.
name|startx
operator|=
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|stroke_array
index|[
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|starty
operator|=
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|stroke_array
index|[
literal|1
index|]
expr_stmt|;
name|non_gui_offset_x
operator|=
call|(
name|int
call|)
argument_list|(
name|src_x
operator|-
name|non_gui_paint_core
operator|.
name|startx
argument_list|)
expr_stmt|;
name|non_gui_offset_y
operator|=
call|(
name|int
call|)
argument_list|(
name|src_y
operator|-
name|non_gui_paint_core
operator|.
name|starty
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_strokes
operator|==
literal|1
condition|)
name|clone_non_gui_paint_func
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_strokes
condition|;
name|i
operator|++
control|)
block|{
name|non_gui_paint_core
operator|.
name|curx
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|cury
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|paint_core_interpolate
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|non_gui_paint_core
operator|.
name|curx
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|non_gui_paint_core
operator|.
name|cury
expr_stmt|;
block|}
comment|/*  finish the painting  */
name|paint_core_finish
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  cleanup  */
name|paint_core_cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|clone_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

end_unit

