begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl. */
end_comment

begin_include
include|#
directive|include
file|"procedural_db.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"pathsP.h"
end_include

begin_decl_stmt
DECL|variable|path_list_proc
specifier|static
name|ProcRecord
name|path_list_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_proc
specifier|static
name|ProcRecord
name|path_get_points_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_proc
specifier|static
name|ProcRecord
name|path_get_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_current_proc
specifier|static
name|ProcRecord
name|path_set_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_points_proc
specifier|static
name|ProcRecord
name|path_set_points_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_stroke_current_proc
specifier|static
name|ProcRecord
name|path_stroke_current_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_proc
specifier|static
name|ProcRecord
name|path_get_point_at_dist_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_proc
specifier|static
name|ProcRecord
name|path_get_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_proc
specifier|static
name|ProcRecord
name|get_path_by_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_delete_proc
specifier|static
name|ProcRecord
name|path_delete_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_proc
specifier|static
name|ProcRecord
name|path_get_locked_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_locked_proc
specifier|static
name|ProcRecord
name|path_set_locked_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_tattoo_proc
specifier|static
name|ProcRecord
name|path_set_tattoo_proc
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|register_paths_procs (void)
name|register_paths_procs
parameter_list|(
name|void
parameter_list|)
block|{
name|procedural_db_register
argument_list|(
operator|&
name|path_list_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_get_points_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_get_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_set_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_set_points_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_stroke_current_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_get_point_at_dist_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_get_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|get_path_by_tattoo_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_delete_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_get_locked_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_set_locked_proc
argument_list|)
expr_stmt|;
name|procedural_db_register
argument_list|(
operator|&
name|path_set_tattoo_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_list_invoker (Argument * args)
name|path_list_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|num_paths
init|=
literal|0
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|paths_list
init|=
name|NULL
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|gint
name|count
init|=
literal|0
decl_stmt|;
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
name|num_paths
operator|=
name|g_slist_length
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|paths_list
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
name|num_paths
argument_list|)
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|PATHP
name|pptr
init|=
name|pl
operator|->
name|data
decl_stmt|;
name|paths_list
index|[
name|count
operator|++
index|]
operator|=
name|g_strdup
argument_list|(
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_list_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_paths
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|paths_list
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_list_inargs
specifier|static
name|ProcArg
name|path_list_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list the paths from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_outargs
specifier|static
name|ProcArg
name|path_list_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_paths"
block|,
literal|"The number of paths returned"
block|}
block|,
block|{
name|PDB_STRINGARRAY
block|,
literal|"paths_list"
block|,
literal|"List of the paths belonging to this image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_proc
specifier|static
name|ProcRecord
name|path_list_proc
init|=
block|{
literal|"gimp_path_list"
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|path_list_inargs
block|,
literal|2
block|,
name|path_list_outargs
block|,
block|{
block|{
name|path_list_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_points_invoker (Argument * args)
name|path_get_points_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|num_pdetails
init|=
literal|0
decl_stmt|;
name|gdouble
modifier|*
name|pnts
init|=
name|NULL
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
condition|)
break|break;
comment|/* Found the path */
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
condition|)
block|{
name|GSList
modifier|*
name|points_list
decl_stmt|;
name|gint
name|pcount
init|=
literal|0
decl_stmt|;
name|points_list
operator|=
name|pptr
operator|->
name|path_details
expr_stmt|;
if|if
condition|(
name|points_list
condition|)
block|{
name|num_pdetails
operator|=
name|g_slist_length
argument_list|(
name|points_list
argument_list|)
operator|*
literal|3
expr_stmt|;
name|pnts
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|num_pdetails
argument_list|)
expr_stmt|;
comment|/* fill points and types in */
while|while
condition|(
name|points_list
condition|)
block|{
name|PATHPOINTP
name|ppoint
init|=
name|points_list
operator|->
name|data
decl_stmt|;
name|pnts
index|[
name|pcount
index|]
operator|=
name|ppoint
operator|->
name|x
expr_stmt|;
name|pnts
index|[
name|pcount
operator|+
literal|1
index|]
operator|=
name|ppoint
operator|->
name|y
expr_stmt|;
name|pnts
index|[
name|pcount
operator|+
literal|2
index|]
operator|=
operator|(
name|gfloat
operator|)
name|ppoint
operator|->
name|type
expr_stmt|;
comment|/* Bit of fiddle but should be understandable why it was done */
name|pcount
operator|+=
literal|3
expr_stmt|;
name|points_list
operator|=
name|points_list
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pptr
operator|->
name|pathtype
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pptr
operator|->
name|closed
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_pdetails
expr_stmt|;
name|return_args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|pnts
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_points_inargs
specifier|static
name|ProcArg
name|path_get_points_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list the paths from"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose points should be listed"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_outargs
specifier|static
name|ProcArg
name|path_get_points_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"paths_type"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"path_closed"
block|,
literal|"Return if the path is closed. {0=path open, 1= path closed}"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_path_point_details"
block|,
literal|"The number of points returned. Each point is made up of (x,y,pnt_type) of floats"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 3 floats. The first is the x pos, next is the y pos, last is the type of the pnt. The type field is dependant on the path type. For beziers (type 1 paths) the type can either be {1.0= BEZIER_ANCHOR, 2.0= BEZIER_CONTROL}. Note all points are returned in pixel resolution"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_proc
specifier|static
name|ProcRecord
name|path_get_points_proc
init|=
block|{
literal|"gimp_path_get_points"
block|,
literal|"List the points associated with the named path."
block|,
literal|"List the points associated with the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_get_points_inargs
block|,
literal|4
block|,
name|path_get_points_outargs
block|,
block|{
block|{
name|path_get_points_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_current_invoker (Argument * args)
name|path_get_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
operator|&&
name|plist
operator|->
name|last_selected_row
operator|>=
literal|0
condition|)
name|pptr
operator|=
operator|(
name|PATHP
operator|)
name|g_slist_nth_data
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|,
name|plist
operator|->
name|last_selected_row
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_current_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_current_inargs
specifier|static
name|ProcArg
name|path_get_current_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to get the current paths from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_outargs
specifier|static
name|ProcArg
name|path_get_current_outargs
index|[]
init|=
block|{
block|{
name|PDB_STRING
block|,
literal|"current_path_name"
block|,
literal|"The name of the current path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_proc
specifier|static
name|ProcRecord
name|path_get_current_proc
init|=
block|{
literal|"gimp_path_get_current"
block|,
literal|"The name of the current path. Error if no paths."
block|,
literal|"The name of the current path. Error if no paths."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|path_get_current_inargs
block|,
literal|1
block|,
name|path_get_current_outargs
block|,
block|{
block|{
name|path_get_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_current_invoker (Argument * args)
name|path_set_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|paths_set_path
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_current_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_current_inargs
specifier|static
name|ProcArg
name|path_set_current_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list set the paths in"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"set_current_path_name"
block|,
literal|"The name of the path to set the current path to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_current_proc
specifier|static
name|ProcRecord
name|path_set_current_proc
init|=
block|{
literal|"gimp_path_set_current"
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"List the paths associated with the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_set_current_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_points_invoker (Argument * args)
name|path_set_points_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
init|=
name|NULL
decl_stmt|;
name|gint32
name|ptype
decl_stmt|;
name|gint32
name|numpoints
init|=
literal|0
decl_stmt|;
name|gdouble
modifier|*
name|pnts
decl_stmt|;
name|gboolean
name|pclosed
init|=
name|FALSE
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|ptype
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|numpoints
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|numpoints
operator|<=
literal|0
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pnts
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|(
name|numpoints
operator|/
literal|3
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
name|pclosed
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|numpoints
operator|/
literal|3
operator|)
operator|%
literal|3
operator|!=
literal|2
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|!
name|paths_set_path_points
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|,
name|ptype
argument_list|,
name|pclosed
argument_list|,
name|numpoints
argument_list|,
name|pnts
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_points_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_points_inargs
specifier|static
name|ProcArg
name|path_set_points_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to set the paths in"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"The name of the path to create (if it exists then a unique name will be created - query the list of paths if you want to make sure that the name of the path you create is unique. This will be set as the current path."
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"ptype"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_path_points"
block|,
literal|"The number of points in the path. Each point is made up of (x,y,type) of floats. Currently only the creation of bezier curves is allowed. The type parameter must be set to (1) to indicate a BEZIER type curve. For BEZIERS. Note the that points must be given in the following order... ACCACCAC ... If the path is not closed the last control point is missed off. Points consist of three control points (control/anchor/control) so for a curve that is not closed there must be at least two points passed (2 x,y pairs). If num_path_pnts % 3 = 0 then the path is assumed to be closed and the points are ACCACCACCACC."
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 3 floats. The first is the x pos, next is the y pos, last is the type of the pnt. The type field is dependant on the path type. For beziers (type 1 paths) the type can either be {1.0= BEZIER_ANCHOR, 2.0= BEZIER_CONTROL}. Note all points are returned in pixel resolution"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_points_proc
specifier|static
name|ProcRecord
name|path_set_points_proc
init|=
block|{
literal|"gimp_path_set_points"
block|,
literal|"Set the points associated with the named path."
block|,
literal|"Set the points associated with the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|5
block|,
name|path_set_points_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_points_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_stroke_current_invoker (Argument * args)
name|path_stroke_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
operator|&&
name|plist
operator|->
name|last_selected_row
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pptr
operator|=
operator|(
name|PATHP
operator|)
name|g_slist_nth_data
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|,
name|plist
operator|->
name|last_selected_row
argument_list|)
operator|)
condition|)
name|paths_stroke
argument_list|(
name|gimage
argument_list|,
name|plist
argument_list|,
name|pptr
argument_list|)
expr_stmt|;
comment|/* Found the path to stroke.. */
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_stroke_current_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_stroke_current_inargs
specifier|static
name|ProcArg
name|path_stroke_current_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image which contains the path to stroke"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_stroke_current_proc
specifier|static
name|ProcRecord
name|path_stroke_current_proc
init|=
block|{
literal|"gimp_path_stroke_current"
block|,
literal|"Stroke the current path in the passed image."
block|,
literal|"Stroke the current path in the passed image."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|1
block|,
name|path_stroke_current_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_stroke_current_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_point_at_dist_invoker (Argument * args)
name|path_get_point_at_dist_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gdouble
name|distance
decl_stmt|;
name|gint32
name|x_point
init|=
literal|0
decl_stmt|;
name|gint32
name|y_point
init|=
literal|0
decl_stmt|;
name|gdouble
name|gradient
init|=
literal|0
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|distance
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_float
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
operator|&&
name|plist
operator|->
name|last_selected_row
operator|>=
literal|0
condition|)
block|{
name|pptr
operator|=
operator|(
name|PATHP
operator|)
name|g_slist_nth_data
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|,
name|plist
operator|->
name|last_selected_row
argument_list|)
expr_stmt|;
name|success
operator|=
name|paths_distance
argument_list|(
name|pptr
argument_list|,
name|distance
argument_list|,
operator|&
name|x_point
argument_list|,
operator|&
name|y_point
argument_list|,
operator|&
name|gradient
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_point_at_dist_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|x_point
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|y_point
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_float
operator|=
name|gradient
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_point_at_dist_inargs
specifier|static
name|ProcArg
name|path_get_point_at_dist_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image the paths belongs to"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"distance"
block|,
literal|"The distance along the path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_outargs
specifier|static
name|ProcArg
name|path_get_point_at_dist_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"x_point"
block|,
literal|"The x position of the point"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"y_point"
block|,
literal|"The y position of the point"
block|}
block|,
block|{
name|PDB_FLOAT
block|,
literal|"gradient"
block|,
literal|"The gradient at the specified point"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_point_at_dist_proc
specifier|static
name|ProcRecord
name|path_get_point_at_dist_proc
init|=
block|{
literal|"gimp_path_get_point_at_dist"
block|,
literal|"Get point on a path at a specified distance along the path."
block|,
literal|"This will return the x,y position of a point at a given distance along the bezier curve. The distance will the obtained by first digitizing the curve internally an then walking along the curve. For a closed curve the start of the path is the first point on the path that was created. This might not be obvious. Note the current path is used."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_get_point_at_dist_inargs
block|,
literal|3
block|,
name|path_get_point_at_dist_outargs
block|,
block|{
block|{
name|path_get_point_at_dist_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_tattoo_invoker (Argument * args)
name|path_get_tattoo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|tattoo
init|=
literal|0
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
condition|)
break|break;
comment|/* Found the path */
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
condition|)
name|tattoo
operator|=
name|paths_get_tattoo
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|tattoo
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_tattoo_inargs
specifier|static
name|ProcArg
name|path_get_tattoo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose tattoo should be obtained"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_outargs
specifier|static
name|ProcArg
name|path_get_tattoo_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo associated with the name path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_tattoo_proc
specifier|static
name|ProcRecord
name|path_get_tattoo_proc
init|=
block|{
literal|"gimp_path_get_tattoo"
block|,
literal|"Returns the tattoo associated with the name path."
block|,
literal|"This procedure returns the tattoo associated with the specified path. A tattoo is a unique and permanent identifier attached to a path that can be used to uniquely identify a path within an image even between sessions."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_get_tattoo_inargs
block|,
literal|1
block|,
name|path_get_tattoo_outargs
block|,
block|{
block|{
name|path_get_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|get_path_by_tattoo_invoker (Argument * args)
name|get_path_by_tattoo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gint32
name|tattoo
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattoo
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
if|if
condition|(
operator|(
name|pptr
operator|=
name|paths_get_path_by_tattoo
argument_list|(
name|gimage
argument_list|,
name|tattoo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|get_path_by_tattoo_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|get_path_by_tattoo_inargs
specifier|static
name|ProcArg
name|get_path_by_tattoo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"tattoo"
block|,
literal|"The tattoo of the required path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_outargs
specifier|static
name|ProcArg
name|get_path_by_tattoo_outargs
index|[]
init|=
block|{
block|{
name|PDB_STRING
block|,
literal|"path_name"
block|,
literal|"The name of the path with the specified tattoo"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_path_by_tattoo_proc
specifier|static
name|ProcRecord
name|get_path_by_tattoo_proc
init|=
block|{
literal|"gimp_get_path_by_tattoo"
block|,
literal|"Return the name of the path with the given tattoo."
block|,
literal|"The procedure returns the name of the path in the specified image which has the passed tattoo. The tattoos are unique within the image and will be preserved across sessions and through renaming of the path. An error is returned if no path woth the specified tattoo can be found."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|get_path_by_tattoo_inargs
block|,
literal|1
block|,
name|get_path_by_tattoo_outargs
block|,
block|{
block|{
name|get_path_by_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_delete_invoker (Argument * args)
name|path_delete_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|paths_delete_path
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_delete_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_delete_inargs
specifier|static
name|ProcArg
name|path_delete_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The ID of the image to list delete the paths from"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"path_name_to_del"
block|,
literal|"The name of the path to delete"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_delete_proc
specifier|static
name|ProcRecord
name|path_delete_proc
init|=
block|{
literal|"gimp_path_delete"
block|,
literal|"Delete the named paths associated with the passed image."
block|,
literal|"Delete the named path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_delete_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_delete_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_locked_invoker (Argument * args)
name|path_get_locked_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|lockstatus
init|=
literal|0
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
condition|)
break|break;
comment|/* Found the path */
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
condition|)
name|lockstatus
operator|=
name|pptr
operator|->
name|locked
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_locked_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|lockstatus
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_get_locked_inargs
specifier|static
name|ProcArg
name|path_get_locked_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose locked status should be obtained"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_outargs
specifier|static
name|ProcArg
name|path_get_locked_outargs
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"lockstatus"
block|,
literal|"The lock status associated with the name path. 0 returned if the path is not locked. 1 is returned if the path is locked"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_locked_proc
specifier|static
name|ProcRecord
name|path_get_locked_proc
init|=
block|{
literal|"gimp_path_get_locked"
block|,
literal|"Returns the locked status associated with the name path."
block|,
literal|"This procedure returns the lock status associated with the specified path. A path can be \"locked\" which means that the transformation tool operations will also apply to the path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|2
block|,
name|path_get_locked_inargs
block|,
literal|1
block|,
name|path_get_locked_outargs
block|,
block|{
block|{
name|path_get_locked_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_locked_invoker (Argument * args)
name|path_set_locked_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|lockstatus
init|=
literal|0
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|lockstatus
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
condition|)
break|break;
comment|/* Found the path */
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
operator|&&
name|lockstatus
operator|>=
literal|0
operator|&&
name|lockstatus
operator|<=
literal|1
condition|)
name|pptr
operator|->
name|locked
operator|=
name|lockstatus
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_locked_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_locked_inargs
specifier|static
name|ProcArg
name|path_set_locked_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose locked status should be set"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"lockstatus"
block|,
literal|"The lock status associated with the name path. 0 if the path is not locked. 1 if the path is to be locked"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_locked_proc
specifier|static
name|ProcRecord
name|path_set_locked_proc
init|=
block|{
literal|"gimp_path_set_locked"
block|,
literal|"Set the locked status associated with the name path."
block|,
literal|"This procedure sets the lock status associated with the specified path. A path can be \"locked\" which means that the transformation tool operations will also apply to the path."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|path_set_locked_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_locked_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_tattoo_invoker (Argument * args)
name|path_set_tattoo_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint32
name|tattovalue
init|=
literal|0
decl_stmt|;
name|PathsList
modifier|*
name|plist
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
name|gimage
operator|=
name|pdb_id_to_image
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pname
operator|=
operator|(
name|gchar
operator|*
operator|)
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|tattovalue
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|plist
operator|=
name|gimage
operator|->
name|paths
expr_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
condition|)
break|break;
comment|/* Found the path */
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
condition|)
name|pptr
operator|->
name|tattoo
operator|=
name|tattovalue
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_tattoo_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|path_set_tattoo_inargs
specifier|static
name|ProcArg
name|path_set_tattoo_inargs
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The image"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose tattoo should be set"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"tattovalue"
block|,
literal|"The tattoo associated with the name path. Only values returned from 'path_get_tattoo' should be used here"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_set_tattoo_proc
specifier|static
name|ProcRecord
name|path_set_tattoo_proc
init|=
block|{
literal|"gimp_path_set_tattoo"
block|,
literal|"Sets the tattoo associated with the name path."
block|,
literal|"This procedure sets the tattoo associated with the specified path. A tattoo is a unique and permenant identifier attached to a path that can be used to uniquely identify a path within an image even between sessions. Note that the value passed to this function must have been obtained from a previous call to path_get_tattoo."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
literal|3
block|,
name|path_set_tattoo_inargs
block|,
literal|0
block|,
name|NULL
block|,
block|{
block|{
name|path_set_tattoo_invoker
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

