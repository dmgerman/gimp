begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1999 Andy Thomas alt@gimp.org  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  * Some of this code is based on the layers_dialog box code.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"pathsP.h"
end_include

begin_include
include|#
directive|include
file|"paths_cmds.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_decl_stmt
DECL|variable|success
specifier|static
name|int
name|success
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the PDB functions that interact with the PATHS structures. */
end_comment

begin_comment
comment|/* List the paths that an image has */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_list_invoker (Argument * args)
name|path_list_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|paths_list
decl_stmt|;
name|gint
name|num_paths
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_list_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|PathsList
modifier|*
name|plist
init|=
name|gimage
operator|->
name|paths
decl_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|gint
name|count
init|=
literal|0
decl_stmt|;
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
name|num_paths
operator|=
name|g_slist_length
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_paths
expr_stmt|;
name|paths_list
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gchar
operator|*
argument_list|)
operator|*
name|num_paths
argument_list|)
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|PATHP
name|pptr
init|=
name|pl
operator|->
name|data
decl_stmt|;
name|paths_list
index|[
name|count
operator|++
index|]
operator|=
name|g_strdup
argument_list|(
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
expr_stmt|;
name|pl
operator|=
name|g_slist_next
argument_list|(
name|pl
argument_list|)
expr_stmt|;
block|}
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|paths_list
expr_stmt|;
block|}
else|else
block|{
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
literal|0
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_list_in_args
name|ProcArg
name|path_list_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image to list the paths from"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_out_args
name|ProcArg
name|path_list_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"num_paths"
block|,
literal|"The number of paths returned"
block|}
block|,
block|{
name|PDB_STRINGARRAY
block|,
literal|"paths_list"
block|,
literal|"list of the paths belonging to this image"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_list_proc
name|ProcRecord
name|path_list_proc
init|=
block|{
literal|"gimp_path_list"
block|,
literal|"List the paths associated with the passed image"
block|,
literal|"List the paths associated with the passed image"
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_list_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_list_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_list_in_args
block|,
comment|/*  Output arguments  */
sizeof|sizeof
argument_list|(
name|path_list_out_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_list_out_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_list_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_list_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the points the named path is composed of */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_points_invoker (Argument * args)
name|path_get_points_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
init|=
name|NULL
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|PathsList
modifier|*
name|plist
init|=
name|gimage
operator|->
name|paths
decl_stmt|;
name|pname
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|&&
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pptr
operator|=
name|pl
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pname
argument_list|,
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found the path */
break|break;
block|}
name|pl
operator|=
name|g_slist_next
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|&&
name|pptr
condition|)
block|{
name|gint
name|num_pdetails
decl_stmt|;
name|gdouble
modifier|*
name|pnts
decl_stmt|;
name|GSList
modifier|*
name|points_list
decl_stmt|;
name|gint
name|pcount
init|=
literal|0
decl_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|/* Get the details for this path */
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pptr
operator|->
name|pathtype
expr_stmt|;
name|return_args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|pptr
operator|->
name|closed
expr_stmt|;
name|points_list
operator|=
name|pptr
operator|->
name|path_details
expr_stmt|;
if|if
condition|(
name|points_list
condition|)
block|{
name|num_pdetails
operator|=
name|g_slist_length
argument_list|(
name|points_list
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
name|num_pdetails
operator|*
literal|3
expr_stmt|;
comment|/* 3 floats for each point */
name|pnts
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
literal|3
operator|*
name|num_pdetails
argument_list|)
expr_stmt|;
comment|/* fill points and types in */
while|while
condition|(
name|points_list
condition|)
block|{
name|PATHPOINTP
name|ppoint
init|=
name|points_list
operator|->
name|data
decl_stmt|;
name|pnts
index|[
name|pcount
index|]
operator|=
name|ppoint
operator|->
name|x
expr_stmt|;
name|pnts
index|[
name|pcount
operator|+
literal|1
index|]
operator|=
name|ppoint
operator|->
name|y
expr_stmt|;
name|pnts
index|[
name|pcount
operator|+
literal|2
index|]
operator|=
operator|(
name|gfloat
operator|)
name|ppoint
operator|->
name|type
expr_stmt|;
comment|/* Bit of fiddle but should be understandable why it was done */
name|pcount
operator|+=
literal|3
expr_stmt|;
name|points_list
operator|=
name|g_slist_next
argument_list|(
name|points_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|return_args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
operator|=
literal|0
expr_stmt|;
name|pnts
operator|=
name|NULL
expr_stmt|;
block|}
name|return_args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|pnts
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_get_points_in_args
name|ProcArg
name|path_get_points_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image to list the paths from"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path whose points should be listed"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_out_args
name|ProcArg
name|path_get_points_out_args
index|[]
init|=
block|{
block|{
name|PDB_INT32
block|,
literal|"paths_type"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"pathclosed"
block|,
literal|"Return if the path is closed. {0=path open, 1= path closed}"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_path_point_details"
block|,
literal|"The number of point returned. Each point is made up of (x,y,pnt_type) of floats"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 3 floats. The first is the x pos, next is the y pos, last is the type of the pnt. The type field is dependant on the path type. For beziers (type 1 paths) the type can either be {1.0= BEZIER_ANCHOR, 2.0= BEZIER_CONTROL}. Note all points are returned in pixel resolution"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_points_proc
name|ProcRecord
name|path_get_points_proc
init|=
block|{
literal|"gimp_path_get_points"
block|,
literal|"List the points associated with the named path"
block|,
literal|"List the points associated with the named path"
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_get_points_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_get_points_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_get_points_in_args
block|,
comment|/*  Output arguments  */
sizeof|sizeof
argument_list|(
name|path_get_points_out_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_get_points_out_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_get_points_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_get_points_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the name of the current path (of the passed image) */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_get_current_invoker (Argument * args)
name|path_get_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
init|=
name|NULL
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|PathsList
modifier|*
name|plist
init|=
name|gimage
operator|->
name|paths
decl_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|plist
operator|->
name|last_selected_row
operator|>=
literal|0
condition|)
block|{
name|pptr
operator|=
operator|(
name|PATHP
operator|)
name|g_slist_nth_data
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|,
name|plist
operator|->
name|last_selected_row
argument_list|)
expr_stmt|;
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_current_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|return_args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
operator|=
name|g_strdup
argument_list|(
name|pptr
operator|->
name|name
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_get_current_in_args
name|ProcArg
name|path_get_current_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image to get the current paths from"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_out_args
name|ProcArg
name|path_get_current_out_args
index|[]
init|=
block|{
block|{
name|PDB_STRING
block|,
literal|"current_path_name"
block|,
literal|"The name of the current path"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|path_get_current_proc
name|ProcRecord
name|path_get_current_proc
init|=
block|{
literal|"gimp_path_get_current"
block|,
literal|"The name of the current path. Error if no paths"
block|,
literal|"The name of the current path. Error if no paths"
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_get_current_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_get_current_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_get_current_in_args
block|,
comment|/*  Output arguments  */
sizeof|sizeof
argument_list|(
name|path_get_current_out_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_get_current_out_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_get_current_out_args
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_get_current_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the name of the current path (of the passed image) */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_current_invoker (Argument * args)
name|path_set_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
init|=
name|NULL
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Set the current path to the given name */
name|pname
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|pname
operator|&&
name|paths_set_path
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|)
condition|)
block|{
name|success
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_current_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_set_current_in_args
name|ProcArg
name|path_set_current_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image to set the current paths"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"set_current_path_name"
block|,
literal|"The name of the path to set the current path to"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NO out args.. Either works or errors. */
end_comment

begin_decl_stmt
DECL|variable|path_set_current_proc
name|ProcRecord
name|path_set_current_proc
init|=
block|{
literal|"gimp_path_set_current"
block|,
literal|"The name path to set to the current. Error if path does not exist."
block|,
literal|"The name path to set to the current. Error if path does not exist."
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_set_current_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_set_current_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_set_current_in_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_set_current_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set a path up from the given points */
end_comment

begin_comment
comment|/* Currently only the creation of bezier curves is allowed.   * The type parameter must be set to (1) to indicate a BEZIER type curve.  */
end_comment

begin_comment
comment|/* For BEZIERS..  *   * Note the that points must be given in the following order...  * ACCACCACC ...  * The last control point is missing for non closed curves.  */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_set_points_invoker (Argument * args)
name|path_set_points_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
init|=
name|NULL
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gchar
modifier|*
name|pname
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gint
name|ptype
decl_stmt|;
name|gint
name|numpoints
decl_stmt|;
name|gint
name|pclosed
init|=
name|FALSE
decl_stmt|;
name|gdouble
modifier|*
name|pnts
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|pname
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
name|ptype
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|numpoints
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|numpoints
operator|/
literal|2
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
name|pclosed
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|numpoints
operator|/
literal|2
operator|)
operator|%
literal|3
operator|!=
literal|2
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
name|pnts
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|paths_set_path_points
argument_list|(
name|gimage
argument_list|,
name|pname
argument_list|,
name|ptype
argument_list|,
name|pclosed
argument_list|,
name|numpoints
argument_list|,
name|pnts
argument_list|)
condition|)
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_get_points_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_set_points_in_args
name|ProcArg
name|path_set_points_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image to list the paths from"
block|}
block|,
block|{
name|PDB_STRING
block|,
literal|"pathname"
block|,
literal|"the name of the path to create (if it exists then all current points are removed). This will not be set as the current path.You will have to do a gimp_set_current_path after creating the path to make it current."
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"path_type"
block|,
literal|"The type of the path. Currently only one type (1 = Bezier) is supported"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_path_points"
block|,
literal|"The number of points in the path. Each point is made up of (x,y) of floats. "
literal|"Currently only the creation of bezier curves is allowed. "
literal|"The type parameter must be set to (1) to indicate a BEZIER type curve.\n"
literal|"For BEZIERS.\n"
literal|"Note the that points must be given in the following order... "
literal|"ACCACCAC ... "
literal|"If the path is not closed the last control point is missed off. "
literal|"Points consist of three control points (control/anchor/control) "
literal|"so for a curve that is not closed there must be at least two points passed (2 x,y pairs). "
literal|"If num_path_pnts%3 = 0 then the path is assumed to be closed and the points are ACCACCACCACC."
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"points_pairs"
block|,
literal|"The points in the path represented as 2 floats. The first is the x pos, next is the y pos. The order of points define there types (see num_path_points comment)."
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No Out args */
end_comment

begin_decl_stmt
DECL|variable|path_set_points_proc
name|ProcRecord
name|path_set_points_proc
init|=
block|{
literal|"gimp_path_set_points"
block|,
literal|"Set the points associated with the named path"
block|,
literal|"Set the points associated with the named path"
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_set_points_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_set_points_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_set_points_in_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_set_points_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stroke the current path */
end_comment

begin_comment
comment|/* Note it will ONLY do the current path.. */
end_comment

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|path_stroke_current_invoker (Argument * args)
name|path_stroke_current_invoker
parameter_list|(
name|Argument
modifier|*
name|args
parameter_list|)
block|{
name|Argument
modifier|*
name|return_args
init|=
name|NULL
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|int_value
decl_stmt|;
name|gimage
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Get the path with the given name */
name|PathsList
modifier|*
name|plist
init|=
name|gimage
operator|->
name|paths
decl_stmt|;
if|if
condition|(
name|plist
operator|&&
name|plist
operator|->
name|bz_paths
condition|)
block|{
name|GSList
modifier|*
name|pl
init|=
name|plist
operator|->
name|bz_paths
decl_stmt|;
name|PATHP
name|pptr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|plist
operator|->
name|last_selected_row
operator|>=
literal|0
operator|&&
operator|(
name|pptr
operator|=
operator|(
name|PATHP
operator|)
name|g_slist_nth_data
argument_list|(
name|plist
operator|->
name|bz_paths
argument_list|,
name|plist
operator|->
name|last_selected_row
argument_list|)
operator|)
condition|)
block|{
comment|/* Found the path to stroke.. */
name|paths_stroke
argument_list|(
name|gimage
argument_list|,
name|plist
argument_list|,
name|pptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|return_args
operator|=
name|procedural_db_return_args
argument_list|(
operator|&
name|path_set_current_proc
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
name|return_args
return|;
block|}
end_function

begin_comment
comment|/*  The procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|path_stroke_current_in_args
name|ProcArg
name|path_stroke_current_in_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image which contains the path to stroke"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NO out args.. Either works or errors. */
end_comment

begin_decl_stmt
DECL|variable|path_stroke_current_proc
name|ProcRecord
name|path_stroke_current_proc
init|=
block|{
literal|"gimp_path_stroke_current"
block|,
literal|"Stroke the current path in the passed image"
block|,
literal|"Stroke the current path in the passed image"
block|,
literal|"Andy Thomas"
block|,
literal|"Andy Thomas"
block|,
literal|"1999"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
sizeof|sizeof
argument_list|(
name|path_stroke_current_in_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|path_stroke_current_in_args
index|[
literal|0
index|]
argument_list|)
block|,
name|path_stroke_current_in_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|path_stroke_current_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

end_unit

