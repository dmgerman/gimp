begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Fractal Compression routines for the XCF File Format  * Yaroslav Faybishenko  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"gimage.h"
end_include

begin_include
include|#
directive|include
file|"xcf.h"
end_include

begin_include
include|#
directive|include
file|"frac.h"
end_include

begin_define
DECL|macro|float
define|#
directive|define
name|float
value|double
end_define

begin_typedef
DECL|typedef|image_data
typedef|typedef
name|unsigned
name|char
name|image_data
typedef|;
end_typedef

begin_typedef
DECL|typedef|uns_long
typedef|typedef
name|unsigned
name|long
name|uns_long
typedef|;
end_typedef

begin_define
DECL|macro|MIN_BITS
define|#
directive|define
name|MIN_BITS
value|2
end_define

begin_define
DECL|macro|MAX_BITS
define|#
directive|define
name|MAX_BITS
value|4
end_define

begin_define
DECL|macro|MAX_GREY
define|#
directive|define
name|MAX_GREY
value|255
end_define

begin_define
DECL|macro|MAX_CONTRAST
define|#
directive|define
name|MAX_CONTRAST
value|1.0
end_define

begin_define
DECL|macro|CONTRAST_BITS
define|#
directive|define
name|CONTRAST_BITS
value|4
end_define

begin_define
DECL|macro|BRIGHTNESS_BITS
define|#
directive|define
name|BRIGHTNESS_BITS
value|6
end_define

begin_define
DECL|macro|MAX_QCONTRAST
define|#
directive|define
name|MAX_QCONTRAST
value|((1<<CONTRAST_BITS)-1)
end_define

begin_comment
DECL|macro|MAX_QCONTRAST
comment|/* max quantized contrast */
end_comment

begin_define
DECL|macro|MAX_QBRIGHTNESS
define|#
directive|define
name|MAX_QBRIGHTNESS
value|((1<<BRIGHTNESS_BITS)-1)
end_define

begin_comment
DECL|macro|MAX_QBRIGHTNESS
comment|/* max quantized brightness */
end_comment

begin_comment
comment|/* Number of classes. Each class corresponds to one specific ordering  * of the image brightness in the four quadrants of a range or domain.  * There are 4*3*2 = 24 classes. */
end_comment

begin_define
DECL|macro|NCLASSES
define|#
directive|define
name|NCLASSES
value|24
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
DECL|macro|OF (args)
define|#
directive|define
name|OF
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|OF (args)
define|#
directive|define
name|OF
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compute the sum of pixel values or squared pixel values in a range  * or domain from (x,y) to (x+size-1, y+size-1) included.  * For a domain, the returned value is scaled by 4 or 16.0 respectively.  * x, y and size must all be even. */
end_comment

begin_define
DECL|macro|region_sum (cum,x,y,size)
define|#
directive|define
name|region_sum
parameter_list|(
name|cum
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|)
define|\
value|(cum[((y)+(size))>>1][((x)+(size))>>1] - cum[(y)>>1][((x)+(size))>>1] \  - cum[((y)+(size))>>1][(x)>>1]          + cum[(y)>>1][(x)>>1])
end_define

begin_define
DECL|macro|square (pixel)
define|#
directive|define
name|square
parameter_list|(
name|pixel
parameter_list|)
value|(uns_long)(pixel)*(pixel)
end_define

begin_define
DECL|macro|dequantize (value,max,imax)
define|#
directive|define
name|dequantize
parameter_list|(
name|value
parameter_list|,
name|max
parameter_list|,
name|imax
parameter_list|)
value|((double)(value)*(max)/(double)imax)
end_define

begin_comment
comment|/* Information common to all domains of a certain size: info[s] describes  * domains of size 1<<(s+1), corresponding to ranges of size 1<<s  */
end_comment

begin_struct
DECL|struct|domain_info
struct|struct
name|domain_info
block|{
DECL|member|pos_bits
name|gint
name|pos_bits
decl_stmt|;
comment|/* Number of bits required to encode a domain position */
DECL|member|x_domains
name|gint
name|x_domains
decl_stmt|;
comment|/* Number of domains in x (horizontal) dimension */
DECL|variable|dom_info
block|}
name|dom_info
index|[
name|MAX_BITS
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/* Each domain is described by a 'domain_data' structure.  * domain_head[c][s] is the head of the list of domains of class c  * and size 1<<(s+1) (corresponding to ranges of size 1<<s).  */
end_comment

begin_typedef
DECL|struct|domain_struct
typedef|typedef
struct|struct
name|domain_struct
block|{
DECL|member|x
name|gint
name|x
decl_stmt|;
comment|/* horizontal position */
DECL|member|y
name|gint
name|y
decl_stmt|;
comment|/* vertical position */
DECL|member|d_sum
name|float
name|d_sum
decl_stmt|;
comment|/* sum of all values in the domain */
DECL|member|d_sum2
name|float
name|d_sum2
decl_stmt|;
comment|/* sum of all squared values in the domain */
DECL|member|next
name|struct
name|domain_struct
modifier|*
name|next
decl_stmt|;
comment|/* next domain in same class */
DECL|typedef|domain_data
block|}
name|domain_data
typedef|;
end_typedef

begin_typedef
DECL|struct|map_struct
typedef|typedef
struct|struct
name|map_struct
block|{
DECL|member|contrast
name|gint
name|contrast
decl_stmt|;
comment|/* quantized best contrast between range and domain */
DECL|member|brightness
name|gint
name|brightness
decl_stmt|;
comment|/* quantized best brightness offset */
DECL|member|error2
name|double
name|error2
decl_stmt|;
comment|/* sum of squared differences between range and domain */
DECL|typedef|affine_map
block|}
name|affine_map
typedef|;
end_typedef

begin_typedef
DECL|struct|range_struct
typedef|typedef
struct|struct
name|range_struct
block|{
DECL|member|x
name|gint
name|x
decl_stmt|;
comment|/* horizontal position */
DECL|member|y
name|gint
name|y
decl_stmt|;
comment|/* vertical position */
DECL|member|s_log
name|gint
name|s_log
decl_stmt|;
comment|/* log base 2 of the range size */
DECL|member|r_sum
name|double
name|r_sum
decl_stmt|;
comment|/* sum of all values in the range */
DECL|member|r_sum2
name|double
name|r_sum2
decl_stmt|;
comment|/* sum of all squared values in the range */
DECL|typedef|range_data
block|}
name|range_data
typedef|;
end_typedef

begin_typedef
DECL|typedef|process_func
typedef|typedef
name|void
argument_list|(
argument|*process_func
argument_list|)
name|OF
argument_list|(
operator|(
name|gint
name|x
operator|,
name|gint
name|y
operator|,
name|gint
name|s_log
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
DECL|typedef|BIT_FILE
typedef|typedef
name|struct
name|_BIT_FILE
name|BIT_FILE
typedef|;
end_typedef

begin_struct
DECL|struct|_BIT_FILE
struct|struct
name|_BIT_FILE
block|{
DECL|member|file
name|FILE
modifier|*
name|file
decl_stmt|;
DECL|member|mask
name|unsigned
name|char
name|mask
decl_stmt|;
DECL|member|rack
name|int
name|rack
decl_stmt|;
DECL|member|pacifier_counter
name|int
name|pacifier_counter
decl_stmt|;
DECL|member|cp
name|guint
modifier|*
name|cp
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|BIT_FILE
modifier|*
name|OpenInputBitFile
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BIT_FILE
modifier|*
name|OpenOutputBitFile
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|OutputBit
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|int
name|bit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|OutputBits
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|unsigned
name|long
name|code
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|InputBit
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|long
name|InputBits
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|int
name|bit_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|CloseInputBitFile
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|CloseOutputBitFile
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|FilePrintBinary
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|code
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decompressTile
parameter_list|(
name|Tile
modifier|*
name|destTile
parameter_list|,
name|gint
name|num_channels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decompressChannelTile
parameter_list|(
name|guchar
modifier|*
name|destData
parameter_list|,
name|gint
name|_x
parameter_list|,
name|gint
name|_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decompose_into_channels
parameter_list|(
name|Tile
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|channelTilesData
index|[
name|MAX_CHANNELS
index|]
parameter_list|,
name|gint
name|num_channels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fractal_compress
parameter_list|(
name|guchar
modifier|*
name|srcData
parameter_list|,
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|size_sanity_check
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress_init
parameter_list|(
name|guchar
modifier|*
name|tile
parameter_list|,
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|classify_domains
parameter_list|(
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|,
name|gint
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|find_class
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pete_fatal
parameter_list|(
name|char
modifier|*
name|shoutAtPete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pete_warn
parameter_list|(
name|char
modifier|*
name|tellPete
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
modifier|*
name|allocate
name|OF
argument_list|(
operator|(
name|gint
name|rows
operator|,
name|gint
name|columns
operator|,
name|gint
name|elem_size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|xalloc
name|OF
argument_list|(
operator|(
name|unsigned
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dominfo_init
name|OF
argument_list|(
operator|(
name|gint
name|x_size
operator|,
name|gint
name|y_size
operator|,
name|gint
name|density
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gint
name|bitlength
name|OF
argument_list|(
operator|(
name|uns_long
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compress_range
name|OF
argument_list|(
operator|(
name|gint
name|x
operator|,
name|gint
name|y
operator|,
name|gint
name|s_log
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|traverse_image
name|OF
argument_list|(
operator|(
name|gint
name|x
operator|,
name|gint
name|y
operator|,
name|gint
name|x_size
operator|,
name|gint
name|y_size
operator|,
name|process_func
name|process
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gint
name|quantize
name|OF
argument_list|(
operator|(
name|double
name|value
operator|,
name|double
name|max
operator|,
name|gint
name|imax
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compress_cleanup
name|OF
argument_list|(
operator|(
name|gint
name|y_size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_array
name|OF
argument_list|(
operator|(
name|void
operator|*
operator|*
name|array
operator|,
name|gint
name|rows
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decompress_range
name|OF
argument_list|(
operator|(
name|gint
name|x
operator|,
name|gint
name|y
operator|,
name|gint
name|s_log
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|refine_image
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|average_boundaries
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|layer_type
name|gint
name|layer_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|quality
name|double
name|quality
init|=
literal|2.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dom_density
name|gint
name|dom_density
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cum_range
name|uns_long
modifier|*
modifier|*
name|cum_range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|domain_head
name|domain_data
modifier|*
name|domain_head
index|[
name|NCLASSES
index|]
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cum_domain2
name|float
modifier|*
modifier|*
name|cum_domain2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|range
name|image_data
modifier|*
modifier|*
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|domain
name|unsigned
modifier|*
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cum_range2
name|float
modifier|*
modifier|*
name|cum_range2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_error2
name|double
name|max_error2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|progname
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|frac_file
name|BIT_FILE
modifier|*
name|frac_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_scale
name|gint
name|image_scale
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|iterations
name|gint
name|iterations
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curProgress
name|gint
name|curProgress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|maxProgress
name|gint
name|maxProgress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|XCFFileInfo
name|XcfInfo
modifier|*
name|XCFFileInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_channels_arr
name|gint
name|num_channels_arr
index|[]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RGB has 3 channels, RGBA - 4, GRAY - 1, GRAYA - 2, INDEXED - 1, INDEXEDA - 2, right? */
end_comment

begin_comment
comment|/* Domain density: domains of size s*s are located every (s>>dom_density)  * pixels. The density factor can range from 0 to 2 (smallest domains  * have a size of 8 and must start on even pixels boundaries). Density  * factors 1 and 2 get better image quality but significantly slow  * down compression. */
end_comment

begin_decl_stmt
DECL|variable|layer_type_init
name|gint
name|layer_type_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|load_initted
name|gint
name|load_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|save_initted
name|gint
name|save_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|xcf_compress_frac_info (gint _layer_type)
name|xcf_compress_frac_info
parameter_list|(
name|gint
name|_layer_type
parameter_list|)
block|{
name|layer_type
operator|=
name|_layer_type
expr_stmt|;
name|g_print
argument_list|(
literal|"layer_type = %i\n"
argument_list|,
name|layer_type
argument_list|)
expr_stmt|;
name|layer_type_init
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|xcf_load_compress_frac_init (gint _image_scale,gint _iterations)
name|xcf_load_compress_frac_init
parameter_list|(
name|gint
name|_image_scale
parameter_list|,
name|gint
name|_iterations
parameter_list|)
block|{
if|if
condition|(
name|_image_scale
operator|!=
literal|1
condition|)
name|pete_fatal
argument_list|(
literal|"You aren't supposed to allow for scale != 1 yet!"
argument_list|)
expr_stmt|;
name|image_scale
operator|=
name|_image_scale
expr_stmt|;
name|iterations
operator|=
name|_iterations
expr_stmt|;
name|g_print
argument_list|(
literal|"image_scale = %i;  iterations = %i\n"
argument_list|,
name|image_scale
argument_list|,
name|iterations
argument_list|)
expr_stmt|;
name|load_initted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|xcf_save_compress_frac_init (gint _dom_density,double _quality)
name|xcf_save_compress_frac_init
parameter_list|(
name|gint
name|_dom_density
parameter_list|,
name|double
name|_quality
parameter_list|)
block|{
name|dom_density
operator|=
name|_dom_density
expr_stmt|;
name|quality
operator|=
name|_quality
expr_stmt|;
name|g_print
argument_list|(
literal|"dom_density = %i;  quality = %f\n"
argument_list|,
name|dom_density
argument_list|,
name|quality
argument_list|)
expr_stmt|;
name|save_initted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|xcf_load_frac_compressed_tile (XcfInfo * info,Tile * tile)
name|xcf_load_frac_compressed_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|char
name|type
decl_stmt|;
name|gint
name|x_size
decl_stmt|;
comment|/* horizontal image size */
name|gint
name|y_size
decl_stmt|;
comment|/* vertical image size */
name|gint
name|x_dsize
decl_stmt|;
comment|/* horizontal size of decompressed image */
name|gint
name|y_dsize
decl_stmt|;
comment|/* vertical size of decompressed image */
if|if
condition|(
operator|!
name|load_initted
condition|)
name|pete_warn
argument_list|(
literal|"You forgot to make a call to load_init"
argument_list|)
expr_stmt|;
else|else
name|g_print
argument_list|(
literal|"Good job, pete\n"
argument_list|)
expr_stmt|;
name|XCFFileInfo
operator|=
name|info
expr_stmt|;
name|tile_ref
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|frac_file
operator|=
name|OpenInputBitFile
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|info
operator|->
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frac_file
operator|==
name|NULL
condition|)
block|{
name|g_error
argument_list|(
literal|"Error converting %s FILE * to BIT_FILE"
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|g_print
argument_list|(
literal|" OpenInputBitFile (info->fp,&info->cp) suceeded\n"
argument_list|)
expr_stmt|;
comment|/* Read the header of the fractal file: */
name|type
operator|=
name|InputBits
argument_list|(
name|frac_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|'X'
condition|)
block|{
name|g_error
argument_list|(
literal|"Sanity check failed - first byte not 'X'!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|g_print
argument_list|(
literal|"Sanity check passed\n"
argument_list|)
expr_stmt|;
name|x_size
operator|=
operator|(
name|gint
operator|)
name|InputBits
argument_list|(
name|frac_file
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|y_size
operator|=
operator|(
name|gint
operator|)
name|InputBits
argument_list|(
name|frac_file
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|dom_density
operator|=
operator|(
name|gint
operator|)
name|InputBits
argument_list|(
name|frac_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"Image width = %i, height = %i\n"
argument_list|,
name|x_size
argument_list|,
name|y_size
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"Domain density = %i\n"
argument_list|,
name|dom_density
argument_list|)
expr_stmt|;
comment|/* Allocate the scaled image: */
name|x_dsize
operator|=
name|x_size
operator|*
name|image_scale
expr_stmt|;
name|y_dsize
operator|=
name|y_size
operator|*
name|image_scale
expr_stmt|;
name|g_print
argument_list|(
literal|"Scaled image width = %i, height = %i\n"
argument_list|,
name|x_size
argument_list|,
name|y_size
argument_list|)
expr_stmt|;
name|range
operator|=
operator|(
name|image_data
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_dsize
argument_list|,
name|x_dsize
argument_list|,
sizeof|sizeof
argument_list|(
name|image_data
argument_list|)
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"%i x %i range allocated\n"
argument_list|,
name|x_dsize
argument_list|,
name|y_dsize
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"Calling decompressTile (tile, num_channels=%i)\n"
argument_list|,
name|num_channels_arr
index|[
name|layer_type
index|]
argument_list|)
expr_stmt|;
name|decompressTile
argument_list|(
name|tile
argument_list|,
name|num_channels_arr
index|[
name|layer_type
index|]
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"Returned from decompressTile (tile, num_channels=%i)\n"
argument_list|,
name|num_channels_arr
index|[
name|layer_type
index|]
argument_list|)
expr_stmt|;
name|tile_unref
argument_list|(
name|tile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decompressTile (Tile * destTile,gint num_channels)
name|decompressTile
parameter_list|(
name|Tile
modifier|*
name|destTile
parameter_list|,
name|gint
name|num_channels
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|guchar
modifier|*
name|channelData
index|[
literal|6
index|]
decl_stmt|;
name|guchar
modifier|*
name|cur_char
decl_stmt|;
name|guchar
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|InputBits
argument_list|(
name|frac_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|'X'
condition|)
name|g_error
argument_list|(
literal|"Sanity check failed - first byte not 'X'!"
argument_list|)
expr_stmt|;
name|channelData
index|[
name|i
index|]
operator|=
operator|(
name|guchar
operator|*
operator|)
name|malloc
argument_list|(
name|destTile
operator|->
name|ewidth
operator|*
name|destTile
operator|->
name|eheight
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|decompressChannelTile
argument_list|(
name|channelData
index|[
name|i
index|]
argument_list|,
name|destTile
operator|->
name|ewidth
argument_list|,
name|destTile
operator|->
name|eheight
argument_list|)
expr_stmt|;
block|}
name|g_print
argument_list|(
literal|"Squishing the channel tiles back\n"
argument_list|)
expr_stmt|;
name|cur_char
operator|=
name|destTile
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|destTile
operator|->
name|ewidth
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|destTile
operator|->
name|eheight
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_channels
condition|;
name|k
operator|++
control|)
comment|/* squish the channels back */
operator|*
operator|(
name|cur_char
operator|)
operator|++
operator|=
operator|*
operator|(
name|channelData
index|[
name|k
index|]
operator|)
operator|++
expr_stmt|;
name|g_print
argument_list|(
literal|"\tDone squishing\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decompressChannelTile (guchar * channelTileData,gint _x,gint _y)
name|decompressChannelTile
parameter_list|(
name|guchar
modifier|*
name|channelTileData
parameter_list|,
name|gint
name|_x
parameter_list|,
name|gint
name|_y
parameter_list|)
block|{
name|gint
name|y
decl_stmt|,
name|x
decl_stmt|;
name|guchar
modifier|*
name|cur_char
decl_stmt|;
comment|/* Initialize the domain information as in the compressor: */
name|g_print
argument_list|(
literal|"Calling dominfo_init (%i, %i, %i)\n"
argument_list|,
name|_x
argument_list|,
name|_y
argument_list|,
name|dom_density
argument_list|)
expr_stmt|;
name|dominfo_init
argument_list|(
name|_x
argument_list|,
name|_y
argument_list|,
name|dom_density
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"\t- done\n"
argument_list|)
expr_stmt|;
comment|/* Read all the affine maps, by using the same recursive traversal      of the image as the compressor:   */
name|g_print
argument_list|(
literal|"Calling traverse_image (0, 0, %i, %i, decompress_range)\n"
argument_list|,
name|_x
argument_list|,
name|_y
argument_list|)
expr_stmt|;
name|traverse_image
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_x
argument_list|,
name|_y
argument_list|,
name|decompress_range
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"\t- done\n"
argument_list|)
expr_stmt|;
comment|/* Iterate all affine maps over an initially random image. Since the      affine maps are contractive, this process converges.   */
name|iterations
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|iterations
operator|--
operator|>
literal|0
condition|)
block|{
name|g_print
argument_list|(
literal|"Iteration #%i\n"
argument_list|,
name|iterations
argument_list|)
expr_stmt|;
name|refine_image
argument_list|()
expr_stmt|;
block|}
comment|/* Smooth the transition between adjacent ranges: */
name|g_print
argument_list|(
literal|"Calling average_boundaries()"
argument_list|)
expr_stmt|;
name|average_boundaries
argument_list|()
expr_stmt|;
name|g_print
argument_list|(
literal|"\t- done\n"
argument_list|)
expr_stmt|;
name|cur_char
operator|=
name|channelTileData
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|_y
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|_x
condition|;
name|x
operator|++
control|)
operator|*
operator|(
name|cur_char
operator|)
operator|++
operator|=
name|range
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
name|g_print
argument_list|(
literal|"Done copying data into destChannelTile\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|gint
DECL|function|xcf_save_frac_compressed_tile (XcfInfo * info,Tile * tile)
name|xcf_save_frac_compressed_tile
parameter_list|(
name|XcfInfo
modifier|*
name|info
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|guchar
modifier|*
name|channelTilesData
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|num_channels
decl_stmt|;
name|tile_ref
argument_list|(
name|tile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_initted
condition|)
name|pete_warn
argument_list|(
literal|"Using default values for save variables"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size_sanity_check
argument_list|(
name|tile
argument_list|)
condition|)
return|return
literal|0
return|;
name|num_channels
operator|=
name|num_channels_arr
index|[
name|layer_type
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
control|)
name|channelTilesData
index|[
name|i
index|]
operator|=
operator|(
name|guchar
operator|*
operator|)
name|malloc
argument_list|(
name|tile
operator|->
name|eheight
operator|*
name|tile
operator|->
name|ewidth
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"channelTilesData address = %p\n"
argument_list|,
name|channelTilesData
argument_list|)
expr_stmt|;
name|decompose_into_channels
argument_list|(
name|tile
argument_list|,
name|channelTilesData
argument_list|,
name|num_channels
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"\tchannelTilesData address = %p\n"
argument_list|,
name|channelTilesData
argument_list|)
expr_stmt|;
name|frac_file
operator|=
name|OpenOutputBitFile
argument_list|(
name|info
operator|->
name|fp
argument_list|,
operator|&
name|info
operator|->
name|cp
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
literal|'X'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|fractal_compress
argument_list|(
name|channelTilesData
index|[
name|i
index|]
argument_list|,
name|tile
operator|->
name|ewidth
argument_list|,
name|tile
operator|->
name|eheight
argument_list|)
expr_stmt|;
name|compress_cleanup
argument_list|(
name|tile
operator|->
name|eheight
argument_list|)
expr_stmt|;
block|}
name|CloseOutputBitFile
argument_list|(
name|frac_file
argument_list|)
expr_stmt|;
name|tile_unref
argument_list|(
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|size_sanity_check (Tile * tile)
name|size_sanity_check
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|char
name|message
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|tile
operator|->
name|ewidth
operator|%
literal|4
operator|!=
literal|0
operator|||
name|tile
operator|->
name|eheight
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|g_warning
argument_list|(
name|message
argument_list|,
literal|"Width = %i, Height = %i\nTile sizes must be multiple of 4"
argument_list|,
name|tile
operator|->
name|ewidth
argument_list|,
name|tile
operator|->
name|eheight
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fractal_compress (guchar * srcTileData,gint x_size,gint y_size)
name|fractal_compress
parameter_list|(
name|guchar
modifier|*
name|srcTileData
parameter_list|,
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|)
block|{
name|gint
name|s
decl_stmt|;
comment|/* size index for domains; their size is 1<<(s+1) */
comment|/* Allocate and initialize the image data and cumulative image data: */
name|compress_init
argument_list|(
name|srcTileData
argument_list|,
name|x_size
argument_list|,
name|y_size
argument_list|)
expr_stmt|;
comment|/* Initialize the domain size information as in the decompressor: */
name|dominfo_init
argument_list|(
name|x_size
argument_list|,
name|y_size
argument_list|,
name|dom_density
argument_list|)
expr_stmt|;
comment|/* Classify all domains: */
for|for
control|(
name|s
operator|=
name|MIN_BITS
init|;
name|s
operator|<=
name|MAX_BITS
condition|;
name|s
operator|++
control|)
name|classify_domains
argument_list|(
name|x_size
argument_list|,
name|y_size
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
name|x_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
name|y_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
name|dom_density
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
literal|'X'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|max_error2
operator|=
name|quality
operator|*
name|quality
expr_stmt|;
name|traverse_image
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x_size
argument_list|,
name|y_size
argument_list|,
name|compress_range
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize the image data and cumulative image data.  * must be a one-channel tile */
end_comment

begin_function
specifier|static
name|void
DECL|function|compress_init (guchar * srcData,gint x_size,gint y_size)
name|compress_init
parameter_list|(
name|guchar
modifier|*
name|srcData
parameter_list|,
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|uns_long
name|r_sum
decl_stmt|;
comment|/* cumulative range and domain data */
name|double
name|r_sum2
decl_stmt|;
comment|/* cumulative squared range data */
name|double
name|d_sum2
decl_stmt|;
comment|/* cumulative squared domain data */
name|guchar
modifier|*
name|cur
decl_stmt|;
name|range
operator|=
operator|(
name|image_data
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_size
argument_list|,
name|x_size
argument_list|,
sizeof|sizeof
argument_list|(
name|image_data
argument_list|)
argument_list|)
expr_stmt|;
name|domain
operator|=
operator|(
name|unsigned
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_size
operator|/
literal|2
argument_list|,
name|x_size
operator|/
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|cum_range
operator|=
operator|(
name|uns_long
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|x_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|uns_long
argument_list|)
argument_list|)
expr_stmt|;
name|cum_range2
operator|=
operator|(
name|float
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|x_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|cum_domain2
operator|=
operator|(
name|float
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|x_size
operator|/
literal|2
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
comment|/* transfer srcData (from the tile) ginto our own array */
name|cur
operator|=
name|srcData
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y_size
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x_size
condition|;
name|x
operator|++
control|)
name|range
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
comment|/* Compute the 'domain' image from the 'range' image. Each pixel in    * the domain image is the sum of 4 pixels in the range image.  We    * don't average (divide by 4) to avoid losing precision.    */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y_size
operator|/
literal|2
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x_size
operator|/
literal|2
condition|;
name|x
operator|++
control|)
name|domain
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
operator|(
name|unsigned
operator|)
name|range
index|[
name|y
operator|<<
literal|1
index|]
index|[
name|x
operator|<<
literal|1
index|]
operator|+
name|range
index|[
name|y
operator|<<
literal|1
index|]
index|[
operator|(
name|x
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|+
name|range
index|[
operator|(
name|y
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
index|[
name|x
operator|<<
literal|1
index|]
operator|+
name|range
index|[
operator|(
name|y
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
index|[
operator|(
name|x
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Compute the cumulative data, which will avoid repeated computations    * later (see the region_sum() macro below).    */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|x_size
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|cum_range
index|[
literal|0
index|]
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|cum_range2
index|[
literal|0
index|]
index|[
name|x
index|]
operator|=
name|cum_domain2
index|[
literal|0
index|]
index|[
name|x
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y_size
operator|/
literal|2
condition|;
name|y
operator|++
control|)
block|{
name|d_sum2
operator|=
name|r_sum2
operator|=
literal|0.0
expr_stmt|;
name|r_sum
operator|=
name|cum_range
index|[
name|y
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cum_range2
index|[
name|y
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|cum_domain2
index|[
name|y
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x_size
operator|/
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|r_sum
operator|+=
name|domain
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
name|cum_range
index|[
name|y
operator|+
literal|1
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|cum_range
index|[
name|y
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|+
name|r_sum
expr_stmt|;
name|d_sum2
operator|+=
operator|(
name|double
operator|)
name|square
argument_list|(
name|domain
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|cum_domain2
index|[
name|y
operator|+
literal|1
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|cum_domain2
index|[
name|y
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|+
name|d_sum2
expr_stmt|;
name|r_sum2
operator|+=
call|(
name|double
call|)
argument_list|(
name|square
argument_list|(
name|range
index|[
name|y
operator|<<
literal|1
index|]
index|[
name|x
operator|<<
literal|1
index|]
argument_list|)
operator|+
name|square
argument_list|(
name|range
index|[
name|y
operator|<<
literal|1
index|]
index|[
operator|(
name|x
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|)
operator|+
name|square
argument_list|(
name|range
index|[
operator|(
name|y
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
index|[
name|x
operator|<<
literal|1
index|]
argument_list|)
operator|+
name|square
argument_list|(
name|range
index|[
operator|(
name|y
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
index|[
operator|(
name|x
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cum_range2
index|[
name|y
operator|+
literal|1
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|cum_range2
index|[
name|y
index|]
index|[
name|x
operator|+
literal|1
index|]
operator|+
name|r_sum2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Classify all domains of a certain size. This is done only once to save  * computations later. Each domain is inserted in a linked list according  * to its class and size.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|classify_domains (gint x_size,gint y_size,gint s)
name|classify_domains
parameter_list|(
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|,
name|gint
name|s
parameter_list|)
block|{
name|domain_data
modifier|*
name|dom
init|=
name|NULL
decl_stmt|;
comment|/* pointer to new domain */
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* horizontal and vertical domain position */
name|gint
name|class
decl_stmt|;
comment|/* domain class */
name|gint
name|dom_size
init|=
literal|1
operator|<<
operator|(
name|s
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* domain size */
name|gint
name|dom_dist
init|=
name|dom_size
operator|>>
name|dom_density
decl_stmt|;
comment|/* distance between domains */
comment|/* Initialize all domain lists to be empty: */
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|NCLASSES
condition|;
name|class
operator|++
control|)
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Classify all domains of this size: */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<=
name|y_size
operator|-
name|dom_size
condition|;
name|y
operator|+=
name|dom_dist
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|x_size
operator|-
name|dom_size
condition|;
name|x
operator|+=
name|dom_dist
control|)
block|{
name|dom
operator|=
operator|(
name|domain_data
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|domain_data
argument_list|)
argument_list|)
expr_stmt|;
name|dom
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|dom
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|dom
operator|->
name|d_sum
operator|=
literal|0.25
operator|*
operator|(
name|double
operator|)
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|dom_size
argument_list|)
expr_stmt|;
name|dom
operator|->
name|d_sum2
operator|=
literal|0.0625
operator|*
operator|(
name|double
operator|)
name|region_sum
argument_list|(
name|cum_domain2
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|dom_size
argument_list|)
expr_stmt|;
name|class
operator|=
name|find_class
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|dom_size
argument_list|)
expr_stmt|;
name|dom
operator|->
name|next
operator|=
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
expr_stmt|;
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
operator|=
name|dom
expr_stmt|;
block|}
comment|/* Check that each domain class contains at least one domain.      * If a class is empty, we do as if it contains the last created      * domain (which is actually of a different class).      */
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|NCLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
operator|==
name|NULL
condition|)
block|{
name|domain_data
modifier|*
name|dom2
init|=
operator|(
name|domain_data
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|domain_data
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|dom2
operator|=
operator|*
name|dom
expr_stmt|;
name|dom2
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
operator|=
name|dom2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Classify a range or domain.  The class is determined by the  * ordering of the image brightness in the four quadrants of the range  * or domain. For each quadrant we compute the number of brighter  * quadrants; this is sufficient to uniquely determine the  * class. class 0 has quadrants in order of decreasing brightness;  * class 23 has quadrants in order of increasing brightness.  *  * IN assertion: x, y and size are all multiple of 4.  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|find_class (gint x,gint y,gint size)
name|find_class
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|size
parameter_list|)
block|{
name|gint
name|class
init|=
literal|0
decl_stmt|;
comment|/* the result class */
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* quadrant indices */
name|uns_long
name|sum
index|[
literal|4
index|]
decl_stmt|;
comment|/* sums for each quadrant */
specifier|static
name|gint
name|delta
index|[
literal|3
index|]
init|=
block|{
literal|6
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* table used to compute the class number */
name|gint
name|size1
init|=
name|size
operator|>>
literal|1
decl_stmt|;
comment|/* Get the cumulative values of each quadrant. By the IN assertion,      * size1, x+size1 and y+size1 are all even. */
name|sum
index|[
literal|0
index|]
operator|=
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|sum
index|[
literal|1
index|]
operator|=
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|size1
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|sum
index|[
literal|2
index|]
operator|=
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
operator|+
name|size1
argument_list|,
name|y
operator|+
name|size1
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|sum
index|[
literal|3
index|]
operator|=
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
operator|+
name|size1
argument_list|,
name|y
argument_list|,
name|size1
argument_list|)
expr_stmt|;
comment|/* Compute the class from the ordering of these values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
literal|3
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|sum
index|[
name|i
index|]
operator|<
name|sum
index|[
name|j
index|]
condition|)
name|class
operator|+=
name|delta
index|[
name|i
index|]
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decompose_into_channels (Tile * tile,guchar * channelTilesData[MAX_CHANNELS],gint num_channels)
name|decompose_into_channels
parameter_list|(
name|Tile
modifier|*
name|tile
parameter_list|,
name|guchar
modifier|*
name|channelTilesData
index|[
name|MAX_CHANNELS
index|]
parameter_list|,
name|gint
name|num_channels
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|begin
decl_stmt|,
modifier|*
name|cur_char_tile
decl_stmt|;
name|g_print
argument_list|(
literal|"Decomposing into %i num_channels\n"
argument_list|,
name|num_channels
argument_list|)
expr_stmt|;
name|cur_char_tile
operator|=
name|tile
operator|->
name|data
expr_stmt|;
name|begin
operator|=
operator|&
name|channelTilesData
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile
operator|->
name|eheight
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tile
operator|->
name|ewidth
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_channels
condition|;
name|k
operator|++
control|)
operator|*
operator|(
name|channelTilesData
index|[
name|k
index|]
operator|)
operator|++
operator|=
operator|*
operator|(
name|cur_char_tile
operator|)
operator|++
expr_stmt|;
name|channelTilesData
operator|=
name|begin
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Allocate a two dimensional array. For portability to 16-bit   architectures with segments limited to 64K, we allocate one   array per row, so the two dimensional array is allocated   as an array of arrays.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|allocate (gint rows,gint columns,gint elem_size)
modifier|*
modifier|*
name|allocate
parameter_list|(
name|gint
name|rows
parameter_list|,
name|gint
name|columns
parameter_list|,
name|gint
name|elem_size
parameter_list|)
block|{
name|gint
name|row
decl_stmt|;
name|void
modifier|*
modifier|*
name|array
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|xalloc
argument_list|(
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
name|array
index|[
name|row
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|xalloc
argument_list|(
name|columns
operator|*
name|elem_size
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_comment
comment|/* Initialize the domain information dom_info. This must be done in the  * same manner in the compressor and the decompressor.  */
end_comment

begin_function
DECL|function|dominfo_init (gint x_size,gint y_size,gint density)
specifier|static
name|void
name|dominfo_init
parameter_list|(
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|,
name|gint
name|density
parameter_list|)
block|{
name|gint
name|s
decl_stmt|;
comment|/* size index for domains; their size is 1<<(s+1) */
for|for
control|(
name|s
operator|=
name|MIN_BITS
init|;
name|s
operator|<=
name|MAX_BITS
condition|;
name|s
operator|++
control|)
block|{
name|gint
name|y_domains
decl_stmt|;
comment|/* number of domains vertically */
name|gint
name|dom_size
init|=
literal|1
operator|<<
operator|(
name|s
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* domain size */
comment|/* The distance between two domains is the domain size 1<<(s+1)        * shifted right by the domain density, so it is a power of two.        */
name|dom_info
index|[
name|s
index|]
operator|.
name|x_domains
operator|=
operator|(
operator|(
name|x_size
operator|-
name|dom_size
operator|)
operator|>>
operator|(
name|s
operator|+
literal|1
operator|-
name|density
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|y_domains
operator|=
operator|(
operator|(
name|y_size
operator|-
name|dom_size
operator|)
operator|>>
operator|(
name|s
operator|+
literal|1
operator|-
name|density
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Number of bits required to encode a domain position: */
name|dom_info
index|[
name|s
index|]
operator|.
name|pos_bits
operator|=
name|bitlength
argument_list|(
operator|(
name|uns_long
operator|)
name|dom_info
index|[
name|s
index|]
operator|.
name|x_domains
operator|*
name|y_domains
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate memory and check that the allocation was successful. */
end_comment

begin_function
specifier|static
name|void
DECL|function|xalloc (unsigned size)
modifier|*
name|xalloc
parameter_list|(
name|unsigned
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|g_error
argument_list|(
literal|"insufficient memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* shouldn't we really be doing something else? */
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits needed to represent an integer:  * 0 to 1 -> 1,  * 2 to 3 -> 2,  * 3 to 7 -> 3, etc...  * This function could be made faster with a lookup table.  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|bitlength (uns_long val)
name|bitlength
parameter_list|(
name|uns_long
name|val
parameter_list|)
block|{
name|gint
name|bits
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xffff
condition|)
name|bits
operator|+=
literal|16
operator|,
name|val
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xff
condition|)
name|bits
operator|+=
literal|8
operator|,
name|val
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xf
condition|)
name|bits
operator|+=
literal|4
operator|,
name|val
operator|>>=
literal|4
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0x3
condition|)
name|bits
operator|+=
literal|2
operator|,
name|val
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0x1
condition|)
name|bits
operator|+=
literal|1
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_comment
comment|/* Find the best affine mapping from a range to a domain. This is done  * by minimizing the sum of squared errors as a function of the contrast  * and brightness:  sum on all range pixels ri and domain pixels di of  *      square(contrast*domain[di] + brightness - range[ri])  * and solving the resulting equations to get contrast and brightness.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_map (range_data * rangep,domain_data * dom,affine_map * map)
name|find_map
parameter_list|(
name|range_data
modifier|*
name|rangep
parameter_list|,
name|domain_data
modifier|*
name|dom
parameter_list|,
name|affine_map
modifier|*
name|map
parameter_list|)
block|{
comment|/*    range_data  *rangep; range information (input parameter) 	domain_data *dom;    domain information (input parameter) 	affine_map  *map;    resulting map (output parameter) */
name|gint
name|ry
decl_stmt|;
comment|/* vertical position inside the range */
name|gint
name|dy
init|=
name|dom
operator|->
name|y
operator|>>
literal|1
decl_stmt|;
comment|/* vertical position inside the domain */
name|uns_long
name|rd
init|=
literal|0
decl_stmt|;
comment|/* sum of range*domain values (scaled by 4) */
name|double
name|rd_sum
decl_stmt|;
comment|/* sum of range*domain values (normalized) */
name|double
name|contrast
decl_stmt|;
comment|/* optimal contrast between range and domain */
name|double
name|brightness
decl_stmt|;
comment|/* optimal brightness offset between range and domain */
name|double
name|qbrightness
decl_stmt|;
comment|/* brightness after quantization */
name|double
name|max_scaled
decl_stmt|;
comment|/* maximum scaled value = contrast*MAX_GREY */
name|gint
name|r_size
init|=
literal|1
operator|<<
name|rangep
operator|->
name|s_log
decl_stmt|;
comment|/* the range size */
name|double
name|pixels
init|=
call|(
name|double
call|)
argument_list|(
operator|(
name|long
operator|)
name|r_size
operator|*
name|r_size
argument_list|)
decl_stmt|;
comment|/* total number of pixels */
for|for
control|(
name|ry
operator|=
name|rangep
operator|->
name|y
init|;
name|ry
operator|<
name|rangep
operator|->
name|y
operator|+
name|r_size
condition|;
name|ry
operator|++
operator|,
name|dy
operator|++
control|)
block|{
specifier|register
name|image_data
modifier|*
name|r
init|=
operator|&
name|range
index|[
name|ry
index|]
index|[
name|rangep
operator|->
name|x
index|]
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|d
init|=
operator|&
name|domain
index|[
name|dy
index|]
index|[
name|dom
operator|->
name|x
operator|>>
literal|1
index|]
decl_stmt|;
name|gint
name|i
init|=
name|r_size
operator|>>
literal|2
decl_stmt|;
comment|/* The following loop is the most time consuming part of the whole        * program, so it is unrolled a little. I rely on r_size being a        * multiple of 4 (ranges smaller than 4 don't make sense because        * of the very bad compression). rd cannot overflow with unsigned        * 32-bit arithmetic since MAX_BITS<= 7 implies r_size<= 128.        */
do|do
block|{
name|rd
operator|+=
call|(
name|uns_long
call|)
argument_list|(
operator|*
name|r
operator|++
argument_list|)
operator|*
operator|(
operator|*
name|d
operator|++
operator|)
expr_stmt|;
name|rd
operator|+=
call|(
name|uns_long
call|)
argument_list|(
operator|*
name|r
operator|++
argument_list|)
operator|*
operator|(
operator|*
name|d
operator|++
operator|)
expr_stmt|;
name|rd
operator|+=
call|(
name|uns_long
call|)
argument_list|(
operator|*
name|r
operator|++
argument_list|)
operator|*
operator|(
operator|*
name|d
operator|++
operator|)
expr_stmt|;
name|rd
operator|+=
call|(
name|uns_long
call|)
argument_list|(
operator|*
name|r
operator|++
argument_list|)
operator|*
operator|(
operator|*
name|d
operator|++
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
name|rd_sum
operator|=
literal|0.25
operator|*
name|rd
expr_stmt|;
comment|/* Compute and quantize the contrast: */
name|contrast
operator|=
name|pixels
operator|*
name|dom
operator|->
name|d_sum2
operator|-
name|dom
operator|->
name|d_sum
operator|*
name|dom
operator|->
name|d_sum
expr_stmt|;
if|if
condition|(
name|contrast
operator|!=
literal|0.0
condition|)
block|{
name|contrast
operator|=
operator|(
name|pixels
operator|*
name|rd_sum
operator|-
name|rangep
operator|->
name|r_sum
operator|*
name|dom
operator|->
name|d_sum
operator|)
operator|/
name|contrast
expr_stmt|;
block|}
name|map
operator|->
name|contrast
operator|=
name|quantize
argument_list|(
name|contrast
argument_list|,
name|MAX_CONTRAST
argument_list|,
name|MAX_QCONTRAST
argument_list|)
expr_stmt|;
comment|/* Recompute the contrast as in the decompressor: */
name|contrast
operator|=
name|dequantize
argument_list|(
name|map
operator|->
name|contrast
argument_list|,
name|MAX_CONTRAST
argument_list|,
name|MAX_QCONTRAST
argument_list|)
expr_stmt|;
comment|/* Compute and quantize the brightness. We actually quantize the value    * (brightness + 255*contrast) to get a positive value:    *    -contrast*255<= brightness<= 255    * so 0<= brightness + 255*contrast<= 255 + contrast*255    */
name|brightness
operator|=
operator|(
name|rangep
operator|->
name|r_sum
operator|-
name|contrast
operator|*
name|dom
operator|->
name|d_sum
operator|)
operator|/
name|pixels
expr_stmt|;
name|max_scaled
operator|=
name|contrast
operator|*
name|MAX_GREY
expr_stmt|;
name|map
operator|->
name|brightness
operator|=
name|quantize
argument_list|(
name|brightness
operator|+
name|max_scaled
argument_list|,
name|max_scaled
operator|+
name|MAX_GREY
argument_list|,
name|MAX_QBRIGHTNESS
argument_list|)
expr_stmt|;
comment|/* Recompute the quantized brightness as in the decompressor: */
name|qbrightness
operator|=
name|dequantize
argument_list|(
name|map
operator|->
name|brightness
argument_list|,
name|max_scaled
operator|+
name|MAX_GREY
argument_list|,
name|MAX_QBRIGHTNESS
argument_list|)
operator|-
name|max_scaled
expr_stmt|;
comment|/* Compute the sum of squared errors, which is the quantity we are    * trying to minimize: */
name|map
operator|->
name|error2
operator|=
name|contrast
operator|*
operator|(
name|contrast
operator|*
name|dom
operator|->
name|d_sum2
operator|-
literal|2.0
operator|*
name|rd_sum
operator|)
operator|+
name|rangep
operator|->
name|r_sum2
operator|+
name|qbrightness
operator|*
name|pixels
operator|*
operator|(
name|qbrightness
operator|-
literal|2.0
operator|*
name|brightness
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a rectangle sub-image into a square and potentially two rectangles,  * then split the square and rectangles recursively if necessary.  To simplify  * the algorithm, the size of the square is chosen as a power of two.  * If the square if small enough as a range, call the appropriate compression  * or decompression function for this range.  * IN assertions: x, y, x_size and y_size are multiple of 4. */
end_comment

begin_function
specifier|static
name|void
DECL|function|traverse_image (gint x,gint y,gint x_size,gint y_size,process_func process)
name|traverse_image
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|x_size
parameter_list|,
name|gint
name|y_size
parameter_list|,
name|process_func
name|process
parameter_list|)
block|{
comment|/* x, y;        sub-image horizontal and vertical position      x_size, y_size;   sub-image horizontal and vertical sizes      process_func process; the compression or decompression function */
name|gint
name|s_size
decl_stmt|;
comment|/* size of the square; s_size = 1<<s_log */
name|gint
name|s_log
decl_stmt|;
comment|/* log base 2 of this size */
name|s_log
operator|=
name|bitlength
argument_list|(
name|x_size
operator|<
name|y_size
condition|?
operator|(
name|uns_long
operator|)
name|x_size
else|:
operator|(
name|uns_long
operator|)
name|y_size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s_size
operator|=
literal|1
operator|<<
name|s_log
expr_stmt|;
comment|/* Since x_size and y_size are>= 4, s_log>= MIN_BITS */
comment|/* Split the square recursively if it is too large for a range: */
if|if
condition|(
name|s_log
operator|>
name|MAX_BITS
condition|)
block|{
name|traverse_image
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|process
argument_list|)
expr_stmt|;
name|traverse_image
argument_list|(
name|x
operator|+
name|s_size
operator|/
literal|2
argument_list|,
name|y
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|process
argument_list|)
expr_stmt|;
name|traverse_image
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|process
argument_list|)
expr_stmt|;
name|traverse_image
argument_list|(
name|x
operator|+
name|s_size
operator|/
literal|2
argument_list|,
name|y
operator|+
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|s_size
operator|/
literal|2
argument_list|,
name|process
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compress or decompress the square as a range: */
call|(
modifier|*
name|process
call|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s_log
argument_list|)
expr_stmt|;
block|}
comment|/* Traverse the rectangle on the right of the square: */
if|if
condition|(
name|x_size
operator|>
name|s_size
condition|)
block|{
name|traverse_image
argument_list|(
name|x
operator|+
name|s_size
argument_list|,
name|y
argument_list|,
name|x_size
operator|-
name|s_size
argument_list|,
name|y_size
argument_list|,
name|process
argument_list|)
expr_stmt|;
comment|/* Since x_size and s_size are multiple of 4, x + s_size and      * x_size - s_size are also multiple of 4.      */
block|}
comment|/* Traverse the rectangle below the square: */
if|if
condition|(
name|y_size
operator|>
name|s_size
condition|)
name|traverse_image
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|s_size
argument_list|,
name|s_size
argument_list|,
name|y_size
operator|-
name|s_size
argument_list|,
name|process
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compress a range by searching a match with all domains of the same class.  * Split the range if the mean square error with the best domain is larger  * than max_error2.  * IN assertion: MIN_BITS<= s_log<= MAX_BITS */
end_comment

begin_function
specifier|static
name|void
DECL|function|compress_range (gint x,gint y,gint s_log)
name|compress_range
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|s_log
parameter_list|)
block|{
comment|/* s_log is  log base 2 of the range size */
name|gint
name|r_size
init|=
literal|1
operator|<<
name|s_log
decl_stmt|;
comment|/* size of the range */
name|gint
name|class
decl_stmt|;
comment|/* range class */
name|domain_data
modifier|*
name|dom
decl_stmt|;
comment|/* used to iterate over all domains of this class */
name|domain_data
modifier|*
name|best_dom
init|=
name|NULL
decl_stmt|;
comment|/* pointer to the best domain */
name|range_data
name|range
decl_stmt|;
comment|/* range information for this range */
name|affine_map
name|map
decl_stmt|;
comment|/* affine map for current domain  */
name|affine_map
name|best_map
decl_stmt|;
comment|/* best map for this range */
name|uns_long
name|dom_number
decl_stmt|;
comment|/* domain number */
comment|/* Compute the range class and cumulative sums: */
name|class
operator|=
name|find_class
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
name|range
operator|.
name|r_sum
operator|=
operator|(
name|double
operator|)
name|region_sum
argument_list|(
name|cum_range
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
name|range
operator|.
name|r_sum2
operator|=
operator|(
name|double
operator|)
name|region_sum
argument_list|(
name|cum_range2
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
name|range
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|range
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|range
operator|.
name|s_log
operator|=
name|s_log
expr_stmt|;
comment|/* Searching all classes can improve image quality but significantly slows    * down compression. Compile with -DCOMPLETE_SEARCH if you can wait, pete */
ifdef|#
directive|ifdef
name|COMPLETE_SEARCH
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|NCLASSES
condition|;
name|class
operator|++
control|)
endif|#
directive|endif
for|for
control|(
name|dom
operator|=
name|domain_head
index|[
name|class
index|]
index|[
name|s_log
index|]
init|;
name|dom
operator|!=
name|NULL
condition|;
name|dom
operator|=
name|dom
operator|->
name|next
control|)
block|{
comment|/* Find the optimal map from the range to the domain: */
name|find_map
argument_list|(
operator|&
name|range
argument_list|,
name|dom
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_dom
operator|==
name|NULL
operator|||
name|map
operator|.
name|error2
operator|<
name|best_map
operator|.
name|error2
condition|)
block|{
name|best_map
operator|=
name|map
expr_stmt|;
name|best_dom
operator|=
name|dom
expr_stmt|;
block|}
block|}
comment|/* Output the best affine map if the mean square error with the    * best domain is smaller than max_error2, or if it not possible    * to split the range because it is too small: */
if|if
condition|(
name|s_log
operator|==
name|MIN_BITS
operator|||
name|best_map
operator|.
name|error2
operator|<=
name|max_error2
operator|*
operator|(
operator|(
name|long
operator|)
name|r_size
operator|*
name|r_size
operator|)
condition|)
block|{
comment|/* If the range is too small to be split, the decompressor knows        * this, otherwise we must indicate that the range has not been split: */
if|if
condition|(
name|s_log
operator|!=
name|MIN_BITS
condition|)
name|OutputBit
argument_list|(
name|frac_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* affine map follows */
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
name|best_map
operator|.
name|contrast
argument_list|,
name|CONTRAST_BITS
argument_list|)
expr_stmt|;
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
operator|(
name|uns_long
operator|)
name|best_map
operator|.
name|brightness
argument_list|,
name|BRIGHTNESS_BITS
argument_list|)
expr_stmt|;
comment|/* When the contrast is null, the decompressor does not need to know        * which domain was selected: */
if|if
condition|(
name|best_map
operator|.
name|contrast
operator|==
literal|0
condition|)
return|return;
name|dom_number
operator|=
operator|(
name|uns_long
operator|)
name|best_dom
operator|->
name|y
operator|*
name|dom_info
index|[
name|s_log
index|]
operator|.
name|x_domains
operator|+
operator|(
name|uns_long
operator|)
name|best_dom
operator|->
name|x
expr_stmt|;
comment|/* The distance between two domains is the domain size 1<<(s_log+1)        * shifted right by the domain_density, so it is a power of two.        * The domain x and y positions have (s_log + 1 - dom_density) zero        * bits each, which we don't have to transmit.        */
name|OutputBits
argument_list|(
name|frac_file
argument_list|,
name|dom_number
operator|>>
operator|(
name|s_log
operator|+
literal|1
operator|-
name|dom_density
operator|)
argument_list|,
name|dom_info
index|[
name|s_log
index|]
operator|.
name|pos_bits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell the decompressor that no affine map follows because        * this range has been split:        */
name|OutputBit
argument_list|(
name|frac_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Split the range into 4 squares and process them recursively: */
name|compress_range
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|compress_range
argument_list|(
name|x
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|y
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|compress_range
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|compress_range
argument_list|(
name|x
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|y
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Quantize a value in the range 0.0 .. max to the range 0..imax  * ensuring that 0.0 is encoded as 0 and max as imax.  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|quantize (double value,double max,gint imax)
name|quantize
parameter_list|(
name|double
name|value
parameter_list|,
name|double
name|max
parameter_list|,
name|gint
name|imax
parameter_list|)
block|{
name|gint
name|ival
init|=
operator|(
name|gint
operator|)
name|floor
argument_list|(
operator|(
name|value
operator|/
name|max
operator|)
operator|*
call|(
name|double
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ival
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ival
operator|>
name|imax
condition|)
return|return
name|imax
return|;
return|return
name|ival
return|;
block|}
end_function

begin_comment
comment|/* Free all dynamically allocated data structures for compression. */
end_comment

begin_function
specifier|static
name|void
DECL|function|compress_cleanup (gint y_size)
name|compress_cleanup
parameter_list|(
name|gint
name|y_size
parameter_list|)
block|{
name|gint
name|s
decl_stmt|;
comment|/* size index for domains */
name|gint
name|class
decl_stmt|;
comment|/* class number */
name|domain_data
modifier|*
name|dom
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* domain pointers */
name|free_array
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|range
argument_list|,
name|y_size
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|domain
argument_list|,
name|y_size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cum_range
argument_list|,
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cum_range2
argument_list|,
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cum_domain2
argument_list|,
name|y_size
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|MIN_BITS
init|;
name|s
operator|<=
name|MAX_BITS
condition|;
name|s
operator|++
control|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|NCLASSES
condition|;
name|class
operator|++
control|)
for|for
control|(
name|dom
operator|=
name|domain_head
index|[
name|class
index|]
index|[
name|s
index|]
init|;
name|dom
operator|!=
name|NULL
condition|;
name|dom
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dom
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free a two dimensional array allocated as a set of rows. */
end_comment

begin_function
DECL|function|free_array (void ** array,gint rows)
specifier|static
name|void
name|free_array
parameter_list|(
name|void
modifier|*
modifier|*
name|array
parameter_list|,
name|gint
name|rows
parameter_list|)
block|{
name|gint
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
name|free
argument_list|(
name|array
index|[
name|row
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------IO Routines ------------------------ */
end_comment

begin_define
DECL|macro|PACIFIER_COUNT
define|#
directive|define
name|PACIFIER_COUNT
value|2047
end_define

begin_function
name|BIT_FILE
DECL|function|OpenOutputBitFile (FILE * fp,guint * cp)
modifier|*
name|OpenOutputBitFile
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
modifier|*
name|cp
parameter_list|)
block|{
name|BIT_FILE
modifier|*
name|bit_file
decl_stmt|;
name|bit_file
operator|=
operator|(
name|BIT_FILE
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BIT_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_file
operator|==
name|NULL
condition|)
return|return
operator|(
name|bit_file
operator|)
return|;
name|bit_file
operator|->
name|file
operator|=
name|fp
expr_stmt|;
name|bit_file
operator|->
name|cp
operator|=
name|cp
expr_stmt|;
name|bit_file
operator|->
name|rack
operator|=
literal|0
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
name|bit_file
operator|->
name|pacifier_counter
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bit_file
operator|)
return|;
block|}
end_function

begin_function
name|BIT_FILE
DECL|function|OpenInputBitFile (FILE * fp,guint * cp)
modifier|*
name|OpenInputBitFile
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
modifier|*
name|cp
parameter_list|)
block|{
name|BIT_FILE
modifier|*
name|bit_file
decl_stmt|;
name|bit_file
operator|=
operator|(
name|BIT_FILE
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BIT_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_file
operator|==
name|NULL
condition|)
return|return
operator|(
name|bit_file
operator|)
return|;
name|bit_file
operator|->
name|file
operator|=
name|fp
expr_stmt|;
name|bit_file
operator|->
name|cp
operator|=
name|cp
expr_stmt|;
name|bit_file
operator|->
name|rack
operator|=
literal|0
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
name|bit_file
operator|->
name|pacifier_counter
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bit_file
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|CloseOutputBitFile (BIT_FILE * bit_file)
name|CloseOutputBitFile
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
block|{
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|!=
literal|0x80
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|bit_file
operator|->
name|rack
argument_list|,
name|bit_file
operator|->
name|file
argument_list|)
operator|!=
name|bit_file
operator|->
name|rack
condition|)
name|g_error
argument_list|(
literal|"Fatal error in CloseOutputBitFile!\n"
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
operator|(
name|bit_file
operator|->
name|cp
operator|)
operator|)
operator|+=
literal|1
expr_stmt|;
block|}
comment|/*  fclose (bit_file->file );       free ((char *) bit_file);  */
block|}
end_function

begin_function
name|void
DECL|function|CloseInputBitFile (BIT_FILE * bit_file)
name|CloseInputBitFile
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
block|{
comment|/* fclose( bit_file->file );   free( (char *) bit_file ); */
block|}
end_function

begin_function
name|void
DECL|function|OutputBit (BIT_FILE * bit_file,gint bit)
name|OutputBit
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|gint
name|bit
parameter_list|)
block|{
if|if
condition|(
name|bit
condition|)
name|bit_file
operator|->
name|rack
operator||=
name|bit_file
operator|->
name|mask
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|bit_file
operator|->
name|rack
argument_list|,
name|bit_file
operator|->
name|file
argument_list|)
operator|!=
name|bit_file
operator|->
name|rack
condition|)
name|g_error
argument_list|(
literal|"Fatal error in OutputBit!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bit_file
operator|->
name|pacifier_counter
operator|++
operator|&
name|PACIFIER_COUNT
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
comment|/* putc succeeded */
operator|(
operator|*
operator|(
name|bit_file
operator|->
name|cp
operator|)
operator|)
operator|+=
literal|1
expr_stmt|;
name|bit_file
operator|->
name|rack
operator|=
literal|0
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|OutputBits (BIT_FILE * bit_file,unsigned long code,gint count)
name|OutputBits
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|unsigned
name|long
name|code
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|mask
operator|=
literal|1L
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|code
condition|)
name|bit_file
operator|->
name|rack
operator||=
name|bit_file
operator|->
name|mask
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|bit_file
operator|->
name|rack
argument_list|,
name|bit_file
operator|->
name|file
argument_list|)
operator|!=
name|bit_file
operator|->
name|rack
condition|)
name|g_error
argument_list|(
literal|"Fatal error in OutputBit!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bit_file
operator|->
name|pacifier_counter
operator|++
operator|&
name|PACIFIER_COUNT
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
comment|/* putc suceeded */
operator|(
operator|*
operator|(
name|bit_file
operator|->
name|cp
operator|)
operator|)
operator|+=
literal|1
expr_stmt|;
name|bit_file
operator|->
name|rack
operator|=
literal|0
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|InputBit (BIT_FILE * bit_file)
name|InputBit
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|)
block|{
name|gint
name|value
decl_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0x80
condition|)
block|{
name|bit_file
operator|->
name|rack
operator|=
name|getc
argument_list|(
name|bit_file
operator|->
name|file
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|bit_file
operator|->
name|cp
operator|)
operator|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|rack
operator|==
name|EOF
condition|)
name|g_error
argument_list|(
literal|"Fatal error in InputBit!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bit_file
operator|->
name|pacifier_counter
operator|++
operator|&
name|PACIFIER_COUNT
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|bit_file
operator|->
name|rack
operator|&
name|bit_file
operator|->
name|mask
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0
condition|)
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
return|return
operator|(
name|value
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
DECL|function|InputBits (BIT_FILE * bit_file,gint bit_count)
name|InputBits
parameter_list|(
name|BIT_FILE
modifier|*
name|bit_file
parameter_list|,
name|gint
name|bit_count
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|return_value
decl_stmt|;
name|mask
operator|=
literal|1L
operator|<<
operator|(
name|bit_count
operator|-
literal|1
operator|)
expr_stmt|;
name|return_value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0x80
condition|)
block|{
name|bit_file
operator|->
name|rack
operator|=
name|getc
argument_list|(
name|bit_file
operator|->
name|file
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|bit_file
operator|->
name|cp
operator|)
operator|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|rack
operator|==
name|EOF
condition|)
name|g_error
argument_list|(
literal|"Fatal error in InputBit!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bit_file
operator|->
name|pacifier_counter
operator|++
operator|&
name|PACIFIER_COUNT
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bit_file
operator|->
name|rack
operator|&
name|bit_file
operator|->
name|mask
condition|)
name|return_value
operator||=
name|mask
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
name|bit_file
operator|->
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit_file
operator|->
name|mask
operator|==
literal|0
condition|)
name|bit_file
operator|->
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|FilePrintBinary (FILE * file,guint code,gint bits)
name|FilePrintBinary
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|guint
name|code
parameter_list|,
name|gint
name|bits
parameter_list|)
block|{
name|guint
name|mask
decl_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|&
name|mask
condition|)
name|fputc
argument_list|(
literal|'1'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions used for decompression */
end_comment

begin_comment
comment|/* An affine map is described by a contrast, a brightness offset, a range    and a domain. The contrast and brightness are kept as integer values    to speed up the decompression on machines with slow floating point. */
end_comment

begin_typedef
DECL|struct|map_info_struct
typedef|typedef
struct|struct
name|map_info_struct
block|{
DECL|member|contrast
name|gint
name|contrast
decl_stmt|;
comment|/* contrast scaled by 16384 (to maintain precision) */
DECL|member|brightness
name|gint
name|brightness
decl_stmt|;
comment|/* brightness offset scaled by 128 */
DECL|member|x
name|gint
name|x
decl_stmt|;
comment|/* horizontal position of the range */
DECL|member|y
name|gint
name|y
decl_stmt|;
comment|/* vertical position of the range */
DECL|member|size
name|gint
name|size
decl_stmt|;
comment|/* range size */
DECL|member|dom_x
name|gint
name|dom_x
decl_stmt|;
comment|/* horizontal position of the domain */
DECL|member|dom_y
name|gint
name|dom_y
decl_stmt|;
comment|/* vertical position of the domain */
DECL|member|next
name|struct
name|map_info_struct
modifier|*
name|next
decl_stmt|;
comment|/* next map */
DECL|typedef|map_info
block|}
name|map_info
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|map_head
name|map_info
modifier|*
name|map_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|map_head
comment|/* head of the linked list of all affine maps */
end_comment

begin_comment
comment|/* Read the affine map for a range, or split the range if the compressor    did so in the function compress_range().  */
end_comment

begin_function
specifier|static
name|void
DECL|function|decompress_range (gint x,gint y,gint s_log)
name|decompress_range
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|s_log
parameter_list|)
block|{
comment|/* x, y;  horizontal and vertical position of the range /      s_log;    log base 2 of the range size */
name|gint
name|r_size
init|=
literal|1
operator|<<
name|s_log
decl_stmt|;
comment|/* range size */
name|map_info
modifier|*
name|map
decl_stmt|;
comment|/* pointer to affine map information */
name|double
name|contrast
decl_stmt|;
comment|/* contrast between range and domain */
name|double
name|brightness
decl_stmt|;
comment|/* brightness offset between range and domain */
name|double
name|max_scaled
decl_stmt|;
comment|/* maximum scaled value = contrast*MAX_GREY */
name|uns_long
name|dom_number
decl_stmt|;
comment|/* domain number */
comment|/* Read an affine map if the compressor has written one at this point: */
if|if
condition|(
name|s_log
operator|==
name|MIN_BITS
operator|||
name|InputBit
argument_list|(
name|frac_file
argument_list|)
condition|)
block|{
name|map
operator|=
operator|(
name|map_info
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|map_info
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|next
operator|=
name|map_head
expr_stmt|;
name|map_head
operator|=
name|map
expr_stmt|;
name|map
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|map
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|r_size
expr_stmt|;
name|map
operator|->
name|contrast
operator|=
operator|(
name|gint
operator|)
name|InputBits
argument_list|(
name|frac_file
argument_list|,
name|CONTRAST_BITS
argument_list|)
expr_stmt|;
name|map
operator|->
name|brightness
operator|=
operator|(
name|gint
operator|)
name|InputBits
argument_list|(
name|frac_file
argument_list|,
name|BRIGHTNESS_BITS
argument_list|)
expr_stmt|;
name|contrast
operator|=
name|dequantize
argument_list|(
name|map
operator|->
name|contrast
argument_list|,
name|MAX_CONTRAST
argument_list|,
name|MAX_QCONTRAST
argument_list|)
expr_stmt|;
name|max_scaled
operator|=
name|contrast
operator|*
name|MAX_GREY
expr_stmt|;
name|brightness
operator|=
name|dequantize
argument_list|(
name|map
operator|->
name|brightness
argument_list|,
name|max_scaled
operator|+
name|MAX_GREY
argument_list|,
name|MAX_QBRIGHTNESS
argument_list|)
operator|-
name|max_scaled
expr_stmt|;
comment|/* Scale the brightness by 128 to maintain precision later, while          * avoiding overflow with 16-bit arithmetic:          *     -255<= -contrast*255<= brightness<= 255          * so -32767< brightness*128< 32767          */
name|map
operator|->
name|brightness
operator|=
call|(
name|gint
call|)
argument_list|(
name|brightness
operator|*
literal|128.0
argument_list|)
expr_stmt|;
comment|/* When the contrast is null, the compressor did not encode the          * domain number:          */
if|if
condition|(
name|map
operator|->
name|contrast
operator|!=
literal|0
condition|)
block|{
comment|/* Scale the contrast by 16384 to maintain precision later.              *   0.0<= contrast<= 1.0 so 0<= contrast*16384<= 16384              */
name|map
operator|->
name|contrast
operator|=
call|(
name|gint
call|)
argument_list|(
name|contrast
operator|*
literal|16384.0
argument_list|)
expr_stmt|;
comment|/* Read the domain number, and add the zero bits that the              * compressor did not transmit:              */
name|dom_number
operator|=
name|InputBits
argument_list|(
name|frac_file
argument_list|,
name|dom_info
index|[
name|s_log
index|]
operator|.
name|pos_bits
argument_list|)
expr_stmt|;
name|map
operator|->
name|dom_x
operator|=
call|(
name|gint
call|)
argument_list|(
name|dom_number
operator|%
name|dom_info
index|[
name|s_log
index|]
operator|.
name|x_domains
argument_list|)
operator|<<
operator|(
name|s_log
operator|+
literal|1
operator|-
name|dom_density
operator|)
expr_stmt|;
name|map
operator|->
name|dom_y
operator|=
call|(
name|gint
call|)
argument_list|(
name|dom_number
operator|/
name|dom_info
index|[
name|s_log
index|]
operator|.
name|x_domains
argument_list|)
operator|<<
operator|(
name|s_log
operator|+
literal|1
operator|-
name|dom_density
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For a null contrast, use an arbitrary domain: */
name|map
operator|->
name|dom_x
operator|=
name|map
operator|->
name|dom_y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Scale the range and domain if necessary. This implementation          * uses only an integer scale to make sure that the union of all          * ranges is exactly the scaled image, that ranges never overlap,          * and that all range sizes are even.          */
if|if
condition|(
name|image_scale
operator|!=
literal|1
condition|)
block|{
name|map
operator|->
name|x
operator|*=
name|image_scale
expr_stmt|;
name|map
operator|->
name|y
operator|*=
name|image_scale
expr_stmt|;
name|map
operator|->
name|size
operator|*=
name|image_scale
expr_stmt|;
name|map
operator|->
name|dom_x
operator|*=
name|image_scale
expr_stmt|;
name|map
operator|->
name|dom_y
operator|*=
name|image_scale
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Split the range into 4 squares and process them recursively          * as in the compressor:          */
name|decompress_range
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|decompress_range
argument_list|(
name|x
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|y
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|decompress_range
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
name|decompress_range
argument_list|(
name|x
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|y
operator|+
name|r_size
operator|/
literal|2
argument_list|,
name|s_log
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Refine the image by applying one round of all affine maps on the   image. The "pure" method would compute a separate new image and then   copy it to the original image. However the convergence towards the   final image happens to be quicker if we overwrite the same image   while applying the affine maps; for the same quality of reconstructed   image we need fewer iterations. Overwriting the same image also   reduces the memory requirements.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|refine_image ()
name|refine_image
parameter_list|()
block|{
name|map_info
modifier|*
name|map
decl_stmt|;
comment|/* pointer to current affine map */
name|long
name|brightness
decl_stmt|;
comment|/* brightness offset of the map, scaled by 65536 */
name|long
name|val
decl_stmt|;
comment|/* new pixel value */
name|gint
name|y
decl_stmt|;
comment|/* vertical position in range */
name|gint
name|dom_y
decl_stmt|;
comment|/* vertical position in domain */
name|gint
name|j
decl_stmt|;
for|for
control|(
name|map
operator|=
name|map_head
init|;
name|map
operator|!=
name|NULL
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
block|{
comment|/* map->brightness is scaled by 128, so scale it again by 512 to          * get a total scale factor of 65536:          */
name|brightness
operator|=
operator|(
name|long
operator|)
name|map
operator|->
name|brightness
operator|<<
literal|9
expr_stmt|;
name|dom_y
operator|=
name|map
operator|->
name|dom_y
expr_stmt|;
for|for
control|(
name|y
operator|=
name|map
operator|->
name|y
init|;
name|y
operator|<
name|map
operator|->
name|y
operator|+
name|map
operator|->
name|size
condition|;
name|y
operator|++
control|)
block|{
comment|/* The following loop is the most time consuming, so we move              * some address calculations outside the loop:              */
comment|/*	  if (!range) 	    g_error ("range is null!\n"); 	  else 	    g_print ("range is alright\n"); 	    */
name|image_data
modifier|*
name|r
init|=
operator|&
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
index|]
decl_stmt|;
name|image_data
modifier|*
name|d
init|=
operator|&
name|range
index|[
name|dom_y
operator|++
index|]
index|[
name|map
operator|->
name|dom_x
index|]
decl_stmt|;
name|image_data
modifier|*
name|d1
init|=
operator|&
name|range
index|[
name|dom_y
operator|++
index|]
index|[
name|map
operator|->
name|dom_x
index|]
decl_stmt|;
name|j
operator|=
name|map
operator|->
name|size
expr_stmt|;
do|do
block|{
name|val
operator|=
operator|*
name|d
operator|++
operator|+
operator|*
name|d1
operator|++
expr_stmt|;
name|val
operator|+=
operator|*
name|d
operator|++
operator|+
operator|*
name|d1
operator|++
expr_stmt|;
comment|/* val is now scaled by 4 and map->contrast is scaled by 16384, 		   so val * map->contrast will be scaled by 65536. */
name|val
operator|=
name|val
operator|*
name|map
operator|->
name|contrast
operator|+
name|brightness
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|val
operator|>>=
literal|16
expr_stmt|;
comment|/* get rid of the 65536 scaling */
if|if
condition|(
name|val
operator|>=
name|MAX_GREY
condition|)
name|val
operator|=
name|MAX_GREY
expr_stmt|;
operator|*
name|r
operator|++
operator|=
operator|(
name|image_data
operator|)
name|val
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|j
operator|!=
literal|0
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Go through all ranges to smooth the transition between adjacent    ranges, except those of minimal size.    */
end_comment

begin_function
specifier|static
name|void
DECL|function|average_boundaries ()
name|average_boundaries
parameter_list|()
block|{
name|map_info
modifier|*
name|map
decl_stmt|;
comment|/* pointer to current affine map */
name|unsigned
name|val
decl_stmt|;
comment|/* sum of pixel value for current and adjacent ranges */
name|gint
name|x
decl_stmt|;
comment|/* horizontal position in current range */
name|gint
name|y
decl_stmt|;
comment|/* vertical position in current range */
for|for
control|(
name|map
operator|=
name|map_head
init|;
name|map
operator|!=
name|NULL
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
block|{
if|if
condition|(
name|map
operator|->
name|size
operator|==
operator|(
literal|1
operator|<<
name|MIN_BITS
operator|)
condition|)
continue|continue;
comment|/* range too small */
if|if
condition|(
name|map
operator|->
name|x
operator|>
literal|1
condition|)
block|{
comment|/* Smooth the left boundary of the range and the right boundary 	     of the adjacent range(s) to the left: 	     */
for|for
control|(
name|y
operator|=
name|map
operator|->
name|y
init|;
name|y
operator|<
name|map
operator|->
name|y
operator|+
name|map
operator|->
name|size
condition|;
name|y
operator|++
control|)
block|{
name|val
operator|=
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
operator|-
literal|1
index|]
operator|+
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
index|]
expr_stmt|;
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
operator|-
literal|1
index|]
operator|=
call|(
name|image_data
call|)
argument_list|(
operator|(
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
operator|-
literal|2
index|]
operator|+
name|val
operator|)
operator|/
literal|3
argument_list|)
expr_stmt|;
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
index|]
operator|=
call|(
name|image_data
call|)
argument_list|(
operator|(
name|val
operator|+
name|range
index|[
name|y
index|]
index|[
name|map
operator|->
name|x
operator|+
literal|1
index|]
operator|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map
operator|->
name|y
operator|>
literal|1
condition|)
block|{
comment|/* Smooth the top boundary of the range and the bottom boundary              * of the range(s) above:              */
for|for
control|(
name|x
operator|=
name|map
operator|->
name|x
init|;
name|x
operator|<
name|map
operator|->
name|x
operator|+
name|map
operator|->
name|size
condition|;
name|x
operator|++
control|)
block|{
name|val
operator|=
name|range
index|[
name|map
operator|->
name|y
operator|-
literal|1
index|]
index|[
name|x
index|]
operator|+
name|range
index|[
name|map
operator|->
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
name|range
index|[
name|map
operator|->
name|y
operator|-
literal|1
index|]
index|[
name|x
index|]
operator|=
call|(
name|image_data
call|)
argument_list|(
operator|(
name|range
index|[
name|map
operator|->
name|y
operator|-
literal|2
index|]
index|[
name|x
index|]
operator|+
name|val
operator|)
operator|/
literal|3
argument_list|)
expr_stmt|;
name|range
index|[
name|map
operator|->
name|y
index|]
index|[
name|x
index|]
operator|=
call|(
name|image_data
call|)
argument_list|(
operator|(
name|val
operator|+
name|range
index|[
name|map
operator|->
name|y
operator|+
literal|1
index|]
index|[
name|x
index|]
operator|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|pete_warn (char * tellPete)
name|pete_warn
parameter_list|(
name|char
modifier|*
name|tellPete
parameter_list|)
block|{
name|g_warning
argument_list|(
literal|"Pete, %s\n"
argument_list|,
name|tellPete
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|pete_fatal (char * shoutAtPete)
name|pete_fatal
parameter_list|(
name|char
modifier|*
name|shoutAtPete
parameter_list|)
block|{
name|g_error
argument_list|(
literal|"Pete, you are a dumbass because %s\n"
argument_list|,
name|shoutAtPete
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

