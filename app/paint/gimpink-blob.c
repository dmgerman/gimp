begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* blob.c: routines for manipulating scan converted convex  *         polygons.  *  * Copyright 1998-1999, Owen Taylor<otaylor@gtk.org>  *  *> Please contact the above author before modifying the copy<  *> of this file in the GIMP distribution. Thanks.<  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"paint-types.h"
end_include

begin_include
include|#
directive|include
file|"gimpink-blob.h"
end_include

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27fd0e050103
block|{
DECL|enumerator|EDGE_NONE
name|EDGE_NONE
init|=
literal|0
block|,
DECL|enumerator|EDGE_LEFT
name|EDGE_LEFT
init|=
literal|1
operator|<<
literal|0
block|,
DECL|enumerator|EDGE_RIGHT
name|EDGE_RIGHT
init|=
literal|1
operator|<<
literal|1
DECL|typedef|EdgeType
block|}
name|EdgeType
typedef|;
end_typedef

begin_comment
comment|/*  local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|Blob
modifier|*
name|blob_new
parameter_list|(
name|gint
name|y
parameter_list|,
name|gint
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blob_fill
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blob_make_convex
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void   blob_line_add_pixel (Blob     *b,                                    gint      x,                                    gint      y); static void   blob_line           (Blob     *b,                                    gint      x0,                                    gint      y0,                                    gint      x1,                                    gint      y1);
endif|#
directive|endif
end_endif

begin_comment
comment|/*  public functions  */
end_comment

begin_comment
comment|/* Return blob for the given (convex) polygon  */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_polygon (BlobPoint * points,gint npoints)
name|blob_polygon
parameter_list|(
name|BlobPoint
modifier|*
name|points
parameter_list|,
name|gint
name|npoints
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|im1
decl_stmt|;
name|gint
name|ip1
decl_stmt|;
name|gint
name|ymin
decl_stmt|,
name|ymax
decl_stmt|;
name|ymax
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|ymin
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|>
name|ymax
condition|)
name|ymax
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|ymin
condition|)
name|ymin
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
name|result
operator|=
name|blob_new
argument_list|(
name|ymin
argument_list|,
name|ymax
operator|-
name|ymin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|present
operator|=
name|g_new0
argument_list|(
name|EdgeType
argument_list|,
name|result
operator|->
name|height
argument_list|)
expr_stmt|;
name|im1
operator|=
name|npoints
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ip1
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|npoints
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|sides
init|=
literal|0
decl_stmt|;
name|gint
name|j
init|=
name|points
index|[
name|i
index|]
operator|.
name|y
operator|-
name|ymin
decl_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|points
index|[
name|im1
index|]
operator|.
name|y
condition|)
name|sides
operator||=
name|EDGE_RIGHT
expr_stmt|;
elseif|else
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|y
operator|>
name|points
index|[
name|im1
index|]
operator|.
name|y
condition|)
name|sides
operator||=
name|EDGE_LEFT
expr_stmt|;
if|if
condition|(
name|points
index|[
name|ip1
index|]
operator|.
name|y
operator|<
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
name|sides
operator||=
name|EDGE_RIGHT
expr_stmt|;
elseif|else
if|if
condition|(
name|points
index|[
name|ip1
index|]
operator|.
name|y
operator|>
name|points
index|[
name|i
index|]
operator|.
name|y
condition|)
name|sides
operator||=
name|EDGE_LEFT
expr_stmt|;
if|if
condition|(
name|sides
operator|&
name|EDGE_RIGHT
condition|)
block|{
if|if
condition|(
name|present
index|[
name|j
index|]
operator|&
name|EDGE_RIGHT
condition|)
block|{
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|j
index|]
operator||=
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sides
operator|&
name|EDGE_LEFT
condition|)
block|{
if|if
condition|(
name|present
index|[
name|j
index|]
operator|&
name|EDGE_LEFT
condition|)
block|{
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|j
index|]
operator||=
name|EDGE_LEFT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
block|}
name|im1
operator|=
name|i
expr_stmt|;
name|ip1
operator|++
expr_stmt|;
if|if
condition|(
name|ip1
operator|==
name|npoints
condition|)
name|ip1
operator|=
literal|0
expr_stmt|;
block|}
name|blob_fill
argument_list|(
name|result
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Scan convert a square specified by _offsets_ of major and minor  * axes, and by center into a blob  */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_square (gdouble xc,gdouble yc,gdouble xp,gdouble yp,gdouble xq,gdouble yq)
name|blob_square
parameter_list|(
name|gdouble
name|xc
parameter_list|,
name|gdouble
name|yc
parameter_list|,
name|gdouble
name|xp
parameter_list|,
name|gdouble
name|yp
parameter_list|,
name|gdouble
name|xq
parameter_list|,
name|gdouble
name|yq
parameter_list|)
block|{
name|BlobPoint
name|points
index|[
literal|4
index|]
decl_stmt|;
comment|/* Make sure we order points ccw */
if|if
condition|(
name|xp
operator|*
name|yq
operator|-
name|yq
operator|*
name|xp
operator|<
literal|0
condition|)
block|{
name|xq
operator|=
operator|-
name|xq
expr_stmt|;
name|yq
operator|=
operator|-
name|yq
expr_stmt|;
block|}
name|points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|xp
operator|+
name|xq
expr_stmt|;
name|points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|yp
operator|+
name|yq
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|xp
operator|-
name|xq
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|yp
operator|-
name|yq
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|xp
operator|-
name|xq
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|yp
operator|-
name|yq
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|xp
operator|+
name|xq
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|yp
operator|+
name|yq
expr_stmt|;
return|return
name|blob_polygon
argument_list|(
name|points
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan convert a diamond specified by _offsets_ of major and minor  * axes, and by center into a blob  */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_diamond (gdouble xc,gdouble yc,gdouble xp,gdouble yp,gdouble xq,gdouble yq)
name|blob_diamond
parameter_list|(
name|gdouble
name|xc
parameter_list|,
name|gdouble
name|yc
parameter_list|,
name|gdouble
name|xp
parameter_list|,
name|gdouble
name|yp
parameter_list|,
name|gdouble
name|xq
parameter_list|,
name|gdouble
name|yq
parameter_list|)
block|{
name|BlobPoint
name|points
index|[
literal|4
index|]
decl_stmt|;
comment|/* Make sure we order points ccw */
if|if
condition|(
name|xp
operator|*
name|yq
operator|-
name|yq
operator|*
name|xp
operator|<
literal|0
condition|)
block|{
name|xq
operator|=
operator|-
name|xq
expr_stmt|;
name|yq
operator|=
operator|-
name|yq
expr_stmt|;
block|}
name|points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|xp
expr_stmt|;
name|points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|yp
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|xq
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|yq
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|xp
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|yp
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|xq
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|yq
expr_stmt|;
return|return
name|blob_polygon
argument_list|(
name|points
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_define
DECL|macro|TABLE_SIZE
define|#
directive|define
name|TABLE_SIZE
value|256
end_define

begin_define
DECL|macro|ELLIPSE_SHIFT
define|#
directive|define
name|ELLIPSE_SHIFT
value|2
end_define

begin_define
DECL|macro|TABLE_SHIFT
define|#
directive|define
name|TABLE_SHIFT
value|12
end_define

begin_define
DECL|macro|TOTAL_SHIFT
define|#
directive|define
name|TOTAL_SHIFT
value|(ELLIPSE_SHIFT + TABLE_SHIFT)
end_define

begin_comment
comment|/*  * The choose of this values limits the maximal image_size to  * 16384 x 16384 pixels. The values will overflow as soon as  * x or y> INT_MAX / (1<< (ELLIPSE_SHIFT + TABLE_SHIFT)) / SUBSAMPLE  *  * Alternatively the code could be change the code as follows:  *  *   xc_base = floor (xc)  *   xc_shift = 0.5 + (xc - xc_base) * (1<< TOTAL_SHIFT);  *  *    gint x = xc_base + (xc_shift + c * xp_shift + s * xq_shift +  *             (1<< (TOTAL_SHIFT - 1)))>> TOTAL_SHIFT;  *  * which would change the limit from the image to the ellipse size  */
end_comment

begin_decl_stmt
DECL|variable|trig_initialized
specifier|static
name|gboolean
name|trig_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|trig_table
specifier|static
name|gint
name|trig_table
index|[
name|TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan convert an ellipse specified by _offsets_ of major and  * minor axes, and by center into a blob  */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_ellipse (gdouble xc,gdouble yc,gdouble xp,gdouble yp,gdouble xq,gdouble yq)
name|blob_ellipse
parameter_list|(
name|gdouble
name|xc
parameter_list|,
name|gdouble
name|yc
parameter_list|,
name|gdouble
name|xp
parameter_list|,
name|gdouble
name|yp
parameter_list|,
name|gdouble
name|xq
parameter_list|,
name|gdouble
name|yq
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gdouble
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|gint
name|maxy
decl_stmt|,
name|miny
decl_stmt|;
name|gint
name|step
decl_stmt|;
name|gdouble
name|max_radius
decl_stmt|;
name|gint
name|xc_shift
decl_stmt|,
name|yc_shift
decl_stmt|;
name|gint
name|xp_shift
decl_stmt|,
name|yp_shift
decl_stmt|;
name|gint
name|xq_shift
decl_stmt|,
name|yq_shift
decl_stmt|;
if|if
condition|(
operator|!
name|trig_initialized
condition|)
block|{
name|trig_initialized
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|trig_table
index|[
name|i
index|]
operator|=
literal|0.5
operator|+
name|sin
argument_list|(
name|i
operator|*
operator|(
name|G_PI
operator|/
literal|128.0
operator|)
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|TABLE_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* Make sure we traverse ellipse in ccw direction */
if|if
condition|(
name|xp
operator|*
name|yq
operator|-
name|yq
operator|*
name|xp
operator|<
literal|0
condition|)
block|{
name|xq
operator|=
operator|-
name|xq
expr_stmt|;
name|yq
operator|=
operator|-
name|yq
expr_stmt|;
block|}
comment|/* Compute bounds as if we were drawing a rectangle */
name|maxy
operator|=
name|ceil
argument_list|(
name|yc
operator|+
name|fabs
argument_list|(
name|yp
argument_list|)
operator|+
name|fabs
argument_list|(
name|yq
argument_list|)
argument_list|)
expr_stmt|;
name|miny
operator|=
name|floor
argument_list|(
name|yc
operator|-
name|fabs
argument_list|(
name|yp
argument_list|)
operator|-
name|fabs
argument_list|(
name|yq
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|blob_new
argument_list|(
name|miny
argument_list|,
name|maxy
operator|-
name|miny
operator|+
literal|1
argument_list|)
expr_stmt|;
name|present
operator|=
name|g_new0
argument_list|(
name|EdgeType
argument_list|,
name|result
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Figure out a step that will draw most of the points */
name|r1
operator|=
name|sqrt
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|xq
operator|*
name|xq
operator|+
name|yq
operator|*
name|yq
argument_list|)
expr_stmt|;
name|max_radius
operator|=
name|MAX
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|step
operator|=
name|TABLE_SIZE
expr_stmt|;
while|while
condition|(
name|step
operator|>
literal|1
operator|&&
operator|(
name|TABLE_SIZE
operator|/
name|step
operator|<
literal|4
operator|*
name|max_radius
operator|)
condition|)
name|step
operator|>>=
literal|1
expr_stmt|;
comment|/* Fill in the edge points */
name|xc_shift
operator|=
literal|0.5
operator|+
name|xc
operator|*
operator|(
literal|1
operator|<<
name|TOTAL_SHIFT
operator|)
expr_stmt|;
name|yc_shift
operator|=
literal|0.5
operator|+
name|yc
operator|*
operator|(
literal|1
operator|<<
name|TOTAL_SHIFT
operator|)
expr_stmt|;
name|xp_shift
operator|=
literal|0.5
operator|+
name|xp
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|yp_shift
operator|=
literal|0.5
operator|+
name|yp
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|xq_shift
operator|=
literal|0.5
operator|+
name|xq
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|yq_shift
operator|=
literal|0.5
operator|+
name|yq
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLE_SIZE
condition|;
name|i
operator|+=
name|step
control|)
block|{
name|gint
name|s
init|=
name|trig_table
index|[
name|i
index|]
decl_stmt|;
name|gint
name|c
init|=
name|trig_table
index|[
operator|(
name|TABLE_SIZE
operator|+
name|TABLE_SIZE
operator|/
literal|4
operator|-
name|i
operator|)
operator|%
name|TABLE_SIZE
index|]
decl_stmt|;
name|gint
name|x
init|=
operator|(
name|xc_shift
operator|+
name|c
operator|*
name|xp_shift
operator|+
name|s
operator|*
name|xq_shift
operator|+
operator|(
literal|1
operator|<<
operator|(
name|TOTAL_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|TOTAL_SHIFT
decl_stmt|;
name|gint
name|y
init|=
operator|(
operator|(
name|yc_shift
operator|+
name|c
operator|*
name|yp_shift
operator|+
name|s
operator|*
name|yq_shift
operator|+
operator|(
literal|1
operator|<<
operator|(
name|TOTAL_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|TOTAL_SHIFT
operator|)
operator|-
name|result
operator|->
name|y
decl_stmt|;
name|gint
name|dydi
init|=
name|c
operator|*
name|yq_shift
operator|-
name|s
operator|*
name|yp_shift
decl_stmt|;
if|if
condition|(
name|dydi
operator|<=
literal|0
condition|)
comment|/* left edge */
block|{
if|if
condition|(
name|present
index|[
name|y
index|]
operator|&
name|EDGE_LEFT
condition|)
block|{
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|y
index|]
operator||=
name|EDGE_LEFT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dydi
operator|>=
literal|0
condition|)
comment|/* right edge */
block|{
if|if
condition|(
name|present
index|[
name|y
index|]
operator|&
name|EDGE_RIGHT
condition|)
block|{
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|y
index|]
operator||=
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
operator|=
name|x
expr_stmt|;
block|}
block|}
block|}
comment|/* Now fill in missing points */
name|blob_fill
argument_list|(
name|result
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
DECL|function|blob_bounds (Blob * b,gint * x,gint * y,gint * width,gint * height)
name|blob_bounds
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|gint
modifier|*
name|x
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gint
modifier|*
name|width
parameter_list|,
name|gint
modifier|*
name|height
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|y0
decl_stmt|,
name|y1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|>
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|y0
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
name|x0
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|<=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
block|{
name|x0
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|y1
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|x0
operator|=
name|y0
operator|=
literal|0
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|x
operator|=
name|x0
expr_stmt|;
operator|*
name|y
operator|=
name|y0
expr_stmt|;
operator|*
name|width
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
operator|*
name|height
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
block|}
end_function

begin_function
name|Blob
modifier|*
DECL|function|blob_convex_union (Blob * b1,Blob * b2)
name|blob_convex_union
parameter_list|(
name|Blob
modifier|*
name|b1
parameter_list|,
name|Blob
modifier|*
name|b2
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|gint
name|y
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
comment|/* Create the storage for the result */
name|y
operator|=
name|MIN
argument_list|(
name|b1
operator|->
name|y
argument_list|,
name|b2
operator|->
name|y
argument_list|)
expr_stmt|;
name|result
operator|=
name|blob_new
argument_list|(
name|y
argument_list|,
name|MAX
argument_list|(
name|b1
operator|->
name|y
operator|+
name|b1
operator|->
name|height
argument_list|,
name|b2
operator|->
name|y
operator|+
name|b2
operator|->
name|height
argument_list|)
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|height
operator|==
literal|0
condition|)
return|return
name|result
return|;
name|present
operator|=
name|g_new0
argument_list|(
name|EdgeType
argument_list|,
name|result
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Initialize spans from original objects */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b1
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b1
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b2
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b2
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
if|if
condition|(
name|present
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|>
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|<
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
block|}
name|blob_make_convex
argument_list|(
name|result
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|Blob
modifier|*
DECL|function|blob_duplicate (Blob * b)
name|blob_duplicate
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|b
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|g_memdup
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|Blob
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BlobSpan
argument_list|)
operator|*
operator|(
name|b
operator|->
name|height
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void blob_dump (Blob *b) {   gint i,j;    for (i = 0; i< b->height; i++)     {       for (j = 0; j< b->data[i].left; j++)         putchar (' ');        for (j = b->data[i].left; j<= b->data[i].right; j++)         putchar ('*');        putchar ('\n');     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
name|Blob
modifier|*
DECL|function|blob_new (gint y,gint height)
name|blob_new
parameter_list|(
name|gint
name|y
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Blob
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BlobSpan
argument_list|)
operator|*
operator|(
name|height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|result
operator|->
name|height
operator|=
name|height
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_fill (Blob * b,EdgeType * present)
name|blob_fill
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
block|{
name|gint
name|start
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Mark empty lines at top and bottom as unused */
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|present
index|[
name|start
index|]
condition|)
block|{
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|present
index|[
name|start
index|]
operator|!=
operator|(
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
operator|)
condition|)
block|{
if|if
condition|(
name|present
index|[
name|start
index|]
operator|==
name|EDGE_RIGHT
condition|)
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|present
index|[
name|start
index|]
operator|=
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|b
operator|->
name|height
operator|-
literal|1
init|;
operator|!
name|present
index|[
name|i
index|]
condition|;
name|i
operator|--
control|)
block|{
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|present
index|[
name|i
index|]
operator|!=
operator|(
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
operator|)
condition|)
block|{
if|if
condition|(
name|present
index|[
name|i
index|]
operator|==
name|EDGE_RIGHT
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|present
index|[
name|i
index|]
operator|=
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
expr_stmt|;
block|}
comment|/* Restore missing edges  */
comment|/* We fill only interior regions of convex hull, as if we were    * filling polygons. But since we draw ellipses with nearest points,    * not interior points, maybe it would look better if we did the    * same here. Probably not a big deal either way after anti-aliasing    */
comment|/* left edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|b
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
block|{
name|gint
name|increment
decl_stmt|;
comment|/* fractional part */
name|gint
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|gint
name|step
decl_stmt|;
comment|/* integral step */
name|gint
name|frac
decl_stmt|;
comment|/* fractional step */
name|gint
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|i2
operator|<
name|b
operator|->
name|height
operator|&&
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|increment
operator|==
literal|0
operator|||
name|reverse
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
comment|/* right edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|b
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
block|{
name|gint
name|increment
decl_stmt|;
comment|/* fractional part */
name|gint
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|gint
name|step
decl_stmt|;
comment|/* integral step */
name|gint
name|frac
decl_stmt|;
comment|/* fractional step */
name|gint
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|i2
operator|<
name|b
operator|->
name|height
operator|&&
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|&&
name|increment
operator|!=
literal|0
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
operator|-
literal|1
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_make_convex (Blob * b,EdgeType * present)
name|blob_make_convex
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
block|{
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|start
decl_stmt|;
comment|/* Walk through edges, deleting points that aren't on convex hull */
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|present
index|[
name|start
index|]
condition|)
name|start
operator|++
expr_stmt|;
comment|/*    left edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|<
literal|0
condition|)
comment|/* clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_LEFT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|i1
operator|)
operator|>=
name|start
operator|&&
operator|(
operator|!
operator|(
name|present
index|[
name|i1
index|]
operator|&
name|EDGE_LEFT
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
comment|/*     Right edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|>
literal|0
condition|)
comment|/* counter-clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_RIGHT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|i1
operator|)
operator|>=
name|start
operator|&&
operator|(
operator|!
operator|(
name|present
index|[
name|i1
index|]
operator|&
name|EDGE_RIGHT
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
name|blob_fill
argument_list|(
name|b
argument_list|,
name|present
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void blob_line_add_pixel (Blob *b,                      gint  x,                      gint  y) {   if (b->data[y - b->y].left> b->data[y - b->y].right)     {       b->data[y - b->y].left = b->data[y - b->y].right = x;     }   else     {       b->data[y - b->y].left  = MIN (b->data[y - b->y].left,  x);       b->data[y - b->y].right = MAX (b->data[y - b->y].right, x);     } }  static void blob_line (Blob *b,            gint  x0,            gint  y0,            gint  x1,            gint  y1) {   gint dx, dy, d;   gint incrE, incrNE;   gint x, y;    gint xstep = 1;   gint ystep = 1;    dx = x1 - x0;   dy = y1 - y0;    if (dx< 0)     {       dx = -dx;       xstep = -1;     }    if (dy< 0)     {       dy = -dy;       ystep = -1;     }
comment|/*  for (y = y0; y != y1 + ystep ; y += ystep)     {       b->data[y-b->y].left = 0;       b->data[y-b->y].right = -1;       }*/
end_comment

begin_comment
unit|x = x0;   y = y0;    if (dy< dx)     {       d = 2 * dy - dx;
comment|/* initial value of d */
end_comment

begin_comment
unit|incrE  = 2 * dy;
comment|/* increment used for move to E */
end_comment

begin_comment
unit|incrNE = 2 * (dy - dx);
comment|/* increment used for move to NE */
end_comment

begin_comment
unit|blob_line_add_pixel (b, x, y);        while (x != x1)         {           if (d<= 0)             {               d += incrE;               x += xstep;             }           else             {               d += incrNE;               x += xstep;               y += ystep;             }            blob_line_add_pixel (b, x, y);         }     }   else     {       d = 2 * dx - dy;
comment|/* initial value of d */
end_comment

begin_comment
unit|incrE  = 2 * dx;
comment|/* increment used for move to E */
end_comment

begin_comment
unit|incrNE = 2 * (dx - dy);
comment|/* increment used for move to NE */
end_comment

begin_endif
unit|blob_line_add_pixel (b, x, y);        while (y != y1)         {           if (d<= 0)             {               d += incrE;               y += ystep;             }           else             {               d += incrNE;               x += xstep;               y += ystep;             }            blob_line_add_pixel (b, x, y);         }     } }
endif|#
directive|endif
end_endif

end_unit

