begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* blob.c: routines for manipulating scan converted convex  *         polygons.  *    * Copyright 1998-1999, Owen Taylor<otaylor@gtk.org>  *  *> Please contact the above author before modifying the copy<  *> of this file in the GIMP distribution. Thanks.<  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"blob.h"
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
DECL|macro|ROUND (A)
define|#
directive|define
name|ROUND
parameter_list|(
name|A
parameter_list|)
value|floor((A)+0.5)
end_define

begin_function
specifier|static
name|Blob
modifier|*
DECL|function|blob_new (int y,int height)
name|blob_new
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Blob
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BlobSpan
argument_list|)
operator|*
operator|(
name|height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|result
operator|->
name|height
operator|=
name|height
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
DECL|enum|__anon28a273f90103
typedef|typedef
enum|enum
block|{
DECL|enumerator|EDGE_NONE
name|EDGE_NONE
init|=
literal|0
block|,
DECL|enumerator|EDGE_LEFT
name|EDGE_LEFT
init|=
literal|1
operator|<<
literal|0
block|,
DECL|enumerator|EDGE_RIGHT
name|EDGE_RIGHT
init|=
literal|1
operator|<<
literal|1
DECL|typedef|EdgeType
block|}
name|EdgeType
typedef|;
end_typedef

begin_function
specifier|static
name|void
DECL|function|blob_fill (Blob * b,EdgeType * present)
name|blob_fill
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Mark empty lines at top and bottom as unused */
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|start
index|]
operator|)
condition|)
block|{
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|present
index|[
name|start
index|]
operator|!=
operator|(
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
operator|)
condition|)
block|{
if|if
condition|(
name|present
index|[
name|start
index|]
operator|==
name|EDGE_RIGHT
condition|)
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|present
index|[
name|start
index|]
operator|=
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|b
operator|->
name|height
operator|-
literal|1
init|;
operator|!
name|present
index|[
name|i
index|]
condition|;
name|i
operator|--
control|)
block|{
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|present
index|[
name|i
index|]
operator|!=
operator|(
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
operator|)
condition|)
block|{
if|if
condition|(
name|present
index|[
name|i
index|]
operator|==
name|EDGE_RIGHT
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|present
index|[
name|i
index|]
operator|=
name|EDGE_RIGHT
operator||
name|EDGE_LEFT
expr_stmt|;
block|}
comment|/* Restore missing edges  */
comment|/* We fill only interior regions of convex hull, as if we were filling      polygons. But since we draw ellipses with nearest points, not interior      points, maybe it would look better if we did the same here. Probably      not a big deal either way after anti-aliasing */
comment|/*     left edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|b
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
block|{
name|int
name|increment
decl_stmt|;
comment|/* fractional part */
name|int
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|int
name|step
decl_stmt|;
comment|/* integral step */
name|int
name|frac
decl_stmt|;
comment|/* fractional step */
name|int
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_LEFT
operator|)
operator|&&
name|i2
operator|<
name|b
operator|->
name|height
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|increment
operator|==
literal|0
operator|||
name|reverse
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|=
name|x1
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
comment|/*     right edge */
for|for
control|(
name|i1
operator|=
name|start
init|;
name|i1
operator|<
name|b
operator|->
name|height
operator|-
literal|2
condition|;
name|i1
operator|++
control|)
block|{
comment|/* Find empty gaps */
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i1
operator|+
literal|1
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
block|{
name|int
name|increment
decl_stmt|;
comment|/* fractional part */
name|int
name|denom
decl_stmt|;
comment|/* denominator of fraction */
name|int
name|step
decl_stmt|;
comment|/* integral step */
name|int
name|frac
decl_stmt|;
comment|/* fractional step */
name|int
name|reverse
decl_stmt|;
comment|/* find bottom of gap */
name|i2
operator|=
name|i1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|i2
index|]
operator|&
name|EDGE_RIGHT
operator|)
operator|&&
name|i2
operator|<
name|b
operator|->
name|height
condition|)
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|denom
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|step
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|denom
expr_stmt|;
name|frac
operator|=
name|x2
operator|-
name|x1
operator|-
name|step
operator|*
name|denom
expr_stmt|;
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
block|{
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i1
operator|+
literal|1
init|;
name|i
operator|<
name|i2
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|+=
name|step
expr_stmt|;
name|increment
operator|+=
name|frac
expr_stmt|;
if|if
condition|(
name|increment
operator|>=
name|denom
condition|)
block|{
name|increment
operator|-=
name|denom
expr_stmt|;
name|x1
operator|+=
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|&&
name|increment
operator|!=
literal|0
condition|)
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
operator|-
literal|1
expr_stmt|;
else|else
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|=
name|x1
expr_stmt|;
block|}
block|}
name|i1
operator|=
name|i2
operator|-
literal|1
expr_stmt|;
comment|/* advance to next possibility */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_make_convex (Blob * b,EdgeType * present)
name|blob_make_convex
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|EdgeType
modifier|*
name|present
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|start
decl_stmt|;
comment|/* Walk through edges, deleting points that aren't on convex hull */
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
name|start
index|]
operator|)
condition|)
name|start
operator|++
expr_stmt|;
comment|/*    left edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_LEFT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|<
literal|0
condition|)
comment|/* clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_LEFT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
operator|--
name|i1
index|]
operator|&
name|EDGE_LEFT
operator|)
operator|&&
name|i1
operator|>=
name|start
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|left
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
comment|/*     Right edge */
name|i1
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|start
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|present
index|[
name|i
index|]
operator|&
name|EDGE_RIGHT
operator|)
condition|)
continue|continue;
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
while|while
condition|(
name|x2
operator|*
name|y1
operator|-
name|x1
operator|*
name|y2
operator|>
literal|0
condition|)
comment|/* counter-clockwise rotation */
block|{
name|present
index|[
name|i2
index|]
operator|&=
operator|~
name|EDGE_RIGHT
expr_stmt|;
name|i2
operator|=
name|i1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|present
index|[
operator|--
name|i1
index|]
operator|&
name|EDGE_RIGHT
operator|)
operator|&&
name|i1
operator|>=
name|start
condition|)
empty_stmt|;
if|if
condition|(
name|i1
operator|<
name|start
condition|)
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|start
index|]
operator|.
name|left
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i1
index|]
operator|.
name|right
expr_stmt|;
name|y1
operator|=
name|i2
operator|-
name|i1
expr_stmt|;
block|}
name|x2
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|-
name|b
operator|->
name|data
index|[
name|i2
index|]
operator|.
name|right
expr_stmt|;
name|y2
operator|=
name|i
operator|-
name|i2
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|i1
operator|=
name|i2
expr_stmt|;
name|i2
operator|=
name|i
expr_stmt|;
block|}
name|blob_fill
argument_list|(
name|b
argument_list|,
name|present
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Blob
modifier|*
DECL|function|blob_convex_union (Blob * b1,Blob * b2)
name|blob_convex_union
parameter_list|(
name|Blob
modifier|*
name|b1
parameter_list|,
name|Blob
modifier|*
name|b2
parameter_list|)
block|{
name|Blob
modifier|*
name|result
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|start
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
comment|/* Create the storage for the result */
name|y
operator|=
name|MIN
argument_list|(
name|b1
operator|->
name|y
argument_list|,
name|b2
operator|->
name|y
argument_list|)
expr_stmt|;
name|result
operator|=
name|blob_new
argument_list|(
name|y
argument_list|,
name|MAX
argument_list|(
name|b1
operator|->
name|y
operator|+
name|b1
operator|->
name|height
argument_list|,
name|b2
operator|->
name|y
operator|+
name|b2
operator|->
name|height
argument_list|)
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|height
operator|==
literal|0
condition|)
return|return
name|result
return|;
name|present
operator|=
name|g_new0
argument_list|(
name|EdgeType
argument_list|,
name|result
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Initialize spans from original objects */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b1
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b1
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b1
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|b2
operator|->
name|y
operator|-
name|y
init|;
name|i
operator|<
name|b2
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|>=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
block|{
if|if
condition|(
name|present
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|>
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|<
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|j
index|]
operator|=
name|EDGE_LEFT
operator||
name|EDGE_RIGHT
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|left
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|result
operator|->
name|data
index|[
name|j
index|]
operator|.
name|right
operator|=
name|b2
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
block|}
block|}
block|}
name|blob_make_convex
argument_list|(
name|result
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|blob_line_add_pixel (Blob * b,int x,int y)
name|blob_line_add_pixel
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|>
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
condition|)
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|x
expr_stmt|;
else|else
block|{
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|left
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|y
operator|-
name|b
operator|->
name|y
index|]
operator|.
name|right
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|blob_line (Blob * b,int x0,int y0,int x1,int y1)
name|blob_line
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|d
decl_stmt|;
name|int
name|incrE
decl_stmt|,
name|incrNE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xstep
init|=
literal|1
decl_stmt|;
name|int
name|ystep
init|=
literal|1
decl_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|xstep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|ystep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/*  for (y = y0; y != y1 + ystep ; y += ystep)     {       b->data[y-b->y].left = 0;       b->data[y-b->y].right = -1;       }*/
name|x
operator|=
name|x0
expr_stmt|;
name|y
operator|=
name|y0
expr_stmt|;
if|if
condition|(
name|dy
operator|<
name|dx
condition|)
block|{
name|d
operator|=
literal|2
operator|*
name|dy
operator|-
name|dx
expr_stmt|;
comment|/* initial value of d */
name|incrE
operator|=
literal|2
operator|*
name|dy
expr_stmt|;
comment|/* increment used for move to E */
name|incrNE
operator|=
literal|2
operator|*
operator|(
name|dy
operator|-
name|dx
operator|)
expr_stmt|;
comment|/* increment used for move to NE */
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
name|d
operator|+=
name|incrE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
block|}
else|else
block|{
name|d
operator|+=
name|incrNE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|=
literal|2
operator|*
name|dx
operator|-
name|dy
expr_stmt|;
comment|/* initial value of d */
name|incrE
operator|=
literal|2
operator|*
name|dx
expr_stmt|;
comment|/* increment used for move to E */
name|incrNE
operator|=
literal|2
operator|*
operator|(
name|dx
operator|-
name|dy
operator|)
expr_stmt|;
comment|/* increment used for move to NE */
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
name|d
operator|+=
name|incrE
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
else|else
block|{
name|d
operator|+=
name|incrNE
expr_stmt|;
name|x
operator|+=
name|xstep
expr_stmt|;
name|y
operator|+=
name|ystep
expr_stmt|;
block|}
name|blob_line_add_pixel
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
DECL|macro|TABLE_SIZE
define|#
directive|define
name|TABLE_SIZE
value|256
end_define

begin_define
DECL|macro|ELLIPSE_SHIFT
define|#
directive|define
name|ELLIPSE_SHIFT
value|2
end_define

begin_define
DECL|macro|TABLE_SHIFT
define|#
directive|define
name|TABLE_SHIFT
value|14
end_define

begin_define
DECL|macro|TOTAL_SHIFT
define|#
directive|define
name|TOTAL_SHIFT
value|ELLIPSE_SHIFT + TABLE_SHIFT
end_define

begin_decl_stmt
DECL|variable|trig_initialized
specifier|static
name|int
name|trig_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|trig_table
specifier|static
name|int
name|trig_table
index|[
name|TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan convert an ellipse specified by _offsets_ of major and    minor axes, and by center into a blob */
end_comment

begin_function
name|Blob
modifier|*
DECL|function|blob_ellipse (double xc,double yc,double xp,double yp,double xq,double yq)
name|blob_ellipse
parameter_list|(
name|double
name|xc
parameter_list|,
name|double
name|yc
parameter_list|,
name|double
name|xp
parameter_list|,
name|double
name|yp
parameter_list|,
name|double
name|xq
parameter_list|,
name|double
name|yq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Blob
modifier|*
name|r
decl_stmt|;
name|gdouble
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|gint
name|maxy
decl_stmt|,
name|miny
decl_stmt|;
name|gint
name|step
decl_stmt|;
name|double
name|max_radius
decl_stmt|;
name|gint
name|xc_shift
decl_stmt|,
name|yc_shift
decl_stmt|;
name|gint
name|xp_shift
decl_stmt|,
name|yp_shift
decl_stmt|;
name|gint
name|xq_shift
decl_stmt|,
name|yq_shift
decl_stmt|;
name|EdgeType
modifier|*
name|present
decl_stmt|;
if|if
condition|(
operator|!
name|trig_initialized
condition|)
block|{
name|trig_initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|trig_table
index|[
name|i
index|]
operator|=
literal|0.5
operator|+
name|sin
argument_list|(
name|i
operator|*
operator|(
name|M_PI
operator|/
literal|128.
operator|)
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|TABLE_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* Make sure we traverse ellipse in ccw direction */
if|if
condition|(
name|xp
operator|*
name|yq
operator|-
name|yq
operator|*
name|xp
operator|<
literal|0
condition|)
block|{
name|xq
operator|=
operator|-
name|xq
expr_stmt|;
name|yq
operator|=
operator|-
name|yq
expr_stmt|;
block|}
comment|/* Compute bounds as if we were drawing a rectangle */
name|maxy
operator|=
name|ceil
argument_list|(
name|yc
operator|+
name|fabs
argument_list|(
name|yp
argument_list|)
operator|+
name|fabs
argument_list|(
name|yq
argument_list|)
argument_list|)
expr_stmt|;
name|miny
operator|=
name|floor
argument_list|(
name|yc
operator|-
name|fabs
argument_list|(
name|yp
argument_list|)
operator|-
name|fabs
argument_list|(
name|yq
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|blob_new
argument_list|(
name|miny
argument_list|,
name|maxy
operator|-
name|miny
operator|+
literal|1
argument_list|)
expr_stmt|;
name|present
operator|=
name|g_new0
argument_list|(
name|EdgeType
argument_list|,
name|r
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Figure out a step that will draw most of the points */
name|r1
operator|=
name|sqrt
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
expr_stmt|;
name|max_radius
operator|=
name|MAX
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|step
operator|=
name|TABLE_SIZE
expr_stmt|;
while|while
condition|(
name|step
operator|>
literal|1
operator|&&
operator|(
name|TABLE_SIZE
operator|/
name|step
operator|<
literal|4
operator|*
name|max_radius
operator|)
condition|)
name|step
operator|>>=
literal|1
expr_stmt|;
comment|/* Fill in the edge points */
name|xc_shift
operator|=
literal|0.5
operator|+
name|xc
operator|*
operator|(
literal|1
operator|<<
name|TOTAL_SHIFT
operator|)
expr_stmt|;
name|yc_shift
operator|=
literal|0.5
operator|+
name|yc
operator|*
operator|(
literal|1
operator|<<
name|TOTAL_SHIFT
operator|)
expr_stmt|;
name|xp_shift
operator|=
literal|0.5
operator|+
name|xp
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|yp_shift
operator|=
literal|0.5
operator|+
name|yp
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|xq_shift
operator|=
literal|0.5
operator|+
name|xq
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
name|yq_shift
operator|=
literal|0.5
operator|+
name|yq
operator|*
operator|(
literal|1
operator|<<
name|ELLIPSE_SHIFT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLE_SIZE
condition|;
name|i
operator|+=
name|step
control|)
block|{
name|gint
name|s
init|=
name|trig_table
index|[
name|i
index|]
decl_stmt|;
name|gint
name|c
init|=
name|trig_table
index|[
operator|(
name|TABLE_SIZE
operator|+
name|TABLE_SIZE
operator|/
literal|4
operator|-
name|i
operator|)
operator|%
name|TABLE_SIZE
index|]
decl_stmt|;
name|gint
name|x
init|=
operator|(
name|xc_shift
operator|+
name|c
operator|*
name|xp_shift
operator|+
name|s
operator|*
name|xq_shift
operator|+
operator|(
literal|1
operator|<<
operator|(
name|TOTAL_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|TOTAL_SHIFT
decl_stmt|;
name|gint
name|y
init|=
operator|(
operator|(
name|yc_shift
operator|+
name|c
operator|*
name|yp_shift
operator|+
name|s
operator|*
name|yq_shift
operator|+
operator|(
literal|1
operator|<<
operator|(
name|TOTAL_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|TOTAL_SHIFT
operator|)
operator|-
name|r
operator|->
name|y
decl_stmt|;
name|gint
name|dydi
init|=
name|c
operator|*
name|yq_shift
operator|-
name|s
operator|*
name|yp_shift
decl_stmt|;
if|if
condition|(
name|dydi
operator|<=
literal|0
condition|)
comment|/* left edge */
block|{
if|if
condition|(
name|present
index|[
name|y
index|]
operator|&
name|EDGE_LEFT
condition|)
block|{
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
operator|=
name|MIN
argument_list|(
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|y
index|]
operator||=
name|EDGE_LEFT
expr_stmt|;
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|left
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dydi
operator|>=
literal|0
condition|)
comment|/* right edge */
block|{
if|if
condition|(
name|present
index|[
name|y
index|]
operator|&
name|EDGE_RIGHT
condition|)
block|{
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
operator|=
name|MAX
argument_list|(
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|present
index|[
name|y
index|]
operator||=
name|EDGE_RIGHT
expr_stmt|;
name|r
operator|->
name|data
index|[
name|y
index|]
operator|.
name|right
operator|=
name|x
expr_stmt|;
block|}
block|}
block|}
comment|/* Now fill in missing points */
name|blob_fill
argument_list|(
name|r
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|present
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
DECL|function|blob_bounds (Blob * b,int * x,int * y,int * width,int * height)
name|blob_bounds
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|height
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|y0
decl_stmt|,
name|y1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|>
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|b
operator|->
name|height
condition|)
block|{
name|y0
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
name|x0
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|x1
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|b
operator|->
name|height
operator|&&
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
operator|<=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|)
block|{
name|x0
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|MAX
argument_list|(
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
operator|+
literal|1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|y1
operator|=
name|b
operator|->
name|y
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|x0
operator|=
name|y0
operator|=
literal|0
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|x
operator|=
name|x0
expr_stmt|;
operator|*
name|y
operator|=
name|y0
expr_stmt|;
operator|*
name|width
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
operator|*
name|height
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|blob_dump (Blob * b)
name|blob_dump
parameter_list|(
name|Blob
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|left
init|;
name|j
operator|<=
name|b
operator|->
name|data
index|[
name|i
index|]
operator|.
name|right
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

