begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"appenv.h"
end_include

begin_include
include|#
directive|include
file|"brushes.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"paint_core.h"
end_include

begin_include
include|#
directive|include
file|"palette.h"
end_include

begin_include
include|#
directive|include
file|"eraser.h"
end_include

begin_include
include|#
directive|include
file|"selection.h"
end_include

begin_include
include|#
directive|include
file|"tools.h"
end_include

begin_comment
comment|/*  forward function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|eraser_motion
parameter_list|(
name|PaintCore
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|gboolean
parameter_list|,
name|gboolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|eraser_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Argument
modifier|*
name|eraser_extended_invoker
parameter_list|(
name|Argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|non_gui_hard
DECL|variable|non_gui_incremental
specifier|static
name|gboolean
name|non_gui_hard
decl_stmt|,
name|non_gui_incremental
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|typedef|EraserOptions
typedef|typedef
name|struct
name|_EraserOptions
name|EraserOptions
typedef|;
end_typedef

begin_struct
DECL|struct|_EraserOptions
struct|struct
name|_EraserOptions
block|{
DECL|member|hard
name|gboolean
name|hard
decl_stmt|;
DECL|member|incremental
name|gboolean
name|incremental
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|eraser_options
specifier|static
name|EraserOptions
modifier|*
name|eraser_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|eraser_toggle_update (GtkWidget * w,gpointer data)
name|eraser_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gboolean
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|gboolean
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|w
argument_list|)
operator|->
name|active
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|EraserOptions
modifier|*
DECL|function|create_eraser_options (void)
name|create_eraser_options
parameter_list|(
name|void
parameter_list|)
block|{
name|EraserOptions
modifier|*
name|options
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|hard_toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|incremental_toggle
decl_stmt|;
name|options
operator|=
operator|(
name|EraserOptions
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EraserOptions
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|->
name|hard
operator|=
name|FALSE
expr_stmt|;
name|options
operator|->
name|incremental
operator|=
name|FALSE
expr_stmt|;
comment|/*  the main vbox  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  the main label  */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Eraser Options"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* the hard toggle */
name|hard_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Hard edge"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hard_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|hard_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|eraser_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|hard
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|hard_toggle
argument_list|)
argument_list|,
name|options
operator|->
name|hard
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hard_toggle
argument_list|)
expr_stmt|;
comment|/* the incremental toggle */
name|incremental_toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Incremental"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|incremental_toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|incremental_toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|eraser_toggle_update
argument_list|,
operator|&
name|options
operator|->
name|incremental
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|incremental_toggle
argument_list|)
argument_list|,
name|options
operator|->
name|incremental
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|incremental_toggle
argument_list|)
expr_stmt|;
comment|/*  Register this eraser options widget with the main tools options dialog  */
name|tools_register_options
argument_list|(
name|ERASER
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
name|void
modifier|*
DECL|function|eraser_paint_func (paint_core,drawable,state)
name|eraser_paint_func
parameter_list|(
name|paint_core
parameter_list|,
name|drawable
parameter_list|,
name|state
parameter_list|)
name|PaintCore
modifier|*
name|paint_core
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|INIT_PAINT
case|:
break|break;
case|case
name|MOTION_PAINT
case|:
name|eraser_motion
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|eraser_options
operator|->
name|hard
argument_list|,
name|eraser_options
operator|->
name|incremental
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINISH_PAINT
case|:
break|break;
default|default :
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Tool
modifier|*
DECL|function|tools_new_eraser ()
name|tools_new_eraser
parameter_list|()
block|{
name|Tool
modifier|*
name|tool
decl_stmt|;
name|PaintCore
modifier|*
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|eraser_options
condition|)
name|eraser_options
operator|=
name|create_eraser_options
argument_list|()
expr_stmt|;
name|tool
operator|=
name|paint_core_new
argument_list|(
name|ERASER
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
name|PaintCore
operator|*
operator|)
name|tool
operator|->
name|private
expr_stmt|;
name|private
operator|->
name|paint_func
operator|=
name|eraser_paint_func
expr_stmt|;
return|return
name|tool
return|;
block|}
end_function

begin_function
name|void
DECL|function|tools_free_eraser (tool)
name|tools_free_eraser
parameter_list|(
name|tool
parameter_list|)
name|Tool
modifier|*
name|tool
decl_stmt|;
block|{
name|paint_core_free
argument_list|(
name|tool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|eraser_motion (PaintCore * paint_core,GimpDrawable * drawable,gboolean hard,gboolean incremental)
name|eraser_motion
parameter_list|(
name|PaintCore
modifier|*
name|paint_core
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gboolean
name|hard
parameter_list|,
name|gboolean
name|incremental
parameter_list|)
block|{
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|gint
name|opacity
decl_stmt|;
name|TempBuf
modifier|*
name|area
decl_stmt|;
name|unsigned
name|char
name|col
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
operator|)
condition|)
return|return;
name|gimage_get_background
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|)
expr_stmt|;
comment|/*  Get a region which can be used to paint to  */
if|if
condition|(
operator|!
operator|(
name|area
operator|=
name|paint_core_get_paint_area
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|)
operator|)
condition|)
return|return;
comment|/*  set the alpha channel  */
name|col
index|[
name|area
operator|->
name|bytes
operator|-
literal|1
index|]
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
comment|/*  color the pixels  */
name|color_pixels
argument_list|(
name|temp_buf_data
argument_list|(
name|area
argument_list|)
argument_list|,
name|col
argument_list|,
name|area
operator|->
name|width
operator|*
name|area
operator|->
name|height
argument_list|,
name|area
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|opacity
operator|=
literal|255
operator|*
name|get_brush_opacity
argument_list|()
operator|*
operator|(
name|paint_core
operator|->
name|curpressure
operator|/
literal|0.5
operator|)
expr_stmt|;
if|if
condition|(
name|opacity
operator|>
name|OPAQUE_OPACITY
condition|)
name|opacity
operator|=
name|OPAQUE_OPACITY
expr_stmt|;
comment|/*  paste the newly painted canvas to the gimage which is being worked on  */
name|paint_core_paste_canvas
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|opacity
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_brush_opacity
argument_list|()
operator|*
literal|255
argument_list|)
argument_list|,
name|ERASE_MODE
argument_list|,
name|hard
condition|?
name|HARD
else|:
name|SOFT
argument_list|,
name|incremental
condition|?
name|INCREMENTAL
else|:
name|CONSTANT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|eraser_non_gui_paint_func (PaintCore * paint_core,GimpDrawable * drawable,int state)
name|eraser_non_gui_paint_func
parameter_list|(
name|PaintCore
modifier|*
name|paint_core
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|eraser_motion
argument_list|(
name|paint_core
argument_list|,
name|drawable
argument_list|,
name|non_gui_hard
argument_list|,
name|non_gui_incremental
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  The eraser procedure definition  */
end_comment

begin_decl_stmt
DECL|variable|eraser_extended_args
name|ProcArg
name|eraser_extended_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"array of stroke coordinates: {s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y}"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"hardness"
block|,
literal|"SOFT(0) or HARD(1)"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"method"
block|,
literal|"CONTINUOUS(0) or INCREMENTAL(1)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eraser_args
name|ProcArg
name|eraser_args
index|[]
init|=
block|{
block|{
name|PDB_IMAGE
block|,
literal|"image"
block|,
literal|"the image"
block|}
block|,
block|{
name|PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"the drawable"
block|}
block|,
block|{
name|PDB_INT32
block|,
literal|"num_strokes"
block|,
literal|"number of stroke control points (count each coordinate as 2 points)"
block|}
block|,
block|{
name|PDB_FLOATARRAY
block|,
literal|"strokes"
block|,
literal|"array of stroke coordinates: {s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y}"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eraser_proc
name|ProcRecord
name|eraser_proc
init|=
block|{
literal|"gimp_eraser"
block|,
literal|"Erase using the current brush"
block|,
literal|"This tool erases using the current brush mask.  If the specified drawable contains an alpha channel, then the erased pixels will become transparent.  Otherwise, the eraser tool replaces the contents of the drawable with the background color.  Like paintbrush, this tool linearly interpolates between the specified stroke coordinates."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|4
block|,
name|eraser_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|eraser_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eraser_extended_proc
name|ProcRecord
name|eraser_extended_proc
init|=
block|{
literal|"gimp_eraser_extended"
block|,
literal|"Erase using the current brush"
block|,
literal|"This tool erases using the current brush mask.  If the specified drawable contains an alpha channel, then the erased pixels will become transparent.  Otherwise, the eraser tool replaces the contents of the drawable with the background color.  Like paintbrush, this tool linearly interpolates between the specified stroke coordinates."
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"Spencer Kimball& Peter Mattis"
block|,
literal|"1995-1996"
block|,
name|PDB_INTERNAL
block|,
comment|/*  Input arguments  */
literal|6
block|,
name|eraser_extended_args
block|,
comment|/*  Output arguments  */
literal|0
block|,
name|NULL
block|,
comment|/*  Exec method  */
block|{
block|{
name|eraser_extended_invoker
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|eraser_invoker (args)
name|eraser_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|num_strokes
decl_stmt|;
name|double
modifier|*
name|stroke_array
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|num_strokes
operator|=
literal|0
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
operator|||
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  num strokes  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>
literal|0
condition|)
name|num_strokes
operator|=
name|int_value
operator|/
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  point array  */
if|if
condition|(
name|success
condition|)
name|stroke_array
operator|=
operator|(
name|double
operator|*
operator|)
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
comment|/*  init the paint core  */
name|success
operator|=
name|paint_core_init
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
name|stroke_array
index|[
literal|0
index|]
argument_list|,
name|stroke_array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|non_gui_hard
operator|=
literal|0
expr_stmt|;
name|non_gui_incremental
operator|=
literal|0
expr_stmt|;
comment|/*  set the paint core's paint func  */
name|non_gui_paint_core
operator|.
name|paint_func
operator|=
name|eraser_non_gui_paint_func
expr_stmt|;
name|non_gui_paint_core
operator|.
name|startx
operator|=
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|stroke_array
index|[
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|starty
operator|=
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|stroke_array
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|num_strokes
operator|==
literal|1
condition|)
name|eraser_non_gui_paint_func
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_strokes
condition|;
name|i
operator|++
control|)
block|{
name|non_gui_paint_core
operator|.
name|curx
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|cury
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|paint_core_interpolate
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|non_gui_paint_core
operator|.
name|curx
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|non_gui_paint_core
operator|.
name|cury
expr_stmt|;
block|}
comment|/*  finish the painting  */
name|paint_core_finish
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  cleanup  */
name|paint_core_cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|eraser_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Argument
modifier|*
DECL|function|eraser_extended_invoker (args)
name|eraser_extended_invoker
parameter_list|(
name|args
parameter_list|)
name|Argument
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|success
init|=
name|TRUE
decl_stmt|;
name|GImage
modifier|*
name|gimage
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|int
name|num_strokes
decl_stmt|;
name|double
modifier|*
name|stroke_array
decl_stmt|;
name|int
name|int_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|num_strokes
operator|=
literal|0
expr_stmt|;
comment|/*  the gimage  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gimage
operator|=
name|gimage_get_ID
argument_list|(
name|int_value
argument_list|)
operator|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  the drawable  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|drawable
operator|=
name|drawable_get_ID
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|==
name|NULL
operator|||
name|gimage
operator|!=
name|drawable_gimage
argument_list|(
name|drawable
argument_list|)
condition|)
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  num strokes  */
if|if
condition|(
name|success
condition|)
block|{
name|int_value
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
if|if
condition|(
name|int_value
operator|>
literal|0
condition|)
name|num_strokes
operator|=
name|int_value
operator|/
literal|2
expr_stmt|;
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*  point array  */
if|if
condition|(
name|success
condition|)
name|stroke_array
operator|=
operator|(
name|double
operator|*
operator|)
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|pdb_pointer
expr_stmt|;
if|if
condition|(
name|success
condition|)
comment|/*  init the paint core  */
name|success
operator|=
name|paint_core_init
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
name|stroke_array
index|[
literal|0
index|]
argument_list|,
name|stroke_array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|non_gui_hard
operator|=
name|args
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
name|non_gui_incremental
operator|=
name|args
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|pdb_int
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
comment|/*  set the paint core's paint func  */
name|non_gui_paint_core
operator|.
name|paint_func
operator|=
name|eraser_non_gui_paint_func
expr_stmt|;
name|non_gui_paint_core
operator|.
name|startx
operator|=
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|stroke_array
index|[
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|starty
operator|=
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|stroke_array
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|num_strokes
operator|==
literal|1
condition|)
name|eraser_non_gui_paint_func
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_strokes
condition|;
name|i
operator|++
control|)
block|{
name|non_gui_paint_core
operator|.
name|curx
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|0
index|]
expr_stmt|;
name|non_gui_paint_core
operator|.
name|cury
operator|=
name|stroke_array
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|paint_core_interpolate
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lastx
operator|=
name|non_gui_paint_core
operator|.
name|curx
expr_stmt|;
name|non_gui_paint_core
operator|.
name|lasty
operator|=
name|non_gui_paint_core
operator|.
name|cury
expr_stmt|;
block|}
comment|/*  finish the painting  */
name|paint_core_finish
argument_list|(
operator|&
name|non_gui_paint_core
argument_list|,
name|drawable
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  cleanup  */
name|paint_core_cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|procedural_db_return_args
argument_list|(
operator|&
name|eraser_proc
argument_list|,
name|success
argument_list|)
return|;
block|}
end_function

end_unit

