begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gimpimageP.h"
end_include

begin_include
include|#
directive|include
file|"cursorutil.h"
end_include

begin_include
include|#
directive|include
file|"drawable.h"
end_include

begin_include
include|#
directive|include
file|"floating_sel.h"
end_include

begin_include
include|#
directive|include
file|"gdisplay.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"gimage_mask.h"
end_include

begin_include
include|#
directive|include
file|"paint_funcs.h"
end_include

begin_include
include|#
directive|include
file|"palette.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/parasite.h"
end_include

begin_include
include|#
directive|include
file|"parasitelist.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"gimpsignal.h"
end_include

begin_include
include|#
directive|include
file|"gimpparasite.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpintl.h"
end_include

begin_include
include|#
directive|include
file|"tile_manager.h"
end_include

begin_include
include|#
directive|include
file|"tile.h"
end_include

begin_include
include|#
directive|include
file|"layer_pvt.h"
end_include

begin_include
include|#
directive|include
file|"drawable_pvt.h"
end_include

begin_comment
comment|/* ick ick. */
end_comment

begin_comment
comment|/*  Local function declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_free_layers
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_free_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|GimpDrawable
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  projection functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Layer
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
parameter_list|,
name|Channel
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|,
name|PixelRegion
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Global variables  */
end_comment

begin_decl_stmt
DECL|variable|valid_combinations
name|int
name|valid_combinations
index|[]
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
init|=
block|{
comment|/* RGB GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|}
block|,
comment|/* RGBA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|}
block|,
comment|/* GRAY GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_INTEN
block|,
name|COMBINE_INTEN_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* GRAYA GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INTEN_A_INTEN
block|,
name|COMBINE_INTEN_A_INTEN_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXED GIMAGE */
block|{
operator|-
literal|1
block|,
name|COMBINE_INDEXED_INDEXED
block|,
name|COMBINE_INDEXED_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* INDEXEDA GIMAGE */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|COMBINE_INDEXED_A_INDEXED_A
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|next_guide_id
name|guint32
name|next_guide_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|next_guide_id
comment|/* For generating guide_ID handles for PDB stuff */
end_comment

begin_comment
comment|/*  *  Static variables  */
end_comment

begin_enum
DECL|enum|__anon27e1090e0103
enum|enum
block|{
DECL|enumerator|DIRTY
name|DIRTY
block|,
DECL|enumerator|REPAINT
name|REPAINT
block|,
DECL|enumerator|RENAME
name|RENAME
block|,
DECL|enumerator|RESIZE
name|RESIZE
block|,
DECL|enumerator|RESTRUCTURE
name|RESTRUCTURE
block|,
DECL|enumerator|COLORMAP_CHANGED
name|COLORMAP_CHANGED
block|,
DECL|enumerator|LAST_SIGNAL
name|LAST_SIGNAL
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|gimp_image_signals
specifier|static
name|guint
name|gimp_image_signals
index|[
name|LAST_SIGNAL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|parent_class
specifier|static
name|GimpObjectClass
modifier|*
name|parent_class
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|gimp_image_class_init (GimpImageClass * klass)
name|gimp_image_class_init
parameter_list|(
name|GimpImageClass
modifier|*
name|klass
parameter_list|)
block|{
name|GtkObjectClass
modifier|*
name|object_class
decl_stmt|;
name|GtkType
name|type
decl_stmt|;
name|object_class
operator|=
name|GTK_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|parent_class
operator|=
name|gtk_type_class
argument_list|(
name|gimp_object_get_type
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|=
name|object_class
operator|->
name|type
expr_stmt|;
name|object_class
operator|->
name|destroy
operator|=
name|gimp_image_destroy
expr_stmt|;
name|gimp_image_signals
index|[
name|DIRTY
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"dirty"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|REPAINT
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"repaint"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_int_int_int_int
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RENAME
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"rename"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESIZE
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"resize"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"restructure"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_void
argument_list|)
expr_stmt|;
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
operator|=
name|gimp_signal_new
argument_list|(
literal|"colormap_changed"
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|gimp_sigtype_int
argument_list|)
expr_stmt|;
name|gtk_object_class_add_signals
argument_list|(
name|object_class
argument_list|,
name|gimp_image_signals
argument_list|,
name|LAST_SIGNAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static functions */
end_comment

begin_function
DECL|function|gimp_image_init (GimpImage * gimage)
specifier|static
name|void
name|gimp_image_init
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|has_filename
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
name|NULL
expr_stmt|;
comment|/* ID and ref_count handled in gimage.c */
name|gimage
operator|->
name|instance_count
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
operator|-
literal|1
expr_stmt|;
name|gimage
operator|->
name|tattoo_state
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|redo_stack
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|undo_bytes
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|undo_levels
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|pushing_undo_group
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|parasites
operator|=
name|parasite_list_new
argument_list|()
expr_stmt|;
name|gimp_matrix_identity
argument_list|(
name|gimage
operator|->
name|transform
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|xresolution
operator|=
literal|72.0
expr_stmt|;
comment|/* maybe should be rc-supplied default? */
name|gimage
operator|->
name|yresolution
operator|=
literal|72.0
expr_stmt|;
name|gimage
operator|->
name|save_proc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
DECL|function|gimp_image_get_type (void)
name|GtkType
name|gimp_image_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GtkType
name|type
decl_stmt|;
name|GIMP_TYPE_INIT
argument_list|(
name|type
argument_list|,
name|GimpImage
argument_list|,
name|GimpImageClass
argument_list|,
name|gimp_image_init
argument_list|,
name|gimp_image_class_init
argument_list|,
name|GIMP_TYPE_OBJECT
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* static functions */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_projection (GimpImage * gimage)
name|gimp_image_allocate_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Find the number of bytes required for the projection.    *  This includes the intensity channels and an alpha channel    *  if one doesn't exist.    */
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|4
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|gimage
operator|->
name|proj_bytes
operator|=
literal|2
expr_stmt|;
name|gimage
operator|->
name|proj_type
operator|=
name|GRAYA_GIMAGE
expr_stmt|;
break|break;
default|default:
name|g_assert_not_reached
argument_list|()
expr_stmt|;
block|}
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|projection
operator|=
name|tile_manager_new
argument_list|(
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|gimage
operator|->
name|proj_bytes
argument_list|)
expr_stmt|;
name|tile_manager_set_user_data
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gimage
argument_list|)
expr_stmt|;
name|tile_manager_set_validate_proc
argument_list|(
name|gimage
operator|->
name|projection
argument_list|,
name|gimp_image_validate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_projection (GimpImage * gimage)
name|gimp_image_free_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|projection
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|projection
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_allocate_shadow (GimpImage * gimage,int width,int height,int bpp)
name|gimp_image_allocate_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
comment|/*  allocate the new projection  */
name|gimage
operator|->
name|shadow
operator|=
name|tile_manager_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function definitions */
end_comment

begin_function
name|GimpImage
modifier|*
DECL|function|gimp_image_new (int width,int height,int base_type)
name|gimp_image_new
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|base_type
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|gtk_type_new
argument_list|(
name|gimp_image_get_type
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|gimage
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|GRAY
case|:
break|break;
case|case
name|INDEXED
case|:
comment|/* always allocate 256 colors for the colormap */
name|gimage
operator|->
name|num_cols
operator|=
literal|0
expr_stmt|;
name|gimage
operator|->
name|cmap
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g_malloc0
argument_list|(
name|COLORMAP_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  configure the active pointers  */
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/* no default active channel */
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
comment|/*  set all color channels visible and active  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|gimage
operator|->
name|visible
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|active
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* create the selection mask */
name|gimage
operator|->
name|selection_mask
operator|=
name|channel_new_mask
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
return|return
name|gimage
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_filename (GimpImage * gimage,char * filename)
name|gimp_image_set_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
comment|/*     * WARNING: this function will free the current filename even if you are     * setting it to itself so any pointer you hold to the filename will be    * invalid after this call.  So please use with care.    */
name|new_filename
operator|=
name|g_strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|gimage
operator|->
name|filename
operator|=
name|new_filename
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|gimage
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|gimage
operator|->
name|has_filename
operator|=
name|FALSE
expr_stmt|;
block|}
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RENAME
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_resolution (GimpImage * gimage,float xresolution,float yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|float
name|xresolution
parameter_list|,
name|float
name|yresolution
parameter_list|)
block|{
name|gimage
operator|->
name|xresolution
operator|=
name|xresolution
expr_stmt|;
name|gimage
operator|->
name|yresolution
operator|=
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_resolution (GimpImage * gimage,float * xresolution,float * yresolution)
name|gimp_image_get_resolution
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|float
modifier|*
name|xresolution
parameter_list|,
name|float
modifier|*
name|yresolution
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|xresolution
operator|&&
name|yresolution
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
name|gimage
operator|->
name|xresolution
expr_stmt|;
operator|*
name|yresolution
operator|=
name|gimage
operator|->
name|yresolution
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_save_proc (GimpImage * gimage,PlugInProcDef * proc)
name|gimp_image_set_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|PlugInProcDef
modifier|*
name|proc
parameter_list|)
block|{
name|gimage
operator|->
name|save_proc
operator|=
name|proc
expr_stmt|;
block|}
end_function

begin_function
name|PlugInProcDef
modifier|*
DECL|function|gimp_image_get_save_proc (GimpImage * gimage)
name|gimp_image_get_save_proc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|save_proc
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_resize (GimpImage * gimage,int new_width,int new_height,int offset_x,int offset_y)
name|gimp_image_resize
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|new_width
parameter_list|,
name|int
name|new_height
parameter_list|,
name|int
name|offset_x
parameter_list|,
name|int
name|offset_y
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|g_assert
argument_list|(
name|new_width
operator|>
literal|0
operator|&&
name|new_height
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|GIMAGE_MOD_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Resize all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_resize
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_resize
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Reposition all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_translate
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_scale (GimpImage * gimage,int new_width,int new_height)
name|gimp_image_scale
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|new_width
parameter_list|,
name|int
name|new_height
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|floating_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|old_width
decl_stmt|,
name|old_height
decl_stmt|;
name|int
name|layer_width
decl_stmt|,
name|layer_height
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
comment|/*  Get the floating layer if one exists  */
name|floating_layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|GIMAGE_MOD_UNDO
argument_list|)
expr_stmt|;
comment|/*  Relax the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_relax
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  Push the image size to the stack  */
name|undo_push_gimage_mod
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Set the new width and height  */
name|old_width
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|old_height
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
name|gimage
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|gimage
operator|->
name|height
operator|=
name|new_height
expr_stmt|;
comment|/*  Scale all channels  */
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_scale
argument_list|(
name|channel
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Don't forget the selection mask!  */
name|channel_scale
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|,
name|new_width
argument_list|,
name|new_height
argument_list|)
expr_stmt|;
name|gimage_mask_invalidate
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Scale all layers  */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_width
operator|=
operator|(
name|new_width
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_width
expr_stmt|;
name|layer_height
operator|=
operator|(
name|new_height
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|/
name|old_height
expr_stmt|;
name|layer_scale
argument_list|(
name|layer
argument_list|,
name|layer_width
argument_list|,
name|layer_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
comment|/*  Make sure the projection matches the gimage size  */
name|gimp_image_projection_realloc
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Rigor the floating selection  */
if|if
condition|(
name|floating_layer
condition|)
name|floating_sel_rigor
argument_list|(
name|floating_layer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESIZE
index|]
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_shadow (GimpImage * gimage,int width,int height,int bpp)
name|gimp_image_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|shadow
operator|&&
operator|(
operator|(
name|width
operator|!=
name|tile_manager_level_width
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|!=
name|tile_manager_level_height
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|||
operator|(
name|bpp
operator|!=
name|tile_manager_level_bpp
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
operator|)
operator|)
condition|)
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
return|return
name|gimage
operator|->
name|shadow
return|;
name|gimp_image_allocate_shadow
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|shadow
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_free_shadow (GimpImage * gimage)
name|gimp_image_free_shadow
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free the shadow buffer from the specified gimage if it exists  */
if|if
condition|(
name|gimage
operator|->
name|shadow
condition|)
name|tile_manager_destroy
argument_list|(
name|gimage
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|shadow
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_destroy (GtkObject * object)
name|gimp_image_destroy
parameter_list|(
name|GtkObject
modifier|*
name|object
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
init|=
name|GIMP_IMAGE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gimp_image_free_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_free_shadow
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|cmap
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
name|g_free
argument_list|(
name|gimage
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gimp_image_free_layers
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimp_image_free_channels
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|channel_delete
argument_list|(
name|gimage
operator|->
name|selection_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|parasites
condition|)
name|gtk_object_unref
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_apply_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,int undo,int opacity,int mode,TileManager * src1_tiles,int x,int y)
name|gimp_image_apply_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|int
name|undo
parameter_list|,
name|int
name|opacity
parameter_list|,
name|int
name|mode
parameter_list|,
comment|/*  alternative to using drawable tiles as src1: */
name|TileManager
modifier|*
name|src1_tiles
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|,
name|maskPR
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_apply_image sent illegal parameters"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|undo_push_image
argument_list|(
name|gimp_drawable_gimage
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
if|if
condition|(
name|src1_tiles
condition|)
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src1_tiles
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to gimp_image_apply_image but works in "replace" mode (i.e.    transparent pixels in src2 make the result transparent rather    than opaque.     Takes an additional mask pixel region as well.  */
end_comment

begin_function
name|void
DECL|function|gimp_image_replace_image (GimpImage * gimage,GimpDrawable * drawable,PixelRegion * src2PR,int undo,int opacity,PixelRegion * maskPR,int x,int y)
name|gimp_image_replace_image
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|PixelRegion
modifier|*
name|src2PR
parameter_list|,
name|int
name|undo
parameter_list|,
name|int
name|opacity
parameter_list|,
name|PixelRegion
modifier|*
name|maskPR
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Channel
modifier|*
name|mask
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|destPR
decl_stmt|;
name|PixelRegion
name|mask2PR
decl_stmt|,
name|tempPR
decl_stmt|;
name|unsigned
name|char
modifier|*
name|temp_data
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/*  get the selection mask if one exists  */
name|mask
operator|=
operator|(
name|gimage_mask_is_empty
argument_list|(
name|gimage
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|gimp_image_get_mask
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  configure the active channel array  */
name|gimp_image_get_active_channels
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and    *  if it's actually legal...    */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|drawable
argument_list|)
index|]
index|[
name|src2PR
operator|->
name|bytes
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_apply_image sent illegal parameters"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  get the layer offsets  */
name|drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
comment|/*  make sure the image application coordinates are within gimage bounds  */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|src2PR
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|src2PR
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|drawable_height
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|/*  make sure coordinates are in mask bounds ...        *  we need to add the layer offset to transform coords        *  into the mask coordinate system        */
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
operator|-
name|offset_x
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
operator|-
name|offset_y
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|-
name|offset_y
argument_list|)
expr_stmt|;
block|}
comment|/*  If the calling procedure specified an undo step...  */
if|if
condition|(
name|undo
condition|)
name|drawable_apply_image
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions    *  If an alternative to using the drawable's data as src1 was provided...    */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|destPR
argument_list|,
name|drawable_data
argument_list|(
name|drawable
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_resize
argument_list|(
name|src2PR
argument_list|,
name|src2PR
operator|->
name|x
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
argument_list|,
name|src2PR
operator|->
name|y
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
comment|/*  configure the mask pixel region        *  don't use x1 and y1 because they are in layer        *  coordinate system.  Need mask coordinate system        */
name|mx
operator|=
name|x1
operator|+
name|offset_x
expr_stmt|;
name|my
operator|=
name|y1
operator|+
name|offset_y
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|mask2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
argument_list|,
name|mx
argument_list|,
name|my
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|bytes
operator|=
literal|1
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|rowstride
operator|=
name|mask2PR
operator|.
name|rowstride
expr_stmt|;
name|temp_data
operator|=
name|g_malloc
argument_list|(
name|tempPR
operator|.
name|h
operator|*
name|tempPR
operator|.
name|rowstride
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|copy_region
argument_list|(
operator|&
name|mask2PR
argument_list|,
operator|&
name|tempPR
argument_list|)
expr_stmt|;
comment|/* apparently, region operations can mutate some PR data. */
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|apply_mask_to_region
argument_list|(
operator|&
name|tempPR
argument_list|,
name|maskPR
argument_list|,
name|OPAQUE_OPACITY
argument_list|)
expr_stmt|;
name|tempPR
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|tempPR
operator|.
name|w
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|tempPR
operator|.
name|h
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tempPR
operator|.
name|data
operator|=
name|temp_data
expr_stmt|;
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
operator|&
name|tempPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_data
argument_list|)
expr_stmt|;
block|}
else|else
name|combine_regions_replace
argument_list|(
operator|&
name|src1PR
argument_list|,
name|src2PR
argument_list|,
operator|&
name|destPR
argument_list|,
name|maskPR
argument_list|,
name|NULL
argument_list|,
name|opacity
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get rid of these! A "foreground" is an UI concept.. */
end_comment

begin_function
name|void
DECL|function|gimp_image_get_foreground (GimpImage * gimage,GimpDrawable * drawable,unsigned char * fg)
name|gimp_image_get_foreground
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|fg
parameter_list|)
block|{
name|unsigned
name|char
name|pfg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|palette_get_foreground
argument_list|(
operator|&
name|pfg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pfg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pfg
argument_list|,
name|fg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_background (GimpImage * gimage,GimpDrawable * drawable,unsigned char * bg)
name|gimp_image_get_background
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|bg
parameter_list|)
block|{
name|unsigned
name|char
name|pbg
index|[
literal|3
index|]
decl_stmt|;
comment|/*  Get the palette color  */
name|palette_get_background
argument_list|(
operator|&
name|pbg
index|[
literal|0
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|1
index|]
argument_list|,
operator|&
name|pbg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_image_transform_color
argument_list|(
name|gimage
argument_list|,
name|drawable
argument_list|,
name|pbg
argument_list|,
name|bg
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_get_color (GimpImage * gimage,int d_type,unsigned char * rgb,unsigned char * src)
name|gimp_image_get_color
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|d_type
parameter_list|,
name|unsigned
name|char
modifier|*
name|rgb
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|)
block|{
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
name|map_to_color
argument_list|(
literal|2
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|src
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_transform_color (GimpImage * gimage,GimpDrawable * drawable,unsigned char * src,unsigned char * dest,int type)
name|gimp_image_transform_color
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|type
parameter_list|)
block|{
DECL|macro|INTENSITY (r,g,b)
define|#
directive|define
name|INTENSITY
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|(r * 0.30 + g * 0.59 + b * 0.11 + 0.001)
name|int
name|d_type
decl_stmt|;
name|d_type
operator|=
operator|(
name|drawable
operator|!=
name|NULL
operator|)
condition|?
name|drawable_type
argument_list|(
name|drawable
argument_list|)
else|:
name|gimp_image_base_type_with_alpha
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RGB
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  NTSC conversion  */
operator|*
name|dest
operator|=
name|INTENSITY
argument_list|(
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|RED_PIX
index|]
argument_list|,
name|src
index|[
name|GREEN_PIX
index|]
argument_list|,
name|src
index|[
name|BLUE_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GRAY
case|:
switch|switch
condition|(
name|d_type
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|RGBA_GIMAGE
case|:
comment|/*  Gray to RG&B */
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|GRAY_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
comment|/*  Straight copy  */
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
comment|/*  Least squares method  */
operator|*
name|dest
operator|=
name|map_rgb_to_indexed
argument_list|(
name|gimage
operator|->
name|cmap
argument_list|,
name|gimage
operator|->
name|num_cols
argument_list|,
name|gimage
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|,
name|src
index|[
name|GRAY_PIX
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_hguide (GimpImage * gimage)
name|gimp_image_add_hguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|HORIZONTAL_GUIDE
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|Guide
modifier|*
DECL|function|gimp_image_add_vguide (GimpImage * gimage)
name|gimp_image_add_vguide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Guide
modifier|*
name|guide
decl_stmt|;
name|guide
operator|=
name|g_new
argument_list|(
name|Guide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|guide
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|guide
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|guide
operator|->
name|guide_ID
operator|=
name|next_guide_id
operator|++
expr_stmt|;
name|guide
operator|->
name|orientation
operator|=
name|VERTICAL_GUIDE
expr_stmt|;
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
return|return
name|guide
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_add_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_add_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_prepend
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_remove_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_remove_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_delete_guide (GimpImage * gimage,Guide * guide)
name|gimp_image_delete_guide
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Guide
modifier|*
name|guide
parameter_list|)
block|{
name|gimage
operator|->
name|guides
operator|=
name|g_list_remove
argument_list|(
name|gimage
operator|->
name|guides
argument_list|,
name|guide
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|guide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Parasite
modifier|*
DECL|function|gimp_image_find_parasite (const GimpImage * gimage,const char * name)
name|gimp_image_find_parasite
parameter_list|(
specifier|const
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_attach_parasite (GimpImage * gimage,Parasite * parasite)
name|gimp_image_attach_parasite
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Parasite
modifier|*
name|parasite
parameter_list|)
block|{
name|parasite_list_add
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_is_persistent
argument_list|(
name|parasite
argument_list|)
condition|)
comment|/* make sure we can be saved */
name|gimp_image_dirty
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite_has_flag
argument_list|(
name|parasite
argument_list|,
name|PARASITE_ATTACH_PARENT
argument_list|)
condition|)
block|{
name|parasite_shift_parent
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|gimp_attach_parasite
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_detach_parasite (GimpImage * gimage,const char * parasite)
name|gimp_image_detach_parasite
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
specifier|const
name|char
modifier|*
name|parasite
parameter_list|)
block|{
name|Parasite
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parasite_list_find
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|parasite_is_persistent
argument_list|(
name|p
argument_list|)
condition|)
name|gimp_image_dirty
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|parasite_list_remove
argument_list|(
name|gimage
operator|->
name|parasites
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Tattoo
DECL|function|gimp_image_get_new_tattoo (GimpImage * image)
name|gimp_image_get_new_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|image
operator|->
name|tattoo_state
operator|++
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|tattoo_state
operator|<=
literal|0
condition|)
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Tattoo state has become corrupt (2.1 billion operation limit exceded)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|image
operator|->
name|tattoo_state
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_colormap_changed (GimpImage * image,gint col)
name|gimp_image_colormap_changed
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|gint
name|col
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|col
operator|<
name|image
operator|->
name|num_cols
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|image
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|COLORMAP_CHANGED
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection functions                                    */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|project_intensity (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_intensity_alpha (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_intensity_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest)
name|project_indexed
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED
argument_list|)
expr_stmt|;
else|else
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to project indexed image."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_indexed_alpha (GimpImage * gimage,Layer * layer,PixelRegion * src,PixelRegion * dest,PixelRegion * mask)
name|project_indexed_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|dest
parameter_list|,
name|PixelRegion
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
name|initial_region
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|INITIAL_INDEXED_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|,
name|gimage
operator|->
name|cmap
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|gimage
operator|->
name|visible
argument_list|,
name|COMBINE_INTEN_A_INDEXED_A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|project_channel (GimpImage * gimage,Channel * channel,PixelRegion * src,PixelRegion * src2)
name|project_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|PixelRegion
modifier|*
name|src
parameter_list|,
name|PixelRegion
modifier|*
name|src2
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|gimage
operator|->
name|construct_flag
condition|)
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|INITIAL_CHANNEL_MASK
else|:
name|INITIAL_CHANNEL_SELECTION
expr_stmt|;
name|initial_region
argument_list|(
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|(
name|channel
operator|->
name|show_masked
operator|)
condition|?
name|COMBINE_INTEN_A_CHANNEL_MASK
else|:
name|COMBINE_INTEN_A_CHANNEL_SELECTION
expr_stmt|;
name|combine_regions
argument_list|(
name|src
argument_list|,
name|src2
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|channel
operator|->
name|col
argument_list|,
name|channel
operator|->
name|opacity
argument_list|,
name|NORMAL
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Layer/Channel functions                                 */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_layers (GimpImage * gimage)
name|gimp_image_free_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|layer_delete
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_free_channels (GimpImage * gimage)
name|gimp_image_free_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|Channel
modifier|*
name|channel
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|channel_delete
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|gimage
operator|->
name|channels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_layers (GimpImage * gimage,int x,int y,int w,int h)
name|gimp_image_construct_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
comment|/*  composite the floating selection if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_composite
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Note added by Raph Levien, 27 Jan 1998       This looks it was intended as an optimization, but it seems to      have correctness problems. In particular, if all channels are      turned off, the screen simply does not update the projected      image. It should be black. Turning off this optimization seems to      restore correct behavior. At some future point, it may be      desirable to turn the optimization back on.       */
if|#
directive|if
literal|0
comment|/*  If all channels are not visible, simply return  */
block|switch (gimp_image_base_type (gimage))     {     case RGB:       if (! gimp_image_get_component_visible (gimage, Red)&& 	  ! gimp_image_get_component_visible (gimage, Green)&& 	  ! gimp_image_get_component_visible (gimage, Blue)) 	return;       break;     case GRAY:       if (! gimp_image_get_component_visible (gimage, Gray)) 	return;       break;     case INDEXED:       if (! gimp_image_get_component_visible (gimage, Indexed)) 	return;       break;     }
endif|#
directive|endif
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections to the list  */
if|if
condition|(
operator|!
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|w
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  If we're showing the layer mask instead of the layer...  */
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|show_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|copy_gray_to_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
block|}
comment|/*  Otherwise, normal  */
else|else
block|{
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x1
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y1
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the 	   *  projection image... 	   */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
comment|/* no mask possible */
name|project_intensity
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
name|project_intensity_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXED_GIMAGE
case|:
comment|/* no mask possible */
name|project_indexed
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXEDA_GIMAGE
case|:
name|project_indexed_alpha
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
comment|/*  something was projected  */
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_construct_channels (GimpImage * gimage,int x,int y,int w,int h)
name|gimp_image_construct_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
comment|/*  reverse the channel list  */
while|while
condition|(
name|list
condition|)
block|{
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
block|{
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|project_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|,
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|construct_flag
operator|=
literal|1
expr_stmt|;
block|}
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_initialize_projection (GimpImage * gimage,int x,int y,int w,int h)
name|gimp_image_initialize_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|coverage
init|=
literal|0
decl_stmt|;
name|PixelRegion
name|PR
decl_stmt|;
name|unsigned
name|char
name|clear
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*  this function determines whether a visible layer    *  provides complete coverage over the image.  If not,    *  the projection is initialized to transparent    */
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|&&
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
operator|(
name|off_x
operator|<=
name|x
operator|)
operator|&&
operator|(
name|off_y
operator|<=
name|y
operator|)
operator|&&
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|x
operator|+
name|w
operator|)
operator|&&
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|>=
name|y
operator|+
name|h
operator|)
condition|)
name|coverage
operator|=
literal|1
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coverage
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|PR
argument_list|,
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|color_region
argument_list|(
operator|&
name|PR
argument_list|,
name|clear
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_image_get_active_channels (GimpImage * gimage,GimpDrawable * drawable,int * active)
name|gimp_image_get_active_channels
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|int
modifier|*
name|active
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  first, blindly copy the gimage active channels  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|active
index|[
name|i
index|]
operator|=
name|gimage
operator|->
name|active
index|[
name|i
index|]
expr_stmt|;
comment|/*  If the drawable is a channel (a saved selection, etc.)    *  make sure that the alpha channel is not valid    */
if|if
condition|(
name|GIMP_IS_CHANNEL
argument_list|(
name|drawable
argument_list|)
condition|)
name|active
index|[
name|ALPHA_G_PIX
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  no alpha values in channels  */
else|else
block|{
comment|/*  otherwise, check whether preserve transparency is        *  enabled in the layer and if the layer has alpha        */
if|if
condition|(
name|GIMP_IS_LAYER
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|layer
operator|=
name|GIMP_LAYER
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer
operator|->
name|preserve_trans
condition|)
name|active
index|[
name|drawable_bytes
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_construct (GimpImage * gimage,int x,int y,int w,int h)
name|gimp_image_construct
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
comment|/*  set the construct flag, used to determine if anything    *  has been written to the gimage raw image yet.    */
name|gimage
operator|->
name|construct_flag
operator|=
literal|0
expr_stmt|;
comment|/*  First, determine if the projection image needs to be    *  initialized--this is the case when there are no visible    *  layers that cover the entire canvas--either because layers    *  are offset or only a floating selection is visible    */
name|gimp_image_initialize_projection
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/*  call functions which process the list of layers and    *  the list of channels    */
name|gimp_image_construct_layers
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|gimp_image_construct_channels
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate (GimpImage * gimage,int x,int y,int w,int h,int x1,int y1,int x2,int y2)
name|gimp_image_invalidate
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|Tile
modifier|*
name|tile
decl_stmt|;
name|TileManager
modifier|*
name|tm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|startx
decl_stmt|,
name|starty
decl_stmt|;
name|int
name|endx
decl_stmt|,
name|endy
decl_stmt|;
name|int
name|tilex
decl_stmt|,
name|tiley
decl_stmt|;
name|tm
operator|=
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|startx
operator|=
name|x
expr_stmt|;
name|starty
operator|=
name|y
expr_stmt|;
name|endx
operator|=
name|x
operator|+
name|w
expr_stmt|;
name|endy
operator|=
name|y
operator|+
name|h
expr_stmt|;
comment|/*  invalidate all tiles which are located outside of the displayed area    *   all tiles inside the displayed area are constructed.    */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<
operator|(
name|y
operator|+
name|h
operator|)
condition|;
name|i
operator|+=
operator|(
name|TILE_HEIGHT
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
operator|)
control|)
for|for
control|(
name|j
operator|=
name|x
init|;
name|j
operator|<
operator|(
name|x
operator|+
name|w
operator|)
condition|;
name|j
operator|+=
operator|(
name|TILE_WIDTH
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
operator|)
control|)
block|{
name|tile
operator|=
name|tile_manager_get_tile
argument_list|(
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  invalidate all lower level tiles  */
comment|/*tile_manager_invalidate_tiles (gimp_image_projection (gimage), tile);*/
comment|/*  check if the tile is outside the bounds  */
if|if
condition|(
operator|(
name|MIN
argument_list|(
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|x2
argument_list|)
operator|-
name|MAX
argument_list|(
name|j
argument_list|,
name|x1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|x1
condition|)
name|startx
operator|=
name|MAX
argument_list|(
name|startx
argument_list|,
operator|(
name|j
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endx
operator|=
name|MIN
argument_list|(
name|endx
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIN
argument_list|(
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|,
name|y2
argument_list|)
operator|-
name|MAX
argument_list|(
name|i
argument_list|,
name|y1
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tile_invalidate_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|tm
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|y1
condition|)
name|starty
operator|=
name|MAX
argument_list|(
name|starty
argument_list|,
operator|(
name|i
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|endy
operator|=
name|MIN
argument_list|(
name|endy
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  If the tile is not valid, make sure we get the entire tile              *   in the construction extents              */
if|if
condition|(
name|tile_is_valid
argument_list|(
name|tile
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|tilex
operator|=
name|j
operator|-
operator|(
name|j
operator|%
name|TILE_WIDTH
operator|)
expr_stmt|;
name|tiley
operator|=
name|i
operator|-
operator|(
name|i
operator|%
name|TILE_HEIGHT
operator|)
expr_stmt|;
name|startx
operator|=
name|MIN
argument_list|(
name|startx
argument_list|,
name|tilex
argument_list|)
expr_stmt|;
name|endx
operator|=
name|MAX
argument_list|(
name|endx
argument_list|,
name|tilex
operator|+
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|starty
operator|=
name|MIN
argument_list|(
name|starty
argument_list|,
name|tiley
argument_list|)
expr_stmt|;
name|endy
operator|=
name|MAX
argument_list|(
name|endy
argument_list|,
name|tiley
operator|+
name|tile_eheight
argument_list|(
name|tile
argument_list|)
argument_list|)
expr_stmt|;
name|tile_mark_valid
argument_list|(
name|tile
argument_list|)
expr_stmt|;
comment|/* hmmmmmmm..... */
block|}
block|}
block|}
if|if
condition|(
operator|(
name|endx
operator|-
name|startx
operator|)
operator|>
literal|0
operator|&&
operator|(
name|endy
operator|-
name|starty
operator|)
operator|>
literal|0
condition|)
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
operator|(
name|endx
operator|-
name|startx
operator|)
argument_list|,
operator|(
name|endy
operator|-
name|starty
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_validate (TileManager * tm,Tile * tile)
name|gimp_image_validate
parameter_list|(
name|TileManager
modifier|*
name|tm
parameter_list|,
name|Tile
modifier|*
name|tile
parameter_list|)
block|{
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/*  Get the gimage from the tilemanager  */
name|gimage
operator|=
operator|(
name|GimpImage
operator|*
operator|)
name|tile_manager_get_user_data
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|/*  Find the coordinates of this tile  */
name|tile_manager_get_tile_coordinates
argument_list|(
name|tm
argument_list|,
name|tile
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|w
operator|=
name|tile_ewidth
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|h
operator|=
name|tile_eheight
argument_list|(
name|tile
argument_list|)
expr_stmt|;
name|gimp_image_construct
argument_list|(
name|gimage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_get_layer_index (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_get_layer_index
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|layers
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|layers
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layers
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|layers
operator|=
name|g_slist_next
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_get_channel_index (GimpImage * gimage,Channel * channel_ID)
name|gimp_image_get_channel_index
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_ID
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_ID
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|channels
operator|=
name|g_slist_next
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_get_active_layer (GimpImage * gimage)
name|gimp_image_get_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_active_channel (GimpImage * gimage)
name|gimp_image_get_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|active_channel
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_get_layer_by_tattoo (GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|layers
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
while|while
condition|(
name|layers
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layers
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_get_tattoo
argument_list|(
name|layer
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|layer
return|;
name|layers
operator|=
name|g_slist_next
argument_list|(
name|layers
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_channel_by_tattoo (GimpImage * gimage,Tattoo tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Tattoo
name|tattoo
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|GSList
modifier|*
name|channels
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
while|while
condition|(
name|channels
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|channels
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel_get_tattoo
argument_list|(
name|channel
argument_list|)
operator|==
name|tattoo
condition|)
return|return
name|channel
return|;
name|channels
operator|=
name|g_slist_next
argument_list|(
name|channels
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_get_component_active (GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_get_component_visible (GimpImage * gimage,ChannelType type)
name|gimp_image_get_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_get_mask (GimpImage * gimage)
name|gimp_image_get_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|selection_mask
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_layer_boundary (GimpImage * gimage,BoundSeg ** segs,int * num_segs)
name|gimp_image_layer_boundary
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|BoundSeg
modifier|*
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|num_segs
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  The second boundary corresponds to the active layer's    *  perimeter...    */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimage
operator|->
name|active_layer
operator|)
condition|)
block|{
operator|*
name|segs
operator|=
name|layer_boundary
argument_list|(
name|layer
argument_list|,
name|num_segs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
operator|*
name|segs
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_segs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_set_active_layer (GimpImage * gimage,Layer * layer)
name|gimp_image_set_active_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
comment|/*  First, find the layer in the gimage    *  If it isn't valid, find the first layer that is    */
if|if
condition|(
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|layers
condition|)
return|return
name|NULL
return|;
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layers
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|layer
condition|)
return|return
name|NULL
return|;
comment|/*  Configure the layer stack to reflect this change  */
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|layer
argument_list|)
expr_stmt|;
comment|/*  invalidate the selection boundary because of a layer modification  */
name|layer_invalidate_boundary
argument_list|(
name|layer
argument_list|)
expr_stmt|;
comment|/*  Set the active layer  */
name|gimage
operator|->
name|active_layer
operator|=
name|layer
expr_stmt|;
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
comment|/*  return the layer  */
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_set_active_channel (GimpImage * gimage,Channel * channel)
name|gimp_image_set_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
comment|/*  Not if there is a floating selection  */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*  First, find the channel    *  If it doesn't exist, find the first channel that does    */
if|if
condition|(
operator|!
name|channel
condition|)
block|{
if|if
condition|(
operator|!
name|gimage
operator|->
name|channels
condition|)
block|{
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
expr_stmt|;
block|}
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|channel
expr_stmt|;
comment|/*  return the channel  */
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_unset_active_channel (GimpImage * gimage)
name|gimp_image_unset_active_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
comment|/*  make sure there is an active channel  */
if|if
condition|(
operator|!
operator|(
name|channel
operator|=
name|gimage
operator|->
name|active_channel
operator|)
condition|)
return|return
name|NULL
return|;
comment|/*  Set the active channel  */
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_active (GimpImage * gimage,ChannelType type,int value)
name|gimp_image_set_component_active
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|gimage
operator|->
name|active
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|gimage
operator|->
name|active
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|gimage
operator|->
name|active
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|gimage
operator|->
name|active
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|gimage
operator|->
name|active
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Auxillary
case|:
break|break;
block|}
comment|/*  If there is an active channel and we mess with the components,    *  the active channel gets unset...    */
if|if
condition|(
name|type
operator|!=
name|Auxillary
condition|)
name|gimp_image_unset_active_channel
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_set_component_visible (GimpImage * gimage,ChannelType type,int value)
name|gimp_image_set_component_visible
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/*  No sanity checking here...  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|gimage
operator|->
name|visible
index|[
name|RED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|gimage
operator|->
name|visible
index|[
name|GREEN_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|gimage
operator|->
name|visible
index|[
name|BLUE_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|gimage
operator|->
name|visible
index|[
name|GRAY_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|gimage
operator|->
name|visible
index|[
name|INDEXED_PIX
index|]
operator|=
name|value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_pick_correlate_layer (GimpImage * gimage,int x,int y)
name|gimp_image_pick_correlate_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_pick_correlate
argument_list|(
name|layer
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|layer
return|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_raise_layer (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_raise_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|prev_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|prev
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|off2_x
decl_stmt|,
name|off2_y
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|prev_layer
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|prev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/*  We can only raise a layer if it has an alpha channel&& 	   *  If it's not already the top layer 	   */
if|if
condition|(
name|prev
operator|&&
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer_has_alpha
argument_list|(
name|prev_layer
argument_list|)
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|prev_layer
expr_stmt|;
name|prev
operator|->
name|data
operator|=
name|layer
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|,
operator|&
name|off2_x
argument_list|,
operator|&
name|off2_y
argument_list|)
expr_stmt|;
comment|/*  calculate minimum area to update  */
name|x1
operator|=
name|MAX
argument_list|(
name|off_x
argument_list|,
name|off2_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAX
argument_list|(
name|off_y
argument_list|,
name|off2_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MIN
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MIN
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|prev_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>
literal|0
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
operator|>
literal|0
condition|)
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|prev_layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be raised any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_lower_layer (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_lower_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|next_layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|off2_x
decl_stmt|,
name|off2_y
decl_stmt|;
name|next_layer
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/*  We can only lower a layer if it has an alpha channel&& 	   *  The layer beneath it has an alpha channel&& 	   *  If it's not already the bottom layer 	   */
if|if
condition|(
name|next
operator|&&
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
operator|&&
name|layer_has_alpha
argument_list|(
name|next_layer
argument_list|)
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|next_layer
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|layer
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|,
operator|&
name|off2_x
argument_list|,
operator|&
name|off2_y
argument_list|)
expr_stmt|;
comment|/*  calculate minimum area to update  */
name|x1
operator|=
name|MAX
argument_list|(
name|off_x
argument_list|,
name|off2_x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAX
argument_list|(
name|off_y
argument_list|,
name|off2_y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MIN
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MIN
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|off2_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|next_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>
literal|0
operator|&&
operator|(
name|y2
operator|-
name|y1
operator|)
operator|>
literal|0
condition|)
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|-
name|x1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|next_layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer cannot be lowered any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_raise_layer_to_top (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|int
name|x_min
decl_stmt|,
name|y_min
decl_stmt|,
name|x_max
decl_stmt|,
name|y_max
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
comment|/* the layers list is empty */
return|return
name|NULL
return|;
block|}
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/* layer_arg is already the top_layer */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on top"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|layer_has_alpha
argument_list|(
name|layer_arg
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Can't raise Layer without alpha"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* search for layer_arg */
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
break|break;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|!=
name|layer_arg
condition|)
block|{
comment|/* The requested layer was not found in the layerstack        * Return without changing anything        */
return|return
name|NULL
return|;
block|}
name|list
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_prepend
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
comment|/* update the affected area (== area of layer_arg) */
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x_min
operator|=
name|off_x
expr_stmt|;
name|y_min
operator|=
name|off_y
expr_stmt|;
name|x_max
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|y_max
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x_min
argument_list|,
name|y_min
argument_list|,
name|x_max
argument_list|,
name|y_max
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_lower_layer_to_bottom (GimpImage * gimage,Layer * layer_arg)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer_arg
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|GSList
modifier|*
name|pos
decl_stmt|;
name|int
name|x_min
decl_stmt|,
name|y_min
decl_stmt|,
name|x_max
decl_stmt|,
name|y_max
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|ex_flag
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|ex_flag
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* 1. loop find layer_arg */
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
break|break;
block|}
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|!=
name|layer_arg
condition|)
block|{
comment|/* The requested layer was not found in the layerstack        * Return without changing anything        */
return|return
name|NULL
return|;
block|}
name|pos
operator|=
name|list
expr_stmt|;
comment|/* 2. loop: search for the bottom layer and check for alpha */
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|layer
operator|==
name|layer_arg
condition|)
block|{
comment|/* there is no next layer below layer_arg */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Layer is already on bottom"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* bottom is reached, we can stop now */
break|break;
block|}
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|ex_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"BG has no alpha, layer was placed above"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|list
operator|=
name|next
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ex_flag
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|list
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_arg
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_insert
argument_list|(
name|list
argument_list|,
name|layer_arg
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* update the affected area (== area of layer_arg) */
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x_min
operator|=
name|off_x
expr_stmt|;
name|y_min
operator|=
name|off_y
expr_stmt|;
name|x_max
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|y_max
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer_arg
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|x_min
argument_list|,
name|y_min
argument_list|,
name|x_max
argument_list|,
name|y_max
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|layer_arg
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_visible_layers (GimpImage * gimage,MergeType merge_type)
name|gimp_image_merge_visible_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge.\nThere must be at least two."
argument_list|)
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_flatten (GimpImage * gimage)
name|gimp_image_flatten
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|FlattenImage
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
return|return
name|layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_down (GimpImage * gimage,Layer * current_layer,MergeType merge_type)
name|gimp_image_merge_down
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|current_layer
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|layer_list
decl_stmt|;
name|GSList
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|Layer
modifier|*
name|layer
init|=
name|NULL
decl_stmt|;
name|layer_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|current_layer
condition|)
block|{
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|layer_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|layer_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|merge_list
operator|=
name|g_slist_append
argument_list|(
name|merge_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|layer_list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
name|merge_list
operator|=
name|g_slist_prepend
argument_list|(
name|merge_list
argument_list|,
name|current_layer
argument_list|)
expr_stmt|;
block|}
else|else
name|layer_list
operator|=
name|g_slist_next
argument_list|(
name|layer_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_list
operator|&&
name|merge_list
operator|->
name|next
condition|)
block|{
name|gimp_add_busy_cursors
argument_list|()
expr_stmt|;
name|layer
operator|=
name|gimp_image_merge_layers
argument_list|(
name|gimage
argument_list|,
name|merge_list
argument_list|,
name|merge_type
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_remove_busy_cursors
argument_list|()
expr_stmt|;
return|return
name|layer
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"There are not enough visible layers for a merge down."
argument_list|)
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_merge_layers (GimpImage * gimage,GSList * merge_list,MergeType merge_type)
name|gimp_image_merge_layers
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|GSList
modifier|*
name|merge_list
parameter_list|,
name|MergeType
name|merge_type
parameter_list|)
block|{
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|Layer
modifier|*
name|merge_layer
decl_stmt|;
name|Layer
modifier|*
name|layer
decl_stmt|;
name|Layer
modifier|*
name|bottom
decl_stmt|;
name|unsigned
name|char
name|bg
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|int
name|operation
decl_stmt|;
name|int
name|position
decl_stmt|;
name|int
name|active
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|layer
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|RGBA_GIMAGE
expr_stmt|;
name|x1
operator|=
name|y1
operator|=
name|x2
operator|=
name|y2
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
name|NULL
expr_stmt|;
comment|/*  Get the layer extents  */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|merge_type
condition|)
block|{
case|case
name|ExpandAsNecessary
case|:
case|case
name|ClipToImage
case|:
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off_x
operator|<
name|x1
condition|)
name|x1
operator|=
name|off_x
expr_stmt|;
if|if
condition|(
name|off_y
operator|<
name|y1
condition|)
name|y1
operator|=
name|off_y
expr_stmt|;
if|if
condition|(
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|x2
condition|)
name|x2
operator|=
operator|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
operator|>
name|y2
condition|)
name|y2
operator|=
operator|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_type
operator|==
name|ClipToImage
condition|)
block|{
name|x1
operator|=
name|CLAMP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y1
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y2
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ClipToBottomLayer
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
name|off_x
expr_stmt|;
name|y1
operator|=
name|off_y
expr_stmt|;
name|x2
operator|=
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FlattenImage
case|:
if|if
condition|(
name|merge_list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|x1
operator|=
literal|0
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
name|gimage
operator|->
name|width
expr_stmt|;
name|y2
operator|=
name|gimage
operator|->
name|height
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|g_slist_next
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|==
literal|0
operator|||
operator|(
name|y2
operator|-
name|y1
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*  Start a merge undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_MERGE_UNDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_type
operator|==
name|FlattenImage
operator|||
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|==
name|INDEXED_GIMAGE
condition|)
block|{
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
name|type
operator|=
name|RGB_GIMAGE
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|type
operator|=
name|GRAY_GIMAGE
expr_stmt|;
break|break;
case|case
name|INDEXED
case|:
name|type
operator|=
name|INDEXED_GIMAGE
expr_stmt|;
break|break;
block|}
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|type
argument_list|,
name|drawable_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  get the background for compositing  */
name|gimp_image_get_background
argument_list|(
name|gimage
argument_list|,
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  init the pixel region  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|gimage
operator|->
name|width
argument_list|,
name|gimage
operator|->
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to the background color  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*  The final merged layer inherits the name of the bottom most layer        *  and the resulting layer has an alpha channel        *  whether or not the original did        *  Opacity is set to 100% and the MODE is set to normal        */
name|merge_layer
operator|=
name|layer_new
argument_list|(
name|gimage
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|drawable_type_with_alpha
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_get_name
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|OPAQUE_OPACITY
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_layer
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_merge_layers: could not allocate merge layer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_x
operator|=
name|x1
expr_stmt|;
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|offset_y
operator|=
name|y1
expr_stmt|;
comment|/*  Set the layer to transparent  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*  set the region to 0's  */
name|color_region
argument_list|(
operator|&
name|src1PR
argument_list|,
name|bg
argument_list|)
expr_stmt|;
comment|/*  Find the index in the layer list of the bottom layer--we need this        *  in order to add the final, merged layer to the layer list correctly        */
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|position
operator|=
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/* set the mode of the bottom layer to normal so that the contents        *  aren't lost when merging with the all-alpha merge_layer        *  Keep a pointer to it so that we can set the mode right after it's been        *  merged so that undo works correctly.        */
name|layer
operator|->
name|mode
operator|=
name|NORMAL
expr_stmt|;
name|bottom
operator|=
name|layer
expr_stmt|;
block|}
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
comment|/*  determine what sort of operation is being attempted and        *  if it's actually legal...        */
name|operation
operator|=
name|valid_combinations
index|[
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
index|]
index|[
name|drawable_bytes
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|operation
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_merge_layers attempting to merge incompatible layers\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x3
operator|=
name|CLAMP
argument_list|(
name|off_x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y3
operator|=
name|CLAMP
argument_list|(
name|off_y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x4
operator|=
name|CLAMP
argument_list|(
name|off_x
operator|+
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
name|y4
operator|=
name|CLAMP
argument_list|(
name|off_y
operator|+
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* configure the pixel regions  */
name|pixel_region_init
argument_list|(
operator|&
name|src1PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|y1
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pixel_region_init
argument_list|(
operator|&
name|src2PR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
condition|)
block|{
name|pixel_region_init
argument_list|(
operator|&
name|maskPR
argument_list|,
name|drawable_data
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
argument_list|)
argument_list|,
operator|(
name|x3
operator|-
name|off_x
operator|)
argument_list|,
operator|(
name|y3
operator|-
name|off_y
operator|)
argument_list|,
operator|(
name|x4
operator|-
name|x3
operator|)
argument_list|,
operator|(
name|y4
operator|-
name|y3
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|active
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
comment|/* Save old mode in undo */
if|if
condition|(
name|bottom
condition|)
name|bottom
operator|->
name|mode
operator|=
name|merge_layer
operator|->
name|mode
expr_stmt|;
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
comment|/*  if the type is flatten, remove all the remaining layers  */
if|if
condition|(
name|merge_type
operator|==
name|FlattenImage
condition|)
block|{
name|merge_list
operator|=
name|gimage
operator|->
name|layers
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|merge_list
operator|->
name|data
expr_stmt|;
name|merge_list
operator|=
name|g_slist_next
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|gimp_image_remove_layer
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Add the layer to the gimage  */
name|gimp_image_add_layer
argument_list|(
name|gimage
argument_list|,
name|merge_layer
argument_list|,
operator|(
name|g_slist_length
argument_list|(
name|gimage
operator|->
name|layers
argument_list|)
operator|-
name|position
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  End the merge undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  Update the gimage  */
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|RESTRUCTURE
index|]
argument_list|)
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|merge_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*reinit_layer_idlerender (gimage, merge_layer);*/
return|return
name|merge_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_add_layer (GimpImage * gimage,Layer * float_layer,int position)
name|gimp_image_add_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|float_layer
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_add_layer: attempt to add layer to wrong image"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|{
name|GSList
modifier|*
name|ll
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|data
operator|==
name|float_layer
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_add_layer: trying to add layer to image twice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ll
operator|=
name|g_slist_next
argument_list|(
name|ll
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Prepare a layer undo and push it  */
name|lu
operator|=
operator|(
name|LayerUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|float_layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
name|lu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  If the layer is a floating selection, set the ID  */
if|if
condition|(
name|layer_is_floating_sel
argument_list|(
name|float_layer
argument_list|)
condition|)
name|gimage
operator|->
name|floating_sel
operator|=
name|float_layer
expr_stmt|;
comment|/*  let the layer know about the gimage  */
name|gimp_drawable_set_gimage
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|,
name|gimage
argument_list|)
expr_stmt|;
comment|/*  add the layer to the list at the specified position  */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
name|position
operator|=
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|gimage
operator|->
name|active_layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*  If there is a floating selection (and this isn't it!),        *  make sure the insert position is greater than 0        */
if|if
condition|(
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|&&
operator|(
name|gimage
operator|->
name|floating_sel
operator|!=
name|float_layer
operator|)
operator|&&
name|position
operator|==
literal|0
condition|)
name|position
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_insert
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_ref
argument_list|(
name|float_layer
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
name|gimage
operator|->
name|layers
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer_ref
argument_list|(
name|float_layer
argument_list|)
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  notify the layers dialog of the currently active layer  */
name|gimp_image_set_active_layer
argument_list|(
name|gimage
argument_list|,
name|float_layer
argument_list|)
expr_stmt|;
comment|/*  update the new layer's area  */
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|float_layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|float_layer
return|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_remove_layer (GimpImage * gimage,Layer * layer)
name|gimp_image_remove_layer
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|)
block|{
name|LayerUndo
modifier|*
name|lu
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
name|layer
condition|)
block|{
comment|/*  Prepare a layer undo--push it at the end  */
name|lu
operator|=
operator|(
name|LayerUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|prev_position
operator|=
name|gimp_image_get_layer_index
argument_list|(
name|gimage
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|lu
operator|->
name|prev_layer
operator|=
name|layer
expr_stmt|;
name|lu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|layers
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layers
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|layer_stack
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|layer_stack
argument_list|,
name|layer
argument_list|)
expr_stmt|;
comment|/*  If this was the floating selection, reset the fs pointer  */
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|layer
condition|)
block|{
name|gimage
operator|->
name|floating_sel
operator|=
name|NULL
expr_stmt|;
name|floating_sel_reset
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|==
name|layer
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|layers
condition|)
name|gimage
operator|->
name|active_layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|gimage
operator|->
name|layer_stack
operator|->
name|data
expr_stmt|;
else|else
name|gimage
operator|->
name|active_layer
operator|=
name|NULL
expr_stmt|;
block|}
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Push the layer undo--It is important it goes here since layer might        *   be immediately destroyed if the undo push fails        */
name|undo_push_layer
argument_list|(
name|gimage
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/*  invalidate the composite preview  */
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|LayerMask
modifier|*
DECL|function|gimp_image_add_layer_mask (GimpImage * gimage,Layer * layer,LayerMask * mask)
name|gimp_image_add_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|LayerMask
modifier|*
name|mask
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|!=
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask since\nthe layer already has one."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawable_indexed
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to add a layer mask to a\nlayer in an indexed image."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask to a layer\nwith no alpha channel."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|||
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|!=
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|mask
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot add layer mask of different dimensions than specified layer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|layer_add_mask
argument_list|(
name|layer
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer undo and push it  */
name|lmu
operator|=
operator|(
name|LayerMaskUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerMaskUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|lmu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_remove_layer_mask (GimpImage * gimage,Layer * layer,int mode)
name|gimp_image_remove_layer_mask
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Layer
modifier|*
name|layer
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|LayerMaskUndo
modifier|*
name|lmu
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|layer
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|layer
operator|->
name|mask
condition|)
return|return
name|NULL
return|;
comment|/*  Start an undo group  */
name|undo_push_group_start
argument_list|(
name|gimage
argument_list|,
name|LAYER_APPLY_MASK_UNDO
argument_list|)
expr_stmt|;
comment|/*  Prepare a layer mask undo--push it below  */
name|lmu
operator|=
operator|(
name|LayerMaskUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LayerMaskUndo
argument_list|)
argument_list|)
expr_stmt|;
name|lmu
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|lmu
operator|->
name|mask
operator|=
name|layer
operator|->
name|mask
expr_stmt|;
name|lmu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|lmu
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|lmu
operator|->
name|apply_mask
operator|=
name|layer
operator|->
name|apply_mask
expr_stmt|;
name|lmu
operator|->
name|edit_mask
operator|=
name|layer
operator|->
name|edit_mask
expr_stmt|;
name|lmu
operator|->
name|show_mask
operator|=
name|layer
operator|->
name|show_mask
expr_stmt|;
name|layer_apply_mask
argument_list|(
name|layer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*  Push the undo--Important to do it here, AFTER the call    *   to layer_apply_mask, in case the undo push fails and the    *   mask is delete : NULL)d    */
name|undo_push_layer_mask
argument_list|(
name|gimage
argument_list|,
name|lmu
argument_list|)
expr_stmt|;
comment|/*  end the undo group  */
name|undo_push_group_end
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
comment|/*  If the layer mode is discard, update the layer--invalidate gimage also  */
if|if
condition|(
name|mode
operator|==
name|DISCARD
condition|)
block|{
name|gimp_image_invalidate_preview
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|REPAINT
index|]
argument_list|,
name|off_x
argument_list|,
name|off_y
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdisplays_flush
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_raise_channel (GimpImage * gimage,Channel * channel_arg)
name|gimp_image_raise_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|prev_channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|prev
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|prev_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|prev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|prev_channel
expr_stmt|;
name|prev
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|prev_channel
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be raised any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_lower_channel (GimpImage * gimage,Channel * channel_arg)
name|gimp_image_lower_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel_arg
parameter_list|)
block|{
name|Channel
modifier|*
name|channel
decl_stmt|;
name|Channel
modifier|*
name|next_channel
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GSList
modifier|*
name|next
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|gimage
operator|->
name|channels
expr_stmt|;
name|next_channel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next_channel
operator|=
operator|(
name|Channel
operator|*
operator|)
name|next
operator|->
name|data
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|channel_arg
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|next_channel
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|channel
expr_stmt|;
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|next_channel
return|;
block|}
else|else
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Channel cannot be lowered any further"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_add_channel (GimpImage * gimage,Channel * channel,int position)
name|gimp_image_add_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
if|if
condition|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|NULL
operator|&&
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
operator|->
name|gimage
operator|!=
name|gimage
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_add_channel: attempt to add channel to wrong image"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|{
name|GSList
modifier|*
name|cc
init|=
name|gimage
operator|->
name|channels
decl_stmt|;
while|while
condition|(
name|cc
condition|)
block|{
if|if
condition|(
name|cc
operator|->
name|data
operator|==
name|channel
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"gimp_image_add_channel: trying to add channel to image twice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cc
operator|=
name|g_slist_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Prepare a channel undo and push it  */
name|cu
operator|=
operator|(
name|ChannelUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChannelUndo
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
literal|0
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|cu
operator|->
name|undo_type
operator|=
literal|0
expr_stmt|;
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/*  add the channel to the list  */
name|gimage
operator|->
name|channels
operator|=
name|g_slist_prepend
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel_ref
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  notify this gimage of the currently active channel  */
name|gimp_image_set_active_channel
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/*  if channel is visible, update the image  */
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
DECL|function|gimp_image_remove_channel (GimpImage * gimage,Channel * channel)
name|gimp_image_remove_channel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|ChannelUndo
modifier|*
name|cu
decl_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
comment|/*  Prepare a channel undo--push it below  */
name|cu
operator|=
operator|(
name|ChannelUndo
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChannelUndo
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|cu
operator|->
name|prev_position
operator|=
name|gimp_image_get_channel_index
argument_list|(
name|gimage
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|cu
operator|->
name|prev_channel
operator|=
name|gimage
operator|->
name|active_channel
expr_stmt|;
name|cu
operator|->
name|undo_type
operator|=
literal|1
expr_stmt|;
name|gimage
operator|->
name|channels
operator|=
name|g_slist_remove
argument_list|(
name|gimage
operator|->
name|channels
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|==
name|channel
condition|)
block|{
if|if
condition|(
name|gimage
operator|->
name|channels
condition|)
name|gimage
operator|->
name|active_channel
operator|=
operator|(
operator|(
operator|(
name|Channel
operator|*
operator|)
name|gimage
operator|->
name|channels
operator|->
name|data
operator|)
operator|)
expr_stmt|;
else|else
name|gimage
operator|->
name|active_channel
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
condition|)
name|drawable_update
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Important to push the undo here in case the push fails  */
name|undo_push_channel
argument_list|(
name|gimage
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Access functions                                        */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|int
DECL|function|gimp_image_is_empty (GimpImage * gimage)
name|gimp_image_is_empty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
operator|(
operator|!
name|gimage
operator|->
name|layers
operator|)
return|;
block|}
end_function

begin_function
name|GimpDrawable
modifier|*
DECL|function|gimp_image_active_drawable (GimpImage * gimage)
name|gimp_image_active_drawable
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  If there is an active channel (a saved selection, etc.),    *  we ignore the active layer    */
if|if
condition|(
name|gimage
operator|->
name|active_channel
operator|!=
name|NULL
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|gimage
operator|->
name|active_channel
argument_list|)
return|;
elseif|else
if|if
condition|(
name|gimage
operator|->
name|active_layer
operator|!=
name|NULL
condition|)
block|{
name|layer
operator|=
name|gimage
operator|->
name|active_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|edit_mask
condition|)
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
operator|->
name|mask
argument_list|)
return|;
else|else
return|return
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_base_type (GimpImage * gimage)
name|gimp_image_base_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|base_type
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_base_type_with_alpha (GimpImage * gimage)
name|gimp_image_base_type_with_alpha
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
switch|switch
condition|(
name|gimage
operator|->
name|base_type
condition|)
block|{
case|case
name|RGB
case|:
return|return
name|RGBA_GIMAGE
return|;
case|case
name|GRAY
case|:
return|return
name|GRAYA_GIMAGE
return|;
case|case
name|INDEXED
case|:
return|return
name|INDEXEDA_GIMAGE
return|;
block|}
return|return
name|RGB_GIMAGE
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|gimp_image_filename (GimpImage * gimage)
name|gimp_image_filename
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|has_filename
condition|)
return|return
name|gimage
operator|->
name|filename
return|;
else|else
return|return
name|_
argument_list|(
literal|"Untitled"
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_enable_undo (GimpImage * gimage)
name|gimp_image_enable_undo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  Free all undo steps as they are now invalidated  */
name|undo_free
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|undo_on
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_disable_undo (GimpImage * gimage)
name|gimp_image_disable_undo
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|undo_on
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_dirty (GimpImage * gimage)
name|gimp_image_dirty
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  if (gimage->dirty< 0)     gimage->dirty = 2;   else */
name|gimage
operator|->
name|dirty
operator|++
expr_stmt|;
name|gtk_signal_emit
argument_list|(
name|GTK_OBJECT
argument_list|(
name|gimage
argument_list|)
argument_list|,
name|gimp_image_signals
index|[
name|DIRTY
index|]
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_clean (GimpImage * gimage)
name|gimp_image_clean
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
comment|/*  if (gimage->dirty<= 0)     gimage->dirty = 0;   else */
name|gimage
operator|->
name|dirty
operator|--
expr_stmt|;
return|return
name|gimage
operator|->
name|dirty
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_clean_all (GimpImage * gimage)
name|gimp_image_clean_all
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimage
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|Layer
modifier|*
DECL|function|gimp_image_floating_sel (GimpImage * gimage)
name|gimp_image_floating_sel
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
name|gimage
operator|->
name|floating_sel
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|gimage
operator|->
name|floating_sel
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
DECL|function|gimp_image_cmap (GimpImage * gimage)
name|gimp_image_cmap
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|drawable_cmap
argument_list|(
name|gimp_image_active_drawable
argument_list|(
name|gimage
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Projection access functions                             */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_projection (GimpImage * gimage)
name|gimp_image_projection
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
if|if
condition|(
operator|(
name|gimage
operator|->
name|projection
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tile_manager_level_width
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|width
operator|)
operator|||
operator|(
name|tile_manager_level_height
argument_list|(
name|gimage
operator|->
name|projection
argument_list|)
operator|!=
name|gimage
operator|->
name|height
operator|)
condition|)
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
return|return
name|gimage
operator|->
name|projection
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_projection_type (GimpImage * gimage)
name|gimp_image_projection_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|proj_type
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_projection_bytes (GimpImage * gimage)
name|gimp_image_projection_bytes
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimage
operator|->
name|proj_bytes
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_projection_opacity (GimpImage * gimage)
name|gimp_image_projection_opacity
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|OPAQUE_OPACITY
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_projection_realloc (GimpImage * gimage)
name|gimp_image_projection_realloc
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|gimp_image_allocate_projection
argument_list|(
name|gimage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  Composition access functions                            */
end_comment

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|TileManager
modifier|*
DECL|function|gimp_image_composite (GimpImage * gimage)
name|gimp_image_composite
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_composite_type (GimpImage * gimage)
name|gimp_image_composite_type
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_type
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_composite_bytes (GimpImage * gimage)
name|gimp_image_composite_bytes
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
return|return
name|gimp_image_projection_bytes
argument_list|(
name|gimage
argument_list|)
return|;
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimp_image_construct_composite_preview (GimpImage * gimage,int width,int height)
name|gimp_image_construct_composite_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
name|PixelRegion
name|src1PR
decl_stmt|,
name|src2PR
decl_stmt|,
name|maskPR
decl_stmt|;
name|PixelRegion
modifier|*
name|mask
decl_stmt|;
name|TempBuf
modifier|*
name|comp
decl_stmt|;
name|TempBuf
modifier|*
name|layer_buf
decl_stmt|;
name|TempBuf
modifier|*
name|mask_buf
decl_stmt|;
name|GSList
modifier|*
name|list
init|=
name|gimage
operator|->
name|layers
decl_stmt|;
name|GSList
modifier|*
name|reverse_list
init|=
name|NULL
decl_stmt|;
name|double
name|ratio
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|construct_flag
decl_stmt|;
name|int
name|visible
index|[
name|MAX_CHANNELS
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|int
name|off_x
decl_stmt|,
name|off_y
decl_stmt|;
name|ratio
operator|=
operator|(
name|double
operator|)
name|width
operator|/
operator|(
name|double
operator|)
name|gimage
operator|->
name|width
expr_stmt|;
switch|switch
condition|(
name|gimp_image_base_type
argument_list|(
name|gimage
argument_list|)
condition|)
block|{
case|case
name|RGB
case|:
case|case
name|INDEXED
case|:
name|bytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
name|bytes
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*  The construction buffer  */
name|comp
operator|=
name|temp_buf_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|comp
operator|->
name|width
operator|*
name|comp
operator|->
name|height
operator|*
name|comp
operator|->
name|bytes
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
comment|/*  only add layers that are visible and not floating selections to the list  */
if|if
condition|(
operator|!
name|layer_is_floating_sel
argument_list|(
name|layer
argument_list|)
operator|&&
name|drawable_visible
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
name|reverse_list
operator|=
name|g_slist_prepend
argument_list|(
name|reverse_list
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|construct_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|reverse_list
condition|)
block|{
name|layer
operator|=
operator|(
name|Layer
operator|*
operator|)
name|reverse_list
operator|->
name|data
expr_stmt|;
name|drawable_offsets
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|,
operator|&
name|off_x
argument_list|,
operator|&
name|off_y
argument_list|)
expr_stmt|;
name|x
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|off_y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|w
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_width
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|h
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
name|drawable_height
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|x1
operator|=
name|CLAMP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y1
operator|=
name|CLAMP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|CLAMP
argument_list|(
name|x
operator|+
name|w
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|y2
operator|=
name|CLAMP
argument_list|(
name|y
operator|+
name|h
argument_list|,
literal|0
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|src1PR
operator|.
name|bytes
operator|=
name|comp
operator|->
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|src1PR
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|src1PR
operator|.
name|w
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|h
operator|=
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|src1PR
operator|.
name|rowstride
operator|=
name|comp
operator|->
name|width
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|src1PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|comp
argument_list|)
operator|+
name|y1
operator|*
name|src1PR
operator|.
name|rowstride
operator|+
name|x1
operator|*
name|src1PR
operator|.
name|bytes
expr_stmt|;
name|layer_buf
operator|=
name|layer_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|src2PR
operator|.
name|bytes
operator|=
name|layer_buf
operator|->
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|w
operator|=
name|src1PR
operator|.
name|w
expr_stmt|;
name|src2PR
operator|.
name|h
operator|=
name|src1PR
operator|.
name|h
expr_stmt|;
name|src2PR
operator|.
name|x
operator|=
name|src1PR
operator|.
name|x
expr_stmt|;
name|src2PR
operator|.
name|y
operator|=
name|src1PR
operator|.
name|y
expr_stmt|;
name|src2PR
operator|.
name|rowstride
operator|=
name|layer_buf
operator|->
name|width
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
name|src2PR
operator|.
name|data
operator|=
name|temp_buf_data
argument_list|(
name|layer_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|src2PR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|src2PR
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|mask
operator|&&
name|layer
operator|->
name|apply_mask
condition|)
block|{
name|mask_buf
operator|=
name|layer_mask_preview
argument_list|(
name|layer
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|maskPR
operator|.
name|bytes
operator|=
name|mask_buf
operator|->
name|bytes
expr_stmt|;
name|maskPR
operator|.
name|rowstride
operator|=
name|mask_buf
operator|->
name|width
expr_stmt|;
name|maskPR
operator|.
name|data
operator|=
name|mask_buf_data
argument_list|(
name|mask_buf
argument_list|)
operator|+
operator|(
name|y1
operator|-
name|y
operator|)
operator|*
name|maskPR
operator|.
name|rowstride
operator|+
operator|(
name|x1
operator|-
name|x
operator|)
operator|*
name|maskPR
operator|.
name|bytes
expr_stmt|;
name|mask
operator|=
operator|&
name|maskPR
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|NULL
expr_stmt|;
comment|/*  Based on the type of the layer, project the layer onto the        *   composite preview...        *  Indexed images are actually already converted to RGB and RGBA,        *   so just project them as if they were type "intensity"        *  Send in all TRUE for visible since that info doesn't matter for previews        */
switch|switch
condition|(
name|drawable_type
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RGB_GIMAGE
case|:
case|case
name|GRAY_GIMAGE
case|:
case|case
name|INDEXED_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGBA_GIMAGE
case|:
case|case
name|GRAYA_GIMAGE
case|:
case|case
name|INDEXEDA_GIMAGE
case|:
if|if
condition|(
operator|!
name|construct_flag
condition|)
name|initial_region
argument_list|(
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|INITIAL_INTENSITY_ALPHA
argument_list|)
expr_stmt|;
else|else
name|combine_regions
argument_list|(
operator|&
name|src1PR
argument_list|,
operator|&
name|src2PR
argument_list|,
operator|&
name|src1PR
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|layer
operator|->
name|opacity
argument_list|,
name|layer
operator|->
name|mode
argument_list|,
name|visible
argument_list|,
name|COMBINE_INTEN_A_INTEN_A
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|construct_flag
operator|=
literal|1
expr_stmt|;
name|reverse_list
operator|=
name|g_slist_next
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
block|}
name|g_slist_free
argument_list|(
name|reverse_list
argument_list|)
expr_stmt|;
return|return
name|comp
return|;
block|}
end_function

begin_function
name|TempBuf
modifier|*
DECL|function|gimp_image_composite_preview (GimpImage * gimage,ChannelType type,int width,int height)
name|gimp_image_composite_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|,
name|ChannelType
name|type
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|channel
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
name|channel
operator|=
name|RED_PIX
expr_stmt|;
break|break;
case|case
name|Green
case|:
name|channel
operator|=
name|GREEN_PIX
expr_stmt|;
break|break;
case|case
name|Blue
case|:
name|channel
operator|=
name|BLUE_PIX
expr_stmt|;
break|break;
case|case
name|Gray
case|:
name|channel
operator|=
name|GRAY_PIX
expr_stmt|;
break|break;
case|case
name|Indexed
case|:
name|channel
operator|=
name|INDEXED_PIX
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
comment|/*  The easy way  */
if|if
condition|(
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|width
operator|==
name|width
operator|&&
name|gimage
operator|->
name|comp_preview
operator|->
name|height
operator|==
name|height
condition|)
return|return
name|gimage
operator|->
name|comp_preview
return|;
comment|/*  The hard way  */
else|else
block|{
if|if
condition|(
name|gimage
operator|->
name|comp_preview
condition|)
name|temp_buf_free
argument_list|(
name|gimage
operator|->
name|comp_preview
argument_list|)
expr_stmt|;
comment|/*  Actually construct the composite preview from the layer previews!        *  This might seem ridiculous, but it's actually the best way, given        *  a number of unsavory alternatives.        */
name|gimage
operator|->
name|comp_preview
operator|=
name|gimp_image_construct_composite_preview
argument_list|(
name|gimage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
name|channel
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
name|gimage
operator|->
name|comp_preview
return|;
block|}
block|}
end_function

begin_function
name|int
DECL|function|gimp_image_preview_valid (gimage,type)
name|gimp_image_preview_valid
parameter_list|(
name|gimage
parameter_list|,
name|type
parameter_list|)
name|GimpImage
modifier|*
name|gimage
decl_stmt|;
name|ChannelType
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Red
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|RED_PIX
index|]
return|;
break|break;
case|case
name|Green
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GREEN_PIX
index|]
return|;
break|break;
case|case
name|Blue
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|BLUE_PIX
index|]
return|;
break|break;
case|case
name|Gray
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|GRAY_PIX
index|]
return|;
break|break;
case|case
name|Indexed
case|:
return|return
name|gimage
operator|->
name|comp_preview_valid
index|[
name|INDEXED_PIX
index|]
return|;
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gimp_image_invalidate_preview (GimpImage * gimage)
name|gimp_image_invalidate_preview
parameter_list|(
name|GimpImage
modifier|*
name|gimage
parameter_list|)
block|{
name|Layer
modifier|*
name|layer
decl_stmt|;
comment|/*  Invalidate the floating sel if it exists  */
if|if
condition|(
operator|(
name|layer
operator|=
name|gimp_image_floating_sel
argument_list|(
name|gimage
argument_list|)
operator|)
condition|)
name|floating_sel_invalidate
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimage
operator|->
name|comp_preview_valid
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

end_unit

